
obj/net/ns:     file format elf32-i386


Disassembly of section .text:

00800020 <_start>:
// starts us running when we are initially loaded into a new environment.
.text
.globl _start
_start:
	// See if we were started with arguments on the stack
	cmpl $USTACKTOP, %esp
  800020:	81 fc 00 e0 bf ee    	cmp    $0xeebfe000,%esp
	jne args_exist
  800026:	75 04                	jne    80002c <args_exist>

	// If not, push dummy argc/argv arguments.
	// This happens when we are loaded by the kernel,
	// because the kernel does not know about passing arguments.
	pushl $0
  800028:	6a 00                	push   $0x0
	pushl $0
  80002a:	6a 00                	push   $0x0

0080002c <args_exist>:

args_exist:
	call libmain
  80002c:	e8 37 09 00 00       	call   800968 <libmain>
1:	jmp 1b
  800031:	eb fe                	jmp    800031 <args_exist+0x5>
	...

00800040 <put_buffer>:

	return va;
}

static void
put_buffer(void *va) {
  800040:	55                   	push   %ebp
  800041:	89 e5                	mov    %esp,%ebp
	int i = ((uint32_t)va - REQVA) / PGSIZE;
	buse[i] = 0;
  800043:	2d 00 b0 fe 0f       	sub    $0xffeb000,%eax
  800048:	c1 e8 0c             	shr    $0xc,%eax
  80004b:	c7 04 85 c0 93 81 00 	movl   $0x0,0x8193c0(,%eax,4)
  800052:	00 00 00 00 
}
  800056:	5d                   	pop    %ebp
  800057:	c3                   	ret    

00800058 <umain>:
	serve();
}

void
umain(void)
{
  800058:	55                   	push   %ebp
  800059:	89 e5                	mov    %esp,%ebp
  80005b:	53                   	push   %ebx
  80005c:	83 ec 14             	sub    $0x14,%esp
	envid_t ns_envid = sys_getenvid();
  80005f:	e8 7a 19 00 00       	call   8019de <sys_getenvid>
  800064:	89 c3                	mov    %eax,%ebx

	binaryname = "ns";
  800066:	c7 05 00 90 81 00 c3 	movl   $0x812ec3,0x819000
  80006d:	2e 81 00 

	// fork off the timer thread which will send us periodic messages
	timer_envid = fork();
  800070:	e8 60 1b 00 00       	call   801bd5 <fork>
  800075:	a3 a4 93 81 00       	mov    %eax,0x8193a4
	if (timer_envid < 0)
  80007a:	85 c0                	test   %eax,%eax
  80007c:	79 1c                	jns    80009a <umain+0x42>
		panic("error forking");
  80007e:	c7 44 24 08 c0 24 81 	movl   $0x8124c0,0x8(%esp)
  800085:	00 
  800086:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  80008d:	00 
  80008e:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  800095:	e8 3a 09 00 00       	call   8009d4 <_panic>
	else if (timer_envid == 0) {
  80009a:	85 c0                	test   %eax,%eax
  80009c:	75 15                	jne    8000b3 <umain+0x5b>
		timer(ns_envid, TIMER_INTERVAL);
  80009e:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  8000a5:	00 
  8000a6:	89 1c 24             	mov    %ebx,(%esp)
  8000a9:	e8 d2 06 00 00       	call   800780 <timer>
		return;
  8000ae:	e9 a3 00 00 00       	jmp    800156 <umain+0xfe>
	}

	// fork off the input thread which will poll the NIC driver for input
	// packets
	input_envid = fork();
  8000b3:	e8 1d 1b 00 00       	call   801bd5 <fork>
  8000b8:	a3 a8 93 81 00       	mov    %eax,0x8193a8
	if (input_envid < 0)
  8000bd:	85 c0                	test   %eax,%eax
  8000bf:	79 1c                	jns    8000dd <umain+0x85>
		panic("error forking");
  8000c1:	c7 44 24 08 c0 24 81 	movl   $0x8124c0,0x8(%esp)
  8000c8:	00 
  8000c9:	c7 44 24 04 4d 01 00 	movl   $0x14d,0x4(%esp)
  8000d0:	00 
  8000d1:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  8000d8:	e8 f7 08 00 00       	call   8009d4 <_panic>
	else if (input_envid == 0) {
  8000dd:	85 c0                	test   %eax,%eax
  8000df:	75 0a                	jne    8000eb <umain+0x93>
		input(ns_envid);
  8000e1:	89 1c 24             	mov    %ebx,(%esp)
  8000e4:	e8 37 07 00 00       	call   800820 <input>
		return;
  8000e9:	eb 6b                	jmp    800156 <umain+0xfe>
	}

	// fork off the output thread that will send the packets to the NIC
	// driver
	output_envid = fork();
  8000eb:	90                   	nop
  8000ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8000f0:	e8 e0 1a 00 00       	call   801bd5 <fork>
  8000f5:	a3 ac 93 81 00       	mov    %eax,0x8193ac
	if (output_envid < 0)
  8000fa:	85 c0                	test   %eax,%eax
  8000fc:	79 1c                	jns    80011a <umain+0xc2>
		panic("error forking");
  8000fe:	c7 44 24 08 c0 24 81 	movl   $0x8124c0,0x8(%esp)
  800105:	00 
  800106:	c7 44 24 04 57 01 00 	movl   $0x157,0x4(%esp)
  80010d:	00 
  80010e:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  800115:	e8 ba 08 00 00       	call   8009d4 <_panic>
	else if (output_envid == 0) {
  80011a:	85 c0                	test   %eax,%eax
  80011c:	75 0a                	jne    800128 <umain+0xd0>
		output(ns_envid);
  80011e:	89 1c 24             	mov    %ebx,(%esp)
  800121:	e8 ba 07 00 00       	call   8008e0 <output>
		return;
  800126:	eb 2e                	jmp    800156 <umain+0xfe>
	}

	// lwIP requires a user threading library; start the library and jump
	// into a thread to continue initialization. 
	thread_init();
  800128:	e8 a3 dd 00 00       	call   80ded0 <thread_init>
	thread_create(0, "main", tmain, 0);
  80012d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800134:	00 
  800135:	c7 44 24 08 14 07 80 	movl   $0x800714,0x8(%esp)
  80013c:	00 
  80013d:	c7 44 24 04 d9 24 81 	movl   $0x8124d9,0x4(%esp)
  800144:	00 
  800145:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80014c:	e8 66 df 00 00       	call   80e0b7 <thread_create>
	thread_yield();
  800151:	e8 1a de 00 00       	call   80df70 <thread_yield>
	// never coming here!
}
  800156:	83 c4 14             	add    $0x14,%esp
  800159:	5b                   	pop    %ebx
  80015a:	5d                   	pop    %ebp
  80015b:	c3                   	ret    

0080015c <serve>:
	sys_page_unmap(0, (void*) args->req);
	free(args);
}

void
serve(void) {
  80015c:	55                   	push   %ebp
  80015d:	89 e5                	mov    %esp,%ebp
  80015f:	57                   	push   %edi
  800160:	56                   	push   %esi
  800161:	53                   	push   %ebx
  800162:	83 ec 3c             	sub    $0x3c,%esp
  800165:	bb 00 00 00 00       	mov    $0x0,%ebx
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  80016a:	8d 7d e0             	lea    -0x20(%ebp),%edi
  80016d:	eb 08                	jmp    800177 <serve+0x1b>
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();
  80016f:	e8 fc dd 00 00       	call   80df70 <thread_yield>
	
	while (1) {
		// ipc_recv will block the entire process, so we flush
		// all pending work from other threads.  We limit the
		// number of yields in case there's a rogue thread.
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
  800174:	83 c3 01             	add    $0x1,%ebx
  800177:	e8 a5 dd 00 00       	call   80df21 <thread_wakeups_pending>
  80017c:	85 c0                	test   %eax,%eax
  80017e:	74 05                	je     800185 <serve+0x29>
  800180:	83 fb 1f             	cmp    $0x1f,%ebx
  800183:	7e ea                	jle    80016f <serve+0x13>
			thread_yield();

		perm = 0;
  800185:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
		if (!buse[i]) break;
  80018c:	83 3d c0 93 81 00 00 	cmpl   $0x0,0x8193c0
  800193:	74 3b                	je     8001d0 <serve+0x74>
  800195:	b8 01 00 00 00       	mov    $0x1,%eax
  80019a:	ba c0 93 81 00       	mov    $0x8193c0,%edx
  80019f:	83 3c 82 00          	cmpl   $0x0,(%edx,%eax,4)
  8001a3:	74 0a                	je     8001af <serve+0x53>
static void *
get_buffer(void) {
	void *va;

	int i;
	for (i = 0; i < QUEUE_SIZE; i++)
  8001a5:	83 c0 01             	add    $0x1,%eax
  8001a8:	83 f8 14             	cmp    $0x14,%eax
  8001ab:	75 f2                	jne    80019f <serve+0x43>
  8001ad:	eb 05                	jmp    8001b4 <serve+0x58>
		if (!buse[i]) break;

	if (i == QUEUE_SIZE) {
  8001af:	83 f8 14             	cmp    $0x14,%eax
  8001b2:	75 21                	jne    8001d5 <serve+0x79>
		panic("NS: buffer overflow");
  8001b4:	c7 44 24 08 de 24 81 	movl   $0x8124de,0x8(%esp)
  8001bb:	00 
  8001bc:	c7 44 24 04 3f 00 00 	movl   $0x3f,0x4(%esp)
  8001c3:	00 
  8001c4:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  8001cb:	e8 04 08 00 00       	call   8009d4 <_panic>
  8001d0:	b8 00 00 00 00       	mov    $0x0,%eax
		return 0;
	}

	va = (void *)(REQVA + i * PGSIZE);
  8001d5:	8d 98 eb ff 00 00    	lea    0xffeb(%eax),%ebx
  8001db:	c1 e3 0c             	shl    $0xc,%ebx
	buse[i] = 1;
  8001de:	c7 04 85 c0 93 81 00 	movl   $0x1,0x8193c0(,%eax,4)
  8001e5:	01 00 00 00 
		for (i = 0; thread_wakeups_pending() && i < 32; ++i)
			thread_yield();

		perm = 0;
		va = get_buffer();
		reqno = ipc_recv((int32_t *) &whom, (void *) va, &perm);
  8001e9:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8001ed:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8001f1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8001f4:	89 04 24             	mov    %eax,(%esp)
  8001f7:	e8 9a 1c 00 00       	call   801e96 <ipc_recv>
  8001fc:	89 c6                	mov    %eax,%esi
		if (debug) {
			cprintf("ns req %d from %08x\n", reqno, whom);
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
  8001fe:	83 f8 0c             	cmp    $0xc,%eax
  800201:	75 67                	jne    80026a <serve+0x10e>
			process_timer(whom);
  800203:	8b 75 e4             	mov    -0x1c(%ebp),%esi

static void
process_timer(envid_t envid) {
	uint32_t start, now, to;

	if (envid != timer_envid) {
  800206:	3b 35 a4 93 81 00    	cmp    0x8193a4,%esi
  80020c:	74 12                	je     800220 <serve+0xc4>
		cprintf("NS: received timer interrupt from envid %x not timer env\n", envid);
  80020e:	89 74 24 04          	mov    %esi,0x4(%esp)
  800212:	c7 04 24 6c 25 81 00 	movl   $0x81256c,(%esp)
  800219:	e8 7b 08 00 00       	call   800a99 <cprintf>
  80021e:	eb 39                	jmp    800259 <serve+0xfd>
		return;
	}

	start = sys_time_msec();
  800220:	e8 87 14 00 00       	call   8016ac <sys_time_msec>
  800225:	89 45 d4             	mov    %eax,-0x2c(%ebp)
	thread_yield();
  800228:	e8 43 dd 00 00       	call   80df70 <thread_yield>
	now = sys_time_msec();
  80022d:	e8 7a 14 00 00       	call   8016ac <sys_time_msec>

	to = TIMER_INTERVAL - (now - start);
	ipc_send(envid, to, 0, 0);
  800232:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800239:	00 
  80023a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  800241:	00 
  800242:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  800245:	81 c2 fa 00 00 00    	add    $0xfa,%edx
  80024b:	29 c2                	sub    %eax,%edx
  80024d:	89 54 24 04          	mov    %edx,0x4(%esp)
  800251:	89 34 24             	mov    %esi,(%esp)
  800254:	e8 d7 1b 00 00       	call   801e30 <ipc_send>
		}

		// first take care of requests that do not contain an argument page
		if (reqno == NSREQ_TIMER) {
			process_timer(whom);
			put_buffer(va);
  800259:	89 d8                	mov    %ebx,%eax
  80025b:	e8 e0 fd ff ff       	call   800040 <put_buffer>
  800260:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue;
  800265:	e9 0d ff ff ff       	jmp    800177 <serve+0x1b>
		}

		// All remaining requests must contain an argument page
		if (!(perm & PTE_P)) {
  80026a:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80026e:	66 90                	xchg   %ax,%ax
  800270:	75 1d                	jne    80028f <serve+0x133>
			cprintf("Invalid request from %08x: no argument page\n", whom);
  800272:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800275:	89 44 24 04          	mov    %eax,0x4(%esp)
  800279:	c7 04 24 a8 25 81 00 	movl   $0x8125a8,(%esp)
  800280:	e8 14 08 00 00       	call   800a99 <cprintf>
  800285:	bb 00 00 00 00       	mov    $0x0,%ebx
			continue; // just leave it hanging...
  80028a:	e9 e8 fe ff ff       	jmp    800177 <serve+0x1b>
		}

		// Since some lwIP socket calls will block, create a thread and
		// process the rest of the request in the thread.
		struct st_args *args = malloc(sizeof(struct st_args));
  80028f:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  800296:	e8 a8 2a 00 00       	call   802d43 <malloc>
		if (!args)
  80029b:	85 c0                	test   %eax,%eax
  80029d:	75 1c                	jne    8002bb <serve+0x15f>
			panic("could not allocate thread args structure");
  80029f:	c7 44 24 08 d8 25 81 	movl   $0x8125d8,0x8(%esp)
  8002a6:	00 
  8002a7:	c7 44 24 04 26 01 00 	movl   $0x126,0x4(%esp)
  8002ae:	00 
  8002af:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  8002b6:	e8 19 07 00 00       	call   8009d4 <_panic>

		args->reqno = reqno;
  8002bb:	89 30                	mov    %esi,(%eax)
		args->whom = whom;
  8002bd:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  8002c0:	89 50 04             	mov    %edx,0x4(%eax)
		args->req = va;
  8002c3:	89 58 08             	mov    %ebx,0x8(%eax)

		thread_create(0, "serve_thread", serve_thread, (uint32_t)args);
  8002c6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8002ca:	c7 44 24 08 f5 02 80 	movl   $0x8002f5,0x8(%esp)
  8002d1:	00 
  8002d2:	c7 44 24 04 f2 24 81 	movl   $0x8124f2,0x4(%esp)
  8002d9:	00 
  8002da:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8002e1:	e8 d1 dd 00 00       	call   80e0b7 <thread_create>
		thread_yield(); // let the thread created run
  8002e6:	e8 85 dc 00 00       	call   80df70 <thread_yield>
  8002eb:	bb 00 00 00 00       	mov    $0x0,%ebx
  8002f0:	e9 82 fe ff ff       	jmp    800177 <serve+0x1b>

008002f5 <serve_thread>:
	uint32_t whom;
	union Nsipc *req;
};

static void
serve_thread(uint32_t a) {
  8002f5:	55                   	push   %ebp
  8002f6:	89 e5                	mov    %esp,%ebp
  8002f8:	81 ec 98 00 00 00    	sub    $0x98,%esp
  8002fe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  800301:	89 75 f8             	mov    %esi,-0x8(%ebp)
  800304:	89 7d fc             	mov    %edi,-0x4(%ebp)
	struct st_args *args = (struct st_args *)a;
  800307:	8b 5d 08             	mov    0x8(%ebp),%ebx
	union Nsipc *req = args->req;
  80030a:	8b 73 08             	mov    0x8(%ebx),%esi
	int r;

	switch (args->reqno) {
  80030d:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800310:	0f 87 34 01 00 00    	ja     80044a <serve_thread+0x155>
  800316:	8b 03                	mov    (%ebx),%eax
  800318:	ff 24 85 a4 26 81 00 	jmp    *0x8126a4(,%eax,4)
	case NSREQ_ACCEPT:
	{
		struct Nsret_accept ret;
		r = lwip_accept(req->accept.req_s, &ret.ret_addr,
  80031f:	8d 45 94             	lea    -0x6c(%ebp),%eax
  800322:	89 44 24 08          	mov    %eax,0x8(%esp)
  800326:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800329:	89 44 24 04          	mov    %eax,0x4(%esp)
  80032d:	8b 06                	mov    (%esi),%eax
  80032f:	89 04 24             	mov    %eax,(%esp)
  800332:	e8 7b 4a 00 00       	call   804db2 <lwip_accept>
  800337:	89 c7                	mov    %eax,%edi
				&ret.ret_addrlen);
		memmove(req, &ret, sizeof ret);
  800339:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  800340:	00 
  800341:	8d 45 84             	lea    -0x7c(%ebp),%eax
  800344:	89 44 24 04          	mov    %eax,0x4(%esp)
  800348:	89 34 24             	mov    %esi,(%esp)
  80034b:	e8 c5 0f 00 00       	call   801315 <memmove>
		break;
  800350:	e9 13 01 00 00       	jmp    800468 <serve_thread+0x173>
	}
	case NSREQ_BIND:
		r = lwip_bind(req->bind.req_s, &req->bind.req_name,
  800355:	8b 46 14             	mov    0x14(%esi),%eax
  800358:	89 44 24 08          	mov    %eax,0x8(%esp)
  80035c:	8d 46 04             	lea    0x4(%esi),%eax
  80035f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800363:	8b 06                	mov    (%esi),%eax
  800365:	89 04 24             	mov    %eax,(%esp)
  800368:	e8 8c 49 00 00       	call   804cf9 <lwip_bind>
  80036d:	89 c7                	mov    %eax,%edi
			      req->bind.req_namelen);
		break;
  80036f:	e9 f4 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_SHUTDOWN:
		r = lwip_shutdown(req->shutdown.req_s, req->shutdown.req_how);
  800374:	8b 46 04             	mov    0x4(%esi),%eax
  800377:	89 44 24 04          	mov    %eax,0x4(%esp)
  80037b:	8b 06                	mov    (%esi),%eax
  80037d:	89 04 24             	mov    %eax,(%esp)
  800380:	e8 19 48 00 00       	call   804b9e <lwip_shutdown>
  800385:	89 c7                	mov    %eax,%edi
		break;
  800387:	e9 dc 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CLOSE:
		r = lwip_close(req->close.req_s);
  80038c:	8b 06                	mov    (%esi),%eax
  80038e:	89 04 24             	mov    %eax,(%esp)
  800391:	e8 8c 47 00 00       	call   804b22 <lwip_close>
  800396:	89 c7                	mov    %eax,%edi
		break;
  800398:	e9 cb 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_CONNECT:
		r = lwip_connect(req->connect.req_s, &req->connect.req_name,
  80039d:	8b 46 14             	mov    0x14(%esi),%eax
  8003a0:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003a4:	8d 46 04             	lea    0x4(%esi),%eax
  8003a7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003ab:	8b 06                	mov    (%esi),%eax
  8003ad:	89 04 24             	mov    %eax,(%esp)
  8003b0:	e8 8b 48 00 00       	call   804c40 <lwip_connect>
  8003b5:	89 c7                	mov    %eax,%edi
				 req->connect.req_namelen);
		break;
  8003b7:	e9 ac 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_LISTEN:
		r = lwip_listen(req->listen.req_s, req->listen.req_backlog);
  8003bc:	8b 46 04             	mov    0x4(%esi),%eax
  8003bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8003c3:	8b 06                	mov    (%esi),%eax
  8003c5:	89 04 24             	mov    %eax,(%esp)
  8003c8:	e8 e4 47 00 00       	call   804bb1 <lwip_listen>
  8003cd:	89 c7                	mov    %eax,%edi
		break;
  8003cf:	e9 94 00 00 00       	jmp    800468 <serve_thread+0x173>
	case NSREQ_RECV:
		// Note that we read the request fields before we
		// overwrite it with the response data.
		r = lwip_recv(req->recv.req_s, req->recvRet.ret_buf,
  8003d4:	8b 46 08             	mov    0x8(%esi),%eax
  8003d7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003db:	8b 46 04             	mov    0x4(%esi),%eax
  8003de:	89 44 24 08          	mov    %eax,0x8(%esp)
  8003e2:	89 74 24 04          	mov    %esi,0x4(%esp)
  8003e6:	8b 06                	mov    (%esi),%eax
  8003e8:	89 04 24             	mov    %eax,(%esp)
  8003eb:	e8 c1 46 00 00       	call   804ab1 <lwip_recv>
  8003f0:	89 c7                	mov    %eax,%edi
			      req->recv.req_len, req->recv.req_flags);
		break;
  8003f2:	eb 74                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SEND:
		r = lwip_send(req->send.req_s, &req->send.req_buf,
  8003f4:	8b 46 08             	mov    0x8(%esi),%eax
  8003f7:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8003fb:	8b 46 04             	mov    0x4(%esi),%eax
  8003fe:	89 44 24 08          	mov    %eax,0x8(%esp)
  800402:	8d 46 0c             	lea    0xc(%esi),%eax
  800405:	89 44 24 04          	mov    %eax,0x4(%esp)
  800409:	8b 06                	mov    (%esi),%eax
  80040b:	89 04 24             	mov    %eax,(%esp)
  80040e:	e8 17 42 00 00       	call   80462a <lwip_send>
  800413:	89 c7                	mov    %eax,%edi
			      req->send.req_size, req->send.req_flags);
		break;
  800415:	eb 51                	jmp    800468 <serve_thread+0x173>
	case NSREQ_SOCKET:
		r = lwip_socket(req->socket.req_domain, req->socket.req_type,
  800417:	8b 46 08             	mov    0x8(%esi),%eax
  80041a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80041e:	8b 46 04             	mov    0x4(%esi),%eax
  800421:	89 44 24 04          	mov    %eax,0x4(%esp)
  800425:	8b 06                	mov    (%esi),%eax
  800427:	89 04 24             	mov    %eax,(%esp)
  80042a:	e8 0d 41 00 00       	call   80453c <lwip_socket>
  80042f:	89 c7                	mov    %eax,%edi
				req->socket.req_protocol);
		break;
  800431:	eb 35                	jmp    800468 <serve_thread+0x173>
	case NSREQ_INPUT:
		jif_input(&nif, (void *)&req->pkt);
  800433:	89 74 24 04          	mov    %esi,0x4(%esp)
  800437:	c7 04 24 c0 f5 b3 00 	movl   $0xb3f5c0,(%esp)
  80043e:	e8 b7 e0 00 00       	call   80e4fa <jif_input>
  800443:	bf 00 00 00 00       	mov    $0x0,%edi
		r = 0;
		break;
  800448:	eb 4c                	jmp    800496 <serve_thread+0x1a1>
	default:
		cprintf("Invalid request code %d from %08x\n", args->whom, args->req);
  80044a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80044e:	8b 43 04             	mov    0x4(%ebx),%eax
  800451:	89 44 24 04          	mov    %eax,0x4(%esp)
  800455:	c7 04 24 04 26 81 00 	movl   $0x812604,(%esp)
  80045c:	e8 38 06 00 00       	call   800a99 <cprintf>
  800461:	bf fd ff ff ff       	mov    $0xfffffffd,%edi
  800466:	eb 2e                	jmp    800496 <serve_thread+0x1a1>
		r = -E_INVAL;
		break;
	}

	if (r == -1) {
  800468:	83 ff ff             	cmp    $0xffffffff,%edi
  80046b:	75 29                	jne    800496 <serve_thread+0x1a1>
		char buf[100];
		snprintf(buf, sizeof buf, "ns req type %d", args->reqno);
  80046d:	8b 03                	mov    (%ebx),%eax
  80046f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800473:	c7 44 24 08 ff 24 81 	movl   $0x8124ff,0x8(%esp)
  80047a:	00 
  80047b:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  800482:	00 
  800483:	8d 75 84             	lea    -0x7c(%ebp),%esi
  800486:	89 34 24             	mov    %esi,(%esp)
  800489:	e8 2e 0c 00 00       	call   8010bc <snprintf>
		perror(buf);
  80048e:	89 34 24             	mov    %esi,(%esp)
  800491:	e8 31 de 00 00       	call   80e2c7 <perror>
	}

	if (args->reqno != NSREQ_INPUT)
  800496:	83 3b 0a             	cmpl   $0xa,(%ebx)
  800499:	74 1f                	je     8004ba <serve_thread+0x1c5>
		ipc_send(args->whom, r, 0, 0);
  80049b:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8004a2:	00 
  8004a3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8004aa:	00 
  8004ab:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8004af:	8b 43 04             	mov    0x4(%ebx),%eax
  8004b2:	89 04 24             	mov    %eax,(%esp)
  8004b5:	e8 76 19 00 00       	call   801e30 <ipc_send>

	put_buffer(args->req);
  8004ba:	8b 43 08             	mov    0x8(%ebx),%eax
  8004bd:	e8 7e fb ff ff       	call   800040 <put_buffer>
	sys_page_unmap(0, (void*) args->req);
  8004c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8004c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8004c9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8004d0:	e8 ba 13 00 00       	call   80188f <sys_page_unmap>
	free(args);
  8004d5:	89 1c 24             	mov    %ebx,(%esp)
  8004d8:	e8 93 27 00 00       	call   802c70 <free>
}
  8004dd:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8004e0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8004e3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8004e6:	89 ec                	mov    %ebp,%esp
  8004e8:	5d                   	pop    %ebp
  8004e9:	c3                   	ret    

008004ea <net_timer>:
	netif_set_up(nif);
}

static void __attribute__((noreturn))
net_timer(uint32_t arg)
{
  8004ea:	55                   	push   %ebp
  8004eb:	89 e5                	mov    %esp,%ebp
  8004ed:	56                   	push   %esi
  8004ee:	53                   	push   %ebx
  8004ef:	83 ec 10             	sub    $0x10,%esp
	struct timer_thread *t = (struct timer_thread *) arg;
  8004f2:	8b 5d 08             	mov    0x8(%ebp),%ebx

	for (;;) {
		uint32_t cur = sys_time_msec();
  8004f5:	e8 b2 11 00 00       	call   8016ac <sys_time_msec>
  8004fa:	89 c6                	mov    %eax,%esi

		lwip_core_lock();
  8004fc:	e8 d8 d0 00 00       	call   80d5d9 <lwip_core_lock>
		t->func();
  800501:	ff 53 04             	call   *0x4(%ebx)
		lwip_core_unlock();
  800504:	e8 d5 d0 00 00       	call   80d5de <lwip_core_unlock>

		thread_wait(0, 0, cur + t->msec);
  800509:	03 33                	add    (%ebx),%esi
  80050b:	89 74 24 08          	mov    %esi,0x8(%esp)
  80050f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  800516:	00 
  800517:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80051e:	e8 dc dc 00 00       	call   80e1ff <thread_wait>
  800523:	eb d0                	jmp    8004f5 <net_timer+0xb>

00800525 <start_timer>:
	}
}

static void
start_timer(struct timer_thread *t, void (*func)(void), const char *name, int msec)
{
  800525:	55                   	push   %ebp
  800526:	89 e5                	mov    %esp,%ebp
  800528:	53                   	push   %ebx
  800529:	83 ec 14             	sub    $0x14,%esp
	t->msec = msec;
  80052c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80052f:	89 18                	mov    %ebx,(%eax)
	t->func = func;
  800531:	89 50 04             	mov    %edx,0x4(%eax)
	t->name = name;
  800534:	89 48 08             	mov    %ecx,0x8(%eax)
	int r = thread_create(0, name, &net_timer, (uint32_t)t);
  800537:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80053b:	c7 44 24 08 ea 04 80 	movl   $0x8004ea,0x8(%esp)
  800542:	00 
  800543:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800547:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80054e:	e8 64 db 00 00       	call   80e0b7 <thread_create>
	if (r < 0)
  800553:	85 c0                	test   %eax,%eax
  800555:	79 28                	jns    80057f <start_timer+0x5a>
		panic("cannot create timer thread: %s", e2s(r));
  800557:	89 04 24             	mov    %eax,(%esp)
  80055a:	e8 59 dd 00 00       	call   80e2b8 <e2s>
  80055f:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800563:	c7 44 24 08 28 26 81 	movl   $0x812628,0x8(%esp)
  80056a:	00 
  80056b:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  800572:	00 
  800573:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  80057a:	e8 55 04 00 00       	call   8009d4 <_panic>
}
  80057f:	83 c4 14             	add    $0x14,%esp
  800582:	5b                   	pop    %ebx
  800583:	5d                   	pop    %ebp
  800584:	c3                   	ret    

00800585 <serve_init>:
	thread_wakeup(done);
}

void
serve_init(uint32_t ipaddr, uint32_t netmask, uint32_t gw)
{
  800585:	55                   	push   %ebp
  800586:	89 e5                	mov    %esp,%ebp
  800588:	56                   	push   %esi
  800589:	53                   	push   %ebx
  80058a:	83 ec 30             	sub    $0x30,%esp
  80058d:	8b 75 08             	mov    0x8(%ebp),%esi
	int r;
	lwip_core_lock();
  800590:	e8 44 d0 00 00       	call   80d5d9 <lwip_core_lock>

	uint32_t done = 0;
  800595:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)
	tcpip_init(&tcpip_init_done, &done);
  80059c:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  80059f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8005a3:	c7 04 24 67 07 80 00 	movl   $0x800767,(%esp)
  8005aa:	e8 f4 49 00 00       	call   804fa3 <tcpip_init>
	lwip_core_unlock();
  8005af:	e8 2a d0 00 00       	call   80d5de <lwip_core_unlock>
	thread_wait(&done, 0, (uint32_t)~0);
  8005b4:	c7 44 24 08 ff ff ff 	movl   $0xffffffff,0x8(%esp)
  8005bb:	ff 
  8005bc:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8005c3:	00 
  8005c4:	89 1c 24             	mov    %ebx,(%esp)
  8005c7:	e8 33 dc 00 00       	call   80e1ff <thread_wait>
	lwip_core_lock();
  8005cc:	e8 08 d0 00 00       	call   80d5d9 <lwip_core_lock>
static void
lwip_init(struct netif *nif, void *if_state,
	  uint32_t init_addr, uint32_t init_mask, uint32_t init_gw)
{
	struct ip_addr ipaddr, netmask, gateway;
	ipaddr.addr  = init_addr;
  8005d1:	89 75 f0             	mov    %esi,-0x10(%ebp)
	netmask.addr = init_mask;
  8005d4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8005d7:	89 45 ec             	mov    %eax,-0x14(%ebp)
	gateway.addr = init_gw;
  8005da:	8b 45 10             	mov    0x10(%ebp),%eax
  8005dd:	89 45 e8             	mov    %eax,-0x18(%ebp)

	if (0 == netif_add(nif, &ipaddr, &netmask, &gateway,
  8005e0:	c7 44 24 18 14 9c 80 	movl   $0x809c14,0x18(%esp)
  8005e7:	00 
  8005e8:	c7 44 24 14 00 e3 80 	movl   $0x80e300,0x14(%esp)
  8005ef:	00 
  8005f0:	c7 44 24 10 ac 93 81 	movl   $0x8193ac,0x10(%esp)
  8005f7:	00 
  8005f8:	8d 45 e8             	lea    -0x18(%ebp),%eax
  8005fb:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8005ff:	8d 45 ec             	lea    -0x14(%ebp),%eax
  800602:	89 44 24 08          	mov    %eax,0x8(%esp)
  800606:	8d 45 f0             	lea    -0x10(%ebp),%eax
  800609:	89 44 24 04          	mov    %eax,0x4(%esp)
  80060d:	c7 04 24 c0 f5 b3 00 	movl   $0xb3f5c0,(%esp)
  800614:	e8 48 74 00 00       	call   807a61 <netif_add>
  800619:	85 c0                	test   %eax,%eax
  80061b:	75 1c                	jne    800639 <serve_init+0xb4>
			   if_state,
			   jif_init,
			   ip_input))
		panic("lwip_init: error in netif_add\n");
  80061d:	c7 44 24 08 48 26 81 	movl   $0x812648,0x8(%esp)
  800624:	00 
  800625:	c7 44 24 04 5c 00 00 	movl   $0x5c,0x4(%esp)
  80062c:	00 
  80062d:	c7 04 24 ce 24 81 00 	movl   $0x8124ce,(%esp)
  800634:	e8 9b 03 00 00       	call   8009d4 <_panic>

	netif_set_default(nif);
  800639:	c7 04 24 c0 f5 b3 00 	movl   $0xb3f5c0,(%esp)
  800640:	e8 9c 72 00 00       	call   8078e1 <netif_set_default>
	netif_set_up(nif);
  800645:	c7 04 24 c0 f5 b3 00 	movl   $0xb3f5c0,(%esp)
  80064c:	e8 1d 73 00 00       	call   80796e <netif_set_up>
	thread_wait(&done, 0, (uint32_t)~0);
	lwip_core_lock();

	lwip_init(&nif, &output_envid, ipaddr, netmask, gw);

	start_timer(&t_arp, &etharp_tmr, "arp timer", ARP_TMR_INTERVAL);
  800651:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  800658:	b9 0e 25 81 00       	mov    $0x81250e,%ecx
  80065d:	ba 7c d0 80 00       	mov    $0x80d07c,%edx
  800662:	b8 80 93 81 00       	mov    $0x819380,%eax
  800667:	e8 b9 fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcpf, &tcp_fasttmr, "tcp f timer", TCP_FAST_INTERVAL);
  80066c:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  800673:	b9 18 25 81 00       	mov    $0x812518,%ecx
  800678:	ba 0b 8a 80 00       	mov    $0x808a0b,%edx
  80067d:	b8 8c 93 81 00       	mov    $0x81938c,%eax
  800682:	e8 9e fe ff ff       	call   800525 <start_timer>
	start_timer(&t_tcps, &tcp_slowtmr, "tcp s timer", TCP_SLOW_INTERVAL);
  800687:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  80068e:	b9 24 25 81 00       	mov    $0x812524,%ecx
  800693:	ba 3e 93 80 00       	mov    $0x80933e,%edx
  800698:	b8 98 93 81 00       	mov    $0x819398,%eax
  80069d:	e8 83 fe ff ff       	call   800525 <start_timer>

	struct in_addr ia = {ipaddr};
	cprintf("ns: %02x:%02x:%02x:%02x:%02x:%02x" 
  8006a2:	89 34 24             	mov    %esi,(%esp)
  8006a5:	e8 e6 a5 00 00       	call   80ac90 <inet_ntoa>
  8006aa:	89 44 24 1c          	mov    %eax,0x1c(%esp)
  8006ae:	0f b6 05 ea f5 b3 00 	movzbl 0xb3f5ea,%eax
  8006b5:	89 44 24 18          	mov    %eax,0x18(%esp)
  8006b9:	0f b6 05 e9 f5 b3 00 	movzbl 0xb3f5e9,%eax
  8006c0:	89 44 24 14          	mov    %eax,0x14(%esp)
  8006c4:	0f b6 05 e8 f5 b3 00 	movzbl 0xb3f5e8,%eax
  8006cb:	89 44 24 10          	mov    %eax,0x10(%esp)
  8006cf:	0f b6 05 e7 f5 b3 00 	movzbl 0xb3f5e7,%eax
  8006d6:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8006da:	0f b6 05 e6 f5 b3 00 	movzbl 0xb3f5e6,%eax
  8006e1:	89 44 24 08          	mov    %eax,0x8(%esp)
  8006e5:	0f b6 05 e5 f5 b3 00 	movzbl 0xb3f5e5,%eax
  8006ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8006f0:	c7 04 24 68 26 81 00 	movl   $0x812668,(%esp)
  8006f7:	e8 9d 03 00 00       	call   800a99 <cprintf>
		" bound to static IP %s\n", 
		nif.hwaddr[0], nif.hwaddr[1], nif.hwaddr[2],
		nif.hwaddr[3], nif.hwaddr[4], nif.hwaddr[5],
		inet_ntoa(ia));

	lwip_core_unlock();
  8006fc:	e8 dd ce 00 00       	call   80d5de <lwip_core_unlock>

	cprintf("NS: TCP/IP initialized.\n");
  800701:	c7 04 24 30 25 81 00 	movl   $0x812530,(%esp)
  800708:	e8 8c 03 00 00       	call   800a99 <cprintf>
}
  80070d:	83 c4 30             	add    $0x30,%esp
  800710:	5b                   	pop    %ebx
  800711:	5e                   	pop    %esi
  800712:	5d                   	pop    %ebp
  800713:	c3                   	ret    

00800714 <tmain>:
		thread_yield(); // let the thread created run
	}
}

static void
tmain(uint32_t arg) {
  800714:	55                   	push   %ebp
  800715:	89 e5                	mov    %esp,%ebp
  800717:	83 ec 18             	sub    $0x18,%esp
  80071a:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80071d:	89 75 fc             	mov    %esi,-0x4(%ebp)
	serve_init(inet_addr(IP),
  800720:	c7 04 24 49 25 81 00 	movl   $0x812549,(%esp)
  800727:	e8 4c a8 00 00       	call   80af78 <inet_addr>
  80072c:	89 c3                	mov    %eax,%ebx
  80072e:	c7 04 24 52 25 81 00 	movl   $0x812552,(%esp)
  800735:	e8 3e a8 00 00       	call   80af78 <inet_addr>
  80073a:	89 c6                	mov    %eax,%esi
  80073c:	c7 04 24 60 25 81 00 	movl   $0x812560,(%esp)
  800743:	e8 30 a8 00 00       	call   80af78 <inet_addr>
  800748:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80074c:	89 74 24 04          	mov    %esi,0x4(%esp)
  800750:	89 04 24             	mov    %eax,(%esp)
  800753:	e8 2d fe ff ff       	call   800585 <serve_init>
		   inet_addr(MASK),
		   inet_addr(DEFAULT));
	serve();
  800758:	e8 ff f9 ff ff       	call   80015c <serve>
}
  80075d:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  800760:	8b 75 fc             	mov    -0x4(%ebp),%esi
  800763:	89 ec                	mov    %ebp,%esp
  800765:	5d                   	pop    %ebp
  800766:	c3                   	ret    

00800767 <tcpip_init_done>:
		panic("cannot create timer thread: %s", e2s(r));
}

static void
tcpip_init_done(void *arg)
{
  800767:	55                   	push   %ebp
  800768:	89 e5                	mov    %esp,%ebp
  80076a:	83 ec 18             	sub    $0x18,%esp
  80076d:	8b 45 08             	mov    0x8(%ebp),%eax
	uint32_t *done = arg;
	*done = 1;
  800770:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
	thread_wakeup(done);
  800776:	89 04 24             	mov    %eax,(%esp)
  800779:	e8 81 d7 00 00       	call   80deff <thread_wakeup>
}
  80077e:	c9                   	leave  
  80077f:	c3                   	ret    

00800780 <timer>:
#include "ns.h"

void
timer(envid_t ns_envid, uint32_t initial_to) {
  800780:	55                   	push   %ebp
  800781:	89 e5                	mov    %esp,%ebp
  800783:	57                   	push   %edi
  800784:	56                   	push   %esi
  800785:	53                   	push   %ebx
  800786:	83 ec 2c             	sub    $0x2c,%esp
  800789:	8b 75 08             	mov    0x8(%ebp),%esi
	uint32_t stop = sys_time_msec() + initial_to;
  80078c:	e8 1b 0f 00 00       	call   8016ac <sys_time_msec>
  800791:	89 c3                	mov    %eax,%ebx
  800793:	03 5d 0c             	add    0xc(%ebp),%ebx

	binaryname = "ns_timer";
  800796:	c7 05 00 90 81 00 d0 	movl   $0x8126d0,0x819000
  80079d:	26 81 00 

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007a0:	8d 7d e4             	lea    -0x1c(%ebp),%edi
  8007a3:	eb 05                	jmp    8007aa <timer+0x2a>

	binaryname = "ns_timer";

	while (1) {
		while(sys_time_msec() < stop) {
			sys_yield();
  8007a5:	e8 00 12 00 00       	call   8019aa <sys_yield>
	uint32_t stop = sys_time_msec() + initial_to;

	binaryname = "ns_timer";

	while (1) {
		while(sys_time_msec() < stop) {
  8007aa:	e8 fd 0e 00 00       	call   8016ac <sys_time_msec>
  8007af:	39 c3                	cmp    %eax,%ebx
  8007b1:	77 f2                	ja     8007a5 <timer+0x25>
			sys_yield();
		}

		ipc_send(ns_envid, NSREQ_TIMER, 0, 0);
  8007b3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8007ba:	00 
  8007bb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007c2:	00 
  8007c3:	c7 44 24 04 0c 00 00 	movl   $0xc,0x4(%esp)
  8007ca:	00 
  8007cb:	89 34 24             	mov    %esi,(%esp)
  8007ce:	e8 5d 16 00 00       	call   801e30 <ipc_send>

		while (1) {
			uint32_t to, whom;
			to = ipc_recv((int32_t *) &whom, 0, 0);
  8007d3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8007da:	00 
  8007db:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8007e2:	00 
  8007e3:	89 3c 24             	mov    %edi,(%esp)
  8007e6:	e8 ab 16 00 00       	call   801e96 <ipc_recv>
  8007eb:	89 c3                	mov    %eax,%ebx

			if (whom != ns_envid) {
  8007ed:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8007f0:	39 c6                	cmp    %eax,%esi
  8007f2:	74 12                	je     800806 <timer+0x86>
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
  8007f4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8007f8:	c7 04 24 dc 26 81 00 	movl   $0x8126dc,(%esp)
  8007ff:	e8 95 02 00 00       	call   800a99 <cprintf>
				continue;
			}

			stop = sys_time_msec() + to;
			break;
		}
  800804:	eb cd                	jmp    8007d3 <timer+0x53>
			if (whom != ns_envid) {
				cprintf("NS TIMER: timer thread got IPC message from env %x not NS\n", whom);
				continue;
			}

			stop = sys_time_msec() + to;
  800806:	e8 a1 0e 00 00       	call   8016ac <sys_time_msec>
  80080b:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  80080e:	66 90                	xchg   %ax,%ax
  800810:	eb 98                	jmp    8007aa <timer+0x2a>
	...

00800820 <input>:

extern union Nsipc nsipcbuf;

void
input(envid_t ns_envid)
{
  800820:	55                   	push   %ebp
  800821:	89 e5                	mov    %esp,%ebp
  800823:	53                   	push   %ebx
  800824:	83 ec 14             	sub    $0x14,%esp
  800827:	8b 5d 08             	mov    0x8(%ebp),%ebx
	binaryname = "ns_input";
  80082a:	c7 05 00 90 81 00 17 	movl   $0x812717,0x819000
  800831:	27 81 00 
	int len;

	while (1)
	{

		if (sys_page_alloc(0, &nsipcbuf, PTE_U | PTE_P | PTE_W) < 0)
  800834:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80083b:	00 
  80083c:	c7 44 24 04 00 80 81 	movl   $0x818000,0x4(%esp)
  800843:	00 
  800844:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80084b:	e8 fb 10 00 00       	call   80194b <sys_page_alloc>
  800850:	85 c0                	test   %eax,%eax
  800852:	79 0e                	jns    800862 <input+0x42>
		{
			cprintf("\n input.c: error in sys_page_alloc");
  800854:	c7 04 24 3c 27 81 00 	movl   $0x81273c,(%esp)
  80085b:	e8 39 02 00 00       	call   800a99 <cprintf>
			continue;
  800860:	eb d2                	jmp    800834 <input+0x14>
		}
		len = sys_receive_packet(nsipcbuf.pkt.jp_data);
  800862:	c7 04 24 04 80 81 00 	movl   $0x818004,(%esp)
  800869:	e8 ab 0d 00 00       	call   801619 <sys_receive_packet>
		if (len < 0)
  80086e:	85 c0                	test   %eax,%eax
  800870:	79 13                	jns    800885 <input+0x65>
		{
			// there was an error in sys_receive_packet, print the message and continue
			cprintf("\n input.c: error in receive");	
  800872:	c7 04 24 20 27 81 00 	movl   $0x812720,(%esp)
  800879:	e8 1b 02 00 00       	call   800a99 <cprintf>
			sys_yield();
  80087e:	e8 27 11 00 00       	call   8019aa <sys_yield>
			continue;
  800883:	eb af                	jmp    800834 <input+0x14>
		}
		else if (len == 0)
  800885:	85 c0                	test   %eax,%eax
  800887:	75 0e                	jne    800897 <input+0x77>
		{
			// nothing was received, continue
			sys_yield();
  800889:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  800890:	e8 15 11 00 00       	call   8019aa <sys_yield>
			continue;
  800895:	eb 9d                	jmp    800834 <input+0x14>
		}
		else 
		{
			//cprintf("\n input.c: ipc_send");
			nsipcbuf.pkt.jp_len = len;	
  800897:	a3 00 80 81 00       	mov    %eax,0x818000
			ipc_send(ns_envid, NSREQ_INPUT, &nsipcbuf, PTE_P | PTE_U | PTE_W);
  80089c:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8008a3:	00 
  8008a4:	c7 44 24 08 00 80 81 	movl   $0x818000,0x8(%esp)
  8008ab:	00 
  8008ac:	c7 44 24 04 0a 00 00 	movl   $0xa,0x4(%esp)
  8008b3:	00 
  8008b4:	89 1c 24             	mov    %ebx,(%esp)
  8008b7:	e8 74 15 00 00       	call   801e30 <ipc_send>
		}
		sys_page_unmap(0, &nsipcbuf);
  8008bc:	c7 44 24 04 00 80 81 	movl   $0x818000,0x4(%esp)
  8008c3:	00 
  8008c4:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8008cb:	e8 bf 0f 00 00       	call   80188f <sys_page_unmap>
  8008d0:	e9 5f ff ff ff       	jmp    800834 <input+0x14>
	...

008008e0 <output>:

extern union Nsipc nsipcbuf;

void
output(envid_t ns_envid)
{
  8008e0:	55                   	push   %ebp
  8008e1:	89 e5                	mov    %esp,%ebp
  8008e3:	57                   	push   %edi
  8008e4:	56                   	push   %esi
  8008e5:	53                   	push   %ebx
  8008e6:	83 ec 2c             	sub    $0x2c,%esp
  8008e9:	8b 7d 08             	mov    0x8(%ebp),%edi
	binaryname = "ns_output";
  8008ec:	c7 05 00 90 81 00 5f 	movl   $0x81275f,0x819000
  8008f3:	27 81 00 
	uint32_t request;
	int perm;
	while(1)
	{
		perm = 0;
		request = ipc_recv(&from_env, (void*)&nsipcbuf, &perm);
  8008f6:	8d 5d e0             	lea    -0x20(%ebp),%ebx
  8008f9:	8d 75 e4             	lea    -0x1c(%ebp),%esi
	envid_t from_env;
	uint32_t request;
	int perm;
	while(1)
	{
		perm = 0;
  8008fc:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
		request = ipc_recv(&from_env, (void*)&nsipcbuf, &perm);
  800903:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800907:	c7 44 24 04 00 80 81 	movl   $0x818000,0x4(%esp)
  80090e:	00 
  80090f:	89 34 24             	mov    %esi,(%esp)
  800912:	e8 7f 15 00 00       	call   801e96 <ipc_recv>
		if (!(perm & PTE_P))
  800917:	f6 45 e0 01          	testb  $0x1,-0x20(%ebp)
  80091b:	75 0e                	jne    80092b <output+0x4b>
		{
			cprintf("\n output.c : Page not present! ");
  80091d:	c7 04 24 6c 27 81 00 	movl   $0x81276c,(%esp)
  800924:	e8 70 01 00 00       	call   800a99 <cprintf>
			continue;
  800929:	eb d1                	jmp    8008fc <output+0x1c>
		}
		if (from_env != ns_envid)
  80092b:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80092e:	74 0e                	je     80093e <output+0x5e>
		{
			cprintf("\n output.c : Request received from bogus environment! ");
  800930:	c7 04 24 8c 27 81 00 	movl   $0x81278c,(%esp)
  800937:	e8 5d 01 00 00       	call   800a99 <cprintf>
			continue;
  80093c:	eb be                	jmp    8008fc <output+0x1c>
		}
		if (request == NSREQ_OUTPUT)
  80093e:	83 f8 0b             	cmp    $0xb,%eax
  800941:	75 17                	jne    80095a <output+0x7a>
		{	
			sys_transmit_packet(nsipcbuf.pkt.jp_data, nsipcbuf.pkt.jp_len);
  800943:	a1 00 80 81 00       	mov    0x818000,%eax
  800948:	89 44 24 04          	mov    %eax,0x4(%esp)
  80094c:	c7 04 24 04 80 81 00 	movl   $0x818004,(%esp)
  800953:	e8 f6 0c 00 00       	call   80164e <sys_transmit_packet>
  800958:	eb a2                	jmp    8008fc <output+0x1c>
		}
		else
			cprintf("\n output.c : Invalid request received! ");
  80095a:	c7 04 24 c4 27 81 00 	movl   $0x8127c4,(%esp)
  800961:	e8 33 01 00 00       	call   800a99 <cprintf>
  800966:	eb 94                	jmp    8008fc <output+0x1c>

00800968 <libmain>:
volatile struct Env *env;
char *binaryname = "(PROGRAM NAME UNKNOWN)";

void
libmain(int argc, char **argv)
{
  800968:	55                   	push   %ebp
  800969:	89 e5                	mov    %esp,%ebp
  80096b:	83 ec 18             	sub    $0x18,%esp
  80096e:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  800971:	89 75 fc             	mov    %esi,-0x4(%ebp)
  800974:	8b 75 08             	mov    0x8(%ebp),%esi
  800977:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	// set env to point at our env structure in envs[].
	// LAB 3b: Your code here.
	// Code added by Swastika / Sandeep	
	envid_t envid = sys_getenvid();
  80097a:	e8 5f 10 00 00       	call   8019de <sys_getenvid>
	env = &envs[ENVX(envid)];
  80097f:	25 ff 03 00 00       	and    $0x3ff,%eax
  800984:	6b c0 7c             	imul   $0x7c,%eax,%eax
  800987:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  80098c:	a3 f4 f5 b3 00       	mov    %eax,0xb3f5f4

	// save the name of the program so that panic() can use it
	if (argc > 0)
  800991:	85 f6                	test   %esi,%esi
  800993:	7e 07                	jle    80099c <libmain+0x34>
		binaryname = argv[0];
  800995:	8b 03                	mov    (%ebx),%eax
  800997:	a3 00 90 81 00       	mov    %eax,0x819000

	// call user main routine
	umain(argc, argv);
  80099c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8009a0:	89 34 24             	mov    %esi,(%esp)
  8009a3:	e8 b0 f6 ff ff       	call   800058 <umain>

	// exit gracefully
	exit();
  8009a8:	e8 0b 00 00 00       	call   8009b8 <exit>
}
  8009ad:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8009b0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8009b3:	89 ec                	mov    %ebp,%esp
  8009b5:	5d                   	pop    %ebp
  8009b6:	c3                   	ret    
	...

008009b8 <exit>:
#include <inc/lib.h>

void
exit(void)
{
  8009b8:	55                   	push   %ebp
  8009b9:	89 e5                	mov    %esp,%ebp
  8009bb:	83 ec 18             	sub    $0x18,%esp
	close_all();
  8009be:	e8 18 1a 00 00       	call   8023db <close_all>
	sys_env_destroy(0);
  8009c3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8009ca:	e8 43 10 00 00       	call   801a12 <sys_env_destroy>
}
  8009cf:	c9                   	leave  
  8009d0:	c3                   	ret    
  8009d1:	00 00                	add    %al,(%eax)
	...

008009d4 <_panic>:
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
{
  8009d4:	55                   	push   %ebp
  8009d5:	89 e5                	mov    %esp,%ebp
  8009d7:	53                   	push   %ebx
  8009d8:	83 ec 14             	sub    $0x14,%esp
 * Panic is called on unresolvable fatal errors.
 * It prints "panic: <message>", then causes a breakpoint exception,
 * which causes JOS to enter the JOS kernel monitor.
 */
void
_panic(const char *file, int line, const char *fmt,...)
  8009db:	8d 5d 14             	lea    0x14(%ebp),%ebx
	va_list ap;

	va_start(ap, fmt);

	// Print the panic message
	if (argv0)
  8009de:	a1 f8 f5 b3 00       	mov    0xb3f5f8,%eax
  8009e3:	85 c0                	test   %eax,%eax
  8009e5:	74 10                	je     8009f7 <_panic+0x23>
		cprintf("%s: ", argv0);
  8009e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8009eb:	c7 04 24 03 28 81 00 	movl   $0x812803,(%esp)
  8009f2:	e8 a2 00 00 00       	call   800a99 <cprintf>
	cprintf("user panic in %s at %s:%d: ", binaryname, file, line);
  8009f7:	8b 45 0c             	mov    0xc(%ebp),%eax
  8009fa:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8009fe:	8b 45 08             	mov    0x8(%ebp),%eax
  800a01:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a05:	a1 00 90 81 00       	mov    0x819000,%eax
  800a0a:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a0e:	c7 04 24 08 28 81 00 	movl   $0x812808,(%esp)
  800a15:	e8 7f 00 00 00       	call   800a99 <cprintf>
	vcprintf(fmt, ap);
  800a1a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  800a1e:	8b 45 10             	mov    0x10(%ebp),%eax
  800a21:	89 04 24             	mov    %eax,(%esp)
  800a24:	e8 0f 00 00 00       	call   800a38 <vcprintf>
	cprintf("\n");
  800a29:	c7 04 24 47 25 81 00 	movl   $0x812547,(%esp)
  800a30:	e8 64 00 00 00       	call   800a99 <cprintf>

	// Cause a breakpoint exception
	while (1)
		asm volatile("int3");
  800a35:	cc                   	int3   
  800a36:	eb fd                	jmp    800a35 <_panic+0x61>

00800a38 <vcprintf>:
	b->cnt++;
}

int
vcprintf(const char *fmt, va_list ap)
{
  800a38:	55                   	push   %ebp
  800a39:	89 e5                	mov    %esp,%ebp
  800a3b:	81 ec 28 01 00 00    	sub    $0x128,%esp
	struct printbuf b;

	b.idx = 0;
  800a41:	c7 85 f0 fe ff ff 00 	movl   $0x0,-0x110(%ebp)
  800a48:	00 00 00 
	b.cnt = 0;
  800a4b:	c7 85 f4 fe ff ff 00 	movl   $0x0,-0x10c(%ebp)
  800a52:	00 00 00 
	vprintfmt((void*)putch, &b, fmt, ap);
  800a55:	8b 45 0c             	mov    0xc(%ebp),%eax
  800a58:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800a5c:	8b 45 08             	mov    0x8(%ebp),%eax
  800a5f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800a63:	8d 85 f0 fe ff ff    	lea    -0x110(%ebp),%eax
  800a69:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a6d:	c7 04 24 b3 0a 80 00 	movl   $0x800ab3,(%esp)
  800a74:	e8 d4 01 00 00       	call   800c4d <vprintfmt>
	sys_cputs(b.buf, b.idx);
  800a79:	8b 85 f0 fe ff ff    	mov    -0x110(%ebp),%eax
  800a7f:	89 44 24 04          	mov    %eax,0x4(%esp)
  800a83:	8d 85 f8 fe ff ff    	lea    -0x108(%ebp),%eax
  800a89:	89 04 24             	mov    %eax,(%esp)
  800a8c:	e8 bf 0a 00 00       	call   801550 <sys_cputs>

	return b.cnt;
}
  800a91:	8b 85 f4 fe ff ff    	mov    -0x10c(%ebp),%eax
  800a97:	c9                   	leave  
  800a98:	c3                   	ret    

00800a99 <cprintf>:

int
cprintf(const char *fmt, ...)
{
  800a99:	55                   	push   %ebp
  800a9a:	89 e5                	mov    %esp,%ebp
  800a9c:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
cprintf(const char *fmt, ...)
  800a9f:	8d 45 0c             	lea    0xc(%ebp),%eax
{
	va_list ap;
	int cnt;

	va_start(ap, fmt);
	cnt = vcprintf(fmt, ap);
  800aa2:	89 44 24 04          	mov    %eax,0x4(%esp)
  800aa6:	8b 45 08             	mov    0x8(%ebp),%eax
  800aa9:	89 04 24             	mov    %eax,(%esp)
  800aac:	e8 87 ff ff ff       	call   800a38 <vcprintf>
	va_end(ap);

	return cnt;
}
  800ab1:	c9                   	leave  
  800ab2:	c3                   	ret    

00800ab3 <putch>:
};


static void
putch(int ch, struct printbuf *b)
{
  800ab3:	55                   	push   %ebp
  800ab4:	89 e5                	mov    %esp,%ebp
  800ab6:	53                   	push   %ebx
  800ab7:	83 ec 14             	sub    $0x14,%esp
  800aba:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	b->buf[b->idx++] = ch;
  800abd:	8b 03                	mov    (%ebx),%eax
  800abf:	8b 55 08             	mov    0x8(%ebp),%edx
  800ac2:	88 54 03 08          	mov    %dl,0x8(%ebx,%eax,1)
  800ac6:	83 c0 01             	add    $0x1,%eax
  800ac9:	89 03                	mov    %eax,(%ebx)
	if (b->idx == 256-1) {
  800acb:	3d ff 00 00 00       	cmp    $0xff,%eax
  800ad0:	75 19                	jne    800aeb <putch+0x38>
		sys_cputs(b->buf, b->idx);
  800ad2:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  800ad9:	00 
  800ada:	8d 43 08             	lea    0x8(%ebx),%eax
  800add:	89 04 24             	mov    %eax,(%esp)
  800ae0:	e8 6b 0a 00 00       	call   801550 <sys_cputs>
		b->idx = 0;
  800ae5:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
	}
	b->cnt++;
  800aeb:	83 43 04 01          	addl   $0x1,0x4(%ebx)
}
  800aef:	83 c4 14             	add    $0x14,%esp
  800af2:	5b                   	pop    %ebx
  800af3:	5d                   	pop    %ebp
  800af4:	c3                   	ret    
	...

00800b00 <printnum>:
 * using specified putch function and associated pointer putdat.
 */
static void
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
  800b00:	55                   	push   %ebp
  800b01:	89 e5                	mov    %esp,%ebp
  800b03:	57                   	push   %edi
  800b04:	56                   	push   %esi
  800b05:	53                   	push   %ebx
  800b06:	83 ec 4c             	sub    $0x4c,%esp
  800b09:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  800b0c:	89 d6                	mov    %edx,%esi
  800b0e:	8b 45 08             	mov    0x8(%ebp),%eax
  800b11:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800b14:	8b 55 0c             	mov    0xc(%ebp),%edx
  800b17:	89 55 e0             	mov    %edx,-0x20(%ebp)
  800b1a:	8b 45 10             	mov    0x10(%ebp),%eax
  800b1d:	8b 5d 14             	mov    0x14(%ebp),%ebx
  800b20:	8b 7d 18             	mov    0x18(%ebp),%edi
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
  800b23:	89 45 dc             	mov    %eax,-0x24(%ebp)
  800b26:	b9 00 00 00 00       	mov    $0x0,%ecx
  800b2b:	39 d1                	cmp    %edx,%ecx
  800b2d:	72 15                	jb     800b44 <printnum+0x44>
  800b2f:	77 07                	ja     800b38 <printnum+0x38>
  800b31:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800b34:	39 d0                	cmp    %edx,%eax
  800b36:	76 0c                	jbe    800b44 <printnum+0x44>
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800b38:	83 eb 01             	sub    $0x1,%ebx
  800b3b:	85 db                	test   %ebx,%ebx
  800b3d:	8d 76 00             	lea    0x0(%esi),%esi
  800b40:	7f 61                	jg     800ba3 <printnum+0xa3>
  800b42:	eb 70                	jmp    800bb4 <printnum+0xb4>
printnum(void (*putch)(int, void*), void *putdat,
	 unsigned long long num, unsigned base, int width, int padc)
{
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
  800b44:	89 7c 24 10          	mov    %edi,0x10(%esp)
  800b48:	83 eb 01             	sub    $0x1,%ebx
  800b4b:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b4f:	89 44 24 08          	mov    %eax,0x8(%esp)
  800b53:	8b 4c 24 08          	mov    0x8(%esp),%ecx
  800b57:	8b 5c 24 0c          	mov    0xc(%esp),%ebx
  800b5b:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800b5e:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  800b61:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800b64:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  800b68:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800b6f:	00 
  800b70:	8b 45 d8             	mov    -0x28(%ebp),%eax
  800b73:	89 04 24             	mov    %eax,(%esp)
  800b76:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800b79:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b7d:	e8 ce 16 01 00       	call   812250 <__udivdi3>
  800b82:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800b85:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  800b88:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  800b8c:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  800b90:	89 04 24             	mov    %eax,(%esp)
  800b93:	89 54 24 04          	mov    %edx,0x4(%esp)
  800b97:	89 f2                	mov    %esi,%edx
  800b99:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800b9c:	e8 5f ff ff ff       	call   800b00 <printnum>
  800ba1:	eb 11                	jmp    800bb4 <printnum+0xb4>
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
			putch(padc, putdat);
  800ba3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ba7:	89 3c 24             	mov    %edi,(%esp)
  800baa:	ff 55 e4             	call   *-0x1c(%ebp)
	// first recursively print all preceding (more significant) digits
	if (num >= base) {
		printnum(putch, putdat, num / base, base, width - 1, padc);
	} else {
		// print any needed pad characters before first digit
		while (--width > 0)
  800bad:	83 eb 01             	sub    $0x1,%ebx
  800bb0:	85 db                	test   %ebx,%ebx
  800bb2:	7f ef                	jg     800ba3 <printnum+0xa3>
			putch(padc, putdat);
	}

	// then print this (the least significant) digit
	putch("0123456789abcdef"[num % base], putdat);
  800bb4:	89 74 24 04          	mov    %esi,0x4(%esp)
  800bb8:	8b 74 24 04          	mov    0x4(%esp),%esi
  800bbc:	8b 45 dc             	mov    -0x24(%ebp),%eax
  800bbf:	89 44 24 08          	mov    %eax,0x8(%esp)
  800bc3:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  800bca:	00 
  800bcb:	8b 55 d8             	mov    -0x28(%ebp),%edx
  800bce:	89 14 24             	mov    %edx,(%esp)
  800bd1:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800bd4:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800bd8:	e8 a3 17 01 00       	call   812380 <__umoddi3>
  800bdd:	89 74 24 04          	mov    %esi,0x4(%esp)
  800be1:	0f be 80 24 28 81 00 	movsbl 0x812824(%eax),%eax
  800be8:	89 04 24             	mov    %eax,(%esp)
  800beb:	ff 55 e4             	call   *-0x1c(%ebp)
}
  800bee:	83 c4 4c             	add    $0x4c,%esp
  800bf1:	5b                   	pop    %ebx
  800bf2:	5e                   	pop    %esi
  800bf3:	5f                   	pop    %edi
  800bf4:	5d                   	pop    %ebp
  800bf5:	c3                   	ret    

00800bf6 <getuint>:

// Get an unsigned int of various possible sizes from a varargs list,
// depending on the lflag parameter.
static unsigned long long
getuint(va_list *ap, int lflag)
{
  800bf6:	55                   	push   %ebp
  800bf7:	89 e5                	mov    %esp,%ebp
	if (lflag >= 2)
  800bf9:	83 fa 01             	cmp    $0x1,%edx
  800bfc:	7e 0e                	jle    800c0c <getuint+0x16>
		return va_arg(*ap, unsigned long long);
  800bfe:	8b 10                	mov    (%eax),%edx
  800c00:	8d 4a 08             	lea    0x8(%edx),%ecx
  800c03:	89 08                	mov    %ecx,(%eax)
  800c05:	8b 02                	mov    (%edx),%eax
  800c07:	8b 52 04             	mov    0x4(%edx),%edx
  800c0a:	eb 22                	jmp    800c2e <getuint+0x38>
	else if (lflag)
  800c0c:	85 d2                	test   %edx,%edx
  800c0e:	74 10                	je     800c20 <getuint+0x2a>
		return va_arg(*ap, unsigned long);
  800c10:	8b 10                	mov    (%eax),%edx
  800c12:	8d 4a 04             	lea    0x4(%edx),%ecx
  800c15:	89 08                	mov    %ecx,(%eax)
  800c17:	8b 02                	mov    (%edx),%eax
  800c19:	ba 00 00 00 00       	mov    $0x0,%edx
  800c1e:	eb 0e                	jmp    800c2e <getuint+0x38>
	else
		return va_arg(*ap, unsigned int);
  800c20:	8b 10                	mov    (%eax),%edx
  800c22:	8d 4a 04             	lea    0x4(%edx),%ecx
  800c25:	89 08                	mov    %ecx,(%eax)
  800c27:	8b 02                	mov    (%edx),%eax
  800c29:	ba 00 00 00 00       	mov    $0x0,%edx
}
  800c2e:	5d                   	pop    %ebp
  800c2f:	c3                   	ret    

00800c30 <sprintputch>:
	int cnt;
};

static void
sprintputch(int ch, struct sprintbuf *b)
{
  800c30:	55                   	push   %ebp
  800c31:	89 e5                	mov    %esp,%ebp
  800c33:	8b 45 0c             	mov    0xc(%ebp),%eax
	b->cnt++;
  800c36:	83 40 08 01          	addl   $0x1,0x8(%eax)
	if (b->buf < b->ebuf)
  800c3a:	8b 10                	mov    (%eax),%edx
  800c3c:	3b 50 04             	cmp    0x4(%eax),%edx
  800c3f:	73 0a                	jae    800c4b <sprintputch+0x1b>
		*b->buf++ = ch;
  800c41:	8b 4d 08             	mov    0x8(%ebp),%ecx
  800c44:	88 0a                	mov    %cl,(%edx)
  800c46:	83 c2 01             	add    $0x1,%edx
  800c49:	89 10                	mov    %edx,(%eax)
}
  800c4b:	5d                   	pop    %ebp
  800c4c:	c3                   	ret    

00800c4d <vprintfmt>:
// Main function to format and print a string.
void printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...);

void
vprintfmt(void (*putch)(int, void*), void *putdat, const char *fmt, va_list ap)
{
  800c4d:	55                   	push   %ebp
  800c4e:	89 e5                	mov    %esp,%ebp
  800c50:	57                   	push   %edi
  800c51:	56                   	push   %esi
  800c52:	53                   	push   %ebx
  800c53:	83 ec 5c             	sub    $0x5c,%esp
  800c56:	8b 7d 08             	mov    0x8(%ebp),%edi
  800c59:	8b 75 0c             	mov    0xc(%ebp),%esi
  800c5c:	8b 5d 10             	mov    0x10(%ebp),%ebx
		case '#':
			altflag = 1;
			goto reswitch;

		process_precision:
			if (width < 0)
  800c5f:	c7 45 c8 ff ff ff ff 	movl   $0xffffffff,-0x38(%ebp)
  800c66:	eb 11                	jmp    800c79 <vprintfmt+0x2c>
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
			if (ch == '\0')
  800c68:	85 c0                	test   %eax,%eax
  800c6a:	0f 84 ec 03 00 00    	je     80105c <vprintfmt+0x40f>
				return;
			putch(ch, putdat);
  800c70:	89 74 24 04          	mov    %esi,0x4(%esp)
  800c74:	89 04 24             	mov    %eax,(%esp)
  800c77:	ff d7                	call   *%edi
	unsigned long long num;
	int base, lflag, width, precision, altflag;
	char padc;

	while (1) {
		while ((ch = *(unsigned char *) fmt++) != '%') {
  800c79:	0f b6 03             	movzbl (%ebx),%eax
  800c7c:	83 c3 01             	add    $0x1,%ebx
  800c7f:	83 f8 25             	cmp    $0x25,%eax
  800c82:	75 e4                	jne    800c68 <vprintfmt+0x1b>
  800c84:	c6 45 d4 20          	movb   $0x20,-0x2c(%ebp)
  800c88:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  800c8f:	c7 45 d0 ff ff ff ff 	movl   $0xffffffff,-0x30(%ebp)
  800c96:	c7 45 e4 ff ff ff ff 	movl   $0xffffffff,-0x1c(%ebp)
  800c9d:	b9 00 00 00 00       	mov    $0x0,%ecx
  800ca2:	eb 06                	jmp    800caa <vprintfmt+0x5d>
  800ca4:	c6 45 d4 2d          	movb   $0x2d,-0x2c(%ebp)
  800ca8:	89 c3                	mov    %eax,%ebx
		width = -1;
		precision = -1;
		lflag = 0;
		altflag = 0;
	reswitch:
		switch (ch = *(unsigned char *) fmt++) {
  800caa:	0f b6 13             	movzbl (%ebx),%edx
  800cad:	0f b6 c2             	movzbl %dl,%eax
  800cb0:	89 45 e0             	mov    %eax,-0x20(%ebp)
  800cb3:	8d 43 01             	lea    0x1(%ebx),%eax
  800cb6:	83 ea 23             	sub    $0x23,%edx
  800cb9:	80 fa 55             	cmp    $0x55,%dl
  800cbc:	0f 87 7d 03 00 00    	ja     80103f <vprintfmt+0x3f2>
  800cc2:	0f b6 d2             	movzbl %dl,%edx
  800cc5:	ff 24 95 60 29 81 00 	jmp    *0x812960(,%edx,4)
  800ccc:	c6 45 d4 30          	movb   $0x30,-0x2c(%ebp)
  800cd0:	eb d6                	jmp    800ca8 <vprintfmt+0x5b>
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
				precision = precision * 10 + ch - '0';
  800cd2:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800cd5:	83 ea 30             	sub    $0x30,%edx
  800cd8:	89 55 d0             	mov    %edx,-0x30(%ebp)
				ch = *fmt;
  800cdb:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800cde:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800ce1:	83 fb 09             	cmp    $0x9,%ebx
  800ce4:	77 4c                	ja     800d32 <vprintfmt+0xe5>
  800ce6:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  800ce9:	8b 4d d0             	mov    -0x30(%ebp),%ecx
		case '5':
		case '6':
		case '7':
		case '8':
		case '9':
			for (precision = 0; ; ++fmt) {
  800cec:	83 c0 01             	add    $0x1,%eax
				precision = precision * 10 + ch - '0';
  800cef:	8d 0c 89             	lea    (%ecx,%ecx,4),%ecx
  800cf2:	8d 4c 4a d0          	lea    -0x30(%edx,%ecx,2),%ecx
				ch = *fmt;
  800cf6:	0f be 10             	movsbl (%eax),%edx
				if (ch < '0' || ch > '9')
  800cf9:	8d 5a d0             	lea    -0x30(%edx),%ebx
  800cfc:	83 fb 09             	cmp    $0x9,%ebx
  800cff:	76 eb                	jbe    800cec <vprintfmt+0x9f>
  800d01:	89 4d d0             	mov    %ecx,-0x30(%ebp)
  800d04:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800d07:	eb 29                	jmp    800d32 <vprintfmt+0xe5>
					break;
			}
			goto process_precision;

		case '*':
			precision = va_arg(ap, int);
  800d09:	8b 55 14             	mov    0x14(%ebp),%edx
  800d0c:	8d 5a 04             	lea    0x4(%edx),%ebx
  800d0f:	89 5d 14             	mov    %ebx,0x14(%ebp)
  800d12:	8b 12                	mov    (%edx),%edx
  800d14:	89 55 d0             	mov    %edx,-0x30(%ebp)
			goto process_precision;
  800d17:	eb 19                	jmp    800d32 <vprintfmt+0xe5>

		case '.':
			if (width < 0)
  800d19:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  800d1c:	c1 fa 1f             	sar    $0x1f,%edx
  800d1f:	f7 d2                	not    %edx
  800d21:	21 55 e4             	and    %edx,-0x1c(%ebp)
  800d24:	eb 82                	jmp    800ca8 <vprintfmt+0x5b>
  800d26:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
				width = 0;
			goto reswitch;

		case '#':
			altflag = 1;
			goto reswitch;
  800d2d:	e9 76 ff ff ff       	jmp    800ca8 <vprintfmt+0x5b>

		process_precision:
			if (width < 0)
  800d32:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800d36:	0f 89 6c ff ff ff    	jns    800ca8 <vprintfmt+0x5b>
  800d3c:	8b 55 d0             	mov    -0x30(%ebp),%edx
  800d3f:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  800d42:	8b 55 c8             	mov    -0x38(%ebp),%edx
  800d45:	89 55 d0             	mov    %edx,-0x30(%ebp)
  800d48:	e9 5b ff ff ff       	jmp    800ca8 <vprintfmt+0x5b>
				width = precision, precision = -1;
			goto reswitch;

		// long flag (doubled for long long)
		case 'l':
			lflag++;
  800d4d:	83 c1 01             	add    $0x1,%ecx
			goto reswitch;
  800d50:	e9 53 ff ff ff       	jmp    800ca8 <vprintfmt+0x5b>
  800d55:	89 45 cc             	mov    %eax,-0x34(%ebp)

		// character
		case 'c':
			putch(va_arg(ap, int), putdat);
  800d58:	8b 45 14             	mov    0x14(%ebp),%eax
  800d5b:	8d 50 04             	lea    0x4(%eax),%edx
  800d5e:	89 55 14             	mov    %edx,0x14(%ebp)
  800d61:	89 74 24 04          	mov    %esi,0x4(%esp)
  800d65:	8b 00                	mov    (%eax),%eax
  800d67:	89 04 24             	mov    %eax,(%esp)
  800d6a:	ff d7                	call   *%edi
  800d6c:	8b 5d cc             	mov    -0x34(%ebp),%ebx
			break;
  800d6f:	e9 05 ff ff ff       	jmp    800c79 <vprintfmt+0x2c>
  800d74:	89 45 cc             	mov    %eax,-0x34(%ebp)

		// error message
		case 'e':
			err = va_arg(ap, int);
  800d77:	8b 45 14             	mov    0x14(%ebp),%eax
  800d7a:	8d 50 04             	lea    0x4(%eax),%edx
  800d7d:	89 55 14             	mov    %edx,0x14(%ebp)
  800d80:	8b 00                	mov    (%eax),%eax
  800d82:	89 c2                	mov    %eax,%edx
  800d84:	c1 fa 1f             	sar    $0x1f,%edx
  800d87:	31 d0                	xor    %edx,%eax
  800d89:	29 d0                	sub    %edx,%eax
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800d8b:	83 f8 0f             	cmp    $0xf,%eax
  800d8e:	7f 0b                	jg     800d9b <vprintfmt+0x14e>
  800d90:	8b 14 85 c0 2a 81 00 	mov    0x812ac0(,%eax,4),%edx
  800d97:	85 d2                	test   %edx,%edx
  800d99:	75 20                	jne    800dbb <vprintfmt+0x16e>
				printfmt(putch, putdat, "error %d", err);
  800d9b:	89 44 24 0c          	mov    %eax,0xc(%esp)
  800d9f:	c7 44 24 08 35 28 81 	movl   $0x812835,0x8(%esp)
  800da6:	00 
  800da7:	89 74 24 04          	mov    %esi,0x4(%esp)
  800dab:	89 3c 24             	mov    %edi,(%esp)
  800dae:	e8 31 03 00 00       	call   8010e4 <printfmt>
  800db3:	8b 5d cc             	mov    -0x34(%ebp),%ebx
		// error message
		case 'e':
			err = va_arg(ap, int);
			if (err < 0)
				err = -err;
			if (err > MAXERROR || (p = error_string[err]) == NULL)
  800db6:	e9 be fe ff ff       	jmp    800c79 <vprintfmt+0x2c>
				printfmt(putch, putdat, "error %d", err);
			else
				printfmt(putch, putdat, "%s", p);
  800dbb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  800dbf:	c7 44 24 08 22 2e 81 	movl   $0x812e22,0x8(%esp)
  800dc6:	00 
  800dc7:	89 74 24 04          	mov    %esi,0x4(%esp)
  800dcb:	89 3c 24             	mov    %edi,(%esp)
  800dce:	e8 11 03 00 00       	call   8010e4 <printfmt>
  800dd3:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  800dd6:	e9 9e fe ff ff       	jmp    800c79 <vprintfmt+0x2c>
  800ddb:	89 45 cc             	mov    %eax,-0x34(%ebp)
  800dde:	89 c3                	mov    %eax,%ebx
  800de0:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  800de3:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  800de6:	89 45 c4             	mov    %eax,-0x3c(%ebp)
			break;

		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
  800de9:	8b 45 14             	mov    0x14(%ebp),%eax
  800dec:	8d 50 04             	lea    0x4(%eax),%edx
  800def:	89 55 14             	mov    %edx,0x14(%ebp)
  800df2:	8b 00                	mov    (%eax),%eax
  800df4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  800df7:	85 c0                	test   %eax,%eax
  800df9:	75 07                	jne    800e02 <vprintfmt+0x1b5>
  800dfb:	c7 45 e0 3e 28 81 00 	movl   $0x81283e,-0x20(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
  800e02:	83 7d c4 00          	cmpl   $0x0,-0x3c(%ebp)
  800e06:	7e 06                	jle    800e0e <vprintfmt+0x1c1>
  800e08:	80 7d d4 2d          	cmpb   $0x2d,-0x2c(%ebp)
  800e0c:	75 13                	jne    800e21 <vprintfmt+0x1d4>
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e0e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800e11:	0f be 02             	movsbl (%edx),%eax
  800e14:	85 c0                	test   %eax,%eax
  800e16:	0f 85 99 00 00 00    	jne    800eb5 <vprintfmt+0x268>
  800e1c:	e9 86 00 00 00       	jmp    800ea7 <vprintfmt+0x25a>
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800e21:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  800e25:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  800e28:	89 0c 24             	mov    %ecx,(%esp)
  800e2b:	e8 fb 02 00 00       	call   80112b <strnlen>
  800e30:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  800e33:	29 c2                	sub    %eax,%edx
  800e35:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  800e38:	85 d2                	test   %edx,%edx
  800e3a:	7e d2                	jle    800e0e <vprintfmt+0x1c1>
					putch(padc, putdat);
  800e3c:	0f be 4d d4          	movsbl -0x2c(%ebp),%ecx
  800e40:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  800e43:	89 5d c4             	mov    %ebx,-0x3c(%ebp)
  800e46:	89 d3                	mov    %edx,%ebx
  800e48:	89 74 24 04          	mov    %esi,0x4(%esp)
  800e4c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  800e4f:	89 04 24             	mov    %eax,(%esp)
  800e52:	ff d7                	call   *%edi
		// string
		case 's':
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
  800e54:	83 eb 01             	sub    $0x1,%ebx
  800e57:	85 db                	test   %ebx,%ebx
  800e59:	7f ed                	jg     800e48 <vprintfmt+0x1fb>
  800e5b:	8b 5d c4             	mov    -0x3c(%ebp),%ebx
  800e5e:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  800e65:	eb a7                	jmp    800e0e <vprintfmt+0x1c1>
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e67:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  800e6b:	74 18                	je     800e85 <vprintfmt+0x238>
  800e6d:	8d 50 e0             	lea    -0x20(%eax),%edx
  800e70:	83 fa 5e             	cmp    $0x5e,%edx
  800e73:	76 10                	jbe    800e85 <vprintfmt+0x238>
					putch('?', putdat);
  800e75:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e79:	c7 04 24 3f 00 00 00 	movl   $0x3f,(%esp)
  800e80:	ff 55 e0             	call   *-0x20(%ebp)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
  800e83:	eb 0a                	jmp    800e8f <vprintfmt+0x242>
					putch('?', putdat);
				else
					putch(ch, putdat);
  800e85:	89 7c 24 04          	mov    %edi,0x4(%esp)
  800e89:	89 04 24             	mov    %eax,(%esp)
  800e8c:	ff 55 e0             	call   *-0x20(%ebp)
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800e8f:	83 6d e4 01          	subl   $0x1,-0x1c(%ebp)
  800e93:	0f be 03             	movsbl (%ebx),%eax
  800e96:	85 c0                	test   %eax,%eax
  800e98:	74 05                	je     800e9f <vprintfmt+0x252>
  800e9a:	83 c3 01             	add    $0x1,%ebx
  800e9d:	eb 29                	jmp    800ec8 <vprintfmt+0x27b>
  800e9f:	89 fe                	mov    %edi,%esi
  800ea1:	8b 7d e0             	mov    -0x20(%ebp),%edi
  800ea4:	8b 5d d0             	mov    -0x30(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800ea7:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  800eab:	7f 2e                	jg     800edb <vprintfmt+0x28e>
  800ead:	8b 5d cc             	mov    -0x34(%ebp),%ebx
  800eb0:	e9 c4 fd ff ff       	jmp    800c79 <vprintfmt+0x2c>
			if ((p = va_arg(ap, char *)) == NULL)
				p = "(null)";
			if (width > 0 && padc != '-')
				for (width -= strnlen(p, precision); width > 0; width--)
					putch(padc, putdat);
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
  800eb5:	8b 55 e0             	mov    -0x20(%ebp),%edx
  800eb8:	83 c2 01             	add    $0x1,%edx
  800ebb:	89 7d e0             	mov    %edi,-0x20(%ebp)
  800ebe:	89 f7                	mov    %esi,%edi
  800ec0:	8b 75 d0             	mov    -0x30(%ebp),%esi
  800ec3:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  800ec6:	89 d3                	mov    %edx,%ebx
  800ec8:	85 f6                	test   %esi,%esi
  800eca:	78 9b                	js     800e67 <vprintfmt+0x21a>
  800ecc:	83 ee 01             	sub    $0x1,%esi
  800ecf:	79 96                	jns    800e67 <vprintfmt+0x21a>
  800ed1:	89 fe                	mov    %edi,%esi
  800ed3:	8b 7d e0             	mov    -0x20(%ebp),%edi
  800ed6:	8b 5d d0             	mov    -0x30(%ebp),%ebx
  800ed9:	eb cc                	jmp    800ea7 <vprintfmt+0x25a>
  800edb:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  800ede:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
				putch(' ', putdat);
  800ee1:	89 74 24 04          	mov    %esi,0x4(%esp)
  800ee5:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  800eec:	ff d7                	call   *%edi
			for (; (ch = *p++) != '\0' && (precision < 0 || --precision >= 0); width--)
				if (altflag && (ch < ' ' || ch > '~'))
					putch('?', putdat);
				else
					putch(ch, putdat);
			for (; width > 0; width--)
  800eee:	83 eb 01             	sub    $0x1,%ebx
  800ef1:	85 db                	test   %ebx,%ebx
  800ef3:	7f ec                	jg     800ee1 <vprintfmt+0x294>
  800ef5:	8b 5d d8             	mov    -0x28(%ebp),%ebx
  800ef8:	e9 7c fd ff ff       	jmp    800c79 <vprintfmt+0x2c>
  800efd:	89 45 cc             	mov    %eax,-0x34(%ebp)
// Same as getuint but signed - can't use getuint
// because of sign extension
static long long
getint(va_list *ap, int lflag)
{
	if (lflag >= 2)
  800f00:	83 f9 01             	cmp    $0x1,%ecx
  800f03:	7e 16                	jle    800f1b <vprintfmt+0x2ce>
		return va_arg(*ap, long long);
  800f05:	8b 45 14             	mov    0x14(%ebp),%eax
  800f08:	8d 50 08             	lea    0x8(%eax),%edx
  800f0b:	89 55 14             	mov    %edx,0x14(%ebp)
  800f0e:	8b 10                	mov    (%eax),%edx
  800f10:	8b 48 04             	mov    0x4(%eax),%ecx
  800f13:	89 55 d8             	mov    %edx,-0x28(%ebp)
  800f16:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800f19:	eb 32                	jmp    800f4d <vprintfmt+0x300>
	else if (lflag)
  800f1b:	85 c9                	test   %ecx,%ecx
  800f1d:	74 18                	je     800f37 <vprintfmt+0x2ea>
		return va_arg(*ap, long);
  800f1f:	8b 45 14             	mov    0x14(%ebp),%eax
  800f22:	8d 50 04             	lea    0x4(%eax),%edx
  800f25:	89 55 14             	mov    %edx,0x14(%ebp)
  800f28:	8b 00                	mov    (%eax),%eax
  800f2a:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800f2d:	89 c1                	mov    %eax,%ecx
  800f2f:	c1 f9 1f             	sar    $0x1f,%ecx
  800f32:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  800f35:	eb 16                	jmp    800f4d <vprintfmt+0x300>
	else
		return va_arg(*ap, int);
  800f37:	8b 45 14             	mov    0x14(%ebp),%eax
  800f3a:	8d 50 04             	lea    0x4(%eax),%edx
  800f3d:	89 55 14             	mov    %edx,0x14(%ebp)
  800f40:	8b 00                	mov    (%eax),%eax
  800f42:	89 45 d8             	mov    %eax,-0x28(%ebp)
  800f45:	89 c2                	mov    %eax,%edx
  800f47:	c1 fa 1f             	sar    $0x1f,%edx
  800f4a:	89 55 dc             	mov    %edx,-0x24(%ebp)
				putch(' ', putdat);
			break;

		// (signed) decimal
		case 'd':
			num = getint(&ap, lflag);
  800f4d:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  800f50:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800f53:	b8 0a 00 00 00       	mov    $0xa,%eax
			if ((long long) num < 0) {
  800f58:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  800f5c:	0f 89 9b 00 00 00    	jns    800ffd <vprintfmt+0x3b0>
				putch('-', putdat);
  800f62:	89 74 24 04          	mov    %esi,0x4(%esp)
  800f66:	c7 04 24 2d 00 00 00 	movl   $0x2d,(%esp)
  800f6d:	ff d7                	call   *%edi
				num = -(long long) num;
  800f6f:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  800f72:	8b 5d dc             	mov    -0x24(%ebp),%ebx
  800f75:	f7 d9                	neg    %ecx
  800f77:	83 d3 00             	adc    $0x0,%ebx
  800f7a:	f7 db                	neg    %ebx
  800f7c:	b8 0a 00 00 00       	mov    $0xa,%eax
  800f81:	eb 7a                	jmp    800ffd <vprintfmt+0x3b0>
  800f83:	89 45 cc             	mov    %eax,-0x34(%ebp)
			base = 10;
			goto number;

		// unsigned decimal
		case 'u':
			num = getuint(&ap, lflag);
  800f86:	89 ca                	mov    %ecx,%edx
  800f88:	8d 45 14             	lea    0x14(%ebp),%eax
  800f8b:	e8 66 fc ff ff       	call   800bf6 <getuint>
  800f90:	89 c1                	mov    %eax,%ecx
  800f92:	89 d3                	mov    %edx,%ebx
  800f94:	b8 0a 00 00 00       	mov    $0xa,%eax
			base = 10;
			goto number;
  800f99:	eb 62                	jmp    800ffd <vprintfmt+0x3b0>
  800f9b:	89 45 cc             	mov    %eax,-0x34(%ebp)
		case 'o':
			// Replace this with your code.
			// putch('X', putdat);
			// putch('X', putdat);
			// putch('X', putdat);
			num = getuint(&ap, lflag);
  800f9e:	89 ca                	mov    %ecx,%edx
  800fa0:	8d 45 14             	lea    0x14(%ebp),%eax
  800fa3:	e8 4e fc ff ff       	call   800bf6 <getuint>
  800fa8:	89 c1                	mov    %eax,%ecx
  800faa:	89 d3                	mov    %edx,%ebx
  800fac:	b8 08 00 00 00       	mov    $0x8,%eax
			base = 8;
			goto number;
  800fb1:	eb 4a                	jmp    800ffd <vprintfmt+0x3b0>
  800fb3:	89 45 cc             	mov    %eax,-0x34(%ebp)
			break;

		// pointer
		case 'p':
			putch('0', putdat);
  800fb6:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fba:	c7 04 24 30 00 00 00 	movl   $0x30,(%esp)
  800fc1:	ff d7                	call   *%edi
			putch('x', putdat);
  800fc3:	89 74 24 04          	mov    %esi,0x4(%esp)
  800fc7:	c7 04 24 78 00 00 00 	movl   $0x78,(%esp)
  800fce:	ff d7                	call   *%edi
			num = (unsigned long long)
  800fd0:	8b 45 14             	mov    0x14(%ebp),%eax
  800fd3:	8d 50 04             	lea    0x4(%eax),%edx
  800fd6:	89 55 14             	mov    %edx,0x14(%ebp)
  800fd9:	8b 08                	mov    (%eax),%ecx
  800fdb:	bb 00 00 00 00       	mov    $0x0,%ebx
  800fe0:	b8 10 00 00 00       	mov    $0x10,%eax
				(uintptr_t) va_arg(ap, void *);
			base = 16;
			goto number;
  800fe5:	eb 16                	jmp    800ffd <vprintfmt+0x3b0>
  800fe7:	89 45 cc             	mov    %eax,-0x34(%ebp)

		// (unsigned) hexadecimal
		case 'x':
			num = getuint(&ap, lflag);
  800fea:	89 ca                	mov    %ecx,%edx
  800fec:	8d 45 14             	lea    0x14(%ebp),%eax
  800fef:	e8 02 fc ff ff       	call   800bf6 <getuint>
  800ff4:	89 c1                	mov    %eax,%ecx
  800ff6:	89 d3                	mov    %edx,%ebx
  800ff8:	b8 10 00 00 00       	mov    $0x10,%eax
			base = 16;
		number:
			printnum(putch, putdat, num, base, width, padc);
  800ffd:	0f be 55 d4          	movsbl -0x2c(%ebp),%edx
  801001:	89 54 24 10          	mov    %edx,0x10(%esp)
  801005:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  801008:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80100c:	89 44 24 08          	mov    %eax,0x8(%esp)
  801010:	89 0c 24             	mov    %ecx,(%esp)
  801013:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801017:	89 f2                	mov    %esi,%edx
  801019:	89 f8                	mov    %edi,%eax
  80101b:	e8 e0 fa ff ff       	call   800b00 <printnum>
  801020:	8b 5d cc             	mov    -0x34(%ebp),%ebx
			break;
  801023:	e9 51 fc ff ff       	jmp    800c79 <vprintfmt+0x2c>
  801028:	89 45 cc             	mov    %eax,-0x34(%ebp)
  80102b:	8b 55 e0             	mov    -0x20(%ebp),%edx

		// escaped '%' character
		case '%':
			putch(ch, putdat);
  80102e:	89 74 24 04          	mov    %esi,0x4(%esp)
  801032:	89 14 24             	mov    %edx,(%esp)
  801035:	ff d7                	call   *%edi
  801037:	8b 5d cc             	mov    -0x34(%ebp),%ebx
			break;
  80103a:	e9 3a fc ff ff       	jmp    800c79 <vprintfmt+0x2c>
			
		// unrecognized escape sequence - just print it literally
		default:
			putch('%', putdat);
  80103f:	89 74 24 04          	mov    %esi,0x4(%esp)
  801043:	c7 04 24 25 00 00 00 	movl   $0x25,(%esp)
  80104a:	ff d7                	call   *%edi
			for (fmt--; fmt[-1] != '%'; fmt--)
  80104c:	8d 43 ff             	lea    -0x1(%ebx),%eax
  80104f:	80 38 25             	cmpb   $0x25,(%eax)
  801052:	0f 84 21 fc ff ff    	je     800c79 <vprintfmt+0x2c>
  801058:	89 c3                	mov    %eax,%ebx
  80105a:	eb f0                	jmp    80104c <vprintfmt+0x3ff>
				/* do nothing */;
			break;
		}
	}
}
  80105c:	83 c4 5c             	add    $0x5c,%esp
  80105f:	5b                   	pop    %ebx
  801060:	5e                   	pop    %esi
  801061:	5f                   	pop    %edi
  801062:	5d                   	pop    %ebp
  801063:	c3                   	ret    

00801064 <vsnprintf>:
		*b->buf++ = ch;
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
  801064:	55                   	push   %ebp
  801065:	89 e5                	mov    %esp,%ebp
  801067:	83 ec 28             	sub    $0x28,%esp
  80106a:	8b 45 08             	mov    0x8(%ebp),%eax
  80106d:	8b 55 0c             	mov    0xc(%ebp),%edx
	struct sprintbuf b = {buf, buf+n-1, 0};

	if (buf == NULL || n < 1)
  801070:	85 c0                	test   %eax,%eax
  801072:	74 04                	je     801078 <vsnprintf+0x14>
  801074:	85 d2                	test   %edx,%edx
  801076:	7f 07                	jg     80107f <vsnprintf+0x1b>
  801078:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
  80107d:	eb 3b                	jmp    8010ba <vsnprintf+0x56>
}

int
vsnprintf(char *buf, int n, const char *fmt, va_list ap)
{
	struct sprintbuf b = {buf, buf+n-1, 0};
  80107f:	89 45 ec             	mov    %eax,-0x14(%ebp)
  801082:	8d 44 10 ff          	lea    -0x1(%eax,%edx,1),%eax
  801086:	89 45 f0             	mov    %eax,-0x10(%ebp)
  801089:	c7 45 f4 00 00 00 00 	movl   $0x0,-0xc(%ebp)

	if (buf == NULL || n < 1)
		return -E_INVAL;

	// print the string to the buffer
	vprintfmt((void*)sprintputch, &b, fmt, ap);
  801090:	8b 45 14             	mov    0x14(%ebp),%eax
  801093:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801097:	8b 45 10             	mov    0x10(%ebp),%eax
  80109a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80109e:	8d 45 ec             	lea    -0x14(%ebp),%eax
  8010a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010a5:	c7 04 24 30 0c 80 00 	movl   $0x800c30,(%esp)
  8010ac:	e8 9c fb ff ff       	call   800c4d <vprintfmt>

	// null terminate the buffer
	*b.buf = '\0';
  8010b1:	8b 45 ec             	mov    -0x14(%ebp),%eax
  8010b4:	c6 00 00             	movb   $0x0,(%eax)

	return b.cnt;
  8010b7:	8b 45 f4             	mov    -0xc(%ebp),%eax
}
  8010ba:	c9                   	leave  
  8010bb:	c3                   	ret    

008010bc <snprintf>:

int
snprintf(char *buf, int n, const char *fmt, ...)
{
  8010bc:	55                   	push   %ebp
  8010bd:	89 e5                	mov    %esp,%ebp
  8010bf:	83 ec 18             	sub    $0x18,%esp

	return b.cnt;
}

int
snprintf(char *buf, int n, const char *fmt, ...)
  8010c2:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;
	int rc;

	va_start(ap, fmt);
	rc = vsnprintf(buf, n, fmt, ap);
  8010c5:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8010c9:	8b 45 10             	mov    0x10(%ebp),%eax
  8010cc:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010d0:	8b 45 0c             	mov    0xc(%ebp),%eax
  8010d3:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010d7:	8b 45 08             	mov    0x8(%ebp),%eax
  8010da:	89 04 24             	mov    %eax,(%esp)
  8010dd:	e8 82 ff ff ff       	call   801064 <vsnprintf>
	va_end(ap);

	return rc;
}
  8010e2:	c9                   	leave  
  8010e3:	c3                   	ret    

008010e4 <printfmt>:
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
{
  8010e4:	55                   	push   %ebp
  8010e5:	89 e5                	mov    %esp,%ebp
  8010e7:	83 ec 18             	sub    $0x18,%esp
		}
	}
}

void
printfmt(void (*putch)(int, void*), void *putdat, const char *fmt, ...)
  8010ea:	8d 45 14             	lea    0x14(%ebp),%eax
{
	va_list ap;

	va_start(ap, fmt);
	vprintfmt(putch, putdat, fmt, ap);
  8010ed:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8010f1:	8b 45 10             	mov    0x10(%ebp),%eax
  8010f4:	89 44 24 08          	mov    %eax,0x8(%esp)
  8010f8:	8b 45 0c             	mov    0xc(%ebp),%eax
  8010fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8010ff:	8b 45 08             	mov    0x8(%ebp),%eax
  801102:	89 04 24             	mov    %eax,(%esp)
  801105:	e8 43 fb ff ff       	call   800c4d <vprintfmt>
	va_end(ap);
}
  80110a:	c9                   	leave  
  80110b:	c3                   	ret    
  80110c:	00 00                	add    %al,(%eax)
	...

00801110 <strlen>:
// Primespipe runs 3x faster this way.
#define ASM 1

int
strlen(const char *s)
{
  801110:	55                   	push   %ebp
  801111:	89 e5                	mov    %esp,%ebp
  801113:	8b 55 08             	mov    0x8(%ebp),%edx
	int n;

	for (n = 0; *s != '\0'; s++)
  801116:	b8 00 00 00 00       	mov    $0x0,%eax
  80111b:	80 3a 00             	cmpb   $0x0,(%edx)
  80111e:	74 09                	je     801129 <strlen+0x19>
		n++;
  801120:	83 c0 01             	add    $0x1,%eax
int
strlen(const char *s)
{
	int n;

	for (n = 0; *s != '\0'; s++)
  801123:	80 3c 02 00          	cmpb   $0x0,(%edx,%eax,1)
  801127:	75 f7                	jne    801120 <strlen+0x10>
		n++;
	return n;
}
  801129:	5d                   	pop    %ebp
  80112a:	c3                   	ret    

0080112b <strnlen>:

int
strnlen(const char *s, size_t size)
{
  80112b:	55                   	push   %ebp
  80112c:	89 e5                	mov    %esp,%ebp
  80112e:	53                   	push   %ebx
  80112f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801132:	8b 4d 0c             	mov    0xc(%ebp),%ecx
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801135:	85 c9                	test   %ecx,%ecx
  801137:	74 19                	je     801152 <strnlen+0x27>
  801139:	80 3b 00             	cmpb   $0x0,(%ebx)
  80113c:	74 14                	je     801152 <strnlen+0x27>
  80113e:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
  801143:	83 c0 01             	add    $0x1,%eax
int
strnlen(const char *s, size_t size)
{
	int n;

	for (n = 0; size > 0 && *s != '\0'; s++, size--)
  801146:	39 c8                	cmp    %ecx,%eax
  801148:	74 0d                	je     801157 <strnlen+0x2c>
  80114a:	80 3c 03 00          	cmpb   $0x0,(%ebx,%eax,1)
  80114e:	75 f3                	jne    801143 <strnlen+0x18>
  801150:	eb 05                	jmp    801157 <strnlen+0x2c>
  801152:	b8 00 00 00 00       	mov    $0x0,%eax
		n++;
	return n;
}
  801157:	5b                   	pop    %ebx
  801158:	5d                   	pop    %ebp
  801159:	c3                   	ret    

0080115a <strcpy>:

char *
strcpy(char *dst, const char *src)
{
  80115a:	55                   	push   %ebp
  80115b:	89 e5                	mov    %esp,%ebp
  80115d:	53                   	push   %ebx
  80115e:	8b 45 08             	mov    0x8(%ebp),%eax
  801161:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801164:	ba 00 00 00 00       	mov    $0x0,%edx
	char *ret;

	ret = dst;
	while ((*dst++ = *src++) != '\0')
  801169:	0f b6 0c 13          	movzbl (%ebx,%edx,1),%ecx
  80116d:	88 0c 10             	mov    %cl,(%eax,%edx,1)
  801170:	83 c2 01             	add    $0x1,%edx
  801173:	84 c9                	test   %cl,%cl
  801175:	75 f2                	jne    801169 <strcpy+0xf>
		/* do nothing */;
	return ret;
}
  801177:	5b                   	pop    %ebx
  801178:	5d                   	pop    %ebp
  801179:	c3                   	ret    

0080117a <strncpy>:

char *
strncpy(char *dst, const char *src, size_t size) {
  80117a:	55                   	push   %ebp
  80117b:	89 e5                	mov    %esp,%ebp
  80117d:	56                   	push   %esi
  80117e:	53                   	push   %ebx
  80117f:	8b 45 08             	mov    0x8(%ebp),%eax
  801182:	8b 55 0c             	mov    0xc(%ebp),%edx
  801185:	8b 75 10             	mov    0x10(%ebp),%esi
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  801188:	85 f6                	test   %esi,%esi
  80118a:	74 18                	je     8011a4 <strncpy+0x2a>
  80118c:	b9 00 00 00 00       	mov    $0x0,%ecx
		*dst++ = *src;
  801191:	0f b6 1a             	movzbl (%edx),%ebx
  801194:	88 1c 08             	mov    %bl,(%eax,%ecx,1)
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
  801197:	80 3a 01             	cmpb   $0x1,(%edx)
  80119a:	83 da ff             	sbb    $0xffffffff,%edx
strncpy(char *dst, const char *src, size_t size) {
	size_t i;
	char *ret;

	ret = dst;
	for (i = 0; i < size; i++) {
  80119d:	83 c1 01             	add    $0x1,%ecx
  8011a0:	39 ce                	cmp    %ecx,%esi
  8011a2:	77 ed                	ja     801191 <strncpy+0x17>
		// If strlen(src) < size, null-pad 'dst' out to 'size' chars
		if (*src != '\0')
			src++;
	}
	return ret;
}
  8011a4:	5b                   	pop    %ebx
  8011a5:	5e                   	pop    %esi
  8011a6:	5d                   	pop    %ebp
  8011a7:	c3                   	ret    

008011a8 <strlcpy>:

size_t
strlcpy(char *dst, const char *src, size_t size)
{
  8011a8:	55                   	push   %ebp
  8011a9:	89 e5                	mov    %esp,%ebp
  8011ab:	56                   	push   %esi
  8011ac:	53                   	push   %ebx
  8011ad:	8b 75 08             	mov    0x8(%ebp),%esi
  8011b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  8011b3:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
  8011b6:	89 f0                	mov    %esi,%eax
  8011b8:	85 c9                	test   %ecx,%ecx
  8011ba:	74 27                	je     8011e3 <strlcpy+0x3b>
		while (--size > 0 && *src != '\0')
  8011bc:	83 e9 01             	sub    $0x1,%ecx
  8011bf:	74 1d                	je     8011de <strlcpy+0x36>
  8011c1:	0f b6 1a             	movzbl (%edx),%ebx
  8011c4:	84 db                	test   %bl,%bl
  8011c6:	74 16                	je     8011de <strlcpy+0x36>
			*dst++ = *src++;
  8011c8:	88 18                	mov    %bl,(%eax)
  8011ca:	83 c0 01             	add    $0x1,%eax
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8011cd:	83 e9 01             	sub    $0x1,%ecx
  8011d0:	74 0e                	je     8011e0 <strlcpy+0x38>
			*dst++ = *src++;
  8011d2:	83 c2 01             	add    $0x1,%edx
{
	char *dst_in;

	dst_in = dst;
	if (size > 0) {
		while (--size > 0 && *src != '\0')
  8011d5:	0f b6 1a             	movzbl (%edx),%ebx
  8011d8:	84 db                	test   %bl,%bl
  8011da:	75 ec                	jne    8011c8 <strlcpy+0x20>
  8011dc:	eb 02                	jmp    8011e0 <strlcpy+0x38>
  8011de:	89 f0                	mov    %esi,%eax
			*dst++ = *src++;
		*dst = '\0';
  8011e0:	c6 00 00             	movb   $0x0,(%eax)
  8011e3:	29 f0                	sub    %esi,%eax
	}
	return dst - dst_in;
}
  8011e5:	5b                   	pop    %ebx
  8011e6:	5e                   	pop    %esi
  8011e7:	5d                   	pop    %ebp
  8011e8:	c3                   	ret    

008011e9 <strcmp>:

int
strcmp(const char *p, const char *q)
{
  8011e9:	55                   	push   %ebp
  8011ea:	89 e5                	mov    %esp,%ebp
  8011ec:	8b 4d 08             	mov    0x8(%ebp),%ecx
  8011ef:	8b 55 0c             	mov    0xc(%ebp),%edx
	while (*p && *p == *q)
  8011f2:	0f b6 01             	movzbl (%ecx),%eax
  8011f5:	84 c0                	test   %al,%al
  8011f7:	74 15                	je     80120e <strcmp+0x25>
  8011f9:	3a 02                	cmp    (%edx),%al
  8011fb:	75 11                	jne    80120e <strcmp+0x25>
		p++, q++;
  8011fd:	83 c1 01             	add    $0x1,%ecx
  801200:	83 c2 01             	add    $0x1,%edx
}

int
strcmp(const char *p, const char *q)
{
	while (*p && *p == *q)
  801203:	0f b6 01             	movzbl (%ecx),%eax
  801206:	84 c0                	test   %al,%al
  801208:	74 04                	je     80120e <strcmp+0x25>
  80120a:	3a 02                	cmp    (%edx),%al
  80120c:	74 ef                	je     8011fd <strcmp+0x14>
  80120e:	0f b6 c0             	movzbl %al,%eax
  801211:	0f b6 12             	movzbl (%edx),%edx
  801214:	29 d0                	sub    %edx,%eax
		p++, q++;
	return (int) ((unsigned char) *p - (unsigned char) *q);
}
  801216:	5d                   	pop    %ebp
  801217:	c3                   	ret    

00801218 <strncmp>:

int
strncmp(const char *p, const char *q, size_t n)
{
  801218:	55                   	push   %ebp
  801219:	89 e5                	mov    %esp,%ebp
  80121b:	53                   	push   %ebx
  80121c:	8b 55 08             	mov    0x8(%ebp),%edx
  80121f:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801222:	8b 45 10             	mov    0x10(%ebp),%eax
	while (n > 0 && *p && *p == *q)
  801225:	85 c0                	test   %eax,%eax
  801227:	74 23                	je     80124c <strncmp+0x34>
  801229:	0f b6 1a             	movzbl (%edx),%ebx
  80122c:	84 db                	test   %bl,%bl
  80122e:	74 24                	je     801254 <strncmp+0x3c>
  801230:	3a 19                	cmp    (%ecx),%bl
  801232:	75 20                	jne    801254 <strncmp+0x3c>
  801234:	83 e8 01             	sub    $0x1,%eax
  801237:	74 13                	je     80124c <strncmp+0x34>
		n--, p++, q++;
  801239:	83 c2 01             	add    $0x1,%edx
  80123c:	83 c1 01             	add    $0x1,%ecx
}

int
strncmp(const char *p, const char *q, size_t n)
{
	while (n > 0 && *p && *p == *q)
  80123f:	0f b6 1a             	movzbl (%edx),%ebx
  801242:	84 db                	test   %bl,%bl
  801244:	74 0e                	je     801254 <strncmp+0x3c>
  801246:	3a 19                	cmp    (%ecx),%bl
  801248:	74 ea                	je     801234 <strncmp+0x1c>
  80124a:	eb 08                	jmp    801254 <strncmp+0x3c>
  80124c:	b8 00 00 00 00       	mov    $0x0,%eax
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
}
  801251:	5b                   	pop    %ebx
  801252:	5d                   	pop    %ebp
  801253:	c3                   	ret    
	while (n > 0 && *p && *p == *q)
		n--, p++, q++;
	if (n == 0)
		return 0;
	else
		return (int) ((unsigned char) *p - (unsigned char) *q);
  801254:	0f b6 02             	movzbl (%edx),%eax
  801257:	0f b6 11             	movzbl (%ecx),%edx
  80125a:	29 d0                	sub    %edx,%eax
  80125c:	eb f3                	jmp    801251 <strncmp+0x39>

0080125e <strchr>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
  80125e:	55                   	push   %ebp
  80125f:	89 e5                	mov    %esp,%ebp
  801261:	8b 45 08             	mov    0x8(%ebp),%eax
  801264:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801268:	0f b6 10             	movzbl (%eax),%edx
  80126b:	84 d2                	test   %dl,%dl
  80126d:	74 15                	je     801284 <strchr+0x26>
		if (*s == c)
  80126f:	38 ca                	cmp    %cl,%dl
  801271:	75 07                	jne    80127a <strchr+0x1c>
  801273:	eb 14                	jmp    801289 <strchr+0x2b>
  801275:	38 ca                	cmp    %cl,%dl
  801277:	90                   	nop
  801278:	74 0f                	je     801289 <strchr+0x2b>
// Return a pointer to the first occurrence of 'c' in 's',
// or a null pointer if the string has no 'c'.
char *
strchr(const char *s, char c)
{
	for (; *s; s++)
  80127a:	83 c0 01             	add    $0x1,%eax
  80127d:	0f b6 10             	movzbl (%eax),%edx
  801280:	84 d2                	test   %dl,%dl
  801282:	75 f1                	jne    801275 <strchr+0x17>
  801284:	b8 00 00 00 00       	mov    $0x0,%eax
		if (*s == c)
			return (char *) s;
	return 0;
}
  801289:	5d                   	pop    %ebp
  80128a:	c3                   	ret    

0080128b <strfind>:

// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
  80128b:	55                   	push   %ebp
  80128c:	89 e5                	mov    %esp,%ebp
  80128e:	8b 45 08             	mov    0x8(%ebp),%eax
  801291:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
	for (; *s; s++)
  801295:	0f b6 10             	movzbl (%eax),%edx
  801298:	84 d2                	test   %dl,%dl
  80129a:	74 18                	je     8012b4 <strfind+0x29>
		if (*s == c)
  80129c:	38 ca                	cmp    %cl,%dl
  80129e:	75 0a                	jne    8012aa <strfind+0x1f>
  8012a0:	eb 12                	jmp    8012b4 <strfind+0x29>
  8012a2:	38 ca                	cmp    %cl,%dl
  8012a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8012a8:	74 0a                	je     8012b4 <strfind+0x29>
// Return a pointer to the first occurrence of 'c' in 's',
// or a pointer to the string-ending null character if the string has no 'c'.
char *
strfind(const char *s, char c)
{
	for (; *s; s++)
  8012aa:	83 c0 01             	add    $0x1,%eax
  8012ad:	0f b6 10             	movzbl (%eax),%edx
  8012b0:	84 d2                	test   %dl,%dl
  8012b2:	75 ee                	jne    8012a2 <strfind+0x17>
		if (*s == c)
			break;
	return (char *) s;
}
  8012b4:	5d                   	pop    %ebp
  8012b5:	c3                   	ret    

008012b6 <memset>:

#if ASM
void *
memset(void *v, int c, size_t n)
{
  8012b6:	55                   	push   %ebp
  8012b7:	89 e5                	mov    %esp,%ebp
  8012b9:	83 ec 0c             	sub    $0xc,%esp
  8012bc:	89 1c 24             	mov    %ebx,(%esp)
  8012bf:	89 74 24 04          	mov    %esi,0x4(%esp)
  8012c3:	89 7c 24 08          	mov    %edi,0x8(%esp)
  8012c7:	8b 7d 08             	mov    0x8(%ebp),%edi
  8012ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  8012cd:	8b 4d 10             	mov    0x10(%ebp),%ecx
	char *p;

	if (n == 0)
  8012d0:	85 c9                	test   %ecx,%ecx
  8012d2:	74 30                	je     801304 <memset+0x4e>
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012d4:	f7 c7 03 00 00 00    	test   $0x3,%edi
  8012da:	75 25                	jne    801301 <memset+0x4b>
  8012dc:	f6 c1 03             	test   $0x3,%cl
  8012df:	75 20                	jne    801301 <memset+0x4b>
		c &= 0xFF;
  8012e1:	0f b6 d0             	movzbl %al,%edx
		c = (c<<24)|(c<<16)|(c<<8)|c;
  8012e4:	89 d3                	mov    %edx,%ebx
  8012e6:	c1 e3 08             	shl    $0x8,%ebx
  8012e9:	89 d6                	mov    %edx,%esi
  8012eb:	c1 e6 18             	shl    $0x18,%esi
  8012ee:	89 d0                	mov    %edx,%eax
  8012f0:	c1 e0 10             	shl    $0x10,%eax
  8012f3:	09 f0                	or     %esi,%eax
  8012f5:	09 d0                	or     %edx,%eax
		asm volatile("cld; rep stosl\n"
  8012f7:	09 d8                	or     %ebx,%eax
  8012f9:	c1 e9 02             	shr    $0x2,%ecx
  8012fc:	fc                   	cld    
  8012fd:	f3 ab                	rep stos %eax,%es:(%edi)
{
	char *p;

	if (n == 0)
		return v;
	if ((int)v%4 == 0 && n%4 == 0) {
  8012ff:	eb 03                	jmp    801304 <memset+0x4e>
		c = (c<<24)|(c<<16)|(c<<8)|c;
		asm volatile("cld; rep stosl\n"
			:: "D" (v), "a" (c), "c" (n/4)
			: "cc", "memory");
	} else
		asm volatile("cld; rep stosb\n"
  801301:	fc                   	cld    
  801302:	f3 aa                	rep stos %al,%es:(%edi)
			:: "D" (v), "a" (c), "c" (n)
			: "cc", "memory");
	return v;
}
  801304:	89 f8                	mov    %edi,%eax
  801306:	8b 1c 24             	mov    (%esp),%ebx
  801309:	8b 74 24 04          	mov    0x4(%esp),%esi
  80130d:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801311:	89 ec                	mov    %ebp,%esp
  801313:	5d                   	pop    %ebp
  801314:	c3                   	ret    

00801315 <memmove>:

void *
memmove(void *dst, const void *src, size_t n)
{
  801315:	55                   	push   %ebp
  801316:	89 e5                	mov    %esp,%ebp
  801318:	83 ec 08             	sub    $0x8,%esp
  80131b:	89 34 24             	mov    %esi,(%esp)
  80131e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801322:	8b 45 08             	mov    0x8(%ebp),%eax
  801325:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const char *s;
	char *d;
	
	s = src;
  801328:	8b 75 0c             	mov    0xc(%ebp),%esi
	d = dst;
  80132b:	89 c7                	mov    %eax,%edi
	if (s < d && s + n > d) {
  80132d:	39 c6                	cmp    %eax,%esi
  80132f:	73 35                	jae    801366 <memmove+0x51>
  801331:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
  801334:	39 d0                	cmp    %edx,%eax
  801336:	73 2e                	jae    801366 <memmove+0x51>
		s += n;
		d += n;
  801338:	01 cf                	add    %ecx,%edi
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  80133a:	f6 c2 03             	test   $0x3,%dl
  80133d:	75 1b                	jne    80135a <memmove+0x45>
  80133f:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801345:	75 13                	jne    80135a <memmove+0x45>
  801347:	f6 c1 03             	test   $0x3,%cl
  80134a:	75 0e                	jne    80135a <memmove+0x45>
			asm volatile("std; rep movsl\n"
  80134c:	83 ef 04             	sub    $0x4,%edi
  80134f:	8d 72 fc             	lea    -0x4(%edx),%esi
  801352:	c1 e9 02             	shr    $0x2,%ecx
  801355:	fd                   	std    
  801356:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
	s = src;
	d = dst;
	if (s < d && s + n > d) {
		s += n;
		d += n;
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801358:	eb 09                	jmp    801363 <memmove+0x4e>
			asm volatile("std; rep movsl\n"
				:: "D" (d-4), "S" (s-4), "c" (n/4) : "cc", "memory");
		else
			asm volatile("std; rep movsb\n"
  80135a:	83 ef 01             	sub    $0x1,%edi
  80135d:	8d 72 ff             	lea    -0x1(%edx),%esi
  801360:	fd                   	std    
  801361:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
  801363:	fc                   	cld    
	const char *s;
	char *d;
	
	s = src;
	d = dst;
	if (s < d && s + n > d) {
  801364:	eb 20                	jmp    801386 <memmove+0x71>
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801366:	f7 c6 03 00 00 00    	test   $0x3,%esi
  80136c:	75 15                	jne    801383 <memmove+0x6e>
  80136e:	f7 c7 03 00 00 00    	test   $0x3,%edi
  801374:	75 0d                	jne    801383 <memmove+0x6e>
  801376:	f6 c1 03             	test   $0x3,%cl
  801379:	75 08                	jne    801383 <memmove+0x6e>
			asm volatile("cld; rep movsl\n"
  80137b:	c1 e9 02             	shr    $0x2,%ecx
  80137e:	fc                   	cld    
  80137f:	f3 a5                	rep movsl %ds:(%esi),%es:(%edi)
			asm volatile("std; rep movsb\n"
				:: "D" (d-1), "S" (s-1), "c" (n) : "cc", "memory");
		// Some versions of GCC rely on DF being clear
		asm volatile("cld" ::: "cc");
	} else {
		if ((int)s%4 == 0 && (int)d%4 == 0 && n%4 == 0)
  801381:	eb 03                	jmp    801386 <memmove+0x71>
			asm volatile("cld; rep movsl\n"
				:: "D" (d), "S" (s), "c" (n/4) : "cc", "memory");
		else
			asm volatile("cld; rep movsb\n"
  801383:	fc                   	cld    
  801384:	f3 a4                	rep movsb %ds:(%esi),%es:(%edi)
				:: "D" (d), "S" (s), "c" (n) : "cc", "memory");
	}
	return dst;
}
  801386:	8b 34 24             	mov    (%esp),%esi
  801389:	8b 7c 24 04          	mov    0x4(%esp),%edi
  80138d:	89 ec                	mov    %ebp,%esp
  80138f:	5d                   	pop    %ebp
  801390:	c3                   	ret    

00801391 <memcpy>:

/* sigh - gcc emits references to this for structure assignments! */
/* it is *not* prototyped in inc/string.h - do not use directly. */
void *
memcpy(void *dst, void *src, size_t n)
{
  801391:	55                   	push   %ebp
  801392:	89 e5                	mov    %esp,%ebp
  801394:	83 ec 0c             	sub    $0xc,%esp
	return memmove(dst, src, n);
  801397:	8b 45 10             	mov    0x10(%ebp),%eax
  80139a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80139e:	8b 45 0c             	mov    0xc(%ebp),%eax
  8013a1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8013a5:	8b 45 08             	mov    0x8(%ebp),%eax
  8013a8:	89 04 24             	mov    %eax,(%esp)
  8013ab:	e8 65 ff ff ff       	call   801315 <memmove>
}
  8013b0:	c9                   	leave  
  8013b1:	c3                   	ret    

008013b2 <memcmp>:

int
memcmp(const void *v1, const void *v2, size_t n)
{
  8013b2:	55                   	push   %ebp
  8013b3:	89 e5                	mov    %esp,%ebp
  8013b5:	57                   	push   %edi
  8013b6:	56                   	push   %esi
  8013b7:	53                   	push   %ebx
  8013b8:	8b 75 08             	mov    0x8(%ebp),%esi
  8013bb:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8013be:	8b 4d 10             	mov    0x10(%ebp),%ecx
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013c1:	85 c9                	test   %ecx,%ecx
  8013c3:	74 36                	je     8013fb <memcmp+0x49>
		if (*s1 != *s2)
  8013c5:	0f b6 06             	movzbl (%esi),%eax
  8013c8:	0f b6 1f             	movzbl (%edi),%ebx
  8013cb:	38 d8                	cmp    %bl,%al
  8013cd:	74 20                	je     8013ef <memcmp+0x3d>
  8013cf:	eb 14                	jmp    8013e5 <memcmp+0x33>
  8013d1:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  8013d6:	0f b6 5c 17 01       	movzbl 0x1(%edi,%edx,1),%ebx
  8013db:	83 c2 01             	add    $0x1,%edx
  8013de:	83 e9 01             	sub    $0x1,%ecx
  8013e1:	38 d8                	cmp    %bl,%al
  8013e3:	74 12                	je     8013f7 <memcmp+0x45>
			return (int) *s1 - (int) *s2;
  8013e5:	0f b6 c0             	movzbl %al,%eax
  8013e8:	0f b6 db             	movzbl %bl,%ebx
  8013eb:	29 d8                	sub    %ebx,%eax
  8013ed:	eb 11                	jmp    801400 <memcmp+0x4e>
memcmp(const void *v1, const void *v2, size_t n)
{
	const uint8_t *s1 = (const uint8_t *) v1;
	const uint8_t *s2 = (const uint8_t *) v2;

	while (n-- > 0) {
  8013ef:	83 e9 01             	sub    $0x1,%ecx
  8013f2:	ba 00 00 00 00       	mov    $0x0,%edx
  8013f7:	85 c9                	test   %ecx,%ecx
  8013f9:	75 d6                	jne    8013d1 <memcmp+0x1f>
  8013fb:	b8 00 00 00 00       	mov    $0x0,%eax
			return (int) *s1 - (int) *s2;
		s1++, s2++;
	}

	return 0;
}
  801400:	5b                   	pop    %ebx
  801401:	5e                   	pop    %esi
  801402:	5f                   	pop    %edi
  801403:	5d                   	pop    %ebp
  801404:	c3                   	ret    

00801405 <memfind>:

void *
memfind(const void *s, int c, size_t n)
{
  801405:	55                   	push   %ebp
  801406:	89 e5                	mov    %esp,%ebp
  801408:	8b 45 08             	mov    0x8(%ebp),%eax
	const void *ends = (const char *) s + n;
  80140b:	89 c2                	mov    %eax,%edx
  80140d:	03 55 10             	add    0x10(%ebp),%edx
	for (; s < ends; s++)
  801410:	39 d0                	cmp    %edx,%eax
  801412:	73 15                	jae    801429 <memfind+0x24>
		if (*(const unsigned char *) s == (unsigned char) c)
  801414:	0f b6 4d 0c          	movzbl 0xc(%ebp),%ecx
  801418:	38 08                	cmp    %cl,(%eax)
  80141a:	75 06                	jne    801422 <memfind+0x1d>
  80141c:	eb 0b                	jmp    801429 <memfind+0x24>
  80141e:	38 08                	cmp    %cl,(%eax)
  801420:	74 07                	je     801429 <memfind+0x24>

void *
memfind(const void *s, int c, size_t n)
{
	const void *ends = (const char *) s + n;
	for (; s < ends; s++)
  801422:	83 c0 01             	add    $0x1,%eax
  801425:	39 c2                	cmp    %eax,%edx
  801427:	77 f5                	ja     80141e <memfind+0x19>
		if (*(const unsigned char *) s == (unsigned char) c)
			break;
	return (void *) s;
}
  801429:	5d                   	pop    %ebp
  80142a:	c3                   	ret    

0080142b <strtol>:

long
strtol(const char *s, char **endptr, int base)
{
  80142b:	55                   	push   %ebp
  80142c:	89 e5                	mov    %esp,%ebp
  80142e:	57                   	push   %edi
  80142f:	56                   	push   %esi
  801430:	53                   	push   %ebx
  801431:	83 ec 04             	sub    $0x4,%esp
  801434:	8b 55 08             	mov    0x8(%ebp),%edx
  801437:	8b 5d 10             	mov    0x10(%ebp),%ebx
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  80143a:	0f b6 02             	movzbl (%edx),%eax
  80143d:	3c 20                	cmp    $0x20,%al
  80143f:	74 04                	je     801445 <strtol+0x1a>
  801441:	3c 09                	cmp    $0x9,%al
  801443:	75 0e                	jne    801453 <strtol+0x28>
		s++;
  801445:	83 c2 01             	add    $0x1,%edx
{
	int neg = 0;
	long val = 0;

	// gobble initial whitespace
	while (*s == ' ' || *s == '\t')
  801448:	0f b6 02             	movzbl (%edx),%eax
  80144b:	3c 20                	cmp    $0x20,%al
  80144d:	74 f6                	je     801445 <strtol+0x1a>
  80144f:	3c 09                	cmp    $0x9,%al
  801451:	74 f2                	je     801445 <strtol+0x1a>
		s++;

	// plus/minus sign
	if (*s == '+')
  801453:	3c 2b                	cmp    $0x2b,%al
  801455:	75 0c                	jne    801463 <strtol+0x38>
		s++;
  801457:	83 c2 01             	add    $0x1,%edx
  80145a:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  801461:	eb 15                	jmp    801478 <strtol+0x4d>
	else if (*s == '-')
  801463:	c7 45 f0 00 00 00 00 	movl   $0x0,-0x10(%ebp)
  80146a:	3c 2d                	cmp    $0x2d,%al
  80146c:	75 0a                	jne    801478 <strtol+0x4d>
		s++, neg = 1;
  80146e:	83 c2 01             	add    $0x1,%edx
  801471:	c7 45 f0 01 00 00 00 	movl   $0x1,-0x10(%ebp)

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  801478:	85 db                	test   %ebx,%ebx
  80147a:	0f 94 c0             	sete   %al
  80147d:	74 05                	je     801484 <strtol+0x59>
  80147f:	83 fb 10             	cmp    $0x10,%ebx
  801482:	75 18                	jne    80149c <strtol+0x71>
  801484:	80 3a 30             	cmpb   $0x30,(%edx)
  801487:	75 13                	jne    80149c <strtol+0x71>
  801489:	80 7a 01 78          	cmpb   $0x78,0x1(%edx)
  80148d:	8d 76 00             	lea    0x0(%esi),%esi
  801490:	75 0a                	jne    80149c <strtol+0x71>
		s += 2, base = 16;
  801492:	83 c2 02             	add    $0x2,%edx
  801495:	bb 10 00 00 00       	mov    $0x10,%ebx
		s++;
	else if (*s == '-')
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
  80149a:	eb 15                	jmp    8014b1 <strtol+0x86>
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  80149c:	84 c0                	test   %al,%al
  80149e:	66 90                	xchg   %ax,%ax
  8014a0:	74 0f                	je     8014b1 <strtol+0x86>
  8014a2:	bb 0a 00 00 00       	mov    $0xa,%ebx
  8014a7:	80 3a 30             	cmpb   $0x30,(%edx)
  8014aa:	75 05                	jne    8014b1 <strtol+0x86>
		s++, base = 8;
  8014ac:	83 c2 01             	add    $0x1,%edx
  8014af:	b3 08                	mov    $0x8,%bl
		s++, neg = 1;

	// hex or octal base prefix
	if ((base == 0 || base == 16) && (s[0] == '0' && s[1] == 'x'))
		s += 2, base = 16;
	else if (base == 0 && s[0] == '0')
  8014b1:	b8 00 00 00 00       	mov    $0x0,%eax
  8014b6:	89 de                	mov    %ebx,%esi

	// digits
	while (1) {
		int dig;

		if (*s >= '0' && *s <= '9')
  8014b8:	0f b6 0a             	movzbl (%edx),%ecx
  8014bb:	89 cf                	mov    %ecx,%edi
  8014bd:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  8014c0:	80 fb 09             	cmp    $0x9,%bl
  8014c3:	77 08                	ja     8014cd <strtol+0xa2>
			dig = *s - '0';
  8014c5:	0f be c9             	movsbl %cl,%ecx
  8014c8:	83 e9 30             	sub    $0x30,%ecx
  8014cb:	eb 1e                	jmp    8014eb <strtol+0xc0>
		else if (*s >= 'a' && *s <= 'z')
  8014cd:	8d 5f 9f             	lea    -0x61(%edi),%ebx
  8014d0:	80 fb 19             	cmp    $0x19,%bl
  8014d3:	77 08                	ja     8014dd <strtol+0xb2>
			dig = *s - 'a' + 10;
  8014d5:	0f be c9             	movsbl %cl,%ecx
  8014d8:	83 e9 57             	sub    $0x57,%ecx
  8014db:	eb 0e                	jmp    8014eb <strtol+0xc0>
		else if (*s >= 'A' && *s <= 'Z')
  8014dd:	8d 5f bf             	lea    -0x41(%edi),%ebx
  8014e0:	80 fb 19             	cmp    $0x19,%bl
  8014e3:	77 15                	ja     8014fa <strtol+0xcf>
			dig = *s - 'A' + 10;
  8014e5:	0f be c9             	movsbl %cl,%ecx
  8014e8:	83 e9 37             	sub    $0x37,%ecx
		else
			break;
		if (dig >= base)
  8014eb:	39 f1                	cmp    %esi,%ecx
  8014ed:	7d 0b                	jge    8014fa <strtol+0xcf>
			break;
		s++, val = (val * base) + dig;
  8014ef:	83 c2 01             	add    $0x1,%edx
  8014f2:	0f af c6             	imul   %esi,%eax
  8014f5:	8d 04 01             	lea    (%ecx,%eax,1),%eax
		// we don't properly detect overflow!
	}
  8014f8:	eb be                	jmp    8014b8 <strtol+0x8d>
  8014fa:	89 c1                	mov    %eax,%ecx

	if (endptr)
  8014fc:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  801500:	74 05                	je     801507 <strtol+0xdc>
		*endptr = (char *) s;
  801502:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  801505:	89 13                	mov    %edx,(%ebx)
	return (neg ? -val : val);
  801507:	83 7d f0 00          	cmpl   $0x0,-0x10(%ebp)
  80150b:	74 04                	je     801511 <strtol+0xe6>
  80150d:	89 c8                	mov    %ecx,%eax
  80150f:	f7 d8                	neg    %eax
}
  801511:	83 c4 04             	add    $0x4,%esp
  801514:	5b                   	pop    %ebx
  801515:	5e                   	pop    %esi
  801516:	5f                   	pop    %edi
  801517:	5d                   	pop    %ebp
  801518:	c3                   	ret    
  801519:	00 00                	add    %al,(%eax)
	...

0080151c <sys_cgetc>:
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}

int
sys_cgetc(void)
{
  80151c:	55                   	push   %ebp
  80151d:	89 e5                	mov    %esp,%ebp
  80151f:	83 ec 0c             	sub    $0xc,%esp
  801522:	89 1c 24             	mov    %ebx,(%esp)
  801525:	89 74 24 04          	mov    %esi,0x4(%esp)
  801529:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80152d:	ba 00 00 00 00       	mov    $0x0,%edx
  801532:	b8 01 00 00 00       	mov    $0x1,%eax
  801537:	89 d1                	mov    %edx,%ecx
  801539:	89 d3                	mov    %edx,%ebx
  80153b:	89 d7                	mov    %edx,%edi
  80153d:	89 d6                	mov    %edx,%esi
  80153f:	cd 30                	int    $0x30

int
sys_cgetc(void)
{
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}
  801541:	8b 1c 24             	mov    (%esp),%ebx
  801544:	8b 74 24 04          	mov    0x4(%esp),%esi
  801548:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80154c:	89 ec                	mov    %ebp,%esp
  80154e:	5d                   	pop    %ebp
  80154f:	c3                   	ret    

00801550 <sys_cputs>:
	return ret;
}

void
sys_cputs(const char *s, size_t len)
{
  801550:	55                   	push   %ebp
  801551:	89 e5                	mov    %esp,%ebp
  801553:	83 ec 0c             	sub    $0xc,%esp
  801556:	89 1c 24             	mov    %ebx,(%esp)
  801559:	89 74 24 04          	mov    %esi,0x4(%esp)
  80155d:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801561:	b8 00 00 00 00       	mov    $0x0,%eax
  801566:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801569:	8b 55 08             	mov    0x8(%ebp),%edx
  80156c:	89 c3                	mov    %eax,%ebx
  80156e:	89 c7                	mov    %eax,%edi
  801570:	89 c6                	mov    %eax,%esi
  801572:	cd 30                	int    $0x30

void
sys_cputs(const char *s, size_t len)
{
	syscall(SYS_cputs, 0, (uint32_t)s, len, 0, 0, 0);
}
  801574:	8b 1c 24             	mov    (%esp),%ebx
  801577:	8b 74 24 04          	mov    0x4(%esp),%esi
  80157b:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80157f:	89 ec                	mov    %ebp,%esp
  801581:	5d                   	pop    %ebp
  801582:	c3                   	ret    

00801583 <sys_page_insert>:
{
	return syscall(SYS_page_waste, 0, (uint32_t)p, (uint32_t)n, 0, 0,0);
}
int
sys_page_insert(envid_t envid, void *va, struct Page *p, int perm)
{
  801583:	55                   	push   %ebp
  801584:	89 e5                	mov    %esp,%ebp
  801586:	83 ec 38             	sub    $0x38,%esp
  801589:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80158c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80158f:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801592:	be 00 00 00 00       	mov    $0x0,%esi
  801597:	b8 12 00 00 00       	mov    $0x12,%eax
  80159c:	8b 7d 14             	mov    0x14(%ebp),%edi
  80159f:	8b 5d 10             	mov    0x10(%ebp),%ebx
  8015a2:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8015a5:	8b 55 08             	mov    0x8(%ebp),%edx
  8015a8:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8015aa:	85 c0                	test   %eax,%eax
  8015ac:	7e 28                	jle    8015d6 <sys_page_insert+0x53>
		panic("syscall %d returned %d (> 0)", num, ret);
  8015ae:	89 44 24 10          	mov    %eax,0x10(%esp)
  8015b2:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  8015b9:	00 
  8015ba:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  8015c1:	00 
  8015c2:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8015c9:	00 
  8015ca:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  8015d1:	e8 fe f3 ff ff       	call   8009d4 <_panic>
}
int
sys_page_insert(envid_t envid, void *va, struct Page *p, int perm)
{
	return syscall(SYS_page_insert, 1, envid, (uint32_t) va, (uint32_t)p, perm, 0);
}
  8015d6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8015d9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8015dc:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8015df:	89 ec                	mov    %ebp,%esp
  8015e1:	5d                   	pop    %ebp
  8015e2:	c3                   	ret    

008015e3 <sys_page_waste>:
{
	return (int)syscall(SYS_receive_packet, 0, (uint32_t)buffer, 0,0,0,0);
}

int sys_page_waste(struct Page **p, int n)
{
  8015e3:	55                   	push   %ebp
  8015e4:	89 e5                	mov    %esp,%ebp
  8015e6:	83 ec 0c             	sub    $0xc,%esp
  8015e9:	89 1c 24             	mov    %ebx,(%esp)
  8015ec:	89 74 24 04          	mov    %esi,0x4(%esp)
  8015f0:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8015f4:	bb 00 00 00 00       	mov    $0x0,%ebx
  8015f9:	b8 11 00 00 00       	mov    $0x11,%eax
  8015fe:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801601:	8b 55 08             	mov    0x8(%ebp),%edx
  801604:	89 df                	mov    %ebx,%edi
  801606:	89 de                	mov    %ebx,%esi
  801608:	cd 30                	int    $0x30
}

int sys_page_waste(struct Page **p, int n)
{
	return syscall(SYS_page_waste, 0, (uint32_t)p, (uint32_t)n, 0, 0,0);
}
  80160a:	8b 1c 24             	mov    (%esp),%ebx
  80160d:	8b 74 24 04          	mov    0x4(%esp),%esi
  801611:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801615:	89 ec                	mov    %ebp,%esp
  801617:	5d                   	pop    %ebp
  801618:	c3                   	ret    

00801619 <sys_receive_packet>:
{
	return (int)syscall(SYS_transmit_packet, 1, (uint32_t)data, len, 0,0,0);
}

int sys_receive_packet(void* buffer)
{
  801619:	55                   	push   %ebp
  80161a:	89 e5                	mov    %esp,%ebp
  80161c:	83 ec 0c             	sub    $0xc,%esp
  80161f:	89 1c 24             	mov    %ebx,(%esp)
  801622:	89 74 24 04          	mov    %esi,0x4(%esp)
  801626:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80162a:	b9 00 00 00 00       	mov    $0x0,%ecx
  80162f:	b8 10 00 00 00       	mov    $0x10,%eax
  801634:	8b 55 08             	mov    0x8(%ebp),%edx
  801637:	89 cb                	mov    %ecx,%ebx
  801639:	89 cf                	mov    %ecx,%edi
  80163b:	89 ce                	mov    %ecx,%esi
  80163d:	cd 30                	int    $0x30
}

int sys_receive_packet(void* buffer)
{
	return (int)syscall(SYS_receive_packet, 0, (uint32_t)buffer, 0,0,0,0);
}
  80163f:	8b 1c 24             	mov    (%esp),%ebx
  801642:	8b 74 24 04          	mov    0x4(%esp),%esi
  801646:	8b 7c 24 08          	mov    0x8(%esp),%edi
  80164a:	89 ec                	mov    %ebp,%esp
  80164c:	5d                   	pop    %ebp
  80164d:	c3                   	ret    

0080164e <sys_transmit_packet>:
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0,0);
}

int sys_transmit_packet(void* data, uint32_t len)
{
  80164e:	55                   	push   %ebp
  80164f:	89 e5                	mov    %esp,%ebp
  801651:	83 ec 38             	sub    $0x38,%esp
  801654:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801657:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80165a:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80165d:	bb 00 00 00 00       	mov    $0x0,%ebx
  801662:	b8 0f 00 00 00       	mov    $0xf,%eax
  801667:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80166a:	8b 55 08             	mov    0x8(%ebp),%edx
  80166d:	89 df                	mov    %ebx,%edi
  80166f:	89 de                	mov    %ebx,%esi
  801671:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801673:	85 c0                	test   %eax,%eax
  801675:	7e 28                	jle    80169f <sys_transmit_packet+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801677:	89 44 24 10          	mov    %eax,0x10(%esp)
  80167b:	c7 44 24 0c 0f 00 00 	movl   $0xf,0xc(%esp)
  801682:	00 
  801683:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  80168a:	00 
  80168b:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801692:	00 
  801693:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  80169a:	e8 35 f3 ff ff       	call   8009d4 <_panic>
}

int sys_transmit_packet(void* data, uint32_t len)
{
	return (int)syscall(SYS_transmit_packet, 1, (uint32_t)data, len, 0,0,0);
}
  80169f:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8016a2:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8016a5:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8016a8:	89 ec                	mov    %ebp,%esp
  8016aa:	5d                   	pop    %ebp
  8016ab:	c3                   	ret    

008016ac <sys_time_msec>:
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}

unsigned int
sys_time_msec(void)
{
  8016ac:	55                   	push   %ebp
  8016ad:	89 e5                	mov    %esp,%ebp
  8016af:	83 ec 0c             	sub    $0xc,%esp
  8016b2:	89 1c 24             	mov    %ebx,(%esp)
  8016b5:	89 74 24 04          	mov    %esi,0x4(%esp)
  8016b9:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8016bd:	ba 00 00 00 00       	mov    $0x0,%edx
  8016c2:	b8 0e 00 00 00       	mov    $0xe,%eax
  8016c7:	89 d1                	mov    %edx,%ecx
  8016c9:	89 d3                	mov    %edx,%ebx
  8016cb:	89 d7                	mov    %edx,%edi
  8016cd:	89 d6                	mov    %edx,%esi
  8016cf:	cd 30                	int    $0x30

unsigned int
sys_time_msec(void)
{
	return (unsigned int) syscall(SYS_time_msec, 0, 0, 0, 0, 0,0);
}
  8016d1:	8b 1c 24             	mov    (%esp),%ebx
  8016d4:	8b 74 24 04          	mov    0x4(%esp),%esi
  8016d8:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8016dc:	89 ec                	mov    %ebp,%esp
  8016de:	5d                   	pop    %ebp
  8016df:	c3                   	ret    

008016e0 <sys_ipc_recv>:
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}

int
sys_ipc_recv(void *dstva)
{
  8016e0:	55                   	push   %ebp
  8016e1:	89 e5                	mov    %esp,%ebp
  8016e3:	83 ec 38             	sub    $0x38,%esp
  8016e6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8016e9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8016ec:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8016ef:	b9 00 00 00 00       	mov    $0x0,%ecx
  8016f4:	b8 0d 00 00 00       	mov    $0xd,%eax
  8016f9:	8b 55 08             	mov    0x8(%ebp),%edx
  8016fc:	89 cb                	mov    %ecx,%ebx
  8016fe:	89 cf                	mov    %ecx,%edi
  801700:	89 ce                	mov    %ecx,%esi
  801702:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801704:	85 c0                	test   %eax,%eax
  801706:	7e 28                	jle    801730 <sys_ipc_recv+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  801708:	89 44 24 10          	mov    %eax,0x10(%esp)
  80170c:	c7 44 24 0c 0d 00 00 	movl   $0xd,0xc(%esp)
  801713:	00 
  801714:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  80171b:	00 
  80171c:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801723:	00 
  801724:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  80172b:	e8 a4 f2 ff ff       	call   8009d4 <_panic>

int
sys_ipc_recv(void *dstva)
{
	return syscall(SYS_ipc_recv, 1, (uint32_t)dstva, 0, 0, 0, 0);
}
  801730:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801733:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801736:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801739:	89 ec                	mov    %ebp,%esp
  80173b:	5d                   	pop    %ebp
  80173c:	c3                   	ret    

0080173d <sys_ipc_try_send>:
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
  80173d:	55                   	push   %ebp
  80173e:	89 e5                	mov    %esp,%ebp
  801740:	83 ec 0c             	sub    $0xc,%esp
  801743:	89 1c 24             	mov    %ebx,(%esp)
  801746:	89 74 24 04          	mov    %esi,0x4(%esp)
  80174a:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80174e:	be 00 00 00 00       	mov    $0x0,%esi
  801753:	b8 0c 00 00 00       	mov    $0xc,%eax
  801758:	8b 7d 14             	mov    0x14(%ebp),%edi
  80175b:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80175e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801761:	8b 55 08             	mov    0x8(%ebp),%edx
  801764:	cd 30                	int    $0x30

int
sys_ipc_try_send(envid_t envid, uint32_t value, void *srcva, int perm)
{
	return syscall(SYS_ipc_try_send, 0, envid, value, (uint32_t) srcva, perm, 0);
}
  801766:	8b 1c 24             	mov    (%esp),%ebx
  801769:	8b 74 24 04          	mov    0x4(%esp),%esi
  80176d:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801771:	89 ec                	mov    %ebp,%esp
  801773:	5d                   	pop    %ebp
  801774:	c3                   	ret    

00801775 <sys_env_set_pgfault_upcall>:
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
  801775:	55                   	push   %ebp
  801776:	89 e5                	mov    %esp,%ebp
  801778:	83 ec 38             	sub    $0x38,%esp
  80177b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80177e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801781:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801784:	bb 00 00 00 00       	mov    $0x0,%ebx
  801789:	b8 0a 00 00 00       	mov    $0xa,%eax
  80178e:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  801791:	8b 55 08             	mov    0x8(%ebp),%edx
  801794:	89 df                	mov    %ebx,%edi
  801796:	89 de                	mov    %ebx,%esi
  801798:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  80179a:	85 c0                	test   %eax,%eax
  80179c:	7e 28                	jle    8017c6 <sys_env_set_pgfault_upcall+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80179e:	89 44 24 10          	mov    %eax,0x10(%esp)
  8017a2:	c7 44 24 0c 0a 00 00 	movl   $0xa,0xc(%esp)
  8017a9:	00 
  8017aa:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  8017b1:	00 
  8017b2:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8017b9:	00 
  8017ba:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  8017c1:	e8 0e f2 ff ff       	call   8009d4 <_panic>

int
sys_env_set_pgfault_upcall(envid_t envid, void *upcall)
{
	return syscall(SYS_env_set_pgfault_upcall, 1, envid, (uint32_t) upcall, 0, 0, 0);
}
  8017c6:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8017c9:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8017cc:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8017cf:	89 ec                	mov    %ebp,%esp
  8017d1:	5d                   	pop    %ebp
  8017d2:	c3                   	ret    

008017d3 <sys_env_set_trapframe>:
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
  8017d3:	55                   	push   %ebp
  8017d4:	89 e5                	mov    %esp,%ebp
  8017d6:	83 ec 38             	sub    $0x38,%esp
  8017d9:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8017dc:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8017df:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8017e2:	bb 00 00 00 00       	mov    $0x0,%ebx
  8017e7:	b8 09 00 00 00       	mov    $0x9,%eax
  8017ec:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8017ef:	8b 55 08             	mov    0x8(%ebp),%edx
  8017f2:	89 df                	mov    %ebx,%edi
  8017f4:	89 de                	mov    %ebx,%esi
  8017f6:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8017f8:	85 c0                	test   %eax,%eax
  8017fa:	7e 28                	jle    801824 <sys_env_set_trapframe+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8017fc:	89 44 24 10          	mov    %eax,0x10(%esp)
  801800:	c7 44 24 0c 09 00 00 	movl   $0x9,0xc(%esp)
  801807:	00 
  801808:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  80180f:	00 
  801810:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801817:	00 
  801818:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  80181f:	e8 b0 f1 ff ff       	call   8009d4 <_panic>

int
sys_env_set_trapframe(envid_t envid, struct Trapframe *tf)
{
	return syscall(SYS_env_set_trapframe, 1, envid, (uint32_t) tf, 0, 0, 0);
}
  801824:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801827:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80182a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80182d:	89 ec                	mov    %ebp,%esp
  80182f:	5d                   	pop    %ebp
  801830:	c3                   	ret    

00801831 <sys_env_set_status>:

// sys_exofork is inlined in lib.h

int
sys_env_set_status(envid_t envid, int status)
{
  801831:	55                   	push   %ebp
  801832:	89 e5                	mov    %esp,%ebp
  801834:	83 ec 38             	sub    $0x38,%esp
  801837:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80183a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80183d:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801840:	bb 00 00 00 00       	mov    $0x0,%ebx
  801845:	b8 08 00 00 00       	mov    $0x8,%eax
  80184a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80184d:	8b 55 08             	mov    0x8(%ebp),%edx
  801850:	89 df                	mov    %ebx,%edi
  801852:	89 de                	mov    %ebx,%esi
  801854:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801856:	85 c0                	test   %eax,%eax
  801858:	7e 28                	jle    801882 <sys_env_set_status+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  80185a:	89 44 24 10          	mov    %eax,0x10(%esp)
  80185e:	c7 44 24 0c 08 00 00 	movl   $0x8,0xc(%esp)
  801865:	00 
  801866:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  80186d:	00 
  80186e:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801875:	00 
  801876:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  80187d:	e8 52 f1 ff ff       	call   8009d4 <_panic>

int
sys_env_set_status(envid_t envid, int status)
{
	return syscall(SYS_env_set_status, 1, envid, status, 0, 0, 0);
}
  801882:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801885:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801888:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80188b:	89 ec                	mov    %ebp,%esp
  80188d:	5d                   	pop    %ebp
  80188e:	c3                   	ret    

0080188f <sys_page_unmap>:
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}

int
sys_page_unmap(envid_t envid, void *va)
{
  80188f:	55                   	push   %ebp
  801890:	89 e5                	mov    %esp,%ebp
  801892:	83 ec 38             	sub    $0x38,%esp
  801895:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801898:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80189b:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80189e:	bb 00 00 00 00       	mov    $0x0,%ebx
  8018a3:	b8 06 00 00 00       	mov    $0x6,%eax
  8018a8:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  8018ab:	8b 55 08             	mov    0x8(%ebp),%edx
  8018ae:	89 df                	mov    %ebx,%edi
  8018b0:	89 de                	mov    %ebx,%esi
  8018b2:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  8018b4:	85 c0                	test   %eax,%eax
  8018b6:	7e 28                	jle    8018e0 <sys_page_unmap+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  8018b8:	89 44 24 10          	mov    %eax,0x10(%esp)
  8018bc:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  8018c3:	00 
  8018c4:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  8018cb:	00 
  8018cc:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8018d3:	00 
  8018d4:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  8018db:	e8 f4 f0 ff ff       	call   8009d4 <_panic>

int
sys_page_unmap(envid_t envid, void *va)
{
	return syscall(SYS_page_unmap, 1, envid, (uint32_t) va, 0, 0, 0);
}
  8018e0:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8018e3:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8018e6:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8018e9:	89 ec                	mov    %ebp,%esp
  8018eb:	5d                   	pop    %ebp
  8018ec:	c3                   	ret    

008018ed <sys_page_map>:
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
  8018ed:	55                   	push   %ebp
  8018ee:	89 e5                	mov    %esp,%ebp
  8018f0:	83 ec 38             	sub    $0x38,%esp
  8018f3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8018f6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8018f9:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8018fc:	b8 05 00 00 00       	mov    $0x5,%eax
  801901:	8b 75 18             	mov    0x18(%ebp),%esi
  801904:	8b 7d 14             	mov    0x14(%ebp),%edi
  801907:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80190a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80190d:	8b 55 08             	mov    0x8(%ebp),%edx
  801910:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801912:	85 c0                	test   %eax,%eax
  801914:	7e 28                	jle    80193e <sys_page_map+0x51>
		panic("syscall %d returned %d (> 0)", num, ret);
  801916:	89 44 24 10          	mov    %eax,0x10(%esp)
  80191a:	c7 44 24 0c 05 00 00 	movl   $0x5,0xc(%esp)
  801921:	00 
  801922:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  801929:	00 
  80192a:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801931:	00 
  801932:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  801939:	e8 96 f0 ff ff       	call   8009d4 <_panic>

int
sys_page_map(envid_t srcenv, void *srcva, envid_t dstenv, void *dstva, int perm)
{
	return syscall(SYS_page_map, 1, srcenv, (uint32_t) srcva, dstenv, (uint32_t) dstva, perm);
}
  80193e:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801941:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801944:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801947:	89 ec                	mov    %ebp,%esp
  801949:	5d                   	pop    %ebp
  80194a:	c3                   	ret    

0080194b <sys_page_alloc>:
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
  80194b:	55                   	push   %ebp
  80194c:	89 e5                	mov    %esp,%ebp
  80194e:	83 ec 38             	sub    $0x38,%esp
  801951:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801954:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801957:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  80195a:	be 00 00 00 00       	mov    $0x0,%esi
  80195f:	b8 04 00 00 00       	mov    $0x4,%eax
  801964:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801967:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80196a:	8b 55 08             	mov    0x8(%ebp),%edx
  80196d:	89 f7                	mov    %esi,%edi
  80196f:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801971:	85 c0                	test   %eax,%eax
  801973:	7e 28                	jle    80199d <sys_page_alloc+0x52>
		panic("syscall %d returned %d (> 0)", num, ret);
  801975:	89 44 24 10          	mov    %eax,0x10(%esp)
  801979:	c7 44 24 0c 04 00 00 	movl   $0x4,0xc(%esp)
  801980:	00 
  801981:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  801988:	00 
  801989:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801990:	00 
  801991:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  801998:	e8 37 f0 ff ff       	call   8009d4 <_panic>

int
sys_page_alloc(envid_t envid, void *va, int perm)
{
	return syscall(SYS_page_alloc, 1, envid, (uint32_t) va, perm, 0, 0);
}
  80199d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8019a0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8019a3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8019a6:	89 ec                	mov    %ebp,%esp
  8019a8:	5d                   	pop    %ebp
  8019a9:	c3                   	ret    

008019aa <sys_yield>:
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}

void
sys_yield(void)
{
  8019aa:	55                   	push   %ebp
  8019ab:	89 e5                	mov    %esp,%ebp
  8019ad:	83 ec 0c             	sub    $0xc,%esp
  8019b0:	89 1c 24             	mov    %ebx,(%esp)
  8019b3:	89 74 24 04          	mov    %esi,0x4(%esp)
  8019b7:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8019bb:	ba 00 00 00 00       	mov    $0x0,%edx
  8019c0:	b8 0b 00 00 00       	mov    $0xb,%eax
  8019c5:	89 d1                	mov    %edx,%ecx
  8019c7:	89 d3                	mov    %edx,%ebx
  8019c9:	89 d7                	mov    %edx,%edi
  8019cb:	89 d6                	mov    %edx,%esi
  8019cd:	cd 30                	int    $0x30

void
sys_yield(void)
{
	syscall(SYS_yield, 0, 0, 0, 0, 0, 0);
}
  8019cf:	8b 1c 24             	mov    (%esp),%ebx
  8019d2:	8b 74 24 04          	mov    0x4(%esp),%esi
  8019d6:	8b 7c 24 08          	mov    0x8(%esp),%edi
  8019da:	89 ec                	mov    %ebp,%esp
  8019dc:	5d                   	pop    %ebp
  8019dd:	c3                   	ret    

008019de <sys_getenvid>:
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}

envid_t
sys_getenvid(void)
{
  8019de:	55                   	push   %ebp
  8019df:	89 e5                	mov    %esp,%ebp
  8019e1:	83 ec 0c             	sub    $0xc,%esp
  8019e4:	89 1c 24             	mov    %ebx,(%esp)
  8019e7:	89 74 24 04          	mov    %esi,0x4(%esp)
  8019eb:	89 7c 24 08          	mov    %edi,0x8(%esp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  8019ef:	ba 00 00 00 00       	mov    $0x0,%edx
  8019f4:	b8 02 00 00 00       	mov    $0x2,%eax
  8019f9:	89 d1                	mov    %edx,%ecx
  8019fb:	89 d3                	mov    %edx,%ebx
  8019fd:	89 d7                	mov    %edx,%edi
  8019ff:	89 d6                	mov    %edx,%esi
  801a01:	cd 30                	int    $0x30

envid_t
sys_getenvid(void)
{
	 return syscall(SYS_getenvid, 0, 0, 0, 0, 0, 0);
}
  801a03:	8b 1c 24             	mov    (%esp),%ebx
  801a06:	8b 74 24 04          	mov    0x4(%esp),%esi
  801a0a:	8b 7c 24 08          	mov    0x8(%esp),%edi
  801a0e:	89 ec                	mov    %ebp,%esp
  801a10:	5d                   	pop    %ebp
  801a11:	c3                   	ret    

00801a12 <sys_env_destroy>:
	return syscall(SYS_cgetc, 0, 0, 0, 0, 0, 0);
}

int
sys_env_destroy(envid_t envid)
{
  801a12:	55                   	push   %ebp
  801a13:	89 e5                	mov    %esp,%ebp
  801a15:	83 ec 38             	sub    $0x38,%esp
  801a18:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  801a1b:	89 75 f8             	mov    %esi,-0x8(%ebp)
  801a1e:	89 7d fc             	mov    %edi,-0x4(%ebp)
	// 
	// The last clause tells the assembler that this can
	// potentially change the condition codes and arbitrary
	// memory locations.

	asm volatile("int %1\n"
  801a21:	b9 00 00 00 00       	mov    $0x0,%ecx
  801a26:	b8 03 00 00 00       	mov    $0x3,%eax
  801a2b:	8b 55 08             	mov    0x8(%ebp),%edx
  801a2e:	89 cb                	mov    %ecx,%ebx
  801a30:	89 cf                	mov    %ecx,%edi
  801a32:	89 ce                	mov    %ecx,%esi
  801a34:	cd 30                	int    $0x30
		  "b" (a3),
		  "D" (a4),
		  "S" (a5)
		: "cc", "memory");
	
	if(check && ret > 0)
  801a36:	85 c0                	test   %eax,%eax
  801a38:	7e 28                	jle    801a62 <sys_env_destroy+0x50>
		panic("syscall %d returned %d (> 0)", num, ret);
  801a3a:	89 44 24 10          	mov    %eax,0x10(%esp)
  801a3e:	c7 44 24 0c 03 00 00 	movl   $0x3,0xc(%esp)
  801a45:	00 
  801a46:	c7 44 24 08 1f 2b 81 	movl   $0x812b1f,0x8(%esp)
  801a4d:	00 
  801a4e:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801a55:	00 
  801a56:	c7 04 24 3c 2b 81 00 	movl   $0x812b3c,(%esp)
  801a5d:	e8 72 ef ff ff       	call   8009d4 <_panic>

int
sys_env_destroy(envid_t envid)
{
	return syscall(SYS_env_destroy, 1, envid, 0, 0, 0, 0);
}
  801a62:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  801a65:	8b 75 f8             	mov    -0x8(%ebp),%esi
  801a68:	8b 7d fc             	mov    -0x4(%ebp),%edi
  801a6b:	89 ec                	mov    %ebp,%esp
  801a6d:	5d                   	pop    %ebp
  801a6e:	c3                   	ret    
	...

00801a70 <sfork>:
}

// Challenge!
int
sfork(void)
{
  801a70:	55                   	push   %ebp
  801a71:	89 e5                	mov    %esp,%ebp
  801a73:	83 ec 18             	sub    $0x18,%esp
	panic("sfork not implemented");
  801a76:	c7 44 24 08 4a 2b 81 	movl   $0x812b4a,0x8(%esp)
  801a7d:	00 
  801a7e:	c7 44 24 04 f2 00 00 	movl   $0xf2,0x4(%esp)
  801a85:	00 
  801a86:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801a8d:	e8 42 ef ff ff       	call   8009d4 <_panic>

00801a92 <pgfault>:
// Custom page fault handler - if faulting page is copy-on-write,
// map in our own private writable copy.
//
static void
pgfault(struct UTrapframe *utf)
{
  801a92:	55                   	push   %ebp
  801a93:	89 e5                	mov    %esp,%ebp
  801a95:	53                   	push   %ebx
  801a96:	83 ec 24             	sub    $0x24,%esp
  801a99:	8b 45 08             	mov    0x8(%ebp),%eax
	void *addr = (void *) utf->utf_fault_va;
  801a9c:	8b 18                	mov    (%eax),%ebx
	uint32_t err = utf->utf_err;
  801a9e:	f6 40 04 02          	testb  $0x2,0x4(%eax)
  801aa2:	75 1c                	jne    801ac0 <pgfault+0x2e>
	// LAB 4: Your code here.
	if ((err & FEC_WR) != FEC_WR)
	{
		if (debug)
			cprintf("Error caught = %x\n", err);
		panic ("user panic in lib/fork.c - pgfault(): faulting access is not write\n");
  801aa4:	c7 44 24 08 6c 2b 81 	movl   $0x812b6c,0x8(%esp)
  801aab:	00 
  801aac:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  801ab3:	00 
  801ab4:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801abb:	e8 14 ef ff ff       	call   8009d4 <_panic>
	}
	pte = vpt[VPN(addr)];
  801ac0:	89 d8                	mov    %ebx,%eax
  801ac2:	c1 e8 0c             	shr    $0xc,%eax
  801ac5:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if ((pte & PTE_COW) != PTE_COW)
  801acc:	f6 c4 08             	test   $0x8,%ah
  801acf:	75 1c                	jne    801aed <pgfault+0x5b>
		panic ("user panic in lib/fork.c - pgfault(): faulting access is not to a COW page\n");
  801ad1:	c7 44 24 08 b0 2b 81 	movl   $0x812bb0,0x8(%esp)
  801ad8:	00 
  801ad9:	c7 44 24 04 27 00 00 	movl   $0x27,0x4(%esp)
  801ae0:	00 
  801ae1:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801ae8:	e8 e7 ee ff ff       	call   8009d4 <_panic>
	// Hint:
	//   You should make three system calls.
	//   No need to explicitly delete the old page's mapping.

	// LAB 4: Your code here.
	if ((r = sys_page_alloc(0, (void*)PFTEMP, PTE_P | PTE_U | PTE_W)) < 0)
  801aed:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801af4:	00 
  801af5:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801afc:	00 
  801afd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801b04:	e8 42 fe ff ff       	call   80194b <sys_page_alloc>
  801b09:	85 c0                	test   %eax,%eax
  801b0b:	79 20                	jns    801b2d <pgfault+0x9b>
		panic ("user panic in lib/fork.c - pgfault(): sys_page_alloc: %e", r);
  801b0d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b11:	c7 44 24 08 fc 2b 81 	movl   $0x812bfc,0x8(%esp)
  801b18:	00 
  801b19:	c7 44 24 04 32 00 00 	movl   $0x32,0x4(%esp)
  801b20:	00 
  801b21:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801b28:	e8 a7 ee ff ff       	call   8009d4 <_panic>
	
	memmove((void*)PFTEMP, (void*)ROUNDDOWN(addr,PGSIZE), PGSIZE);
  801b2d:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx
  801b33:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  801b3a:	00 
  801b3b:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  801b3f:	c7 04 24 00 f0 7f 00 	movl   $0x7ff000,(%esp)
  801b46:	e8 ca f7 ff ff       	call   801315 <memmove>
		
	if ((r = sys_page_map(0, (void*)PFTEMP, 0, (void*)ROUNDDOWN(addr,PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)	
  801b4b:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801b52:	00 
  801b53:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  801b57:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801b5e:	00 
  801b5f:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801b66:	00 
  801b67:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801b6e:	e8 7a fd ff ff       	call   8018ed <sys_page_map>
  801b73:	85 c0                	test   %eax,%eax
  801b75:	79 20                	jns    801b97 <pgfault+0x105>
		panic ("user panic in lib/fork.c - pgfault(): sys_page_map: %e", r);
  801b77:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801b7b:	c7 44 24 08 38 2c 81 	movl   $0x812c38,0x8(%esp)
  801b82:	00 
  801b83:	c7 44 24 04 37 00 00 	movl   $0x37,0x4(%esp)
  801b8a:	00 
  801b8b:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801b92:	e8 3d ee ff ff       	call   8009d4 <_panic>
	if ((r = sys_page_unmap(0, (void*)PFTEMP)) < 0)
  801b97:	c7 44 24 04 00 f0 7f 	movl   $0x7ff000,0x4(%esp)
  801b9e:	00 
  801b9f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801ba6:	e8 e4 fc ff ff       	call   80188f <sys_page_unmap>
  801bab:	85 c0                	test   %eax,%eax
  801bad:	79 20                	jns    801bcf <pgfault+0x13d>
		panic ("user panic in lib/fork.c - pgfault(): sys_page_unmap: %e", r);
  801baf:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801bb3:	c7 44 24 08 70 2c 81 	movl   $0x812c70,0x8(%esp)
  801bba:	00 
  801bbb:	c7 44 24 04 39 00 00 	movl   $0x39,0x4(%esp)
  801bc2:	00 
  801bc3:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801bca:	e8 05 ee ff ff       	call   8009d4 <_panic>
	// panic("pgfault not implemented");
}
  801bcf:	83 c4 24             	add    $0x24,%esp
  801bd2:	5b                   	pop    %ebx
  801bd3:	5d                   	pop    %ebp
  801bd4:	c3                   	ret    

00801bd5 <fork>:
//   Neither user exception stack should ever be marked copy-on-write,
//   so you must allocate a new page for the child's user exception stack.
//
envid_t
fork(void)
{
  801bd5:	55                   	push   %ebp
  801bd6:	89 e5                	mov    %esp,%ebp
  801bd8:	57                   	push   %edi
  801bd9:	56                   	push   %esi
  801bda:	53                   	push   %ebx
  801bdb:	83 ec 3c             	sub    $0x3c,%esp
	int r;
	uint32_t pde_x, pte_x, vpn;	// page directory index, page table index and page number
	

	// Set up our page fault handler appropriately.
	set_pgfault_handler(pgfault);
  801bde:	c7 04 24 92 1a 80 00 	movl   $0x801a92,(%esp)
  801be5:	e8 c2 18 00 00       	call   8034ac <set_pgfault_handler>
static __inline envid_t sys_exofork(void) __attribute__((always_inline));
static __inline envid_t
sys_exofork(void)
{
	envid_t ret;
	__asm __volatile("int %2"
  801bea:	ba 07 00 00 00       	mov    $0x7,%edx
  801bef:	89 d0                	mov    %edx,%eax
  801bf1:	cd 30                	int    $0x30
  801bf3:	89 45 e0             	mov    %eax,-0x20(%ebp)
		cprintf("\n After set_pgfaulthandler()\n");
	// Create a child.
	child_envid = sys_exofork();
	if (debug)
		cprintf("\n After exofork()\n");
	if (child_envid < 0)
  801bf6:	85 c0                	test   %eax,%eax
  801bf8:	0f 88 21 02 00 00    	js     801e1f <fork+0x24a>
	if (child_envid == 0)
	{
		if (debug)
			cprintf("\n After child_envid == 0\n");
		env = &envs[ENVX(sys_getenvid())];
		return 0;
  801bfe:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
		return child_envid;
	if (debug)
		cprintf("\n After child_envid >= 0\n");
		// panic(" panic in lib/fork.c - fork():sys_exofork: %e", child_env);
	// fix "env" in the child process
	if (child_envid == 0)
  801c05:	85 c0                	test   %eax,%eax
  801c07:	75 1c                	jne    801c25 <fork+0x50>
	{
		if (debug)
			cprintf("\n After child_envid == 0\n");
		env = &envs[ENVX(sys_getenvid())];
  801c09:	e8 d0 fd ff ff       	call   8019de <sys_getenvid>
  801c0e:	25 ff 03 00 00       	and    $0x3ff,%eax
  801c13:	6b c0 7c             	imul   $0x7c,%eax,%eax
  801c16:	05 00 00 c0 ee       	add    $0xeec00000,%eax
  801c1b:	a3 f4 f5 b3 00       	mov    %eax,0xb3f5f4
		return 0;
  801c20:	e9 fa 01 00 00       	jmp    801e1f <fork+0x24a>
	// Map the address space except the user exception stack
	if (debug)
		cprintf("\n After child_envid > 0\n");
	for (pde_x = VPD(0); pde_x < VPD(UTOP); pde_x++)
	{
		if ((vpd[pde_x] & PTE_P) == PTE_P)
  801c25:	8b 55 dc             	mov    -0x24(%ebp),%edx
  801c28:	8b 04 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%eax
  801c2f:	a8 01                	test   $0x1,%al
  801c31:	0f 84 16 01 00 00    	je     801d4d <fork+0x178>
		{
			for (pte_x = 0; pte_x < NPTENTRIES; pte_x++)
			{
				vpn = (pde_x << (PDXSHIFT - PTXSHIFT)) + pte_x;		//removed hardcoding
  801c37:	89 d3                	mov    %edx,%ebx
  801c39:	c1 e3 0a             	shl    $0xa,%ebx
  801c3c:	89 d7                	mov    %edx,%edi
  801c3e:	c1 e7 16             	shl    $0x16,%edi
  801c41:	be 00 00 00 00       	mov    $0x0,%esi
				if(((vpt[vpn] & PTE_P) == PTE_P) && (vpn < VPN(UXSTACKTOP - PGSIZE)))
  801c46:	8b 04 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%eax
  801c4d:	a8 01                	test   $0x1,%al
  801c4f:	0f 84 e0 00 00 00    	je     801d35 <fork+0x160>
  801c55:	81 fb fe eb 0e 00    	cmp    $0xeebfe,%ebx
  801c5b:	0f 87 d4 00 00 00    	ja     801d35 <fork+0x160>
	
	// LAB 4: Your code here.
	if (debug)
		cprintf("\n duppage: 1\n");	

	pte_t pte = vpt[pn];
  801c61:	8b 14 9d 00 00 40 ef 	mov    -0x10c00000(,%ebx,4),%edx
	int perm = pte & PTE_USER;
  801c68:	89 d0                	mov    %edx,%eax
  801c6a:	25 07 0e 00 00       	and    $0xe07,%eax
	void *va = (void*) (pn*PGSIZE);	
	if (debug)
		cprintf("\n duppage: 2\n");	
	
	if ((perm & PTE_P) != PTE_P)
  801c6f:	f6 c2 01             	test   $0x1,%dl
  801c72:	75 1c                	jne    801c90 <fork+0xbb>
		panic ("user panic: lib\fork.c: duppage(): page to be duplicated is not PTE_P\n");
  801c74:	c7 44 24 08 ac 2c 81 	movl   $0x812cac,0x8(%esp)
  801c7b:	00 
  801c7c:	c7 44 24 04 58 00 00 	movl   $0x58,0x4(%esp)
  801c83:	00 
  801c84:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801c8b:	e8 44 ed ff ff       	call   8009d4 <_panic>
	if ((perm & PTE_U) != PTE_U)
  801c90:	a8 04                	test   $0x4,%al
  801c92:	75 1c                	jne    801cb0 <fork+0xdb>
		panic ("user panic: lib\fork.c: duppage(): page to be duplicated is not PTE_U\n");
  801c94:	c7 44 24 08 f4 2c 81 	movl   $0x812cf4,0x8(%esp)
  801c9b:	00 
  801c9c:	c7 44 24 04 5a 00 00 	movl   $0x5a,0x4(%esp)
  801ca3:	00 
  801ca4:	c7 04 24 60 2b 81 00 	movl   $0x812b60,(%esp)
  801cab:	e8 24 ed ff ff       	call   8009d4 <_panic>
  801cb0:	89 7d e4             	mov    %edi,-0x1c(%ebp)
	if (debug)
		cprintf("\n duppage: 3\n");	

	// LAB 7: Include PTE_SHARE convention
	if ( !(perm & PTE_SHARE) && (((perm & PTE_W) == PTE_W) || ((perm & PTE_COW) == PTE_COW)))
  801cb3:	f6 c4 04             	test   $0x4,%ah
  801cb6:	75 5b                	jne    801d13 <fork+0x13e>
  801cb8:	a9 02 08 00 00       	test   $0x802,%eax
  801cbd:	74 54                	je     801d13 <fork+0x13e>
	{
		if (debug)
			cprintf("\n duppage: 4\n");	
		// perm = PTE_P | PTE_U | PTE_COW;	// buggy permissions, removed in LAB 7
		perm &= ~PTE_W;				// remove write from perm
  801cbf:	83 e0 fd             	and    $0xfffffffd,%eax
		perm |= PTE_COW;			// add copy-on-write
  801cc2:	80 cc 08             	or     $0x8,%ah
  801cc5:	89 45 d8             	mov    %eax,-0x28(%ebp)
		if (debug)
			cprintf("\n duppage: 10\n");	
		if ((r = sys_page_map(0, va, envid, va, perm)) < 0)
  801cc8:	89 44 24 10          	mov    %eax,0x10(%esp)
  801ccc:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  801cd0:	8b 55 e0             	mov    -0x20(%ebp),%edx
  801cd3:	89 54 24 08          	mov    %edx,0x8(%esp)
  801cd7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801cdb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801ce2:	e8 06 fc ff ff       	call   8018ed <sys_page_map>
  801ce7:	85 c0                	test   %eax,%eax
  801ce9:	78 4a                	js     801d35 <fork+0x160>
			return r;
		if (debug)
			cprintf("\n duppage: 11\n");	
		if ((r = sys_page_map(0, va, 0, va, perm)) < 0)
  801ceb:	8b 45 d8             	mov    -0x28(%ebp),%eax
  801cee:	89 44 24 10          	mov    %eax,0x10(%esp)
  801cf2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  801cf5:	89 54 24 0c          	mov    %edx,0xc(%esp)
  801cf9:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801d00:	00 
  801d01:	89 54 24 04          	mov    %edx,0x4(%esp)
  801d05:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801d0c:	e8 dc fb ff ff       	call   8018ed <sys_page_map>
  801d11:	eb 22                	jmp    801d35 <fork+0x160>
	// LAB 7: Include PTE_SHARE convention
	else
	{
		if (debug)
			cprintf("\n duppage: 6\n");	
		if ((r = sys_page_map(0, va, envid, va, perm)) < 0)
  801d13:	89 44 24 10          	mov    %eax,0x10(%esp)
  801d17:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  801d1a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  801d1e:	8b 55 e0             	mov    -0x20(%ebp),%edx
  801d21:	89 54 24 08          	mov    %edx,0x8(%esp)
  801d25:	89 44 24 04          	mov    %eax,0x4(%esp)
  801d29:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801d30:	e8 b8 fb ff ff       	call   8018ed <sys_page_map>
		cprintf("\n After child_envid > 0\n");
	for (pde_x = VPD(0); pde_x < VPD(UTOP); pde_x++)
	{
		if ((vpd[pde_x] & PTE_P) == PTE_P)
		{
			for (pte_x = 0; pte_x < NPTENTRIES; pte_x++)
  801d35:	83 c6 01             	add    $0x1,%esi
  801d38:	83 c3 01             	add    $0x1,%ebx
  801d3b:	81 c7 00 10 00 00    	add    $0x1000,%edi
  801d41:	81 fe 00 04 00 00    	cmp    $0x400,%esi
  801d47:	0f 85 f9 fe ff ff    	jne    801c46 <fork+0x71>
	}
	// reached here... we're the parent process
	// Map the address space except the user exception stack
	if (debug)
		cprintf("\n After child_envid > 0\n");
	for (pde_x = VPD(0); pde_x < VPD(UTOP); pde_x++)
  801d4d:	83 45 dc 01          	addl   $0x1,-0x24(%ebp)
  801d51:	81 7d dc bb 03 00 00 	cmpl   $0x3bb,-0x24(%ebp)
  801d58:	0f 85 c7 fe ff ff    	jne    801c25 <fork+0x50>
	}	
	if (debug)
		cprintf("\n After duppaging()\n");
	// Allocate and copy the use exception stack for the child environment
	// Allocate a page for the stack in the child
	if ((r = sys_page_alloc(child_envid, (void*)(UXSTACKTOP - PGSIZE), PTE_P | PTE_U | PTE_W)) < 0)
  801d5e:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  801d65:	00 
  801d66:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801d6d:	ee 
  801d6e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801d71:	89 04 24             	mov    %eax,(%esp)
  801d74:	e8 d2 fb ff ff       	call   80194b <sys_page_alloc>
  801d79:	85 c0                	test   %eax,%eax
  801d7b:	79 08                	jns    801d85 <fork+0x1b0>
  801d7d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801d80:	e9 9a 00 00 00       	jmp    801e1f <fork+0x24a>
		return r;
	if (debug)
		cprintf("\n After set_pgfaulthandler()\n");
	// Map this page to a free virtual address space in parent
	if ((r = sys_page_map(child_envid, (void*)(UXSTACKTOP - PGSIZE), 0, (void*)UTEMP, PTE_P | PTE_U | PTE_W)) < 0)
  801d85:	c7 44 24 10 07 00 00 	movl   $0x7,0x10(%esp)
  801d8c:	00 
  801d8d:	c7 44 24 0c 00 00 40 	movl   $0x400000,0xc(%esp)
  801d94:	00 
  801d95:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  801d9c:	00 
  801d9d:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801da4:	ee 
  801da5:	8b 55 e0             	mov    -0x20(%ebp),%edx
  801da8:	89 14 24             	mov    %edx,(%esp)
  801dab:	e8 3d fb ff ff       	call   8018ed <sys_page_map>
  801db0:	85 c0                	test   %eax,%eax
  801db2:	79 05                	jns    801db9 <fork+0x1e4>
  801db4:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801db7:	eb 66                	jmp    801e1f <fork+0x24a>
		return r;
	if (debug)
		cprintf("\n After sys_page_map()\n");
	// Copy the parent exception stack to the above, i.e. page from child mapped to parent's address space
	memmove((void*)UTEMP, (void*)(UXSTACKTOP - PGSIZE), PGSIZE);
  801db9:	c7 44 24 08 00 10 00 	movl   $0x1000,0x8(%esp)
  801dc0:	00 
  801dc1:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  801dc8:	ee 
  801dc9:	c7 04 24 00 00 40 00 	movl   $0x400000,(%esp)
  801dd0:	e8 40 f5 ff ff       	call   801315 <memmove>
	if (debug)
		cprintf("\n After memmove()\n");
	// Unmap this page from the parent
	sys_page_unmap(0, (void*)UTEMP);
  801dd5:	c7 44 24 04 00 00 40 	movl   $0x400000,0x4(%esp)
  801ddc:	00 
  801ddd:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  801de4:	e8 a6 fa ff ff       	call   80188f <sys_page_unmap>
	if (debug)
		cprintf("\n After sys_page_unmap()\n");

	// Set up the page fault handler
	if ((r = sys_env_set_pgfault_upcall(child_envid, _pgfault_upcall)) < 0)
  801de9:	c7 44 24 04 40 35 80 	movl   $0x803540,0x4(%esp)
  801df0:	00 
  801df1:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801df4:	89 04 24             	mov    %eax,(%esp)
  801df7:	e8 79 f9 ff ff       	call   801775 <sys_env_set_pgfault_upcall>
  801dfc:	85 c0                	test   %eax,%eax
  801dfe:	79 05                	jns    801e05 <fork+0x230>
  801e00:	89 45 e0             	mov    %eax,-0x20(%ebp)
  801e03:	eb 1a                	jmp    801e1f <fork+0x24a>
		// panic(" panic in lib/fork.c - fork():sys_env_set_pgfault_upcall: %e", child_env);
	if (debug)
		cprintf("\n After set_upcall()\n");

	// Mark the child runnable
	if ((r = sys_env_set_status(child_envid, ENV_RUNNABLE)) < 0)
  801e05:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  801e0c:	00 
  801e0d:	8b 55 e0             	mov    -0x20(%ebp),%edx
  801e10:	89 14 24             	mov    %edx,(%esp)
  801e13:	e8 19 fa ff ff       	call   801831 <sys_env_set_status>
  801e18:	85 c0                	test   %eax,%eax
  801e1a:	79 03                	jns    801e1f <fork+0x24a>
  801e1c:	89 45 e0             	mov    %eax,-0x20(%ebp)
	if (debug)
		cprintf("\n After set_status()\n");
	
	return child_envid;
	
}
  801e1f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  801e22:	83 c4 3c             	add    $0x3c,%esp
  801e25:	5b                   	pop    %ebx
  801e26:	5e                   	pop    %esi
  801e27:	5f                   	pop    %edi
  801e28:	5d                   	pop    %ebp
  801e29:	c3                   	ret    
  801e2a:	00 00                	add    %al,(%eax)
  801e2c:	00 00                	add    %al,(%eax)
	...

00801e30 <ipc_send>:
//   Use sys_yield() to be CPU-friendly.
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value.)
void
ipc_send(envid_t to_env, uint32_t val, void *pg, int perm)
{
  801e30:	55                   	push   %ebp
  801e31:	89 e5                	mov    %esp,%ebp
  801e33:	57                   	push   %edi
  801e34:	56                   	push   %esi
  801e35:	53                   	push   %ebx
  801e36:	83 ec 1c             	sub    $0x1c,%esp
  801e39:	8b 7d 0c             	mov    0xc(%ebp),%edi
  801e3c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  801e3f:	8b 75 14             	mov    0x14(%ebp),%esi
	// LAB 4: Your code here.
	int r;
	if (pg == NULL)
  801e42:	85 db                	test   %ebx,%ebx
  801e44:	75 2d                	jne    801e73 <ipc_send+0x43>
  801e46:	bb 00 00 c0 ee       	mov    $0xeec00000,%ebx
  801e4b:	eb 26                	jmp    801e73 <ipc_send+0x43>
		pg = (void*)UTOP;
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) < 0)
	{
		if(r != -E_IPC_NOT_RECV)
  801e4d:	83 f8 f9             	cmp    $0xfffffff9,%eax
  801e50:	74 1c                	je     801e6e <ipc_send+0x3e>
			panic("Panic in lib ipc.c : ipc_send() \n");
  801e52:	c7 44 24 08 3c 2d 81 	movl   $0x812d3c,0x8(%esp)
  801e59:	00 
  801e5a:	c7 44 24 04 44 00 00 	movl   $0x44,0x4(%esp)
  801e61:	00 
  801e62:	c7 04 24 5e 2d 81 00 	movl   $0x812d5e,(%esp)
  801e69:	e8 66 eb ff ff       	call   8009d4 <_panic>
		sys_yield();
  801e6e:	e8 37 fb ff ff       	call   8019aa <sys_yield>
{
	// LAB 4: Your code here.
	int r;
	if (pg == NULL)
		pg = (void*)UTOP;
	while ((r = sys_ipc_try_send(to_env, val, pg, perm)) < 0)
  801e73:	89 74 24 0c          	mov    %esi,0xc(%esp)
  801e77:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  801e7b:	89 7c 24 04          	mov    %edi,0x4(%esp)
  801e7f:	8b 45 08             	mov    0x8(%ebp),%eax
  801e82:	89 04 24             	mov    %eax,(%esp)
  801e85:	e8 b3 f8 ff ff       	call   80173d <sys_ipc_try_send>
  801e8a:	85 c0                	test   %eax,%eax
  801e8c:	78 bf                	js     801e4d <ipc_send+0x1d>
		if(r != -E_IPC_NOT_RECV)
			panic("Panic in lib ipc.c : ipc_send() \n");
		sys_yield();
	}
	//panic("ipc_send not implemented");
}
  801e8e:	83 c4 1c             	add    $0x1c,%esp
  801e91:	5b                   	pop    %ebx
  801e92:	5e                   	pop    %esi
  801e93:	5f                   	pop    %edi
  801e94:	5d                   	pop    %ebp
  801e95:	c3                   	ret    

00801e96 <ipc_recv>:
//   If 'pg' is null, pass sys_ipc_recv a value that it will understand
//   as meaning "no page".  (Zero is not the right value, since that's
//   a perfectly valid place to map a page.)
int32_t
ipc_recv(envid_t *from_env_store, void *pg, int *perm_store)
{
  801e96:	55                   	push   %ebp
  801e97:	89 e5                	mov    %esp,%ebp
  801e99:	56                   	push   %esi
  801e9a:	53                   	push   %ebx
  801e9b:	83 ec 10             	sub    $0x10,%esp
  801e9e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  801ea1:	8b 45 0c             	mov    0xc(%ebp),%eax
  801ea4:	8b 75 10             	mov    0x10(%ebp),%esi
	// LAB 4: Your code here.
	int r;

	if (pg == NULL)
  801ea7:	85 c0                	test   %eax,%eax
  801ea9:	75 05                	jne    801eb0 <ipc_recv+0x1a>
  801eab:	b8 00 00 c0 ee       	mov    $0xeec00000,%eax
		pg = (void*)UTOP;
	if ((r = sys_ipc_recv(pg)) < 0)
  801eb0:	89 04 24             	mov    %eax,(%esp)
  801eb3:	e8 28 f8 ff ff       	call   8016e0 <sys_ipc_recv>
  801eb8:	85 c0                	test   %eax,%eax
  801eba:	79 16                	jns    801ed2 <ipc_recv+0x3c>
	{
		if (from_env_store != NULL)
  801ebc:	85 db                	test   %ebx,%ebx
  801ebe:	74 06                	je     801ec6 <ipc_recv+0x30>
			*from_env_store = 0;
  801ec0:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
		if(perm_store != NULL)
  801ec6:	85 f6                	test   %esi,%esi
  801ec8:	74 2c                	je     801ef6 <ipc_recv+0x60>
			*perm_store = 0;
  801eca:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
  801ed0:	eb 24                	jmp    801ef6 <ipc_recv+0x60>
		return r;
	}
	else
	{	
		if (from_env_store != NULL)
  801ed2:	85 db                	test   %ebx,%ebx
  801ed4:	74 0a                	je     801ee0 <ipc_recv+0x4a>
			*from_env_store = env->env_ipc_from;
  801ed6:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  801edb:	8b 40 74             	mov    0x74(%eax),%eax
  801ede:	89 03                	mov    %eax,(%ebx)
		if(perm_store != NULL)
  801ee0:	85 f6                	test   %esi,%esi
  801ee2:	74 0a                	je     801eee <ipc_recv+0x58>
			*perm_store = env->env_ipc_perm;
  801ee4:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  801ee9:	8b 40 78             	mov    0x78(%eax),%eax
  801eec:	89 06                	mov    %eax,(%esi)
		return env->env_ipc_value;
  801eee:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  801ef3:	8b 40 70             	mov    0x70(%eax),%eax
	}		
	//panic("ipc_recv not implemented");
	//return 0;
}
  801ef6:	83 c4 10             	add    $0x10,%esp
  801ef9:	5b                   	pop    %ebx
  801efa:	5e                   	pop    %esi
  801efb:	5d                   	pop    %ebp
  801efc:	c3                   	ret    
  801efd:	00 00                	add    %al,(%eax)
	...

00801f00 <fd2num>:
// File descriptor manipulators
// --------------------------------------------------------------

int
fd2num(struct Fd *fd)
{
  801f00:	55                   	push   %ebp
  801f01:	89 e5                	mov    %esp,%ebp
  801f03:	8b 45 08             	mov    0x8(%ebp),%eax
  801f06:	05 00 00 00 30       	add    $0x30000000,%eax
  801f0b:	c1 e8 0c             	shr    $0xc,%eax
	return ((uintptr_t) fd - FDTABLE) / PGSIZE;
}
  801f0e:	5d                   	pop    %ebp
  801f0f:	c3                   	ret    

00801f10 <fd2data>:

char*
fd2data(struct Fd *fd)
{
  801f10:	55                   	push   %ebp
  801f11:	89 e5                	mov    %esp,%ebp
  801f13:	83 ec 04             	sub    $0x4,%esp
	return INDEX2DATA(fd2num(fd));
  801f16:	8b 45 08             	mov    0x8(%ebp),%eax
  801f19:	89 04 24             	mov    %eax,(%esp)
  801f1c:	e8 df ff ff ff       	call   801f00 <fd2num>
  801f21:	05 20 00 0d 00       	add    $0xd0020,%eax
  801f26:	c1 e0 0c             	shl    $0xc,%eax
}
  801f29:	c9                   	leave  
  801f2a:	c3                   	ret    

00801f2b <fd_alloc>:
// Returns 0 on success, < 0 on error.  Errors are:
//	-E_MAX_FD: no more file descriptors
// On error, *fd_store is set to 0.
int
fd_alloc(struct Fd **fd_store)
{
  801f2b:	55                   	push   %ebp
  801f2c:	89 e5                	mov    %esp,%ebp
  801f2e:	57                   	push   %edi
  801f2f:	56                   	push   %esi
  801f30:	53                   	push   %ebx
  801f31:	8b 7d 08             	mov    0x8(%ebp),%edi
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
		fd = INDEX2FD(i);
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
  801f34:	a1 00 dd 7b ef       	mov    0xef7bdd00,%eax
  801f39:	a8 01                	test   $0x1,%al
  801f3b:	74 36                	je     801f73 <fd_alloc+0x48>
  801f3d:	a1 00 00 74 ef       	mov    0xef740000,%eax
  801f42:	a8 01                	test   $0x1,%al
  801f44:	74 2d                	je     801f73 <fd_alloc+0x48>
  801f46:	b8 00 10 00 d0       	mov    $0xd0001000,%eax
  801f4b:	b9 00 d0 7b ef       	mov    $0xef7bd000,%ecx
  801f50:	be 00 00 40 ef       	mov    $0xef400000,%esi
  801f55:	89 c3                	mov    %eax,%ebx
  801f57:	89 c2                	mov    %eax,%edx
  801f59:	c1 ea 16             	shr    $0x16,%edx
  801f5c:	8b 14 91             	mov    (%ecx,%edx,4),%edx
  801f5f:	f6 c2 01             	test   $0x1,%dl
  801f62:	74 14                	je     801f78 <fd_alloc+0x4d>
  801f64:	89 c2                	mov    %eax,%edx
  801f66:	c1 ea 0c             	shr    $0xc,%edx
  801f69:	8b 14 96             	mov    (%esi,%edx,4),%edx
  801f6c:	f6 c2 01             	test   $0x1,%dl
  801f6f:	75 10                	jne    801f81 <fd_alloc+0x56>
  801f71:	eb 05                	jmp    801f78 <fd_alloc+0x4d>
  801f73:	bb 00 00 00 d0       	mov    $0xd0000000,%ebx
			*fd_store = fd;
  801f78:	89 1f                	mov    %ebx,(%edi)
  801f7a:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  801f7f:	eb 17                	jmp    801f98 <fd_alloc+0x6d>
  801f81:	05 00 10 00 00       	add    $0x1000,%eax
fd_alloc(struct Fd **fd_store)
{
	int i;
	struct Fd *fd;

	for (i = 0; i < MAXFD; i++) {
  801f86:	3d 00 00 02 d0       	cmp    $0xd0020000,%eax
  801f8b:	75 c8                	jne    801f55 <fd_alloc+0x2a>
		if ((vpd[PDX(fd)] & PTE_P) == 0 || (vpt[VPN(fd)] & PTE_P) == 0) {
			*fd_store = fd;
			return 0;
		}
	}
	*fd_store = 0;
  801f8d:	c7 07 00 00 00 00    	movl   $0x0,(%edi)
  801f93:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
	return -E_MAX_OPEN;
}
  801f98:	5b                   	pop    %ebx
  801f99:	5e                   	pop    %esi
  801f9a:	5f                   	pop    %edi
  801f9b:	5d                   	pop    %ebp
  801f9c:	c3                   	ret    

00801f9d <fd_lookup>:
// Returns 0 on success (the page is in range and mapped), < 0 on error.
// Errors are:
//	-E_INVAL: fdnum was either not in range or not mapped.
int
fd_lookup(int fdnum, struct Fd **fd_store)
{
  801f9d:	55                   	push   %ebp
  801f9e:	89 e5                	mov    %esp,%ebp
	struct Fd *fd;

	if (fdnum < 0 || fdnum >= MAXFD) {
  801fa0:	8b 45 08             	mov    0x8(%ebp),%eax
  801fa3:	83 f8 1f             	cmp    $0x1f,%eax
  801fa6:	77 36                	ja     801fde <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] bad fd %d\n", env->env_id, fd);
		return -E_INVAL;
	}
	fd = INDEX2FD(fdnum);
  801fa8:	05 00 00 0d 00       	add    $0xd0000,%eax
  801fad:	c1 e0 0c             	shl    $0xc,%eax
	if (!(vpd[PDX(fd)] & PTE_P) || !(vpt[VPN(fd)] & PTE_P)) {
  801fb0:	89 c2                	mov    %eax,%edx
  801fb2:	c1 ea 16             	shr    $0x16,%edx
  801fb5:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  801fbc:	f6 c2 01             	test   $0x1,%dl
  801fbf:	74 1d                	je     801fde <fd_lookup+0x41>
  801fc1:	89 c2                	mov    %eax,%edx
  801fc3:	c1 ea 0c             	shr    $0xc,%edx
  801fc6:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  801fcd:	f6 c2 01             	test   $0x1,%dl
  801fd0:	74 0c                	je     801fde <fd_lookup+0x41>
		if (debug)
			cprintf("[%08x] closed fd %d\n", env->env_id, fd);
		return -E_INVAL;
	}
	*fd_store = fd;
  801fd2:	8b 55 0c             	mov    0xc(%ebp),%edx
  801fd5:	89 02                	mov    %eax,(%edx)
  801fd7:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
  801fdc:	eb 05                	jmp    801fe3 <fd_lookup+0x46>
  801fde:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
}
  801fe3:	5d                   	pop    %ebp
  801fe4:	c3                   	ret    

00801fe5 <seek>:
	return (*dev->dev_write)(fd, buf, n);
}

int
seek(int fdnum, off_t offset)
{
  801fe5:	55                   	push   %ebp
  801fe6:	89 e5                	mov    %esp,%ebp
  801fe8:	83 ec 18             	sub    $0x18,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  801feb:	8d 45 fc             	lea    -0x4(%ebp),%eax
  801fee:	89 44 24 04          	mov    %eax,0x4(%esp)
  801ff2:	8b 45 08             	mov    0x8(%ebp),%eax
  801ff5:	89 04 24             	mov    %eax,(%esp)
  801ff8:	e8 a0 ff ff ff       	call   801f9d <fd_lookup>
  801ffd:	85 c0                	test   %eax,%eax
  801fff:	78 0e                	js     80200f <seek+0x2a>
		return r;
	fd->fd_offset = offset;
  802001:	8b 45 fc             	mov    -0x4(%ebp),%eax
  802004:	8b 55 0c             	mov    0xc(%ebp),%edx
  802007:	89 50 04             	mov    %edx,0x4(%eax)
  80200a:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  80200f:	c9                   	leave  
  802010:	c3                   	ret    

00802011 <dev_lookup>:
	0
};

int
dev_lookup(int dev_id, struct Dev **dev)
{
  802011:	55                   	push   %ebp
  802012:	89 e5                	mov    %esp,%ebp
  802014:	56                   	push   %esi
  802015:	53                   	push   %ebx
  802016:	83 ec 10             	sub    $0x10,%esp
  802019:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80201c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
// File functions
// --------------------------------------------------------------

static struct Dev *devtab[] =
{
	&devfile,
  80201f:	b8 04 90 81 00       	mov    $0x819004,%eax
{
	int i;
	for (i = 0; devtab[i]; i++)
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
  802024:	ba 00 00 00 00       	mov    $0x0,%edx

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  802029:	be e4 2d 81 00       	mov    $0x812de4,%esi
		if (devtab[i]->dev_id == dev_id) {
  80202e:	39 08                	cmp    %ecx,(%eax)
  802030:	75 10                	jne    802042 <dev_lookup+0x31>
  802032:	eb 04                	jmp    802038 <dev_lookup+0x27>
  802034:	39 08                	cmp    %ecx,(%eax)
  802036:	75 0a                	jne    802042 <dev_lookup+0x31>
			*dev = devtab[i];
  802038:	89 03                	mov    %eax,(%ebx)
  80203a:	b8 00 00 00 00       	mov    $0x0,%eax
			return 0;
  80203f:	90                   	nop
  802040:	eb 31                	jmp    802073 <dev_lookup+0x62>

int
dev_lookup(int dev_id, struct Dev **dev)
{
	int i;
	for (i = 0; devtab[i]; i++)
  802042:	83 c2 01             	add    $0x1,%edx
  802045:	8b 04 96             	mov    (%esi,%edx,4),%eax
  802048:	85 c0                	test   %eax,%eax
  80204a:	75 e8                	jne    802034 <dev_lookup+0x23>
		if (devtab[i]->dev_id == dev_id) {
			*dev = devtab[i];
			return 0;
		}
	cprintf("[%08x] unknown device type %d\n", env->env_id, dev_id);
  80204c:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  802051:	8b 40 4c             	mov    0x4c(%eax),%eax
  802054:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  802058:	89 44 24 04          	mov    %eax,0x4(%esp)
  80205c:	c7 04 24 68 2d 81 00 	movl   $0x812d68,(%esp)
  802063:	e8 31 ea ff ff       	call   800a99 <cprintf>
	*dev = 0;
  802068:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  80206e:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
	return -E_INVAL;
}
  802073:	83 c4 10             	add    $0x10,%esp
  802076:	5b                   	pop    %ebx
  802077:	5e                   	pop    %esi
  802078:	5d                   	pop    %ebp
  802079:	c3                   	ret    

0080207a <fstat>:
	return (*dev->dev_trunc)(fd, newsize);
}

int
fstat(int fdnum, struct Stat *stat)
{
  80207a:	55                   	push   %ebp
  80207b:	89 e5                	mov    %esp,%ebp
  80207d:	53                   	push   %ebx
  80207e:	83 ec 24             	sub    $0x24,%esp
  802081:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802084:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802087:	89 44 24 04          	mov    %eax,0x4(%esp)
  80208b:	8b 45 08             	mov    0x8(%ebp),%eax
  80208e:	89 04 24             	mov    %eax,(%esp)
  802091:	e8 07 ff ff ff       	call   801f9d <fd_lookup>
  802096:	85 c0                	test   %eax,%eax
  802098:	78 53                	js     8020ed <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80209a:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80209d:	89 44 24 04          	mov    %eax,0x4(%esp)
  8020a1:	8b 45 f0             	mov    -0x10(%ebp),%eax
  8020a4:	8b 00                	mov    (%eax),%eax
  8020a6:	89 04 24             	mov    %eax,(%esp)
  8020a9:	e8 63 ff ff ff       	call   802011 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8020ae:	85 c0                	test   %eax,%eax
  8020b0:	78 3b                	js     8020ed <fstat+0x73>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if (!dev->dev_stat)
  8020b2:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8020b7:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8020ba:	83 7a 14 00          	cmpl   $0x0,0x14(%edx)
  8020be:	74 2d                	je     8020ed <fstat+0x73>
		return -E_NOT_SUPP;
	stat->st_name[0] = 0;
  8020c0:	c6 03 00             	movb   $0x0,(%ebx)
	stat->st_size = 0;
  8020c3:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  8020ca:	00 00 00 
	stat->st_isdir = 0;
  8020cd:	c7 83 84 00 00 00 00 	movl   $0x0,0x84(%ebx)
  8020d4:	00 00 00 
	stat->st_dev = dev;
  8020d7:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8020da:	89 83 88 00 00 00    	mov    %eax,0x88(%ebx)
	return (*dev->dev_stat)(fd, stat);
  8020e0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8020e4:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8020e7:	89 14 24             	mov    %edx,(%esp)
  8020ea:	ff 50 14             	call   *0x14(%eax)
}
  8020ed:	83 c4 24             	add    $0x24,%esp
  8020f0:	5b                   	pop    %ebx
  8020f1:	5d                   	pop    %ebp
  8020f2:	c3                   	ret    

008020f3 <ftruncate>:
	return 0;
}

int
ftruncate(int fdnum, off_t newsize)
{
  8020f3:	55                   	push   %ebp
  8020f4:	89 e5                	mov    %esp,%ebp
  8020f6:	53                   	push   %ebx
  8020f7:	83 ec 24             	sub    $0x24,%esp
  8020fa:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  8020fd:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802100:	89 44 24 04          	mov    %eax,0x4(%esp)
  802104:	89 1c 24             	mov    %ebx,(%esp)
  802107:	e8 91 fe ff ff       	call   801f9d <fd_lookup>
  80210c:	85 c0                	test   %eax,%eax
  80210e:	78 5f                	js     80216f <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802110:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802113:	89 44 24 04          	mov    %eax,0x4(%esp)
  802117:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80211a:	8b 00                	mov    (%eax),%eax
  80211c:	89 04 24             	mov    %eax,(%esp)
  80211f:	e8 ed fe ff ff       	call   802011 <dev_lookup>
ftruncate(int fdnum, off_t newsize)
{
	int r;
	struct Dev *dev;
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
  802124:	85 c0                	test   %eax,%eax
  802126:	78 47                	js     80216f <ftruncate+0x7c>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  802128:	8b 55 f0             	mov    -0x10(%ebp),%edx
  80212b:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  80212f:	75 23                	jne    802154 <ftruncate+0x61>
		cprintf("[%08x] ftruncate %d -- bad mode\n",
			env->env_id, fdnum); 
  802131:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
	struct Fd *fd;
	if ((r = fd_lookup(fdnum, &fd)) < 0
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
		cprintf("[%08x] ftruncate %d -- bad mode\n",
  802136:	8b 40 4c             	mov    0x4c(%eax),%eax
  802139:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80213d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802141:	c7 04 24 88 2d 81 00 	movl   $0x812d88,(%esp)
  802148:	e8 4c e9 ff ff       	call   800a99 <cprintf>
  80214d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
			env->env_id, fdnum); 
		return -E_INVAL;
  802152:	eb 1b                	jmp    80216f <ftruncate+0x7c>
	}
	if (!dev->dev_trunc)
  802154:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802157:	8b 48 18             	mov    0x18(%eax),%ecx
  80215a:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80215f:	85 c9                	test   %ecx,%ecx
  802161:	74 0c                	je     80216f <ftruncate+0x7c>
		return -E_NOT_SUPP;
	return (*dev->dev_trunc)(fd, newsize);
  802163:	8b 45 0c             	mov    0xc(%ebp),%eax
  802166:	89 44 24 04          	mov    %eax,0x4(%esp)
  80216a:	89 14 24             	mov    %edx,(%esp)
  80216d:	ff d1                	call   *%ecx
}
  80216f:	83 c4 24             	add    $0x24,%esp
  802172:	5b                   	pop    %ebx
  802173:	5d                   	pop    %ebp
  802174:	c3                   	ret    

00802175 <write>:
	return tot;
}

ssize_t
write(int fdnum, const void *buf, size_t n)
{
  802175:	55                   	push   %ebp
  802176:	89 e5                	mov    %esp,%ebp
  802178:	53                   	push   %ebx
  802179:	83 ec 24             	sub    $0x24,%esp
  80217c:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80217f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  802182:	89 44 24 04          	mov    %eax,0x4(%esp)
  802186:	89 1c 24             	mov    %ebx,(%esp)
  802189:	e8 0f fe ff ff       	call   801f9d <fd_lookup>
  80218e:	85 c0                	test   %eax,%eax
  802190:	78 66                	js     8021f8 <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  802192:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802195:	89 44 24 04          	mov    %eax,0x4(%esp)
  802199:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80219c:	8b 00                	mov    (%eax),%eax
  80219e:	89 04 24             	mov    %eax,(%esp)
  8021a1:	e8 6b fe ff ff       	call   802011 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  8021a6:	85 c0                	test   %eax,%eax
  8021a8:	78 4e                	js     8021f8 <write+0x83>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_RDONLY) {
  8021aa:	8b 55 f0             	mov    -0x10(%ebp),%edx
  8021ad:	f6 42 08 03          	testb  $0x3,0x8(%edx)
  8021b1:	75 23                	jne    8021d6 <write+0x61>
		cprintf("[%08x] write %d -- bad mode\n", env->env_id, fdnum);
  8021b3:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  8021b8:	8b 40 4c             	mov    0x4c(%eax),%eax
  8021bb:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  8021bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021c3:	c7 04 24 a9 2d 81 00 	movl   $0x812da9,(%esp)
  8021ca:	e8 ca e8 ff ff       	call   800a99 <cprintf>
  8021cf:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  8021d4:	eb 22                	jmp    8021f8 <write+0x83>
	}
	if (debug)
		cprintf("write %d %p %d via dev %s\n",
			fdnum, buf, n, dev->dev_name);
	if (!dev->dev_write)
  8021d6:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8021d9:	8b 48 0c             	mov    0xc(%eax),%ecx
  8021dc:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8021e1:	85 c9                	test   %ecx,%ecx
  8021e3:	74 13                	je     8021f8 <write+0x83>
		return -E_NOT_SUPP;
	return (*dev->dev_write)(fd, buf, n);
  8021e5:	8b 45 10             	mov    0x10(%ebp),%eax
  8021e8:	89 44 24 08          	mov    %eax,0x8(%esp)
  8021ec:	8b 45 0c             	mov    0xc(%ebp),%eax
  8021ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  8021f3:	89 14 24             	mov    %edx,(%esp)
  8021f6:	ff d1                	call   *%ecx
}
  8021f8:	83 c4 24             	add    $0x24,%esp
  8021fb:	5b                   	pop    %ebx
  8021fc:	5d                   	pop    %ebp
  8021fd:	c3                   	ret    

008021fe <read>:
	return r;
}

ssize_t
read(int fdnum, void *buf, size_t n)
{
  8021fe:	55                   	push   %ebp
  8021ff:	89 e5                	mov    %esp,%ebp
  802201:	53                   	push   %ebx
  802202:	83 ec 24             	sub    $0x24,%esp
  802205:	8b 5d 08             	mov    0x8(%ebp),%ebx
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  802208:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80220b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80220f:	89 1c 24             	mov    %ebx,(%esp)
  802212:	e8 86 fd ff ff       	call   801f9d <fd_lookup>
  802217:	85 c0                	test   %eax,%eax
  802219:	78 6b                	js     802286 <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
  80221b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80221e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802222:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802225:	8b 00                	mov    (%eax),%eax
  802227:	89 04 24             	mov    %eax,(%esp)
  80222a:	e8 e2 fd ff ff       	call   802011 <dev_lookup>
{
	int r;
	struct Dev *dev;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0
  80222f:	85 c0                	test   %eax,%eax
  802231:	78 53                	js     802286 <read+0x88>
	    || (r = dev_lookup(fd->fd_dev_id, &dev)) < 0)
		return r;
	if ((fd->fd_omode & O_ACCMODE) == O_WRONLY) {
  802233:	8b 55 f0             	mov    -0x10(%ebp),%edx
  802236:	8b 42 08             	mov    0x8(%edx),%eax
  802239:	83 e0 03             	and    $0x3,%eax
  80223c:	83 f8 01             	cmp    $0x1,%eax
  80223f:	75 23                	jne    802264 <read+0x66>
		cprintf("[%08x] read %d -- bad mode\n", env->env_id, fdnum); 
  802241:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  802246:	8b 40 4c             	mov    0x4c(%eax),%eax
  802249:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80224d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802251:	c7 04 24 c6 2d 81 00 	movl   $0x812dc6,(%esp)
  802258:	e8 3c e8 ff ff       	call   800a99 <cprintf>
  80225d:	b8 fd ff ff ff       	mov    $0xfffffffd,%eax
		return -E_INVAL;
  802262:	eb 22                	jmp    802286 <read+0x88>
	}
	if (!dev->dev_read)
  802264:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802267:	8b 48 08             	mov    0x8(%eax),%ecx
  80226a:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  80226f:	85 c9                	test   %ecx,%ecx
  802271:	74 13                	je     802286 <read+0x88>
		return -E_NOT_SUPP;
	return (*dev->dev_read)(fd, buf, n);
  802273:	8b 45 10             	mov    0x10(%ebp),%eax
  802276:	89 44 24 08          	mov    %eax,0x8(%esp)
  80227a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80227d:	89 44 24 04          	mov    %eax,0x4(%esp)
  802281:	89 14 24             	mov    %edx,(%esp)
  802284:	ff d1                	call   *%ecx
}
  802286:	83 c4 24             	add    $0x24,%esp
  802289:	5b                   	pop    %ebx
  80228a:	5d                   	pop    %ebp
  80228b:	c3                   	ret    

0080228c <readn>:

ssize_t
readn(int fdnum, void *buf, size_t n)
{
  80228c:	55                   	push   %ebp
  80228d:	89 e5                	mov    %esp,%ebp
  80228f:	57                   	push   %edi
  802290:	56                   	push   %esi
  802291:	53                   	push   %ebx
  802292:	83 ec 1c             	sub    $0x1c,%esp
  802295:	8b 7d 08             	mov    0x8(%ebp),%edi
  802298:	8b 75 10             	mov    0x10(%ebp),%esi
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  80229b:	ba 00 00 00 00       	mov    $0x0,%edx
  8022a0:	bb 00 00 00 00       	mov    $0x0,%ebx
  8022a5:	b8 00 00 00 00       	mov    $0x0,%eax
  8022aa:	85 f6                	test   %esi,%esi
  8022ac:	74 29                	je     8022d7 <readn+0x4b>
		m = read(fdnum, (char*)buf + tot, n - tot);
  8022ae:	89 f0                	mov    %esi,%eax
  8022b0:	29 d0                	sub    %edx,%eax
  8022b2:	89 44 24 08          	mov    %eax,0x8(%esp)
  8022b6:	03 55 0c             	add    0xc(%ebp),%edx
  8022b9:	89 54 24 04          	mov    %edx,0x4(%esp)
  8022bd:	89 3c 24             	mov    %edi,(%esp)
  8022c0:	e8 39 ff ff ff       	call   8021fe <read>
		if (m < 0)
  8022c5:	85 c0                	test   %eax,%eax
  8022c7:	78 0e                	js     8022d7 <readn+0x4b>
			return m;
		if (m == 0)
  8022c9:	85 c0                	test   %eax,%eax
  8022cb:	74 08                	je     8022d5 <readn+0x49>
ssize_t
readn(int fdnum, void *buf, size_t n)
{
	int m, tot;

	for (tot = 0; tot < n; tot += m) {
  8022cd:	01 c3                	add    %eax,%ebx
  8022cf:	89 da                	mov    %ebx,%edx
  8022d1:	39 f3                	cmp    %esi,%ebx
  8022d3:	72 d9                	jb     8022ae <readn+0x22>
  8022d5:	89 d8                	mov    %ebx,%eax
			return m;
		if (m == 0)
			break;
	}
	return tot;
}
  8022d7:	83 c4 1c             	add    $0x1c,%esp
  8022da:	5b                   	pop    %ebx
  8022db:	5e                   	pop    %esi
  8022dc:	5f                   	pop    %edi
  8022dd:	5d                   	pop    %ebp
  8022de:	c3                   	ret    

008022df <fd_close>:
// If 'must_exist' is 1, then fd_close returns -E_INVAL when passed a
// closed or nonexistent file descriptor.
// Returns 0 on success, < 0 on error.
int
fd_close(struct Fd *fd, bool must_exist)
{
  8022df:	55                   	push   %ebp
  8022e0:	89 e5                	mov    %esp,%ebp
  8022e2:	56                   	push   %esi
  8022e3:	53                   	push   %ebx
  8022e4:	83 ec 20             	sub    $0x20,%esp
  8022e7:	8b 75 08             	mov    0x8(%ebp),%esi
	struct Fd *fd2;
	struct Dev *dev;
	int r;
	if ((r = fd_lookup(fd2num(fd), &fd2)) < 0
  8022ea:	89 34 24             	mov    %esi,(%esp)
  8022ed:	e8 0e fc ff ff       	call   801f00 <fd2num>
  8022f2:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8022f5:	89 54 24 04          	mov    %edx,0x4(%esp)
  8022f9:	89 04 24             	mov    %eax,(%esp)
  8022fc:	e8 9c fc ff ff       	call   801f9d <fd_lookup>
  802301:	89 c3                	mov    %eax,%ebx
  802303:	85 c0                	test   %eax,%eax
  802305:	78 05                	js     80230c <fd_close+0x2d>
  802307:	3b 75 f4             	cmp    -0xc(%ebp),%esi
  80230a:	74 0c                	je     802318 <fd_close+0x39>
	    || fd != fd2)
		return (must_exist ? r : 0);
  80230c:	83 7d 0c 01          	cmpl   $0x1,0xc(%ebp)
  802310:	19 c0                	sbb    %eax,%eax
  802312:	f7 d0                	not    %eax
  802314:	21 c3                	and    %eax,%ebx
  802316:	eb 3d                	jmp    802355 <fd_close+0x76>
	if ((r = dev_lookup(fd->fd_dev_id, &dev)) >= 0) {
  802318:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80231b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80231f:	8b 06                	mov    (%esi),%eax
  802321:	89 04 24             	mov    %eax,(%esp)
  802324:	e8 e8 fc ff ff       	call   802011 <dev_lookup>
  802329:	89 c3                	mov    %eax,%ebx
  80232b:	85 c0                	test   %eax,%eax
  80232d:	78 16                	js     802345 <fd_close+0x66>
		if (dev->dev_close)
  80232f:	8b 45 f0             	mov    -0x10(%ebp),%eax
  802332:	8b 40 10             	mov    0x10(%eax),%eax
  802335:	bb 00 00 00 00       	mov    $0x0,%ebx
  80233a:	85 c0                	test   %eax,%eax
  80233c:	74 07                	je     802345 <fd_close+0x66>
			r = (*dev->dev_close)(fd);
  80233e:	89 34 24             	mov    %esi,(%esp)
  802341:	ff d0                	call   *%eax
  802343:	89 c3                	mov    %eax,%ebx
		else
			r = 0;
	}
	// Make sure fd is unmapped.  Might be a no-op if
	// (*dev->dev_close)(fd) already unmapped it.
	(void) sys_page_unmap(0, fd);
  802345:	89 74 24 04          	mov    %esi,0x4(%esp)
  802349:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802350:	e8 3a f5 ff ff       	call   80188f <sys_page_unmap>
	return r;
}
  802355:	89 d8                	mov    %ebx,%eax
  802357:	83 c4 20             	add    $0x20,%esp
  80235a:	5b                   	pop    %ebx
  80235b:	5e                   	pop    %esi
  80235c:	5d                   	pop    %ebp
  80235d:	c3                   	ret    

0080235e <close>:
	return -E_INVAL;
}

int
close(int fdnum)
{
  80235e:	55                   	push   %ebp
  80235f:	89 e5                	mov    %esp,%ebp
  802361:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  802364:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802367:	89 44 24 04          	mov    %eax,0x4(%esp)
  80236b:	8b 45 08             	mov    0x8(%ebp),%eax
  80236e:	89 04 24             	mov    %eax,(%esp)
  802371:	e8 27 fc ff ff       	call   801f9d <fd_lookup>
  802376:	85 c0                	test   %eax,%eax
  802378:	78 13                	js     80238d <close+0x2f>
		return r;
	else
		return fd_close(fd, 1);
  80237a:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  802381:	00 
  802382:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802385:	89 04 24             	mov    %eax,(%esp)
  802388:	e8 52 ff ff ff       	call   8022df <fd_close>
}
  80238d:	c9                   	leave  
  80238e:	c3                   	ret    

0080238f <stat>:
	return (*dev->dev_stat)(fd, stat);
}

int
stat(const char *path, struct Stat *stat)
{
  80238f:	55                   	push   %ebp
  802390:	89 e5                	mov    %esp,%ebp
  802392:	83 ec 18             	sub    $0x18,%esp
  802395:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802398:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int fd, r;

	if ((fd = open(path, O_RDONLY)) < 0)
  80239b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8023a2:	00 
  8023a3:	8b 45 08             	mov    0x8(%ebp),%eax
  8023a6:	89 04 24             	mov    %eax,(%esp)
  8023a9:	e8 55 03 00 00       	call   802703 <open>
  8023ae:	89 c3                	mov    %eax,%ebx
  8023b0:	85 c0                	test   %eax,%eax
  8023b2:	78 1b                	js     8023cf <stat+0x40>
		return fd;
	r = fstat(fd, stat);
  8023b4:	8b 45 0c             	mov    0xc(%ebp),%eax
  8023b7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8023bb:	89 1c 24             	mov    %ebx,(%esp)
  8023be:	e8 b7 fc ff ff       	call   80207a <fstat>
  8023c3:	89 c6                	mov    %eax,%esi
	close(fd);
  8023c5:	89 1c 24             	mov    %ebx,(%esp)
  8023c8:	e8 91 ff ff ff       	call   80235e <close>
  8023cd:	89 f3                	mov    %esi,%ebx
	return r;
}
  8023cf:	89 d8                	mov    %ebx,%eax
  8023d1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8023d4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8023d7:	89 ec                	mov    %ebp,%esp
  8023d9:	5d                   	pop    %ebp
  8023da:	c3                   	ret    

008023db <close_all>:
		return fd_close(fd, 1);
}

void
close_all(void)
{
  8023db:	55                   	push   %ebp
  8023dc:	89 e5                	mov    %esp,%ebp
  8023de:	53                   	push   %ebx
  8023df:	83 ec 14             	sub    $0x14,%esp
  8023e2:	bb 00 00 00 00       	mov    $0x0,%ebx
	int i;
	for (i = 0; i < MAXFD; i++)
		close(i);
  8023e7:	89 1c 24             	mov    %ebx,(%esp)
  8023ea:	e8 6f ff ff ff       	call   80235e <close>

void
close_all(void)
{
	int i;
	for (i = 0; i < MAXFD; i++)
  8023ef:	83 c3 01             	add    $0x1,%ebx
  8023f2:	83 fb 20             	cmp    $0x20,%ebx
  8023f5:	75 f0                	jne    8023e7 <close_all+0xc>
		close(i);
}
  8023f7:	83 c4 14             	add    $0x14,%esp
  8023fa:	5b                   	pop    %ebx
  8023fb:	5d                   	pop    %ebp
  8023fc:	c3                   	ret    

008023fd <dup>:
// file and the file offset of the other.
// Closes any previously open file descriptor at 'newfdnum'.
// This is implemented using virtual memory tricks (of course!).
int
dup(int oldfdnum, int newfdnum)
{
  8023fd:	55                   	push   %ebp
  8023fe:	89 e5                	mov    %esp,%ebp
  802400:	83 ec 58             	sub    $0x58,%esp
  802403:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  802406:	89 75 f8             	mov    %esi,-0x8(%ebp)
  802409:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80240c:	8b 7d 0c             	mov    0xc(%ebp),%edi
	int r;
	char *ova, *nva;
	pte_t pte;
	struct Fd *oldfd, *newfd;

	if ((r = fd_lookup(oldfdnum, &oldfd)) < 0)
  80240f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  802412:	89 44 24 04          	mov    %eax,0x4(%esp)
  802416:	8b 45 08             	mov    0x8(%ebp),%eax
  802419:	89 04 24             	mov    %eax,(%esp)
  80241c:	e8 7c fb ff ff       	call   801f9d <fd_lookup>
  802421:	89 c3                	mov    %eax,%ebx
  802423:	85 c0                	test   %eax,%eax
  802425:	0f 88 e0 00 00 00    	js     80250b <dup+0x10e>
		return r;
	close(newfdnum);
  80242b:	89 3c 24             	mov    %edi,(%esp)
  80242e:	e8 2b ff ff ff       	call   80235e <close>

	newfd = INDEX2FD(newfdnum);
  802433:	8d b7 00 00 0d 00    	lea    0xd0000(%edi),%esi
  802439:	c1 e6 0c             	shl    $0xc,%esi
	ova = fd2data(oldfd);
  80243c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80243f:	89 04 24             	mov    %eax,(%esp)
  802442:	e8 c9 fa ff ff       	call   801f10 <fd2data>
  802447:	89 c3                	mov    %eax,%ebx
	nva = fd2data(newfd);
  802449:	89 34 24             	mov    %esi,(%esp)
  80244c:	e8 bf fa ff ff       	call   801f10 <fd2data>
  802451:	89 45 d4             	mov    %eax,-0x2c(%ebp)

	if ((vpd[PDX(ova)] & PTE_P) && (vpt[VPN(ova)] & PTE_P))
  802454:	89 da                	mov    %ebx,%edx
  802456:	89 d8                	mov    %ebx,%eax
  802458:	c1 e8 16             	shr    $0x16,%eax
  80245b:	8b 04 85 00 d0 7b ef 	mov    -0x10843000(,%eax,4),%eax
  802462:	a8 01                	test   $0x1,%al
  802464:	74 43                	je     8024a9 <dup+0xac>
  802466:	c1 ea 0c             	shr    $0xc,%edx
  802469:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  802470:	a8 01                	test   $0x1,%al
  802472:	74 35                	je     8024a9 <dup+0xac>
		if ((r = sys_page_map(0, ova, 0, nva, vpt[VPN(ova)] & PTE_USER)) < 0)
  802474:	8b 04 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%eax
  80247b:	25 07 0e 00 00       	and    $0xe07,%eax
  802480:	89 44 24 10          	mov    %eax,0x10(%esp)
  802484:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  802487:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80248b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  802492:	00 
  802493:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802497:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80249e:	e8 4a f4 ff ff       	call   8018ed <sys_page_map>
  8024a3:	89 c3                	mov    %eax,%ebx
  8024a5:	85 c0                	test   %eax,%eax
  8024a7:	78 3f                	js     8024e8 <dup+0xeb>
			goto err;
	if ((r = sys_page_map(0, oldfd, 0, newfd, vpt[VPN(oldfd)] & PTE_USER)) < 0)
  8024a9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8024ac:	89 c2                	mov    %eax,%edx
  8024ae:	c1 ea 0c             	shr    $0xc,%edx
  8024b1:	8b 14 95 00 00 40 ef 	mov    -0x10c00000(,%edx,4),%edx
  8024b8:	81 e2 07 0e 00 00    	and    $0xe07,%edx
  8024be:	89 54 24 10          	mov    %edx,0x10(%esp)
  8024c2:	89 74 24 0c          	mov    %esi,0xc(%esp)
  8024c6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8024cd:	00 
  8024ce:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024d2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024d9:	e8 0f f4 ff ff       	call   8018ed <sys_page_map>
  8024de:	89 c3                	mov    %eax,%ebx
  8024e0:	85 c0                	test   %eax,%eax
  8024e2:	78 04                	js     8024e8 <dup+0xeb>
  8024e4:	89 fb                	mov    %edi,%ebx
  8024e6:	eb 23                	jmp    80250b <dup+0x10e>
		goto err;

	return newfdnum;

err:
	sys_page_unmap(0, newfd);
  8024e8:	89 74 24 04          	mov    %esi,0x4(%esp)
  8024ec:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8024f3:	e8 97 f3 ff ff       	call   80188f <sys_page_unmap>
	sys_page_unmap(0, nva);
  8024f8:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  8024fb:	89 44 24 04          	mov    %eax,0x4(%esp)
  8024ff:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802506:	e8 84 f3 ff ff       	call   80188f <sys_page_unmap>
	return r;
}
  80250b:	89 d8                	mov    %ebx,%eax
  80250d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  802510:	8b 75 f8             	mov    -0x8(%ebp),%esi
  802513:	8b 7d fc             	mov    -0x4(%ebp),%edi
  802516:	89 ec                	mov    %ebp,%esp
  802518:	5d                   	pop    %ebp
  802519:	c3                   	ret    
	...

0080251c <fsipc>:
// type: request code, passed as the simple integer IPC value.
// dstva: virtual address at which to receive reply page, 0 if none.
// Returns result from the file server.
static int
fsipc(unsigned type, void *dstva)
{
  80251c:	55                   	push   %ebp
  80251d:	89 e5                	mov    %esp,%ebp
  80251f:	53                   	push   %ebx
  802520:	83 ec 14             	sub    $0x14,%esp
  802523:	89 d3                	mov    %edx,%ebx
	if (debug)
		cprintf("[%08x] fsipc %d %08x\n", env->env_id, type, *(uint32_t *)&fsipcbuf);

	ipc_send(envs[1].env_id, type, &fsipcbuf, PTE_P | PTE_W | PTE_U);
  802525:	8b 15 c8 00 c0 ee    	mov    0xeec000c8,%edx
  80252b:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  802532:	00 
  802533:	c7 44 24 08 00 60 81 	movl   $0x816000,0x8(%esp)
  80253a:	00 
  80253b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80253f:	89 14 24             	mov    %edx,(%esp)
  802542:	e8 e9 f8 ff ff       	call   801e30 <ipc_send>
	return ipc_recv(NULL, dstva, NULL);
  802547:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80254e:	00 
  80254f:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802553:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80255a:	e8 37 f9 ff ff       	call   801e96 <ipc_recv>
}
  80255f:	83 c4 14             	add    $0x14,%esp
  802562:	5b                   	pop    %ebx
  802563:	5d                   	pop    %ebp
  802564:	c3                   	ret    

00802565 <devfile_trunc>:
}

// Truncate or extend an open file to 'size' bytes
static int
devfile_trunc(struct Fd *fd, off_t newsize)
{
  802565:	55                   	push   %ebp
  802566:	89 e5                	mov    %esp,%ebp
  802568:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.set_size.req_fileid = fd->fd_file.id;
  80256b:	8b 45 08             	mov    0x8(%ebp),%eax
  80256e:	8b 40 0c             	mov    0xc(%eax),%eax
  802571:	a3 00 60 81 00       	mov    %eax,0x816000
	fsipcbuf.set_size.req_size = newsize;
  802576:	8b 45 0c             	mov    0xc(%ebp),%eax
  802579:	a3 04 60 81 00       	mov    %eax,0x816004
	return fsipc(FSREQ_SET_SIZE, NULL);
  80257e:	ba 00 00 00 00       	mov    $0x0,%edx
  802583:	b8 02 00 00 00       	mov    $0x2,%eax
  802588:	e8 8f ff ff ff       	call   80251c <fsipc>
}
  80258d:	c9                   	leave  
  80258e:	c3                   	ret    

0080258f <devfile_flush>:
// open, unmapping it is enough to free up server-side resources.
// Other than that, we just have to make sure our changes are flushed
// to disk.
static int
devfile_flush(struct Fd *fd)
{
  80258f:	55                   	push   %ebp
  802590:	89 e5                	mov    %esp,%ebp
  802592:	83 ec 08             	sub    $0x8,%esp
	fsipcbuf.flush.req_fileid = fd->fd_file.id;
  802595:	8b 45 08             	mov    0x8(%ebp),%eax
  802598:	8b 40 0c             	mov    0xc(%eax),%eax
  80259b:	a3 00 60 81 00       	mov    %eax,0x816000
	return fsipc(FSREQ_FLUSH, NULL);
  8025a0:	ba 00 00 00 00       	mov    $0x0,%edx
  8025a5:	b8 06 00 00 00       	mov    $0x6,%eax
  8025aa:	e8 6d ff ff ff       	call   80251c <fsipc>
}
  8025af:	c9                   	leave  
  8025b0:	c3                   	ret    

008025b1 <sync>:
}

// Synchronize disk with buffer cache
int
sync(void)
{
  8025b1:	55                   	push   %ebp
  8025b2:	89 e5                	mov    %esp,%ebp
  8025b4:	83 ec 08             	sub    $0x8,%esp
	// Ask the file server to update the disk
	// by writing any dirty blocks in the buffer cache.

	return fsipc(FSREQ_SYNC, NULL);
  8025b7:	ba 00 00 00 00       	mov    $0x0,%edx
  8025bc:	b8 08 00 00 00       	mov    $0x8,%eax
  8025c1:	e8 56 ff ff ff       	call   80251c <fsipc>
}
  8025c6:	c9                   	leave  
  8025c7:	c3                   	ret    

008025c8 <devfile_stat>:
	return fsipc(FSREQ_WRITE, NULL);	
}

static int
devfile_stat(struct Fd *fd, struct Stat *st)
{
  8025c8:	55                   	push   %ebp
  8025c9:	89 e5                	mov    %esp,%ebp
  8025cb:	53                   	push   %ebx
  8025cc:	83 ec 14             	sub    $0x14,%esp
  8025cf:	8b 5d 0c             	mov    0xc(%ebp),%ebx
	int r;

	fsipcbuf.stat.req_fileid = fd->fd_file.id;
  8025d2:	8b 45 08             	mov    0x8(%ebp),%eax
  8025d5:	8b 40 0c             	mov    0xc(%eax),%eax
  8025d8:	a3 00 60 81 00       	mov    %eax,0x816000
	if ((r = fsipc(FSREQ_STAT, NULL)) < 0)
  8025dd:	ba 00 00 00 00       	mov    $0x0,%edx
  8025e2:	b8 05 00 00 00       	mov    $0x5,%eax
  8025e7:	e8 30 ff ff ff       	call   80251c <fsipc>
  8025ec:	85 c0                	test   %eax,%eax
  8025ee:	78 2b                	js     80261b <devfile_stat+0x53>
		return r;
	strcpy(st->st_name, fsipcbuf.statRet.ret_name);
  8025f0:	c7 44 24 04 00 60 81 	movl   $0x816000,0x4(%esp)
  8025f7:	00 
  8025f8:	89 1c 24             	mov    %ebx,(%esp)
  8025fb:	e8 5a eb ff ff       	call   80115a <strcpy>
	st->st_size = fsipcbuf.statRet.ret_size;
  802600:	a1 80 60 81 00       	mov    0x816080,%eax
  802605:	89 83 80 00 00 00    	mov    %eax,0x80(%ebx)
	st->st_isdir = fsipcbuf.statRet.ret_isdir;
  80260b:	a1 84 60 81 00       	mov    0x816084,%eax
  802610:	89 83 84 00 00 00    	mov    %eax,0x84(%ebx)
  802616:	b8 00 00 00 00       	mov    $0x0,%eax
	return 0;
}
  80261b:	83 c4 14             	add    $0x14,%esp
  80261e:	5b                   	pop    %ebx
  80261f:	5d                   	pop    %ebp
  802620:	c3                   	ret    

00802621 <devfile_write>:
// Returns:
//	 The number of bytes successfully written.
//	 < 0 on error.
static ssize_t
devfile_write(struct Fd *fd, const void *buf, size_t n)
{
  802621:	55                   	push   %ebp
  802622:	89 e5                	mov    %esp,%ebp
  802624:	83 ec 18             	sub    $0x18,%esp
  802627:	8b 45 10             	mov    0x10(%ebp),%eax
  80262a:	3d f8 0f 00 00       	cmp    $0xff8,%eax
  80262f:	76 05                	jbe    802636 <devfile_write+0x15>
  802631:	b8 f8 0f 00 00       	mov    $0xff8,%eax
	// LAB 5: Your code here
	//panic("devfile_write not implemented");
	
	if (n > (PGSIZE - (sizeof(int) + sizeof(size_t))))
		n = PGSIZE - (sizeof(int) + sizeof(size_t));
	fsipcbuf.write.req_fileid = fd->fd_file.id;
  802636:	8b 55 08             	mov    0x8(%ebp),%edx
  802639:	8b 52 0c             	mov    0xc(%edx),%edx
  80263c:	89 15 00 60 81 00    	mov    %edx,0x816000
	fsipcbuf.write.req_n = n;
  802642:	a3 04 60 81 00       	mov    %eax,0x816004
	memmove (fsipcbuf.write.req_buf, (char*)buf, n);	
  802647:	89 44 24 08          	mov    %eax,0x8(%esp)
  80264b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80264e:	89 44 24 04          	mov    %eax,0x4(%esp)
  802652:	c7 04 24 08 60 81 00 	movl   $0x816008,(%esp)
  802659:	e8 b7 ec ff ff       	call   801315 <memmove>
	return fsipc(FSREQ_WRITE, NULL);	
  80265e:	ba 00 00 00 00       	mov    $0x0,%edx
  802663:	b8 04 00 00 00       	mov    $0x4,%eax
  802668:	e8 af fe ff ff       	call   80251c <fsipc>
}
  80266d:	c9                   	leave  
  80266e:	c3                   	ret    

0080266f <devfile_read>:
// Returns:
// 	The number of bytes successfully read.
// 	< 0 on error.
static ssize_t
devfile_read(struct Fd *fd, void *buf, size_t n)
{
  80266f:	55                   	push   %ebp
  802670:	89 e5                	mov    %esp,%ebp
  802672:	53                   	push   %ebx
  802673:	83 ec 14             	sub    $0x14,%esp
	// system server.
	// LAB 5: Your code here
	
	//panic("devfile_read not implemented");
	int r;
	fsipcbuf.read.req_fileid = fd->fd_file.id;
  802676:	8b 45 08             	mov    0x8(%ebp),%eax
  802679:	8b 40 0c             	mov    0xc(%eax),%eax
  80267c:	a3 00 60 81 00       	mov    %eax,0x816000
	fsipcbuf.read.req_n = n;
  802681:	8b 45 10             	mov    0x10(%ebp),%eax
  802684:	a3 04 60 81 00       	mov    %eax,0x816004
	if ((r = fsipc(FSREQ_READ, (void*)&fsipcbuf)) < 0)
  802689:	ba 00 60 81 00       	mov    $0x816000,%edx
  80268e:	b8 03 00 00 00       	mov    $0x3,%eax
  802693:	e8 84 fe ff ff       	call   80251c <fsipc>
  802698:	89 c3                	mov    %eax,%ebx
  80269a:	85 c0                	test   %eax,%eax
  80269c:	78 17                	js     8026b5 <devfile_read+0x46>
		return r;
	memmove((void*)buf, (void*)fsipcbuf.readRet.ret_buf, r);
  80269e:	89 44 24 08          	mov    %eax,0x8(%esp)
  8026a2:	c7 44 24 04 00 60 81 	movl   $0x816000,0x4(%esp)
  8026a9:	00 
  8026aa:	8b 45 0c             	mov    0xc(%ebp),%eax
  8026ad:	89 04 24             	mov    %eax,(%esp)
  8026b0:	e8 60 ec ff ff       	call   801315 <memmove>
	return r;
}
  8026b5:	89 d8                	mov    %ebx,%eax
  8026b7:	83 c4 14             	add    $0x14,%esp
  8026ba:	5b                   	pop    %ebx
  8026bb:	5d                   	pop    %ebp
  8026bc:	c3                   	ret    

008026bd <remove>:
}

// Delete a file
int
remove(const char *path)
{
  8026bd:	55                   	push   %ebp
  8026be:	89 e5                	mov    %esp,%ebp
  8026c0:	53                   	push   %ebx
  8026c1:	83 ec 14             	sub    $0x14,%esp
  8026c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
	if (strlen(path) >= MAXPATHLEN)
  8026c7:	89 1c 24             	mov    %ebx,(%esp)
  8026ca:	e8 41 ea ff ff       	call   801110 <strlen>
  8026cf:	89 c2                	mov    %eax,%edx
  8026d1:	b8 f4 ff ff ff       	mov    $0xfffffff4,%eax
  8026d6:	81 fa ff 03 00 00    	cmp    $0x3ff,%edx
  8026dc:	7f 1f                	jg     8026fd <remove+0x40>
		return -E_BAD_PATH;
	strcpy(fsipcbuf.remove.req_path, path);
  8026de:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8026e2:	c7 04 24 00 60 81 00 	movl   $0x816000,(%esp)
  8026e9:	e8 6c ea ff ff       	call   80115a <strcpy>
	return fsipc(FSREQ_REMOVE, NULL);
  8026ee:	ba 00 00 00 00       	mov    $0x0,%edx
  8026f3:	b8 07 00 00 00       	mov    $0x7,%eax
  8026f8:	e8 1f fe ff ff       	call   80251c <fsipc>
}
  8026fd:	83 c4 14             	add    $0x14,%esp
  802700:	5b                   	pop    %ebx
  802701:	5d                   	pop    %ebp
  802702:	c3                   	ret    

00802703 <open>:
// 	The file descriptor index on success
// 	-E_BAD_PATH if the path is too long (>= MAXPATHLEN)
// 	< 0 for other errors.
int
open(const char *path, int mode)
{
  802703:	55                   	push   %ebp
  802704:	89 e5                	mov    %esp,%ebp
  802706:	83 ec 28             	sub    $0x28,%esp
  802709:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80270c:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80270f:	8b 75 08             	mov    0x8(%ebp),%esi
	// file descriptor.

	// LAB 5: Your code here.
	// Code added by Swastika / Sandeep
	
	if (strlen(path) >= MAXPATHLEN)
  802712:	89 34 24             	mov    %esi,(%esp)
  802715:	e8 f6 e9 ff ff       	call   801110 <strlen>
  80271a:	bb f4 ff ff ff       	mov    $0xfffffff4,%ebx
  80271f:	3d ff 03 00 00       	cmp    $0x3ff,%eax
  802724:	7f 5e                	jg     802784 <open+0x81>
		return -E_BAD_PATH;
	struct Fd * fd;
	int  r;
	if ((r = fd_alloc(&fd)) < 0)
  802726:	8d 45 f4             	lea    -0xc(%ebp),%eax
  802729:	89 04 24             	mov    %eax,(%esp)
  80272c:	e8 fa f7 ff ff       	call   801f2b <fd_alloc>
  802731:	89 c3                	mov    %eax,%ebx
  802733:	85 c0                	test   %eax,%eax
  802735:	78 4d                	js     802784 <open+0x81>
		return r;
	strcpy (fsipcbuf.open.req_path, path);
  802737:	89 74 24 04          	mov    %esi,0x4(%esp)
  80273b:	c7 04 24 00 60 81 00 	movl   $0x816000,(%esp)
  802742:	e8 13 ea ff ff       	call   80115a <strcpy>
	fsipcbuf.open.req_omode = mode;	
  802747:	8b 45 0c             	mov    0xc(%ebp),%eax
  80274a:	a3 00 64 81 00       	mov    %eax,0x816400
	if ((r = fsipc(FSREQ_OPEN,(void*)fd)) < 0)
  80274f:	8b 55 f4             	mov    -0xc(%ebp),%edx
  802752:	b8 01 00 00 00       	mov    $0x1,%eax
  802757:	e8 c0 fd ff ff       	call   80251c <fsipc>
  80275c:	89 c3                	mov    %eax,%ebx
  80275e:	85 c0                	test   %eax,%eax
  802760:	79 15                	jns    802777 <open+0x74>
	{
		fd_close(fd,0);
  802762:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802769:	00 
  80276a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80276d:	89 04 24             	mov    %eax,(%esp)
  802770:	e8 6a fb ff ff       	call   8022df <fd_close>
		return r; 
  802775:	eb 0d                	jmp    802784 <open+0x81>
	}
	return fd2num(fd);
  802777:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80277a:	89 04 24             	mov    %eax,(%esp)
  80277d:	e8 7e f7 ff ff       	call   801f00 <fd2num>
  802782:	89 c3                	mov    %eax,%ebx
	//panic("open not implemented");
}
  802784:	89 d8                	mov    %ebx,%eax
  802786:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802789:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80278c:	89 ec                	mov    %ebp,%esp
  80278e:	5d                   	pop    %ebp
  80278f:	c3                   	ret    

00802790 <devsock_stat>:
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
}

static int
devsock_stat(struct Fd *fd, struct Stat *stat)
{
  802790:	55                   	push   %ebp
  802791:	89 e5                	mov    %esp,%ebp
  802793:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<sock>");
  802796:	c7 44 24 04 f8 2d 81 	movl   $0x812df8,0x4(%esp)
  80279d:	00 
  80279e:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027a1:	89 04 24             	mov    %eax,(%esp)
  8027a4:	e8 b1 e9 ff ff       	call   80115a <strcpy>
	return 0;
}
  8027a9:	b8 00 00 00 00       	mov    $0x0,%eax
  8027ae:	c9                   	leave  
  8027af:	c3                   	ret    

008027b0 <devsock_close>:
	return nsipc_shutdown(r, how);
}

static int
devsock_close(struct Fd *fd)
{
  8027b0:	55                   	push   %ebp
  8027b1:	89 e5                	mov    %esp,%ebp
  8027b3:	83 ec 18             	sub    $0x18,%esp
	return nsipc_close(fd->fd_sock.sockid);
  8027b6:	8b 45 08             	mov    0x8(%ebp),%eax
  8027b9:	8b 40 0c             	mov    0xc(%eax),%eax
  8027bc:	89 04 24             	mov    %eax,(%esp)
  8027bf:	e8 9e 02 00 00       	call   802a62 <nsipc_close>
}
  8027c4:	c9                   	leave  
  8027c5:	c3                   	ret    

008027c6 <devsock_write>:
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
}

static ssize_t
devsock_write(struct Fd *fd, const void *buf, size_t n)
{
  8027c6:	55                   	push   %ebp
  8027c7:	89 e5                	mov    %esp,%ebp
  8027c9:	83 ec 18             	sub    $0x18,%esp
	return nsipc_send(fd->fd_sock.sockid, buf, n, 0);
  8027cc:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8027d3:	00 
  8027d4:	8b 45 10             	mov    0x10(%ebp),%eax
  8027d7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8027db:	8b 45 0c             	mov    0xc(%ebp),%eax
  8027de:	89 44 24 04          	mov    %eax,0x4(%esp)
  8027e2:	8b 45 08             	mov    0x8(%ebp),%eax
  8027e5:	8b 40 0c             	mov    0xc(%eax),%eax
  8027e8:	89 04 24             	mov    %eax,(%esp)
  8027eb:	e8 ae 02 00 00       	call   802a9e <nsipc_send>
}
  8027f0:	c9                   	leave  
  8027f1:	c3                   	ret    

008027f2 <devsock_read>:
	return nsipc_listen(r, backlog);
}

static ssize_t
devsock_read(struct Fd *fd, void *buf, size_t n)
{
  8027f2:	55                   	push   %ebp
  8027f3:	89 e5                	mov    %esp,%ebp
  8027f5:	83 ec 18             	sub    $0x18,%esp
	return nsipc_recv(fd->fd_sock.sockid, buf, n, 0);
  8027f8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8027ff:	00 
  802800:	8b 45 10             	mov    0x10(%ebp),%eax
  802803:	89 44 24 08          	mov    %eax,0x8(%esp)
  802807:	8b 45 0c             	mov    0xc(%ebp),%eax
  80280a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80280e:	8b 45 08             	mov    0x8(%ebp),%eax
  802811:	8b 40 0c             	mov    0xc(%eax),%eax
  802814:	89 04 24             	mov    %eax,(%esp)
  802817:	e8 f5 02 00 00       	call   802b11 <nsipc_recv>
}
  80281c:	c9                   	leave  
  80281d:	c3                   	ret    

0080281e <alloc_sockfd>:
	return sfd->fd_sock.sockid;
}

static int
alloc_sockfd(int sockid)
{
  80281e:	55                   	push   %ebp
  80281f:	89 e5                	mov    %esp,%ebp
  802821:	56                   	push   %esi
  802822:	53                   	push   %ebx
  802823:	83 ec 20             	sub    $0x20,%esp
  802826:	89 c6                	mov    %eax,%esi
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  802828:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80282b:	89 04 24             	mov    %eax,(%esp)
  80282e:	e8 f8 f6 ff ff       	call   801f2b <fd_alloc>
  802833:	89 c3                	mov    %eax,%ebx
  802835:	85 c0                	test   %eax,%eax
  802837:	78 21                	js     80285a <alloc_sockfd+0x3c>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U)) < 0) {
  802839:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  802840:	00 
  802841:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802844:	89 44 24 04          	mov    %eax,0x4(%esp)
  802848:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80284f:	e8 f7 f0 ff ff       	call   80194b <sys_page_alloc>
  802854:	89 c3                	mov    %eax,%ebx
alloc_sockfd(int sockid)
{
	struct Fd *sfd;
	int r;

	if ((r = fd_alloc(&sfd)) < 0
  802856:	85 c0                	test   %eax,%eax
  802858:	79 0a                	jns    802864 <alloc_sockfd+0x46>
	    || (r = sys_page_alloc(0, sfd, PTE_P|PTE_W|PTE_U)) < 0) {
		nsipc_close(sockid);
  80285a:	89 34 24             	mov    %esi,(%esp)
  80285d:	e8 00 02 00 00       	call   802a62 <nsipc_close>
		return r;
  802862:	eb 28                	jmp    80288c <alloc_sockfd+0x6e>
	}

	sfd->fd_dev_id = devsock.dev_id;
  802864:	8b 15 20 90 81 00    	mov    0x819020,%edx
  80286a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80286d:	89 10                	mov    %edx,(%eax)
	sfd->fd_omode = O_RDWR;
  80286f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802872:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	sfd->fd_sock.sockid = sockid;
  802879:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80287c:	89 70 0c             	mov    %esi,0xc(%eax)
	return fd2num(sfd);
  80287f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  802882:	89 04 24             	mov    %eax,(%esp)
  802885:	e8 76 f6 ff ff       	call   801f00 <fd2num>
  80288a:	89 c3                	mov    %eax,%ebx
}
  80288c:	89 d8                	mov    %ebx,%eax
  80288e:	83 c4 20             	add    $0x20,%esp
  802891:	5b                   	pop    %ebx
  802892:	5e                   	pop    %esi
  802893:	5d                   	pop    %ebp
  802894:	c3                   	ret    

00802895 <socket>:
	return 0;
}

int
socket(int domain, int type, int protocol)
{
  802895:	55                   	push   %ebp
  802896:	89 e5                	mov    %esp,%ebp
  802898:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = nsipc_socket(domain, type, protocol)) < 0)
  80289b:	8b 45 10             	mov    0x10(%ebp),%eax
  80289e:	89 44 24 08          	mov    %eax,0x8(%esp)
  8028a2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8028a5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8028a9:	8b 45 08             	mov    0x8(%ebp),%eax
  8028ac:	89 04 24             	mov    %eax,(%esp)
  8028af:	e8 62 01 00 00       	call   802a16 <nsipc_socket>
  8028b4:	85 c0                	test   %eax,%eax
  8028b6:	78 05                	js     8028bd <socket+0x28>
		return r;
	return alloc_sockfd(r);
  8028b8:	e8 61 ff ff ff       	call   80281e <alloc_sockfd>
}
  8028bd:	c9                   	leave  
  8028be:	66 90                	xchg   %ax,%ax
  8028c0:	c3                   	ret    

008028c1 <fd2sockid>:
	.dev_stat =	devsock_stat,
};

static int
fd2sockid(int fd)
{
  8028c1:	55                   	push   %ebp
  8028c2:	89 e5                	mov    %esp,%ebp
  8028c4:	83 ec 28             	sub    $0x28,%esp
	struct Fd *sfd;
	int r;

	if ((r = fd_lookup(fd, &sfd)) < 0)
  8028c7:	8d 55 f4             	lea    -0xc(%ebp),%edx
  8028ca:	89 54 24 04          	mov    %edx,0x4(%esp)
  8028ce:	89 04 24             	mov    %eax,(%esp)
  8028d1:	e8 c7 f6 ff ff       	call   801f9d <fd_lookup>
  8028d6:	85 c0                	test   %eax,%eax
  8028d8:	78 15                	js     8028ef <fd2sockid+0x2e>
		return r;
	if (sfd->fd_dev_id != devsock.dev_id)
  8028da:	8b 55 f4             	mov    -0xc(%ebp),%edx
  8028dd:	8b 0a                	mov    (%edx),%ecx
  8028df:	b8 f1 ff ff ff       	mov    $0xfffffff1,%eax
  8028e4:	3b 0d 20 90 81 00    	cmp    0x819020,%ecx
  8028ea:	75 03                	jne    8028ef <fd2sockid+0x2e>
		return -E_NOT_SUPP;
	return sfd->fd_sock.sockid;
  8028ec:	8b 42 0c             	mov    0xc(%edx),%eax
}
  8028ef:	c9                   	leave  
  8028f0:	c3                   	ret    

008028f1 <listen>:
	return nsipc_connect(r, name, namelen);
}

int
listen(int s, int backlog)
{
  8028f1:	55                   	push   %ebp
  8028f2:	89 e5                	mov    %esp,%ebp
  8028f4:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  8028f7:	8b 45 08             	mov    0x8(%ebp),%eax
  8028fa:	e8 c2 ff ff ff       	call   8028c1 <fd2sockid>
  8028ff:	85 c0                	test   %eax,%eax
  802901:	78 0f                	js     802912 <listen+0x21>
		return r;
	return nsipc_listen(r, backlog);
  802903:	8b 55 0c             	mov    0xc(%ebp),%edx
  802906:	89 54 24 04          	mov    %edx,0x4(%esp)
  80290a:	89 04 24             	mov    %eax,(%esp)
  80290d:	e8 2e 01 00 00       	call   802a40 <nsipc_listen>
}
  802912:	c9                   	leave  
  802913:	c3                   	ret    

00802914 <connect>:
	return nsipc_close(fd->fd_sock.sockid);
}

int
connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802914:	55                   	push   %ebp
  802915:	89 e5                	mov    %esp,%ebp
  802917:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  80291a:	8b 45 08             	mov    0x8(%ebp),%eax
  80291d:	e8 9f ff ff ff       	call   8028c1 <fd2sockid>
  802922:	85 c0                	test   %eax,%eax
  802924:	78 16                	js     80293c <connect+0x28>
		return r;
	return nsipc_connect(r, name, namelen);
  802926:	8b 55 10             	mov    0x10(%ebp),%edx
  802929:	89 54 24 08          	mov    %edx,0x8(%esp)
  80292d:	8b 55 0c             	mov    0xc(%ebp),%edx
  802930:	89 54 24 04          	mov    %edx,0x4(%esp)
  802934:	89 04 24             	mov    %eax,(%esp)
  802937:	e8 55 02 00 00       	call   802b91 <nsipc_connect>
}
  80293c:	c9                   	leave  
  80293d:	c3                   	ret    

0080293e <shutdown>:
	return nsipc_bind(r, name, namelen);
}

int
shutdown(int s, int how)
{
  80293e:	55                   	push   %ebp
  80293f:	89 e5                	mov    %esp,%ebp
  802941:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802944:	8b 45 08             	mov    0x8(%ebp),%eax
  802947:	e8 75 ff ff ff       	call   8028c1 <fd2sockid>
  80294c:	85 c0                	test   %eax,%eax
  80294e:	78 0f                	js     80295f <shutdown+0x21>
		return r;
	return nsipc_shutdown(r, how);
  802950:	8b 55 0c             	mov    0xc(%ebp),%edx
  802953:	89 54 24 04          	mov    %edx,0x4(%esp)
  802957:	89 04 24             	mov    %eax,(%esp)
  80295a:	e8 1d 01 00 00       	call   802a7c <nsipc_shutdown>
}
  80295f:	c9                   	leave  
  802960:	c3                   	ret    

00802961 <bind>:
	return alloc_sockfd(r);
}

int
bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802961:	55                   	push   %ebp
  802962:	89 e5                	mov    %esp,%ebp
  802964:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802967:	8b 45 08             	mov    0x8(%ebp),%eax
  80296a:	e8 52 ff ff ff       	call   8028c1 <fd2sockid>
  80296f:	85 c0                	test   %eax,%eax
  802971:	78 16                	js     802989 <bind+0x28>
		return r;
	return nsipc_bind(r, name, namelen);
  802973:	8b 55 10             	mov    0x10(%ebp),%edx
  802976:	89 54 24 08          	mov    %edx,0x8(%esp)
  80297a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80297d:	89 54 24 04          	mov    %edx,0x4(%esp)
  802981:	89 04 24             	mov    %eax,(%esp)
  802984:	e8 47 02 00 00       	call   802bd0 <nsipc_bind>
}
  802989:	c9                   	leave  
  80298a:	c3                   	ret    

0080298b <accept>:
	return fd2num(sfd);
}

int
accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  80298b:	55                   	push   %ebp
  80298c:	89 e5                	mov    %esp,%ebp
  80298e:	83 ec 18             	sub    $0x18,%esp
	int r;
	if ((r = fd2sockid(s)) < 0)
  802991:	8b 45 08             	mov    0x8(%ebp),%eax
  802994:	e8 28 ff ff ff       	call   8028c1 <fd2sockid>
  802999:	85 c0                	test   %eax,%eax
  80299b:	78 1f                	js     8029bc <accept+0x31>
		return r;
	if ((r = nsipc_accept(r, addr, addrlen)) < 0)
  80299d:	8b 55 10             	mov    0x10(%ebp),%edx
  8029a0:	89 54 24 08          	mov    %edx,0x8(%esp)
  8029a4:	8b 55 0c             	mov    0xc(%ebp),%edx
  8029a7:	89 54 24 04          	mov    %edx,0x4(%esp)
  8029ab:	89 04 24             	mov    %eax,(%esp)
  8029ae:	e8 5c 02 00 00       	call   802c0f <nsipc_accept>
  8029b3:	85 c0                	test   %eax,%eax
  8029b5:	78 05                	js     8029bc <accept+0x31>
		return r;
	return alloc_sockfd(r);
  8029b7:	e8 62 fe ff ff       	call   80281e <alloc_sockfd>
}
  8029bc:	c9                   	leave  
  8029bd:	8d 76 00             	lea    0x0(%esi),%esi
  8029c0:	c3                   	ret    
	...

008029d0 <nsipc>:
// may be written back to nsipcbuf.
// type: request code, passed as the simple integer IPC value.
// Returns 0 if successful, < 0 on failure.
static int
nsipc(unsigned type)
{
  8029d0:	55                   	push   %ebp
  8029d1:	89 e5                	mov    %esp,%ebp
  8029d3:	83 ec 18             	sub    $0x18,%esp
	if (debug)
		cprintf("[%08x] nsipc %d\n", env->env_id, type);

	ipc_send(envs[2].env_id, type, &nsipcbuf, PTE_P|PTE_W|PTE_U);
  8029d6:	8b 15 44 01 c0 ee    	mov    0xeec00144,%edx
  8029dc:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  8029e3:	00 
  8029e4:	c7 44 24 08 00 80 81 	movl   $0x818000,0x8(%esp)
  8029eb:	00 
  8029ec:	89 44 24 04          	mov    %eax,0x4(%esp)
  8029f0:	89 14 24             	mov    %edx,(%esp)
  8029f3:	e8 38 f4 ff ff       	call   801e30 <ipc_send>
	return ipc_recv(NULL, NULL, NULL);
  8029f8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8029ff:	00 
  802a00:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  802a07:	00 
  802a08:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802a0f:	e8 82 f4 ff ff       	call   801e96 <ipc_recv>
}
  802a14:	c9                   	leave  
  802a15:	c3                   	ret    

00802a16 <nsipc_socket>:
	return nsipc(NSREQ_SEND);
}

int
nsipc_socket(int domain, int type, int protocol)
{
  802a16:	55                   	push   %ebp
  802a17:	89 e5                	mov    %esp,%ebp
  802a19:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.socket.req_domain = domain;
  802a1c:	8b 45 08             	mov    0x8(%ebp),%eax
  802a1f:	a3 00 80 81 00       	mov    %eax,0x818000
	nsipcbuf.socket.req_type = type;
  802a24:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a27:	a3 04 80 81 00       	mov    %eax,0x818004
	nsipcbuf.socket.req_protocol = protocol;
  802a2c:	8b 45 10             	mov    0x10(%ebp),%eax
  802a2f:	a3 08 80 81 00       	mov    %eax,0x818008
	return nsipc(NSREQ_SOCKET);
  802a34:	b8 09 00 00 00       	mov    $0x9,%eax
  802a39:	e8 92 ff ff ff       	call   8029d0 <nsipc>
}
  802a3e:	c9                   	leave  
  802a3f:	c3                   	ret    

00802a40 <nsipc_listen>:
	return nsipc(NSREQ_CONNECT);
}

int
nsipc_listen(int s, int backlog)
{
  802a40:	55                   	push   %ebp
  802a41:	89 e5                	mov    %esp,%ebp
  802a43:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.listen.req_s = s;
  802a46:	8b 45 08             	mov    0x8(%ebp),%eax
  802a49:	a3 00 80 81 00       	mov    %eax,0x818000
	nsipcbuf.listen.req_backlog = backlog;
  802a4e:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a51:	a3 04 80 81 00       	mov    %eax,0x818004
	return nsipc(NSREQ_LISTEN);
  802a56:	b8 06 00 00 00       	mov    $0x6,%eax
  802a5b:	e8 70 ff ff ff       	call   8029d0 <nsipc>
}
  802a60:	c9                   	leave  
  802a61:	c3                   	ret    

00802a62 <nsipc_close>:
	return nsipc(NSREQ_SHUTDOWN);
}

int
nsipc_close(int s)
{
  802a62:	55                   	push   %ebp
  802a63:	89 e5                	mov    %esp,%ebp
  802a65:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.close.req_s = s;
  802a68:	8b 45 08             	mov    0x8(%ebp),%eax
  802a6b:	a3 00 80 81 00       	mov    %eax,0x818000
	return nsipc(NSREQ_CLOSE);
  802a70:	b8 04 00 00 00       	mov    $0x4,%eax
  802a75:	e8 56 ff ff ff       	call   8029d0 <nsipc>
}
  802a7a:	c9                   	leave  
  802a7b:	c3                   	ret    

00802a7c <nsipc_shutdown>:
	return nsipc(NSREQ_BIND);
}

int
nsipc_shutdown(int s, int how)
{
  802a7c:	55                   	push   %ebp
  802a7d:	89 e5                	mov    %esp,%ebp
  802a7f:	83 ec 08             	sub    $0x8,%esp
	nsipcbuf.shutdown.req_s = s;
  802a82:	8b 45 08             	mov    0x8(%ebp),%eax
  802a85:	a3 00 80 81 00       	mov    %eax,0x818000
	nsipcbuf.shutdown.req_how = how;
  802a8a:	8b 45 0c             	mov    0xc(%ebp),%eax
  802a8d:	a3 04 80 81 00       	mov    %eax,0x818004
	return nsipc(NSREQ_SHUTDOWN);
  802a92:	b8 03 00 00 00       	mov    $0x3,%eax
  802a97:	e8 34 ff ff ff       	call   8029d0 <nsipc>
}
  802a9c:	c9                   	leave  
  802a9d:	c3                   	ret    

00802a9e <nsipc_send>:
	return r;
}

int
nsipc_send(int s, const void *buf, int size, unsigned int flags)
{
  802a9e:	55                   	push   %ebp
  802a9f:	89 e5                	mov    %esp,%ebp
  802aa1:	53                   	push   %ebx
  802aa2:	83 ec 14             	sub    $0x14,%esp
  802aa5:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.send.req_s = s;
  802aa8:	8b 45 08             	mov    0x8(%ebp),%eax
  802aab:	a3 00 80 81 00       	mov    %eax,0x818000
	assert(size < 1600);
  802ab0:	81 fb 3f 06 00 00    	cmp    $0x63f,%ebx
  802ab6:	7e 24                	jle    802adc <nsipc_send+0x3e>
  802ab8:	c7 44 24 0c 04 2e 81 	movl   $0x812e04,0xc(%esp)
  802abf:	00 
  802ac0:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  802ac7:	00 
  802ac8:	c7 44 24 04 66 00 00 	movl   $0x66,0x4(%esp)
  802acf:	00 
  802ad0:	c7 04 24 25 2e 81 00 	movl   $0x812e25,(%esp)
  802ad7:	e8 f8 de ff ff       	call   8009d4 <_panic>
	memmove(&nsipcbuf.send.req_buf, buf, size);
  802adc:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802ae0:	8b 45 0c             	mov    0xc(%ebp),%eax
  802ae3:	89 44 24 04          	mov    %eax,0x4(%esp)
  802ae7:	c7 04 24 0c 80 81 00 	movl   $0x81800c,(%esp)
  802aee:	e8 22 e8 ff ff       	call   801315 <memmove>
	nsipcbuf.send.req_size = size;
  802af3:	89 1d 04 80 81 00    	mov    %ebx,0x818004
	nsipcbuf.send.req_flags = flags;
  802af9:	8b 45 14             	mov    0x14(%ebp),%eax
  802afc:	a3 08 80 81 00       	mov    %eax,0x818008
	return nsipc(NSREQ_SEND);
  802b01:	b8 08 00 00 00       	mov    $0x8,%eax
  802b06:	e8 c5 fe ff ff       	call   8029d0 <nsipc>
}
  802b0b:	83 c4 14             	add    $0x14,%esp
  802b0e:	5b                   	pop    %ebx
  802b0f:	5d                   	pop    %ebp
  802b10:	c3                   	ret    

00802b11 <nsipc_recv>:
	return nsipc(NSREQ_LISTEN);
}

int
nsipc_recv(int s, void *mem, int len, unsigned int flags)
{
  802b11:	55                   	push   %ebp
  802b12:	89 e5                	mov    %esp,%ebp
  802b14:	56                   	push   %esi
  802b15:	53                   	push   %ebx
  802b16:	83 ec 10             	sub    $0x10,%esp
  802b19:	8b 75 10             	mov    0x10(%ebp),%esi
	int r;

	nsipcbuf.recv.req_s = s;
  802b1c:	8b 45 08             	mov    0x8(%ebp),%eax
  802b1f:	a3 00 80 81 00       	mov    %eax,0x818000
	nsipcbuf.recv.req_len = len;
  802b24:	89 35 04 80 81 00    	mov    %esi,0x818004
	nsipcbuf.recv.req_flags = flags;
  802b2a:	8b 45 14             	mov    0x14(%ebp),%eax
  802b2d:	a3 08 80 81 00       	mov    %eax,0x818008

	if ((r = nsipc(NSREQ_RECV)) >= 0) {
  802b32:	b8 07 00 00 00       	mov    $0x7,%eax
  802b37:	e8 94 fe ff ff       	call   8029d0 <nsipc>
  802b3c:	89 c3                	mov    %eax,%ebx
  802b3e:	85 c0                	test   %eax,%eax
  802b40:	78 46                	js     802b88 <nsipc_recv+0x77>
		assert(r < 1600 && r <= len);
  802b42:	3d 3f 06 00 00       	cmp    $0x63f,%eax
  802b47:	7f 04                	jg     802b4d <nsipc_recv+0x3c>
  802b49:	39 c6                	cmp    %eax,%esi
  802b4b:	7d 24                	jge    802b71 <nsipc_recv+0x60>
  802b4d:	c7 44 24 0c 31 2e 81 	movl   $0x812e31,0xc(%esp)
  802b54:	00 
  802b55:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  802b5c:	00 
  802b5d:	c7 44 24 04 5b 00 00 	movl   $0x5b,0x4(%esp)
  802b64:	00 
  802b65:	c7 04 24 25 2e 81 00 	movl   $0x812e25,(%esp)
  802b6c:	e8 63 de ff ff       	call   8009d4 <_panic>
		memmove(mem, nsipcbuf.recvRet.ret_buf, r);
  802b71:	89 44 24 08          	mov    %eax,0x8(%esp)
  802b75:	c7 44 24 04 00 80 81 	movl   $0x818000,0x4(%esp)
  802b7c:	00 
  802b7d:	8b 45 0c             	mov    0xc(%ebp),%eax
  802b80:	89 04 24             	mov    %eax,(%esp)
  802b83:	e8 8d e7 ff ff       	call   801315 <memmove>
	}

	return r;
}
  802b88:	89 d8                	mov    %ebx,%eax
  802b8a:	83 c4 10             	add    $0x10,%esp
  802b8d:	5b                   	pop    %ebx
  802b8e:	5e                   	pop    %esi
  802b8f:	5d                   	pop    %ebp
  802b90:	c3                   	ret    

00802b91 <nsipc_connect>:
	return nsipc(NSREQ_CLOSE);
}

int
nsipc_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  802b91:	55                   	push   %ebp
  802b92:	89 e5                	mov    %esp,%ebp
  802b94:	53                   	push   %ebx
  802b95:	83 ec 14             	sub    $0x14,%esp
  802b98:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.connect.req_s = s;
  802b9b:	8b 45 08             	mov    0x8(%ebp),%eax
  802b9e:	a3 00 80 81 00       	mov    %eax,0x818000
	memmove(&nsipcbuf.connect.req_name, name, namelen);
  802ba3:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802ba7:	8b 45 0c             	mov    0xc(%ebp),%eax
  802baa:	89 44 24 04          	mov    %eax,0x4(%esp)
  802bae:	c7 04 24 04 80 81 00 	movl   $0x818004,(%esp)
  802bb5:	e8 5b e7 ff ff       	call   801315 <memmove>
	nsipcbuf.connect.req_namelen = namelen;
  802bba:	89 1d 14 80 81 00    	mov    %ebx,0x818014
	return nsipc(NSREQ_CONNECT);
  802bc0:	b8 05 00 00 00       	mov    $0x5,%eax
  802bc5:	e8 06 fe ff ff       	call   8029d0 <nsipc>
}
  802bca:	83 c4 14             	add    $0x14,%esp
  802bcd:	5b                   	pop    %ebx
  802bce:	5d                   	pop    %ebp
  802bcf:	c3                   	ret    

00802bd0 <nsipc_bind>:
	return r;
}

int
nsipc_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  802bd0:	55                   	push   %ebp
  802bd1:	89 e5                	mov    %esp,%ebp
  802bd3:	53                   	push   %ebx
  802bd4:	83 ec 14             	sub    $0x14,%esp
  802bd7:	8b 5d 10             	mov    0x10(%ebp),%ebx
	nsipcbuf.bind.req_s = s;
  802bda:	8b 45 08             	mov    0x8(%ebp),%eax
  802bdd:	a3 00 80 81 00       	mov    %eax,0x818000
	memmove(&nsipcbuf.bind.req_name, name, namelen);
  802be2:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  802be6:	8b 45 0c             	mov    0xc(%ebp),%eax
  802be9:	89 44 24 04          	mov    %eax,0x4(%esp)
  802bed:	c7 04 24 04 80 81 00 	movl   $0x818004,(%esp)
  802bf4:	e8 1c e7 ff ff       	call   801315 <memmove>
	nsipcbuf.bind.req_namelen = namelen;
  802bf9:	89 1d 14 80 81 00    	mov    %ebx,0x818014
	return nsipc(NSREQ_BIND);
  802bff:	b8 02 00 00 00       	mov    $0x2,%eax
  802c04:	e8 c7 fd ff ff       	call   8029d0 <nsipc>
}
  802c09:	83 c4 14             	add    $0x14,%esp
  802c0c:	5b                   	pop    %ebx
  802c0d:	5d                   	pop    %ebp
  802c0e:	c3                   	ret    

00802c0f <nsipc_accept>:
	return ipc_recv(NULL, NULL, NULL);
}

int
nsipc_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  802c0f:	55                   	push   %ebp
  802c10:	89 e5                	mov    %esp,%ebp
  802c12:	83 ec 18             	sub    $0x18,%esp
  802c15:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802c18:	89 75 fc             	mov    %esi,-0x4(%ebp)
	int r;
	
	nsipcbuf.accept.req_s = s;
  802c1b:	8b 45 08             	mov    0x8(%ebp),%eax
  802c1e:	a3 00 80 81 00       	mov    %eax,0x818000
	if ((r = nsipc(NSREQ_ACCEPT)) >= 0) {
  802c23:	b8 01 00 00 00       	mov    $0x1,%eax
  802c28:	e8 a3 fd ff ff       	call   8029d0 <nsipc>
  802c2d:	89 c3                	mov    %eax,%ebx
  802c2f:	85 c0                	test   %eax,%eax
  802c31:	78 25                	js     802c58 <nsipc_accept+0x49>
		struct Nsret_accept *ret = &nsipcbuf.acceptRet;
		memmove(addr, &ret->ret_addr, ret->ret_addrlen);
  802c33:	be 10 80 81 00       	mov    $0x818010,%esi
  802c38:	8b 06                	mov    (%esi),%eax
  802c3a:	89 44 24 08          	mov    %eax,0x8(%esp)
  802c3e:	c7 44 24 04 00 80 81 	movl   $0x818000,0x4(%esp)
  802c45:	00 
  802c46:	8b 45 0c             	mov    0xc(%ebp),%eax
  802c49:	89 04 24             	mov    %eax,(%esp)
  802c4c:	e8 c4 e6 ff ff       	call   801315 <memmove>
		*addrlen = ret->ret_addrlen;
  802c51:	8b 16                	mov    (%esi),%edx
  802c53:	8b 45 10             	mov    0x10(%ebp),%eax
  802c56:	89 10                	mov    %edx,(%eax)
	}
	return r;
}
  802c58:	89 d8                	mov    %ebx,%eax
  802c5a:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802c5d:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802c60:	89 ec                	mov    %ebp,%esp
  802c62:	5d                   	pop    %ebp
  802c63:	c3                   	ret    
	...

00802c70 <free>:
	return v;
}

void
free(void *v)
{
  802c70:	55                   	push   %ebp
  802c71:	89 e5                	mov    %esp,%ebp
  802c73:	56                   	push   %esi
  802c74:	53                   	push   %ebx
  802c75:	83 ec 10             	sub    $0x10,%esp
  802c78:	8b 5d 08             	mov    0x8(%ebp),%ebx
	uint8_t *c;
	uint32_t *ref;

	if (v == 0)
  802c7b:	85 db                	test   %ebx,%ebx
  802c7d:	0f 84 b9 00 00 00    	je     802d3c <free+0xcc>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);
  802c83:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802c89:	76 08                	jbe    802c93 <free+0x23>
  802c8b:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802c91:	76 24                	jbe    802cb7 <free+0x47>
  802c93:	c7 44 24 0c 48 2e 81 	movl   $0x812e48,0xc(%esp)
  802c9a:	00 
  802c9b:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  802ca2:	00 
  802ca3:	c7 44 24 04 7a 00 00 	movl   $0x7a,0x4(%esp)
  802caa:	00 
  802cab:	c7 04 24 76 2e 81 00 	movl   $0x812e76,(%esp)
  802cb2:	e8 1d dd ff ff       	call   8009d4 <_panic>

	c = ROUNDDOWN(v, PGSIZE);
  802cb7:	81 e3 00 f0 ff ff    	and    $0xfffff000,%ebx

	while (vpt[VPN(c)] & PTE_CONTINUED) {
  802cbd:	be 00 00 40 ef       	mov    $0xef400000,%esi
  802cc2:	eb 4a                	jmp    802d0e <free+0x9e>
		sys_page_unmap(0, c);
  802cc4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802cc8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802ccf:	e8 bb eb ff ff       	call   80188f <sys_page_unmap>
		c += PGSIZE;
  802cd4:	81 c3 00 10 00 00    	add    $0x1000,%ebx
		assert(mbegin <= c && c < mend);
  802cda:	81 fb ff ff ff 07    	cmp    $0x7ffffff,%ebx
  802ce0:	76 08                	jbe    802cea <free+0x7a>
  802ce2:	81 fb ff ff ff 0f    	cmp    $0xfffffff,%ebx
  802ce8:	76 24                	jbe    802d0e <free+0x9e>
  802cea:	c7 44 24 0c 83 2e 81 	movl   $0x812e83,0xc(%esp)
  802cf1:	00 
  802cf2:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  802cf9:	00 
  802cfa:	c7 44 24 04 81 00 00 	movl   $0x81,0x4(%esp)
  802d01:	00 
  802d02:	c7 04 24 76 2e 81 00 	movl   $0x812e76,(%esp)
  802d09:	e8 c6 dc ff ff       	call   8009d4 <_panic>
		return;
	assert(mbegin <= (uint8_t*) v && (uint8_t*) v < mend);

	c = ROUNDDOWN(v, PGSIZE);

	while (vpt[VPN(c)] & PTE_CONTINUED) {
  802d0e:	89 d8                	mov    %ebx,%eax
  802d10:	c1 e8 0c             	shr    $0xc,%eax
  802d13:	8b 04 86             	mov    (%esi,%eax,4),%eax
  802d16:	f6 c4 04             	test   $0x4,%ah
  802d19:	75 a9                	jne    802cc4 <free+0x54>

	/*
	 * c is just a piece of this page, so dec the ref count
	 * and maybe free the page.
	 */
	ref = (uint32_t*) (c + PGSIZE - 4);
  802d1b:	8d 93 fc 0f 00 00    	lea    0xffc(%ebx),%edx
	if (--(*ref) == 0)
  802d21:	8b 02                	mov    (%edx),%eax
  802d23:	83 e8 01             	sub    $0x1,%eax
  802d26:	89 02                	mov    %eax,(%edx)
  802d28:	85 c0                	test   %eax,%eax
  802d2a:	75 10                	jne    802d3c <free+0xcc>
		sys_page_unmap(0, c);	
  802d2c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802d30:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802d37:	e8 53 eb ff ff       	call   80188f <sys_page_unmap>
}
  802d3c:	83 c4 10             	add    $0x10,%esp
  802d3f:	5b                   	pop    %ebx
  802d40:	5e                   	pop    %esi
  802d41:	5d                   	pop    %ebp
  802d42:	c3                   	ret    

00802d43 <malloc>:
	return 1;
}

void*
malloc(size_t n)
{
  802d43:	55                   	push   %ebp
  802d44:	89 e5                	mov    %esp,%ebp
  802d46:	57                   	push   %edi
  802d47:	56                   	push   %esi
  802d48:	53                   	push   %ebx
  802d49:	83 ec 3c             	sub    $0x3c,%esp
	int i, cont;
	int nwrap;
	uint32_t *ref;
	void *v;

	if (mptr == 0)
  802d4c:	83 3d 10 94 81 00 00 	cmpl   $0x0,0x819410
  802d53:	75 0a                	jne    802d5f <malloc+0x1c>
		mptr = mbegin;
  802d55:	c7 05 10 94 81 00 00 	movl   $0x8000000,0x819410
  802d5c:	00 00 08 

	n = ROUNDUP(n, 4);
  802d5f:	8b 45 08             	mov    0x8(%ebp),%eax
  802d62:	83 c0 03             	add    $0x3,%eax
  802d65:	83 e0 fc             	and    $0xfffffffc,%eax
  802d68:	89 45 d8             	mov    %eax,-0x28(%ebp)

	if (n >= MAXMALLOC)
  802d6b:	3d ff ff 0f 00       	cmp    $0xfffff,%eax
  802d70:	0f 87 97 01 00 00    	ja     802f0d <malloc+0x1ca>
		return 0;

	if ((uintptr_t) mptr % PGSIZE){
  802d76:	a1 10 94 81 00       	mov    0x819410,%eax
  802d7b:	89 c2                	mov    %eax,%edx
  802d7d:	a9 ff 0f 00 00       	test   $0xfff,%eax
  802d82:	74 4d                	je     802dd1 <malloc+0x8e>
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
  802d84:	89 c3                	mov    %eax,%ebx
  802d86:	c1 eb 0c             	shr    $0xc,%ebx
  802d89:	8b 75 d8             	mov    -0x28(%ebp),%esi
  802d8c:	8d 4c 30 03          	lea    0x3(%eax,%esi,1),%ecx
  802d90:	c1 e9 0c             	shr    $0xc,%ecx
  802d93:	39 cb                	cmp    %ecx,%ebx
  802d95:	75 1e                	jne    802db5 <malloc+0x72>
		/*
		 * we're in the middle of a partially
		 * allocated page - can we add this chunk?
		 * the +4 below is for the ref count.
		 */
		ref = (uint32_t*) (ROUNDUP(mptr, PGSIZE) - 4);
  802d97:	81 c2 ff 0f 00 00    	add    $0xfff,%edx
  802d9d:	81 e2 00 f0 ff ff    	and    $0xfffff000,%edx
		if ((uintptr_t) mptr / PGSIZE == (uintptr_t) (mptr + n - 1 + 4) / PGSIZE) {
			(*ref)++;
  802da3:	83 42 fc 01          	addl   $0x1,-0x4(%edx)
			v = mptr;
			mptr += n;
  802da7:	8d 14 30             	lea    (%eax,%esi,1),%edx
  802daa:	89 15 10 94 81 00    	mov    %edx,0x819410
			return v;
  802db0:	e9 5d 01 00 00       	jmp    802f12 <malloc+0x1cf>
		}
		/*
		 * stop working on this page and move on.
		 */
		free(mptr);	/* drop reference to this page */
  802db5:	89 04 24             	mov    %eax,(%esp)
  802db8:	e8 b3 fe ff ff       	call   802c70 <free>
		mptr = ROUNDDOWN(mptr + PGSIZE, PGSIZE);
  802dbd:	a1 10 94 81 00       	mov    0x819410,%eax
  802dc2:	05 00 10 00 00       	add    $0x1000,%eax
  802dc7:	25 00 f0 ff ff       	and    $0xfffff000,%eax
  802dcc:	a3 10 94 81 00       	mov    %eax,0x819410
  802dd1:	8b 3d 10 94 81 00    	mov    0x819410,%edi
  802dd7:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802dde:	8b 45 d8             	mov    -0x28(%ebp),%eax
  802de1:	83 c0 04             	add    $0x4,%eax
  802de4:	89 45 dc             	mov    %eax,-0x24(%ebp)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
  802de7:	bb 00 d0 7b ef       	mov    $0xef7bd000,%ebx
  802dec:	be 00 00 40 ef       	mov    $0xef400000,%esi
			return 0;
	return 1;
}

void*
malloc(size_t n)
  802df1:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  802df4:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  802df7:	8d 0c 0f             	lea    (%edi,%ecx,1),%ecx
  802dfa:	89 7d e4             	mov    %edi,-0x1c(%ebp)
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802dfd:	39 cf                	cmp    %ecx,%edi
  802dff:	0f 83 d7 00 00 00    	jae    802edc <malloc+0x199>
		if (va >= (uintptr_t) mend
  802e05:	89 f8                	mov    %edi,%eax
  802e07:	81 ff ff ff ff 0f    	cmp    $0xfffffff,%edi
  802e0d:	76 09                	jbe    802e18 <malloc+0xd5>
  802e0f:	eb 38                	jmp    802e49 <malloc+0x106>
  802e11:	3d ff ff ff 0f       	cmp    $0xfffffff,%eax
  802e16:	77 31                	ja     802e49 <malloc+0x106>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
  802e18:	89 c2                	mov    %eax,%edx
  802e1a:	c1 ea 16             	shr    $0x16,%edx
  802e1d:	8b 14 93             	mov    (%ebx,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e20:	f6 c2 01             	test   $0x1,%dl
  802e23:	74 0d                	je     802e32 <malloc+0xef>
		    || ((vpd[PDX(va)] & PTE_P) && (vpt[VPN(va)] & PTE_P)))
  802e25:	89 c2                	mov    %eax,%edx
  802e27:	c1 ea 0c             	shr    $0xc,%edx
  802e2a:	8b 14 96             	mov    (%esi,%edx,4),%edx
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
		if (va >= (uintptr_t) mend
  802e2d:	f6 c2 01             	test   $0x1,%dl
  802e30:	75 17                	jne    802e49 <malloc+0x106>
static int
isfree(void *v, size_t n)
{
	uintptr_t va, end_va = (uintptr_t) v + n;

	for (va = (uintptr_t) v; va < end_va; va += PGSIZE)
  802e32:	05 00 10 00 00       	add    $0x1000,%eax
  802e37:	39 c8                	cmp    %ecx,%eax
  802e39:	72 d6                	jb     802e11 <malloc+0xce>
  802e3b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  802e3e:	89 35 10 94 81 00    	mov    %esi,0x819410
  802e44:	e9 9b 00 00 00       	jmp    802ee4 <malloc+0x1a1>
  802e49:	81 c7 00 10 00 00    	add    $0x1000,%edi
  802e4f:	81 c1 00 10 00 00    	add    $0x1000,%ecx
	nwrap = 0;
	while (1) {
		if (isfree(mptr, n + 4))
			break;
		mptr += PGSIZE;
		if (mptr == mend) {
  802e55:	81 ff 00 00 00 10    	cmp    $0x10000000,%edi
  802e5b:	75 9d                	jne    802dfa <malloc+0xb7>
			mptr = mbegin;
			if (++nwrap == 2)
  802e5d:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  802e61:	83 7d e0 02          	cmpl   $0x2,-0x20(%ebp)
  802e65:	74 07                	je     802e6e <malloc+0x12b>
  802e67:	bf 00 00 00 08       	mov    $0x8000000,%edi
  802e6c:	eb 83                	jmp    802df1 <malloc+0xae>
  802e6e:	c7 05 10 94 81 00 00 	movl   $0x8000000,0x819410
  802e75:	00 00 08 
  802e78:	b8 00 00 00 00       	mov    $0x0,%eax
  802e7d:	e9 90 00 00 00       	jmp    802f12 <malloc+0x1cf>

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
  802e82:	8d b3 00 10 00 00    	lea    0x1000(%ebx),%esi
  802e88:	39 fe                	cmp    %edi,%esi
  802e8a:	19 c0                	sbb    %eax,%eax
  802e8c:	25 00 04 00 00       	and    $0x400,%eax
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
  802e91:	83 c8 07             	or     $0x7,%eax
  802e94:	89 44 24 08          	mov    %eax,0x8(%esp)
  802e98:	03 15 10 94 81 00    	add    0x819410,%edx
  802e9e:	89 54 24 04          	mov    %edx,0x4(%esp)
  802ea2:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802ea9:	e8 9d ea ff ff       	call   80194b <sys_page_alloc>
  802eae:	85 c0                	test   %eax,%eax
  802eb0:	78 04                	js     802eb6 <malloc+0x173>
  802eb2:	89 f3                	mov    %esi,%ebx
  802eb4:	eb 36                	jmp    802eec <malloc+0x1a9>
			for (; i >= 0; i -= PGSIZE)
  802eb6:	85 db                	test   %ebx,%ebx
  802eb8:	78 53                	js     802f0d <malloc+0x1ca>
				sys_page_unmap(0, mptr + i);
  802eba:	89 d8                	mov    %ebx,%eax
  802ebc:	03 05 10 94 81 00    	add    0x819410,%eax
  802ec2:	89 44 24 04          	mov    %eax,0x4(%esp)
  802ec6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802ecd:	e8 bd e9 ff ff       	call   80188f <sys_page_unmap>
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
		cont = (i + PGSIZE < n + 4) ? PTE_CONTINUED : 0;
		if (sys_page_alloc(0, mptr + i, PTE_P|PTE_U|PTE_W|cont) < 0){
			for (; i >= 0; i -= PGSIZE)
  802ed2:	81 eb 00 10 00 00    	sub    $0x1000,%ebx
  802ed8:	79 e0                	jns    802eba <malloc+0x177>
  802eda:	eb 31                	jmp    802f0d <malloc+0x1ca>
  802edc:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802edf:	a3 10 94 81 00       	mov    %eax,0x819410
  802ee4:	bb 00 00 00 00       	mov    $0x0,%ebx
  802ee9:	8b 7d d4             	mov    -0x2c(%ebp),%edi
  802eec:	89 da                	mov    %ebx,%edx
	}

	/*
	 * allocate at mptr - the +4 makes sure we allocate a ref count.
	 */
	for (i = 0; i < n + 4; i += PGSIZE){
  802eee:	39 fb                	cmp    %edi,%ebx
  802ef0:	72 90                	jb     802e82 <malloc+0x13f>
				sys_page_unmap(0, mptr + i);
			return 0;	/* out of physical memory */
		}
	}

	ref = (uint32_t*) (mptr + i - 4);
  802ef2:	a1 10 94 81 00       	mov    0x819410,%eax
	*ref = 2;	/* reference for mptr, reference for returned block */
  802ef7:	c7 44 18 fc 02 00 00 	movl   $0x2,-0x4(%eax,%ebx,1)
  802efe:	00 
	v = mptr;
	mptr += n;
  802eff:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  802f02:	8d 14 08             	lea    (%eax,%ecx,1),%edx
  802f05:	89 15 10 94 81 00    	mov    %edx,0x819410
	return v;
  802f0b:	eb 05                	jmp    802f12 <malloc+0x1cf>
  802f0d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  802f12:	83 c4 3c             	add    $0x3c,%esp
  802f15:	5b                   	pop    %ebx
  802f16:	5e                   	pop    %esi
  802f17:	5f                   	pop    %edi
  802f18:	5d                   	pop    %ebp
  802f19:	c3                   	ret    
  802f1a:	00 00                	add    %al,(%eax)
  802f1c:	00 00                	add    %al,(%eax)
	...

00802f20 <devpipe_stat>:
	return i;
}

static int
devpipe_stat(struct Fd *fd, struct Stat *stat)
{
  802f20:	55                   	push   %ebp
  802f21:	89 e5                	mov    %esp,%ebp
  802f23:	83 ec 18             	sub    $0x18,%esp
  802f26:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  802f29:	89 75 fc             	mov    %esi,-0x4(%ebp)
  802f2c:	8b 75 0c             	mov    0xc(%ebp),%esi
	struct Pipe *p = (struct Pipe*) fd2data(fd);
  802f2f:	8b 45 08             	mov    0x8(%ebp),%eax
  802f32:	89 04 24             	mov    %eax,(%esp)
  802f35:	e8 d6 ef ff ff       	call   801f10 <fd2data>
  802f3a:	89 c3                	mov    %eax,%ebx
	strcpy(stat->st_name, "<pipe>");
  802f3c:	c7 44 24 04 9b 2e 81 	movl   $0x812e9b,0x4(%esp)
  802f43:	00 
  802f44:	89 34 24             	mov    %esi,(%esp)
  802f47:	e8 0e e2 ff ff       	call   80115a <strcpy>
	stat->st_size = p->p_wpos - p->p_rpos;
  802f4c:	8b 43 04             	mov    0x4(%ebx),%eax
  802f4f:	2b 03                	sub    (%ebx),%eax
  802f51:	89 86 80 00 00 00    	mov    %eax,0x80(%esi)
	stat->st_isdir = 0;
  802f57:	c7 86 84 00 00 00 00 	movl   $0x0,0x84(%esi)
  802f5e:	00 00 00 
	stat->st_dev = &devpipe;
  802f61:	c7 86 88 00 00 00 3c 	movl   $0x81903c,0x88(%esi)
  802f68:	90 81 00 
	return 0;
}
  802f6b:	b8 00 00 00 00       	mov    $0x0,%eax
  802f70:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  802f73:	8b 75 fc             	mov    -0x4(%ebp),%esi
  802f76:	89 ec                	mov    %ebp,%esp
  802f78:	5d                   	pop    %ebp
  802f79:	c3                   	ret    

00802f7a <devpipe_close>:

static int
devpipe_close(struct Fd *fd)
{
  802f7a:	55                   	push   %ebp
  802f7b:	89 e5                	mov    %esp,%ebp
  802f7d:	53                   	push   %ebx
  802f7e:	83 ec 14             	sub    $0x14,%esp
  802f81:	8b 5d 08             	mov    0x8(%ebp),%ebx
	(void) sys_page_unmap(0, fd);
  802f84:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  802f88:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802f8f:	e8 fb e8 ff ff       	call   80188f <sys_page_unmap>
	return sys_page_unmap(0, fd2data(fd));
  802f94:	89 1c 24             	mov    %ebx,(%esp)
  802f97:	e8 74 ef ff ff       	call   801f10 <fd2data>
  802f9c:	89 44 24 04          	mov    %eax,0x4(%esp)
  802fa0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  802fa7:	e8 e3 e8 ff ff       	call   80188f <sys_page_unmap>
}
  802fac:	83 c4 14             	add    $0x14,%esp
  802faf:	5b                   	pop    %ebx
  802fb0:	5d                   	pop    %ebp
  802fb1:	c3                   	ret    

00802fb2 <_pipeisclosed>:
	return r;
}

static int
_pipeisclosed(struct Fd *fd, struct Pipe *p)
{
  802fb2:	55                   	push   %ebp
  802fb3:	89 e5                	mov    %esp,%ebp
  802fb5:	57                   	push   %edi
  802fb6:	56                   	push   %esi
  802fb7:	53                   	push   %ebx
  802fb8:	83 ec 2c             	sub    $0x2c,%esp
  802fbb:	89 c7                	mov    %eax,%edi
  802fbd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
	int n, nn, ret;

	while (1) {
		n = env->env_runs;
  802fc0:	a1 f4 f5 b3 00       	mov    0xb3f5f4,%eax
  802fc5:	8b 58 58             	mov    0x58(%eax),%ebx
		ret = pageref(fd) == pageref(p);
  802fc8:	89 3c 24             	mov    %edi,(%esp)
  802fcb:	e8 9c 05 00 00       	call   80356c <pageref>
  802fd0:	89 c6                	mov    %eax,%esi
  802fd2:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  802fd5:	89 04 24             	mov    %eax,(%esp)
  802fd8:	e8 8f 05 00 00       	call   80356c <pageref>
  802fdd:	39 c6                	cmp    %eax,%esi
  802fdf:	0f 94 c0             	sete   %al
  802fe2:	0f b6 c0             	movzbl %al,%eax
		nn = env->env_runs;
  802fe5:	8b 15 f4 f5 b3 00    	mov    0xb3f5f4,%edx
  802feb:	8b 4a 58             	mov    0x58(%edx),%ecx
		if (n == nn)
  802fee:	39 cb                	cmp    %ecx,%ebx
  802ff0:	75 08                	jne    802ffa <_pipeisclosed+0x48>
			return ret;
		if (n != nn && ret == 1)
			cprintf("pipe race avoided\n", n, env->env_runs, ret);
	}
}
  802ff2:	83 c4 2c             	add    $0x2c,%esp
  802ff5:	5b                   	pop    %ebx
  802ff6:	5e                   	pop    %esi
  802ff7:	5f                   	pop    %edi
  802ff8:	5d                   	pop    %ebp
  802ff9:	c3                   	ret    
		n = env->env_runs;
		ret = pageref(fd) == pageref(p);
		nn = env->env_runs;
		if (n == nn)
			return ret;
		if (n != nn && ret == 1)
  802ffa:	83 f8 01             	cmp    $0x1,%eax
  802ffd:	75 c1                	jne    802fc0 <_pipeisclosed+0xe>
			cprintf("pipe race avoided\n", n, env->env_runs, ret);
  802fff:	8b 52 58             	mov    0x58(%edx),%edx
  803002:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803006:	89 54 24 08          	mov    %edx,0x8(%esp)
  80300a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80300e:	c7 04 24 a2 2e 81 00 	movl   $0x812ea2,(%esp)
  803015:	e8 7f da ff ff       	call   800a99 <cprintf>
  80301a:	eb a4                	jmp    802fc0 <_pipeisclosed+0xe>

0080301c <devpipe_write>:
	return i;
}

static ssize_t
devpipe_write(struct Fd *fd, const void *vbuf, size_t n)
{
  80301c:	55                   	push   %ebp
  80301d:	89 e5                	mov    %esp,%ebp
  80301f:	57                   	push   %edi
  803020:	56                   	push   %esi
  803021:	53                   	push   %ebx
  803022:	83 ec 1c             	sub    $0x1c,%esp
  803025:	8b 75 08             	mov    0x8(%ebp),%esi
	const uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*) fd2data(fd);
  803028:	89 34 24             	mov    %esi,(%esp)
  80302b:	e8 e0 ee ff ff       	call   801f10 <fd2data>
  803030:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  803032:	bf 00 00 00 00       	mov    $0x0,%edi
  803037:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80303b:	75 54                	jne    803091 <devpipe_write+0x75>
  80303d:	eb 60                	jmp    80309f <devpipe_write+0x83>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
			// pipe is full
			// if all the readers are gone
			// (it's only writers like us now),
			// note eof
			if (_pipeisclosed(fd, p))
  80303f:	89 da                	mov    %ebx,%edx
  803041:	89 f0                	mov    %esi,%eax
  803043:	e8 6a ff ff ff       	call   802fb2 <_pipeisclosed>
  803048:	85 c0                	test   %eax,%eax
  80304a:	74 07                	je     803053 <devpipe_write+0x37>
  80304c:	b8 00 00 00 00       	mov    $0x0,%eax
  803051:	eb 53                	jmp    8030a6 <devpipe_write+0x8a>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_write yield\n");
			sys_yield();
  803053:	90                   	nop
  803054:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803058:	e8 4d e9 ff ff       	call   8019aa <sys_yield>
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  80305d:	8b 43 04             	mov    0x4(%ebx),%eax
  803060:	8b 13                	mov    (%ebx),%edx
  803062:	83 c2 20             	add    $0x20,%edx
  803065:	39 d0                	cmp    %edx,%eax
  803067:	73 d6                	jae    80303f <devpipe_write+0x23>
				cprintf("devpipe_write yield\n");
			sys_yield();
		}
		// there's room for a byte.  store it.
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
  803069:	89 c2                	mov    %eax,%edx
  80306b:	c1 fa 1f             	sar    $0x1f,%edx
  80306e:	c1 ea 1b             	shr    $0x1b,%edx
  803071:	01 d0                	add    %edx,%eax
  803073:	83 e0 1f             	and    $0x1f,%eax
  803076:	29 d0                	sub    %edx,%eax
  803078:	89 c2                	mov    %eax,%edx
  80307a:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  80307d:	0f b6 04 39          	movzbl (%ecx,%edi,1),%eax
  803081:	88 44 13 08          	mov    %al,0x8(%ebx,%edx,1)
		p->p_wpos++;
  803085:	83 43 04 01          	addl   $0x1,0x4(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_write %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  803089:	83 c7 01             	add    $0x1,%edi
  80308c:	39 7d 10             	cmp    %edi,0x10(%ebp)
  80308f:	76 13                	jbe    8030a4 <devpipe_write+0x88>
		while (p->p_wpos >= p->p_rpos + sizeof(p->p_buf)) {
  803091:	8b 43 04             	mov    0x4(%ebx),%eax
  803094:	8b 13                	mov    (%ebx),%edx
  803096:	83 c2 20             	add    $0x20,%edx
  803099:	39 d0                	cmp    %edx,%eax
  80309b:	73 a2                	jae    80303f <devpipe_write+0x23>
  80309d:	eb ca                	jmp    803069 <devpipe_write+0x4d>
  80309f:	bf 00 00 00 00       	mov    $0x0,%edi
		// wait to increment wpos until the byte is stored!
		p->p_buf[p->p_wpos % PIPEBUFSIZ] = buf[i];
		p->p_wpos++;
	}
	
	return i;
  8030a4:	89 f8                	mov    %edi,%eax
}
  8030a6:	83 c4 1c             	add    $0x1c,%esp
  8030a9:	5b                   	pop    %ebx
  8030aa:	5e                   	pop    %esi
  8030ab:	5f                   	pop    %edi
  8030ac:	5d                   	pop    %ebp
  8030ad:	c3                   	ret    

008030ae <devpipe_read>:
	return _pipeisclosed(fd, p);
}

static ssize_t
devpipe_read(struct Fd *fd, void *vbuf, size_t n)
{
  8030ae:	55                   	push   %ebp
  8030af:	89 e5                	mov    %esp,%ebp
  8030b1:	83 ec 28             	sub    $0x28,%esp
  8030b4:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8030b7:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8030ba:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8030bd:	8b 7d 08             	mov    0x8(%ebp),%edi
	uint8_t *buf;
	size_t i;
	struct Pipe *p;

	p = (struct Pipe*)fd2data(fd);
  8030c0:	89 3c 24             	mov    %edi,(%esp)
  8030c3:	e8 48 ee ff ff       	call   801f10 <fd2data>
  8030c8:	89 c3                	mov    %eax,%ebx
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  8030ca:	be 00 00 00 00       	mov    $0x0,%esi
  8030cf:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8030d3:	75 4c                	jne    803121 <devpipe_read+0x73>
  8030d5:	eb 5b                	jmp    803132 <devpipe_read+0x84>
		while (p->p_rpos == p->p_wpos) {
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
				return i;
  8030d7:	89 f0                	mov    %esi,%eax
  8030d9:	eb 5e                	jmp    803139 <devpipe_read+0x8b>
			// if all the writers are gone, note eof
			if (_pipeisclosed(fd, p))
  8030db:	89 da                	mov    %ebx,%edx
  8030dd:	89 f8                	mov    %edi,%eax
  8030df:	90                   	nop
  8030e0:	e8 cd fe ff ff       	call   802fb2 <_pipeisclosed>
  8030e5:	85 c0                	test   %eax,%eax
  8030e7:	74 07                	je     8030f0 <devpipe_read+0x42>
  8030e9:	b8 00 00 00 00       	mov    $0x0,%eax
  8030ee:	eb 49                	jmp    803139 <devpipe_read+0x8b>
				return 0;
			// yield and see what happens
			if (debug)
				cprintf("devpipe_read yield\n");
			sys_yield();
  8030f0:	e8 b5 e8 ff ff       	call   8019aa <sys_yield>
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
		while (p->p_rpos == p->p_wpos) {
  8030f5:	8b 03                	mov    (%ebx),%eax
  8030f7:	3b 43 04             	cmp    0x4(%ebx),%eax
  8030fa:	74 df                	je     8030db <devpipe_read+0x2d>
				cprintf("devpipe_read yield\n");
			sys_yield();
		}
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
  8030fc:	89 c2                	mov    %eax,%edx
  8030fe:	c1 fa 1f             	sar    $0x1f,%edx
  803101:	c1 ea 1b             	shr    $0x1b,%edx
  803104:	01 d0                	add    %edx,%eax
  803106:	83 e0 1f             	and    $0x1f,%eax
  803109:	29 d0                	sub    %edx,%eax
  80310b:	0f b6 44 03 08       	movzbl 0x8(%ebx,%eax,1),%eax
  803110:	8b 55 0c             	mov    0xc(%ebp),%edx
  803113:	88 04 32             	mov    %al,(%edx,%esi,1)
		p->p_rpos++;
  803116:	83 03 01             	addl   $0x1,(%ebx)
	if (debug)
		cprintf("[%08x] devpipe_read %08x %d rpos %d wpos %d\n",
			env->env_id, vpt[VPN(p)], n, p->p_rpos, p->p_wpos);

	buf = vbuf;
	for (i = 0; i < n; i++) {
  803119:	83 c6 01             	add    $0x1,%esi
  80311c:	39 75 10             	cmp    %esi,0x10(%ebp)
  80311f:	76 16                	jbe    803137 <devpipe_read+0x89>
		while (p->p_rpos == p->p_wpos) {
  803121:	8b 03                	mov    (%ebx),%eax
  803123:	3b 43 04             	cmp    0x4(%ebx),%eax
  803126:	75 d4                	jne    8030fc <devpipe_read+0x4e>
			// pipe is empty
			// if we got any data, return it
			if (i > 0)
  803128:	85 f6                	test   %esi,%esi
  80312a:	75 ab                	jne    8030d7 <devpipe_read+0x29>
  80312c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803130:	eb a9                	jmp    8030db <devpipe_read+0x2d>
  803132:	be 00 00 00 00       	mov    $0x0,%esi
		// there's a byte.  take it.
		// wait to increment rpos until the byte is taken!
		buf[i] = p->p_buf[p->p_rpos % PIPEBUFSIZ];
		p->p_rpos++;
	}
	return i;
  803137:	89 f0                	mov    %esi,%eax
}
  803139:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80313c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80313f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803142:	89 ec                	mov    %ebp,%esp
  803144:	5d                   	pop    %ebp
  803145:	c3                   	ret    

00803146 <pipeisclosed>:
	}
}

int
pipeisclosed(int fdnum)
{
  803146:	55                   	push   %ebp
  803147:	89 e5                	mov    %esp,%ebp
  803149:	83 ec 28             	sub    $0x28,%esp
	struct Fd *fd;
	struct Pipe *p;
	int r;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80314c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80314f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803153:	8b 45 08             	mov    0x8(%ebp),%eax
  803156:	89 04 24             	mov    %eax,(%esp)
  803159:	e8 3f ee ff ff       	call   801f9d <fd_lookup>
  80315e:	85 c0                	test   %eax,%eax
  803160:	78 15                	js     803177 <pipeisclosed+0x31>
		return r;
	p = (struct Pipe*) fd2data(fd);
  803162:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803165:	89 04 24             	mov    %eax,(%esp)
  803168:	e8 a3 ed ff ff       	call   801f10 <fd2data>
	return _pipeisclosed(fd, p);
  80316d:	89 c2                	mov    %eax,%edx
  80316f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803172:	e8 3b fe ff ff       	call   802fb2 <_pipeisclosed>
}
  803177:	c9                   	leave  
  803178:	c3                   	ret    

00803179 <pipe>:
	uint8_t p_buf[PIPEBUFSIZ];	// data buffer
};

int
pipe(int pfd[2])
{
  803179:	55                   	push   %ebp
  80317a:	89 e5                	mov    %esp,%ebp
  80317c:	83 ec 48             	sub    $0x48,%esp
  80317f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803182:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803185:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803188:	8b 7d 08             	mov    0x8(%ebp),%edi
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  80318b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80318e:	89 04 24             	mov    %eax,(%esp)
  803191:	e8 95 ed ff ff       	call   801f2b <fd_alloc>
  803196:	89 c3                	mov    %eax,%ebx
  803198:	85 c0                	test   %eax,%eax
  80319a:	0f 88 42 01 00 00    	js     8032e2 <pipe+0x169>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8031a0:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8031a7:	00 
  8031a8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8031ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8031af:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8031b6:	e8 90 e7 ff ff       	call   80194b <sys_page_alloc>
  8031bb:	89 c3                	mov    %eax,%ebx
	int r;
	struct Fd *fd0, *fd1;
	void *va;

	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
  8031bd:	85 c0                	test   %eax,%eax
  8031bf:	0f 88 1d 01 00 00    	js     8032e2 <pipe+0x169>
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8031c5:	8d 45 e0             	lea    -0x20(%ebp),%eax
  8031c8:	89 04 24             	mov    %eax,(%esp)
  8031cb:	e8 5b ed ff ff       	call   801f2b <fd_alloc>
  8031d0:	89 c3                	mov    %eax,%ebx
  8031d2:	85 c0                	test   %eax,%eax
  8031d4:	0f 88 f5 00 00 00    	js     8032cf <pipe+0x156>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  8031da:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  8031e1:	00 
  8031e2:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8031e5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8031e9:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8031f0:	e8 56 e7 ff ff       	call   80194b <sys_page_alloc>
  8031f5:	89 c3                	mov    %eax,%ebx
	// allocate the file descriptor table entries
	if ((r = fd_alloc(&fd0)) < 0
	    || (r = sys_page_alloc(0, fd0, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err;

	if ((r = fd_alloc(&fd1)) < 0
  8031f7:	85 c0                	test   %eax,%eax
  8031f9:	0f 88 d0 00 00 00    	js     8032cf <pipe+0x156>
	    || (r = sys_page_alloc(0, fd1, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
		goto err1;

	// allocate the pipe structure as first data page in both
	va = fd2data(fd0);
  8031ff:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803202:	89 04 24             	mov    %eax,(%esp)
  803205:	e8 06 ed ff ff       	call   801f10 <fd2data>
  80320a:	89 c6                	mov    %eax,%esi
	if ((r = sys_page_alloc(0, va, PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  80320c:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  803213:	00 
  803214:	89 44 24 04          	mov    %eax,0x4(%esp)
  803218:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80321f:	e8 27 e7 ff ff       	call   80194b <sys_page_alloc>
  803224:	89 c3                	mov    %eax,%ebx
  803226:	85 c0                	test   %eax,%eax
  803228:	0f 88 8e 00 00 00    	js     8032bc <pipe+0x143>
		goto err2;
	if ((r = sys_page_map(0, va, 0, fd2data(fd1), PTE_P|PTE_W|PTE_U|PTE_SHARE)) < 0)
  80322e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803231:	89 04 24             	mov    %eax,(%esp)
  803234:	e8 d7 ec ff ff       	call   801f10 <fd2data>
  803239:	c7 44 24 10 07 04 00 	movl   $0x407,0x10(%esp)
  803240:	00 
  803241:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803245:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80324c:	00 
  80324d:	89 74 24 04          	mov    %esi,0x4(%esp)
  803251:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803258:	e8 90 e6 ff ff       	call   8018ed <sys_page_map>
  80325d:	89 c3                	mov    %eax,%ebx
  80325f:	85 c0                	test   %eax,%eax
  803261:	78 49                	js     8032ac <pipe+0x133>
		goto err3;

	// set up fd structures
	fd0->fd_dev_id = devpipe.dev_id;
  803263:	b8 3c 90 81 00       	mov    $0x81903c,%eax
  803268:	8b 08                	mov    (%eax),%ecx
  80326a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80326d:	89 0a                	mov    %ecx,(%edx)
	fd0->fd_omode = O_RDONLY;
  80326f:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  803272:	c7 42 08 00 00 00 00 	movl   $0x0,0x8(%edx)

	fd1->fd_dev_id = devpipe.dev_id;
  803279:	8b 10                	mov    (%eax),%edx
  80327b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80327e:	89 10                	mov    %edx,(%eax)
	fd1->fd_omode = O_WRONLY;
  803280:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803283:	c7 40 08 01 00 00 00 	movl   $0x1,0x8(%eax)

	if (debug)
		cprintf("[%08x] pipecreate %08x\n", env->env_id, vpt[VPN(va)]);

	pfd[0] = fd2num(fd0);
  80328a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80328d:	89 04 24             	mov    %eax,(%esp)
  803290:	e8 6b ec ff ff       	call   801f00 <fd2num>
  803295:	89 07                	mov    %eax,(%edi)
	pfd[1] = fd2num(fd1);
  803297:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80329a:	89 04 24             	mov    %eax,(%esp)
  80329d:	e8 5e ec ff ff       	call   801f00 <fd2num>
  8032a2:	89 47 04             	mov    %eax,0x4(%edi)
  8032a5:	bb 00 00 00 00       	mov    $0x0,%ebx
	return 0;
  8032aa:	eb 36                	jmp    8032e2 <pipe+0x169>

    err3:
	sys_page_unmap(0, va);
  8032ac:	89 74 24 04          	mov    %esi,0x4(%esp)
  8032b0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8032b7:	e8 d3 e5 ff ff       	call   80188f <sys_page_unmap>
    err2:
	sys_page_unmap(0, fd1);
  8032bc:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8032bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032c3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8032ca:	e8 c0 e5 ff ff       	call   80188f <sys_page_unmap>
    err1:
	sys_page_unmap(0, fd0);
  8032cf:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8032d2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8032d6:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8032dd:	e8 ad e5 ff ff       	call   80188f <sys_page_unmap>
    err:
	return r;
}
  8032e2:	89 d8                	mov    %ebx,%eax
  8032e4:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8032e7:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8032ea:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8032ed:	89 ec                	mov    %ebp,%esp
  8032ef:	5d                   	pop    %ebp
  8032f0:	c3                   	ret    
	...

00803300 <devcons_close>:
	return tot;
}

static int
devcons_close(struct Fd *fd)
{
  803300:	55                   	push   %ebp
  803301:	89 e5                	mov    %esp,%ebp
	USED(fd);

	return 0;
}
  803303:	b8 00 00 00 00       	mov    $0x0,%eax
  803308:	5d                   	pop    %ebp
  803309:	c3                   	ret    

0080330a <devcons_stat>:

static int
devcons_stat(struct Fd *fd, struct Stat *stat)
{
  80330a:	55                   	push   %ebp
  80330b:	89 e5                	mov    %esp,%ebp
  80330d:	83 ec 18             	sub    $0x18,%esp
	strcpy(stat->st_name, "<cons>");
  803310:	c7 44 24 04 ba 2e 81 	movl   $0x812eba,0x4(%esp)
  803317:	00 
  803318:	8b 45 0c             	mov    0xc(%ebp),%eax
  80331b:	89 04 24             	mov    %eax,(%esp)
  80331e:	e8 37 de ff ff       	call   80115a <strcpy>
	return 0;
}
  803323:	b8 00 00 00 00       	mov    $0x0,%eax
  803328:	c9                   	leave  
  803329:	c3                   	ret    

0080332a <devcons_write>:
	return 1;
}

static ssize_t
devcons_write(struct Fd *fd, const void *vbuf, size_t n)
{
  80332a:	55                   	push   %ebp
  80332b:	89 e5                	mov    %esp,%ebp
  80332d:	57                   	push   %edi
  80332e:	56                   	push   %esi
  80332f:	53                   	push   %ebx
  803330:	81 ec 9c 00 00 00    	sub    $0x9c,%esp
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  803336:	b8 00 00 00 00       	mov    $0x0,%eax
  80333b:	be 00 00 00 00       	mov    $0x0,%esi
  803340:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  803344:	74 3f                	je     803385 <devcons_write+0x5b>
		m = n - tot;
		if (m > sizeof(buf) - 1)
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  803346:	8d bd 68 ff ff ff    	lea    -0x98(%ebp),%edi
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
		m = n - tot;
  80334c:	8b 55 10             	mov    0x10(%ebp),%edx
  80334f:	29 c2                	sub    %eax,%edx
  803351:	89 d3                	mov    %edx,%ebx
		if (m > sizeof(buf) - 1)
  803353:	83 fa 7f             	cmp    $0x7f,%edx
  803356:	76 05                	jbe    80335d <devcons_write+0x33>
  803358:	bb 7f 00 00 00       	mov    $0x7f,%ebx
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
  80335d:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  803361:	03 45 0c             	add    0xc(%ebp),%eax
  803364:	89 44 24 04          	mov    %eax,0x4(%esp)
  803368:	89 3c 24             	mov    %edi,(%esp)
  80336b:	e8 a5 df ff ff       	call   801315 <memmove>
		sys_cputs(buf, m);
  803370:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  803374:	89 3c 24             	mov    %edi,(%esp)
  803377:	e8 d4 e1 ff ff       	call   801550 <sys_cputs>
	int tot, m;
	char buf[128];

	// mistake: have to nul-terminate arg to sys_cputs, 
	// so we have to copy vbuf into buf in chunks and nul-terminate.
	for (tot = 0; tot < n; tot += m) {
  80337c:	01 de                	add    %ebx,%esi
  80337e:	89 f0                	mov    %esi,%eax
  803380:	3b 75 10             	cmp    0x10(%ebp),%esi
  803383:	72 c7                	jb     80334c <devcons_write+0x22>
			m = sizeof(buf) - 1;
		memmove(buf, (char*)vbuf + tot, m);
		sys_cputs(buf, m);
	}
	return tot;
}
  803385:	89 f0                	mov    %esi,%eax
  803387:	81 c4 9c 00 00 00    	add    $0x9c,%esp
  80338d:	5b                   	pop    %ebx
  80338e:	5e                   	pop    %esi
  80338f:	5f                   	pop    %edi
  803390:	5d                   	pop    %ebp
  803391:	c3                   	ret    

00803392 <cputchar>:
#include <inc/string.h>
#include <inc/lib.h>

void
cputchar(int ch)
{
  803392:	55                   	push   %ebp
  803393:	89 e5                	mov    %esp,%ebp
  803395:	83 ec 28             	sub    $0x28,%esp
	char c = ch;
  803398:	8b 45 08             	mov    0x8(%ebp),%eax
  80339b:	88 45 f7             	mov    %al,-0x9(%ebp)

	// Unlike standard Unix's putchar,
	// the cputchar function _always_ outputs to the system console.
	sys_cputs(&c, 1);
  80339e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8033a5:	00 
  8033a6:	8d 45 f7             	lea    -0x9(%ebp),%eax
  8033a9:	89 04 24             	mov    %eax,(%esp)
  8033ac:	e8 9f e1 ff ff       	call   801550 <sys_cputs>
}
  8033b1:	c9                   	leave  
  8033b2:	c3                   	ret    

008033b3 <devcons_read>:
	return fd2num(fd);
}

static ssize_t
devcons_read(struct Fd *fd, void *vbuf, size_t n)
{
  8033b3:	55                   	push   %ebp
  8033b4:	89 e5                	mov    %esp,%ebp
  8033b6:	83 ec 08             	sub    $0x8,%esp
	int c;

	if (n == 0)
  8033b9:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  8033bd:	75 07                	jne    8033c6 <devcons_read+0x13>
  8033bf:	eb 28                	jmp    8033e9 <devcons_read+0x36>
		return 0;

	while ((c = sys_cgetc()) == 0)
		sys_yield();
  8033c1:	e8 e4 e5 ff ff       	call   8019aa <sys_yield>
	int c;

	if (n == 0)
		return 0;

	while ((c = sys_cgetc()) == 0)
  8033c6:	66 90                	xchg   %ax,%ax
  8033c8:	e8 4f e1 ff ff       	call   80151c <sys_cgetc>
  8033cd:	85 c0                	test   %eax,%eax
  8033cf:	90                   	nop
  8033d0:	74 ef                	je     8033c1 <devcons_read+0xe>
  8033d2:	89 c2                	mov    %eax,%edx
		sys_yield();
	if (c < 0)
  8033d4:	85 c0                	test   %eax,%eax
  8033d6:	78 16                	js     8033ee <devcons_read+0x3b>
		return c;
	if (c == 0x04)	// ctl-d is eof
  8033d8:	83 f8 04             	cmp    $0x4,%eax
  8033db:	74 0c                	je     8033e9 <devcons_read+0x36>
		return 0;
	*(char*)vbuf = c;
  8033dd:	8b 45 0c             	mov    0xc(%ebp),%eax
  8033e0:	88 10                	mov    %dl,(%eax)
  8033e2:	b8 01 00 00 00       	mov    $0x1,%eax
	return 1;
  8033e7:	eb 05                	jmp    8033ee <devcons_read+0x3b>
  8033e9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8033ee:	c9                   	leave  
  8033ef:	c3                   	ret    

008033f0 <opencons>:
	return fd->fd_dev_id == devcons.dev_id;
}

int
opencons(void)
{
  8033f0:	55                   	push   %ebp
  8033f1:	89 e5                	mov    %esp,%ebp
  8033f3:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd* fd;

	if ((r = fd_alloc(&fd)) < 0)
  8033f6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  8033f9:	89 04 24             	mov    %eax,(%esp)
  8033fc:	e8 2a eb ff ff       	call   801f2b <fd_alloc>
  803401:	85 c0                	test   %eax,%eax
  803403:	78 3f                	js     803444 <opencons+0x54>
		return r;
	if ((r = sys_page_alloc(0, fd, PTE_P|PTE_U|PTE_W|PTE_SHARE)) < 0)
  803405:	c7 44 24 08 07 04 00 	movl   $0x407,0x8(%esp)
  80340c:	00 
  80340d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803410:	89 44 24 04          	mov    %eax,0x4(%esp)
  803414:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80341b:	e8 2b e5 ff ff       	call   80194b <sys_page_alloc>
  803420:	85 c0                	test   %eax,%eax
  803422:	78 20                	js     803444 <opencons+0x54>
		return r;
	fd->fd_dev_id = devcons.dev_id;
  803424:	8b 15 58 90 81 00    	mov    0x819058,%edx
  80342a:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80342d:	89 10                	mov    %edx,(%eax)
	fd->fd_omode = O_RDWR;
  80342f:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803432:	c7 40 08 02 00 00 00 	movl   $0x2,0x8(%eax)
	return fd2num(fd);
  803439:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80343c:	89 04 24             	mov    %eax,(%esp)
  80343f:	e8 bc ea ff ff       	call   801f00 <fd2num>
}
  803444:	c9                   	leave  
  803445:	c3                   	ret    

00803446 <iscons>:
	.dev_stat =	devcons_stat
};

int
iscons(int fdnum)
{
  803446:	55                   	push   %ebp
  803447:	89 e5                	mov    %esp,%ebp
  803449:	83 ec 28             	sub    $0x28,%esp
	int r;
	struct Fd *fd;

	if ((r = fd_lookup(fdnum, &fd)) < 0)
  80344c:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80344f:	89 44 24 04          	mov    %eax,0x4(%esp)
  803453:	8b 45 08             	mov    0x8(%ebp),%eax
  803456:	89 04 24             	mov    %eax,(%esp)
  803459:	e8 3f eb ff ff       	call   801f9d <fd_lookup>
  80345e:	85 c0                	test   %eax,%eax
  803460:	78 11                	js     803473 <iscons+0x2d>
		return r;
	return fd->fd_dev_id == devcons.dev_id;
  803462:	8b 45 f4             	mov    -0xc(%ebp),%eax
  803465:	8b 00                	mov    (%eax),%eax
  803467:	3b 05 58 90 81 00    	cmp    0x819058,%eax
  80346d:	0f 94 c0             	sete   %al
  803470:	0f b6 c0             	movzbl %al,%eax
}
  803473:	c9                   	leave  
  803474:	c3                   	ret    

00803475 <getchar>:
	sys_cputs(&c, 1);
}

int
getchar(void)
{
  803475:	55                   	push   %ebp
  803476:	89 e5                	mov    %esp,%ebp
  803478:	83 ec 28             	sub    $0x28,%esp
	int r;

	// JOS does, however, support standard _input_ redirection,
	// allowing the user to redirect script files to the shell and such.
	// getchar() reads a character from file descriptor 0.
	r = read(0, &c, 1);
  80347b:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  803482:	00 
  803483:	8d 45 f7             	lea    -0x9(%ebp),%eax
  803486:	89 44 24 04          	mov    %eax,0x4(%esp)
  80348a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803491:	e8 68 ed ff ff       	call   8021fe <read>
	if (r < 0)
  803496:	85 c0                	test   %eax,%eax
  803498:	78 0f                	js     8034a9 <getchar+0x34>
		return r;
	if (r < 1)
  80349a:	85 c0                	test   %eax,%eax
  80349c:	7f 07                	jg     8034a5 <getchar+0x30>
  80349e:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  8034a3:	eb 04                	jmp    8034a9 <getchar+0x34>
		return -E_EOF;
	return c;
  8034a5:	0f b6 45 f7          	movzbl -0x9(%ebp),%eax
}
  8034a9:	c9                   	leave  
  8034aa:	c3                   	ret    
	...

008034ac <set_pgfault_handler>:
// at UXSTACKTOP), and tell the kernel to call the assembly-language
// _pgfault_upcall routine when a page fault occurs.
//
void
set_pgfault_handler(void (*handler)(struct UTrapframe *utf))
{
  8034ac:	55                   	push   %ebp
  8034ad:	89 e5                	mov    %esp,%ebp
  8034af:	83 ec 18             	sub    $0x18,%esp
	int r;

	if (_pgfault_handler == 0) {
  8034b2:	83 3d fc f5 b3 00 00 	cmpl   $0x0,0xb3f5fc
  8034b9:	75 78                	jne    803533 <set_pgfault_handler+0x87>
		// First time through!
		// LAB 4: Your code here.
		// panic("set_pgfault_handler not implemented");
		int ret;	
		if ((ret = sys_page_alloc(0, (void*)(UXSTACKTOP - PGSIZE), PTE_U | PTE_P | PTE_W)) < 0)
  8034bb:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  8034c2:	00 
  8034c3:	c7 44 24 04 00 f0 bf 	movl   $0xeebff000,0x4(%esp)
  8034ca:	ee 
  8034cb:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8034d2:	e8 74 e4 ff ff       	call   80194b <sys_page_alloc>
  8034d7:	85 c0                	test   %eax,%eax
  8034d9:	79 20                	jns    8034fb <set_pgfault_handler+0x4f>
			panic (" error in sys_page_alloc: %e\n", ret);
  8034db:	89 44 24 0c          	mov    %eax,0xc(%esp)
  8034df:	c7 44 24 08 c6 2e 81 	movl   $0x812ec6,0x8(%esp)
  8034e6:	00 
  8034e7:	c7 44 24 04 23 00 00 	movl   $0x23,0x4(%esp)
  8034ee:	00 
  8034ef:	c7 04 24 e4 2e 81 00 	movl   $0x812ee4,(%esp)
  8034f6:	e8 d9 d4 ff ff       	call   8009d4 <_panic>
		if ((ret = sys_env_set_pgfault_upcall(0, _pgfault_upcall)) < 0)
  8034fb:	c7 44 24 04 40 35 80 	movl   $0x803540,0x4(%esp)
  803502:	00 
  803503:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80350a:	e8 66 e2 ff ff       	call   801775 <sys_env_set_pgfault_upcall>
  80350f:	85 c0                	test   %eax,%eax
  803511:	79 20                	jns    803533 <set_pgfault_handler+0x87>
			panic (" error in sys_env_set_pgfault_upcall: %e\n", ret);
  803513:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803517:	c7 44 24 08 f4 2e 81 	movl   $0x812ef4,0x8(%esp)
  80351e:	00 
  80351f:	c7 44 24 04 25 00 00 	movl   $0x25,0x4(%esp)
  803526:	00 
  803527:	c7 04 24 e4 2e 81 00 	movl   $0x812ee4,(%esp)
  80352e:	e8 a1 d4 ff ff       	call   8009d4 <_panic>
	}

	// Save handler pointer for assembly to call.
	_pgfault_handler = handler;
  803533:	8b 45 08             	mov    0x8(%ebp),%eax
  803536:	a3 fc f5 b3 00       	mov    %eax,0xb3f5fc
	
}
  80353b:	c9                   	leave  
  80353c:	c3                   	ret    
  80353d:	00 00                	add    %al,(%eax)
	...

00803540 <_pgfault_upcall>:

.text
.globl _pgfault_upcall
_pgfault_upcall:
	// Call the C page fault handler.
	pushl %esp			// function argument: pointer to UTF
  803540:	54                   	push   %esp
	movl _pgfault_handler, %eax
  803541:	a1 fc f5 b3 00       	mov    0xb3f5fc,%eax
	call *%eax
  803546:	ff d0                	call   *%eax
	addl $4, %esp			// pop function argument
  803548:	83 c4 04             	add    $0x4,%esp
	// may find that you have to rearrange your code in non-obvious
	// ways as registers become unavailable as scratch space.
	//
	// LAB 4: Your code here.
	
	movl %esp, %ecx			// back up esp to ecx
  80354b:	89 e1                	mov    %esp,%ecx
	movl 0x28(%esp), %ebx		// store trap-time eip into ebx
  80354d:	8b 5c 24 28          	mov    0x28(%esp),%ebx
	movl 0x30(%esp), %edx		// store trap-time esp into edx
  803551:	8b 54 24 30          	mov    0x30(%esp),%edx
	movl %edx, %esp			// switch to trap-time stack
  803555:	89 d4                	mov    %edx,%esp
	pushl %ebx			// push trap-time eip here
  803557:	53                   	push   %ebx
	movl %ecx, %esp			// come back to user exception stack
  803558:	89 cc                	mov    %ecx,%esp
	
	// for the push made above, update the trap-time esp value in this user exception stack
	// this enables popl %esp to cause esp point to the adjusted trap-time stack 
	subl $0x4, %edx			
  80355a:	83 ea 04             	sub    $0x4,%edx
	movl %edx, 0x30(%esp)
  80355d:	89 54 24 30          	mov    %edx,0x30(%esp)
	

	// Restore the trap-time registers.  After you do this, you
	// can no longer modify any general-purpose registers.
	// LAB 4: Your code here.
	addl $0x8, %esp
  803561:	83 c4 08             	add    $0x8,%esp
	popal
  803564:	61                   	popa   
	// Restore eflags from the stack.  After you do this, you can
	// no longer use arithmetic operations or anything else that
	// modifies eflags.
	// LAB 4: Your code here.
	
	addl $0x4, %esp
  803565:	83 c4 04             	add    $0x4,%esp
	popfl
  803568:	9d                   	popf   

	// Switch back to the adjusted trap-time stack.
	// LAB 4: Your code here.

	popl %esp
  803569:	5c                   	pop    %esp

	// Return to re-execute the instruction that faulted.
	// LAB 4: Your code here.
	
	ret
  80356a:	c3                   	ret    
	...

0080356c <pageref>:
#include <inc/lib.h>

int
pageref(void *v)
{
  80356c:	55                   	push   %ebp
  80356d:	89 e5                	mov    %esp,%ebp
	pte_t pte;

	if (!(vpd[PDX(v)] & PTE_P))
  80356f:	8b 45 08             	mov    0x8(%ebp),%eax
  803572:	89 c2                	mov    %eax,%edx
  803574:	c1 ea 16             	shr    $0x16,%edx
  803577:	8b 14 95 00 d0 7b ef 	mov    -0x10843000(,%edx,4),%edx
  80357e:	f6 c2 01             	test   $0x1,%dl
  803581:	74 26                	je     8035a9 <pageref+0x3d>
		return 0;
	pte = vpt[VPN(v)];
  803583:	c1 e8 0c             	shr    $0xc,%eax
  803586:	8b 04 85 00 00 40 ef 	mov    -0x10c00000(,%eax,4),%eax
	if (!(pte & PTE_P))
  80358d:	a8 01                	test   $0x1,%al
  80358f:	74 18                	je     8035a9 <pageref+0x3d>
		return 0;
	return pages[PPN(pte)].pp_ref;
  803591:	c1 e8 0c             	shr    $0xc,%eax
  803594:	8d 14 40             	lea    (%eax,%eax,2),%edx
  803597:	c1 e2 02             	shl    $0x2,%edx
  80359a:	b8 00 00 00 ef       	mov    $0xef000000,%eax
  80359f:	0f b7 44 02 08       	movzwl 0x8(%edx,%eax,1),%eax
  8035a4:	0f b7 c0             	movzwl %ax,%eax
  8035a7:	eb 05                	jmp    8035ae <pageref+0x42>
  8035a9:	b8 00 00 00 00       	mov    $0x0,%eax
}
  8035ae:	5d                   	pop    %ebp
  8035af:	c3                   	ret    

008035b0 <get_socket>:
 * @param s externally used socket index
 * @return struct lwip_socket for the socket or NULL if not found
 */
static struct lwip_socket *
get_socket(int s)
{
  8035b0:	55                   	push   %ebp
  8035b1:	89 e5                	mov    %esp,%ebp
  struct lwip_socket *sock;

  if ((s < 0) || (s >= NUM_SOCKETS)) {
  8035b3:	83 f8 1f             	cmp    $0x1f,%eax
  8035b6:	76 11                	jbe    8035c9 <get_socket+0x19>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): invalid\n", s));
    set_errno(EBADF);
  8035b8:	c7 05 a0 f5 b3 00 09 	movl   $0x9,0xb3f5a0
  8035bf:	00 00 00 
  8035c2:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  8035c7:	eb 1e                	jmp    8035e7 <get_socket+0x37>
  }

  sock = &sockets[s];
  8035c9:	8d 04 80             	lea    (%eax,%eax,4),%eax
  8035cc:	8d 04 85 20 94 81 00 	lea    0x819420(,%eax,4),%eax

  if (!sock->conn) {
  8035d3:	83 38 00             	cmpl   $0x0,(%eax)
  8035d6:	75 0f                	jne    8035e7 <get_socket+0x37>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("get_socket(%d): not active\n", s));
    set_errno(EBADF);
  8035d8:	c7 05 a0 f5 b3 00 09 	movl   $0x9,0xb3f5a0
  8035df:	00 00 00 
  8035e2:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  }

  return sock;
}
  8035e7:	5d                   	pop    %ebp
  8035e8:	c3                   	ret    

008035e9 <lwip_ioctl>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_ioctl(int s, long cmd, void *argp)
{
  8035e9:	55                   	push   %ebp
  8035ea:	89 e5                	mov    %esp,%ebp
  8035ec:	56                   	push   %esi
  8035ed:	53                   	push   %ebx
  8035ee:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  8035f1:	8b 75 10             	mov    0x10(%ebp),%esi
  struct lwip_socket *sock = get_socket(s);
  8035f4:	8b 45 08             	mov    0x8(%ebp),%eax
  8035f7:	e8 b4 ff ff ff       	call   8035b0 <get_socket>
  u16_t buflen = 0;

  if (!sock)
  8035fc:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  803601:	85 c0                	test   %eax,%eax
  803603:	0f 84 a6 00 00 00    	je     8036af <lwip_ioctl+0xc6>
    return -1;

  switch (cmd) {
  803609:	81 fb 7e 66 04 80    	cmp    $0x8004667e,%ebx
  80360f:	74 59                	je     80366a <lwip_ioctl+0x81>
  803611:	81 fb 7f 66 04 40    	cmp    $0x4004667f,%ebx
  803617:	0f 85 7c 00 00 00    	jne    803699 <lwip_ioctl+0xb0>
  case FIONREAD:
    if (!argp) {
  80361d:	85 f6                	test   %esi,%esi
  80361f:	90                   	nop
  803620:	75 13                	jne    803635 <lwip_ioctl+0x4c>
      sock_set_errno(sock, EINVAL);
  803622:	c7 40 10 16 00 00 00 	movl   $0x16,0x10(%eax)
  803629:	c7 05 a0 f5 b3 00 16 	movl   $0x16,0xb3f5a0
  803630:	00 00 00 
      return -1;
  803633:	eb 7a                	jmp    8036af <lwip_ioctl+0xc6>
    }

    SYS_ARCH_GET(sock->conn->recv_avail, *((u16_t*)argp));
  803635:	8b 10                	mov    (%eax),%edx
  803637:	0f b7 52 20          	movzwl 0x20(%edx),%edx
  80363b:	66 89 16             	mov    %dx,(%esi)

    /* Check if there is data left from the last recv operation. /maq 041215 */
    if (sock->lastdata) {
  80363e:	8b 48 04             	mov    0x4(%eax),%ecx
  803641:	85 c9                	test   %ecx,%ecx
  803643:	74 0d                	je     803652 <lwip_ioctl+0x69>
      buflen = netbuf_len(sock->lastdata);
  803645:	8b 09                	mov    (%ecx),%ecx
      buflen -= sock->lastoffset;

      *((u16_t*)argp) += buflen;
  803647:	66 03 51 08          	add    0x8(%ecx),%dx
  80364b:	66 2b 50 08          	sub    0x8(%eax),%dx
  80364f:	66 89 16             	mov    %dx,(%esi)
    }

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
  803652:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  803659:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  803660:	00 00 00 
  803663:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  803668:	eb 45                	jmp    8036af <lwip_ioctl+0xc6>

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  80366a:	85 f6                	test   %esi,%esi
  80366c:	74 0d                	je     80367b <lwip_ioctl+0x92>
  80366e:	83 3e 00             	cmpl   $0x0,(%esi)
  803671:	74 08                	je     80367b <lwip_ioctl+0x92>
      sock->flags |= O_NONBLOCK;
  803673:	66 81 48 0e 00 08    	orw    $0x800,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONREAD, %p) = %u\n", s, argp, *((u16_t*)argp)));
    sock_set_errno(sock, 0);
    return 0;

  case FIONBIO:
    if (argp && *(u32_t*)argp)
  803679:	eb 06                	jmp    803681 <lwip_ioctl+0x98>
      sock->flags |= O_NONBLOCK;
    else
      sock->flags &= ~O_NONBLOCK;
  80367b:	66 81 60 0e ff f7    	andw   $0xf7ff,0xe(%eax)
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, FIONBIO, %d)\n", s, !!(sock->flags & O_NONBLOCK)));
    sock_set_errno(sock, 0);
  803681:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  803688:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  80368f:	00 00 00 
  803692:	ba 00 00 00 00       	mov    $0x0,%edx
    return 0;
  803697:	eb 16                	jmp    8036af <lwip_ioctl+0xc6>

  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_ioctl(%d, UNIMPL: 0x%lx, %p)\n", s, cmd, argp));
    sock_set_errno(sock, ENOSYS); /* not yet implemented */
  803699:	c7 40 10 26 00 00 00 	movl   $0x26,0x10(%eax)
  8036a0:	c7 05 a0 f5 b3 00 26 	movl   $0x26,0xb3f5a0
  8036a7:	00 00 00 
  8036aa:	ba ff ff ff ff       	mov    $0xffffffff,%edx
    return -1;
  } /* switch (cmd) */
}
  8036af:	89 d0                	mov    %edx,%eax
  8036b1:	5b                   	pop    %ebx
  8036b2:	5e                   	pop    %esi
  8036b3:	5d                   	pop    %ebp
  8036b4:	c3                   	ret    

008036b5 <lwip_setsockopt>:
  sys_sem_signal(sock->conn->op_completed);
}

int
lwip_setsockopt(int s, int level, int optname, const void *optval, socklen_t optlen)
{
  8036b5:	55                   	push   %ebp
  8036b6:	89 e5                	mov    %esp,%ebp
  8036b8:	83 ec 48             	sub    $0x48,%esp
  8036bb:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8036be:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8036c1:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8036c4:	8b 75 0c             	mov    0xc(%ebp),%esi
  8036c7:	8b 7d 14             	mov    0x14(%ebp),%edi
  struct lwip_socket *sock = get_socket(s);
  8036ca:	8b 45 08             	mov    0x8(%ebp),%eax
  8036cd:	e8 de fe ff ff       	call   8035b0 <get_socket>
  8036d2:	89 c3                	mov    %eax,%ebx
  int err = ERR_OK;
  struct lwip_setgetsockopt_data data;

  if (!sock)
  8036d4:	85 c0                	test   %eax,%eax
  8036d6:	0f 84 5a 01 00 00    	je     803836 <lwip_setsockopt+0x181>
    return -1;

  if (NULL == optval) {
  8036dc:	85 ff                	test   %edi,%edi
  8036de:	75 1b                	jne    8036fb <lwip_setsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  8036e0:	c7 40 10 0e 00 00 00 	movl   $0xe,0x10(%eax)
  8036e7:	c7 05 a0 f5 b3 00 0e 	movl   $0xe,0xb3f5a0
  8036ee:	00 00 00 
  8036f1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8036f6:	e9 47 01 00 00       	jmp    803842 <lwip_setsockopt+0x18d>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8036fb:	83 fe 06             	cmp    $0x6,%esi
  8036fe:	0f 84 8e 00 00 00    	je     803792 <lwip_setsockopt+0xdd>
  803704:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  80370a:	74 11                	je     80371d <lwip_setsockopt+0x68>
  80370c:	85 f6                	test   %esi,%esi
  80370e:	66 90                	xchg   %ax,%ax
  803710:	74 66                	je     803778 <lwip_setsockopt+0xc3>
  803712:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  803718:	e9 a8 00 00 00       	jmp    8037c5 <lwip_setsockopt+0x110>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  80371d:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  803721:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803728:	74 1c                	je     803746 <lwip_setsockopt+0x91>
  80372a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  803731:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803738:	74 1b                	je     803755 <lwip_setsockopt+0xa0>
  80373a:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  80373e:	66 90                	xchg   %ax,%ax
  803740:	0f 85 7f 00 00 00    	jne    8037c5 <lwip_setsockopt+0x110>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (optlen < sizeof(int)) {
  803746:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  80374a:	0f 86 ff 00 00 00    	jbe    80384f <lwip_setsockopt+0x19a>
  803750:	e9 88 00 00 00       	jmp    8037dd <lwip_setsockopt+0x128>
        err = EINVAL;
      }
      break;
    case SO_NO_CHECK:
      if (optlen < sizeof(int)) {
  803755:	83 7d 18 04          	cmpl   $0x4,0x18(%ebp)
  803759:	19 c0                	sbb    %eax,%eax
  80375b:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  80375e:	8b 13                	mov    (%ebx),%edx
  803760:	83 3a 20             	cmpl   $0x20,(%edx)
  803763:	0f 85 f0 00 00 00    	jne    803859 <lwip_setsockopt+0x1a4>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  803769:	8b 52 08             	mov    0x8(%edx),%edx
  80376c:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  803770:	0f 85 e3 00 00 00    	jne    803859 <lwip_setsockopt+0x1a4>
  803776:	eb 52                	jmp    8037ca <lwip_setsockopt+0x115>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803778:	8b 45 10             	mov    0x10(%ebp),%eax
  80377b:	83 e8 01             	sub    $0x1,%eax
  80377e:	83 f8 01             	cmp    $0x1,%eax
  803781:	77 42                	ja     8037c5 <lwip_setsockopt+0x110>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (optlen < sizeof(int)) {
  803783:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803787:	0f 86 c2 00 00 00    	jbe    80384f <lwip_setsockopt+0x19a>
  80378d:	8d 76 00             	lea    0x0(%esi),%esi
  803790:	eb 4b                	jmp    8037dd <lwip_setsockopt+0x128>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (optlen < sizeof(int)) {
  803792:	83 7d 18 03          	cmpl   $0x3,0x18(%ebp)
  803796:	66 90                	xchg   %ax,%ax
  803798:	0f 86 b1 00 00 00    	jbe    80384f <lwip_setsockopt+0x19a>
      err = EINVAL;
      break;
    }

    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  80379e:	8b 00                	mov    (%eax),%eax
  8037a0:	83 38 10             	cmpl   $0x10,(%eax)
  8037a3:	0f 85 94 00 00 00    	jne    80383d <lwip_setsockopt+0x188>
  8037a9:	8b 55 10             	mov    0x10(%ebp),%edx
  8037ac:	83 ea 01             	sub    $0x1,%edx
  8037af:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8037b4:	83 fa 01             	cmp    $0x1,%edx
  8037b7:	77 15                	ja     8037ce <lwip_setsockopt+0x119>
  8037b9:	8b 55 10             	mov    0x10(%ebp),%edx
  8037bc:	8b 04 95 38 30 81 00 	mov    0x813038(,%edx,4),%eax
  8037c3:	eb 05                	jmp    8037ca <lwip_setsockopt+0x115>
  8037c5:	b8 5c 00 00 00       	mov    $0x5c,%eax
                s, level, optname));
    err = ENOPROTOOPT;
  }  /* switch (level) */


  if (err != ERR_OK) {
  8037ca:	85 c0                	test   %eax,%eax
  8037cc:	74 0f                	je     8037dd <lwip_setsockopt+0x128>
    sock_set_errno(sock, err);
  8037ce:	89 43 10             	mov    %eax,0x10(%ebx)
  8037d1:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  8037d6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8037db:	eb 65                	jmp    803842 <lwip_setsockopt+0x18d>
  }


  /* Now do the actual option processing */
  data.sock = sock;
  8037dd:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  8037e0:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  8037e3:	8b 45 10             	mov    0x10(%ebp),%eax
  8037e6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = (void*)optval;
  8037e9:	89 7d dc             	mov    %edi,-0x24(%ebp)
  data.optlen = &optlen;
  8037ec:	8d 45 18             	lea    0x18(%ebp),%eax
  8037ef:	89 45 e0             	mov    %eax,-0x20(%ebp)
  data.err = err;
  8037f2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_setsockopt_internal, &data);
  8037f6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8037fd:	00 
  8037fe:	8d 45 cc             	lea    -0x34(%ebp),%eax
  803801:	89 44 24 04          	mov    %eax,0x4(%esp)
  803805:	c7 04 24 52 3a 80 00 	movl   $0x803a52,(%esp)
  80380c:	e8 05 1b 00 00       	call   805316 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803811:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803818:	00 
  803819:	8b 03                	mov    (%ebx),%eax
  80381b:	8b 40 10             	mov    0x10(%eax),%eax
  80381e:	89 04 24             	mov    %eax,(%esp)
  803821:	e8 10 a1 00 00       	call   80d936 <sys_arch_sem_wait>
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;
  803826:	0f be 45 e4          	movsbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  80382a:	89 43 10             	mov    %eax,0x10(%ebx)
  80382d:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  return err ? -1 : 0;
  803832:	85 c0                	test   %eax,%eax
  803834:	74 07                	je     80383d <lwip_setsockopt+0x188>
  803836:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80383b:	eb 05                	jmp    803842 <lwip_setsockopt+0x18d>
  80383d:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803842:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803845:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803848:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80384b:	89 ec                	mov    %ebp,%esp
  80384d:	5d                   	pop    %ebp
  80384e:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_setsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  80384f:	b8 16 00 00 00       	mov    $0x16,%eax
  803854:	e9 75 ff ff ff       	jmp    8037ce <lwip_setsockopt+0x119>
  803859:	b8 61 00 00 00       	mov    $0x61,%eax
  80385e:	e9 6b ff ff ff       	jmp    8037ce <lwip_setsockopt+0x119>

00803863 <lwip_getsockopt>:
  return lwip_getaddrname(s, name, namelen, 1);
}

int
lwip_getsockopt(int s, int level, int optname, void *optval, socklen_t *optlen)
{
  803863:	55                   	push   %ebp
  803864:	89 e5                	mov    %esp,%ebp
  803866:	57                   	push   %edi
  803867:	56                   	push   %esi
  803868:	53                   	push   %ebx
  803869:	83 ec 3c             	sub    $0x3c,%esp
  80386c:	8b 75 0c             	mov    0xc(%ebp),%esi
  80386f:	8b 7d 18             	mov    0x18(%ebp),%edi
  err_t err = ERR_OK;
  struct lwip_socket *sock = get_socket(s);
  803872:	8b 45 08             	mov    0x8(%ebp),%eax
  803875:	e8 36 fd ff ff       	call   8035b0 <get_socket>
  80387a:	89 c3                	mov    %eax,%ebx
  struct lwip_setgetsockopt_data data;

  if (!sock)
  80387c:	85 c0                	test   %eax,%eax
  80387e:	0f 84 a6 01 00 00    	je     803a2a <lwip_getsockopt+0x1c7>
    return -1;

  if ((NULL == optval) || (NULL == optlen)) {
  803884:	83 7d 14 00          	cmpl   $0x0,0x14(%ebp)
  803888:	74 04                	je     80388e <lwip_getsockopt+0x2b>
  80388a:	85 ff                	test   %edi,%edi
  80388c:	75 1b                	jne    8038a9 <lwip_getsockopt+0x46>
    sock_set_errno(sock, EFAULT);
  80388e:	c7 43 10 0e 00 00 00 	movl   $0xe,0x10(%ebx)
  803895:	c7 05 a0 f5 b3 00 0e 	movl   $0xe,0xb3f5a0
  80389c:	00 00 00 
  80389f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8038a4:	e9 8d 01 00 00       	jmp    803a36 <lwip_getsockopt+0x1d3>
  }

  /* Do length and type checks for the various options first, to keep it readable. */
  switch (level) {
  8038a9:	83 fe 06             	cmp    $0x6,%esi
  8038ac:	0f 84 c6 00 00 00    	je     803978 <lwip_getsockopt+0x115>
  8038b2:	81 fe ff 0f 00 00    	cmp    $0xfff,%esi
  8038b8:	74 13                	je     8038cd <lwip_getsockopt+0x6a>
  8038ba:	85 f6                	test   %esi,%esi
  8038bc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8038c0:	0f 84 99 00 00 00    	je     80395f <lwip_getsockopt+0xfc>
  8038c6:	66 90                	xchg   %ax,%ax
  8038c8:	e9 e5 00 00 00       	jmp    8039b2 <lwip_getsockopt+0x14f>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  8038cd:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8038d1:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  8038d8:	74 50                	je     80392a <lwip_getsockopt+0xc7>
  8038da:	83 7d 10 20          	cmpl   $0x20,0x10(%ebp)
  8038de:	66 90                	xchg   %ax,%ax
  8038e0:	7f 18                	jg     8038fa <lwip_getsockopt+0x97>
  8038e2:	83 7d 10 02          	cmpl   $0x2,0x10(%ebp)
  8038e6:	74 42                	je     80392a <lwip_getsockopt+0xc7>
  8038e8:	83 7d 10 08          	cmpl   $0x8,0x10(%ebp)
  8038ec:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8038f0:	0f 85 bc 00 00 00    	jne    8039b2 <lwip_getsockopt+0x14f>
  8038f6:	66 90                	xchg   %ax,%ax
  8038f8:	eb 30                	jmp    80392a <lwip_getsockopt+0xc7>
  8038fa:	81 7d 10 07 10 00 00 	cmpl   $0x1007,0x10(%ebp)
  803901:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  803908:	0f 8c a4 00 00 00    	jl     8039b2 <lwip_getsockopt+0x14f>
  80390e:	81 7d 10 08 10 00 00 	cmpl   $0x1008,0x10(%ebp)
  803915:	8d 76 00             	lea    0x0(%esi),%esi
  803918:	7e 10                	jle    80392a <lwip_getsockopt+0xc7>
  80391a:	81 7d 10 0a 10 00 00 	cmpl   $0x100a,0x10(%ebp)
  803921:	0f 85 8b 00 00 00    	jne    8039b2 <lwip_getsockopt+0x14f>
  803927:	90                   	nop
  803928:	eb 13                	jmp    80393d <lwip_getsockopt+0xda>
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    case SO_TYPE:
    /* UNIMPL case SO_USELOOPBACK: */
      if (*optlen < sizeof(int)) {
  80392a:	83 3f 03             	cmpl   $0x3,(%edi)
  80392d:	8d 76 00             	lea    0x0(%esi),%esi
  803930:	0f 86 08 01 00 00    	jbe    803a3e <lwip_getsockopt+0x1db>
  803936:	66 90                	xchg   %ax,%ax
  803938:	e9 90 00 00 00       	jmp    8039cd <lwip_getsockopt+0x16a>
        err = EINVAL;
      }
      break;

    case SO_NO_CHECK:
      if (*optlen < sizeof(int)) {
  80393d:	83 3f 04             	cmpl   $0x4,(%edi)
  803940:	19 c0                	sbb    %eax,%eax
  803942:	83 e0 16             	and    $0x16,%eax
        err = EINVAL;
      }
#if LWIP_UDP
      if ((sock->conn->type != NETCONN_UDP) ||
  803945:	8b 13                	mov    (%ebx),%edx
  803947:	83 3a 20             	cmpl   $0x20,(%edx)
  80394a:	0f 85 f8 00 00 00    	jne    803a48 <lwip_getsockopt+0x1e5>
          ((udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_UDPLITE) != 0)) {
  803950:	8b 52 08             	mov    0x8(%edx),%edx
  803953:	f6 42 10 02          	testb  $0x2,0x10(%edx)
  803957:	0f 85 eb 00 00 00    	jne    803a48 <lwip_getsockopt+0x1e5>
  80395d:	eb 58                	jmp    8039b7 <lwip_getsockopt+0x154>
    }  /* switch (optname) */
    break;
                     
/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  80395f:	8b 45 10             	mov    0x10(%ebp),%eax
  803962:	83 e8 01             	sub    $0x1,%eax
  803965:	83 f8 01             	cmp    $0x1,%eax
  803968:	77 48                	ja     8039b2 <lwip_getsockopt+0x14f>
    /* UNIMPL case IP_HDRINCL: */
    /* UNIMPL case IP_RCVDSTADDR: */
    /* UNIMPL case IP_RCVIF: */
    case IP_TTL:
    case IP_TOS:
      if (*optlen < sizeof(int)) {
  80396a:	83 3f 03             	cmpl   $0x3,(%edi)
  80396d:	8d 76 00             	lea    0x0(%esi),%esi
  803970:	0f 86 c8 00 00 00    	jbe    803a3e <lwip_getsockopt+0x1db>
  803976:	eb 55                	jmp    8039cd <lwip_getsockopt+0x16a>
    break;
         
#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    if (*optlen < sizeof(int)) {
  803978:	83 3f 03             	cmpl   $0x3,(%edi)
  80397b:	90                   	nop
  80397c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803980:	0f 86 b8 00 00 00    	jbe    803a3e <lwip_getsockopt+0x1db>
      err = EINVAL;
      break;
    }
    
    /* If this is no TCP socket, ignore any options. */
    if (sock->conn->type != NETCONN_TCP)
  803986:	8b 00                	mov    (%eax),%eax
  803988:	83 38 10             	cmpl   $0x10,(%eax)
  80398b:	90                   	nop
  80398c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803990:	0f 85 9b 00 00 00    	jne    803a31 <lwip_getsockopt+0x1ce>
  803996:	8b 55 10             	mov    0x10(%ebp),%edx
  803999:	83 ea 01             	sub    $0x1,%edx
  80399c:	b8 5c 00 00 00       	mov    $0x5c,%eax
  8039a1:	83 fa 01             	cmp    $0x1,%edx
  8039a4:	77 15                	ja     8039bb <lwip_getsockopt+0x158>
  8039a6:	8b 55 10             	mov    0x10(%ebp),%edx
  8039a9:	0f b6 82 43 30 81 00 	movzbl 0x813043(%edx),%eax
  8039b0:	eb 05                	jmp    8039b7 <lwip_getsockopt+0x154>
  8039b2:	b8 5c 00 00 00       	mov    $0x5c,%eax
                                  s, level, optname));
      err = ENOPROTOOPT;
  }  /* switch */

   
  if (err != ERR_OK) {
  8039b7:	84 c0                	test   %al,%al
  8039b9:	74 12                	je     8039cd <lwip_getsockopt+0x16a>
    sock_set_errno(sock, err);
  8039bb:	0f be c0             	movsbl %al,%eax
  8039be:	89 43 10             	mov    %eax,0x10(%ebx)
  8039c1:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  8039c6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  8039cb:	eb 69                	jmp    803a36 <lwip_getsockopt+0x1d3>
  }

  /* Now do the actual option processing */
  data.sock = sock;
  8039cd:	89 5d cc             	mov    %ebx,-0x34(%ebp)
  data.level = level;
  8039d0:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  data.optname = optname;
  8039d3:	8b 45 10             	mov    0x10(%ebp),%eax
  8039d6:	89 45 d8             	mov    %eax,-0x28(%ebp)
  data.optval = optval;
  8039d9:	8b 55 14             	mov    0x14(%ebp),%edx
  8039dc:	89 55 dc             	mov    %edx,-0x24(%ebp)
  data.optlen = optlen;
  8039df:	89 7d e0             	mov    %edi,-0x20(%ebp)
  data.err = err;
  8039e2:	c6 45 e4 00          	movb   $0x0,-0x1c(%ebp)
  tcpip_callback(lwip_getsockopt_internal, &data);
  8039e6:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  8039ed:	00 
  8039ee:	8d 45 cc             	lea    -0x34(%ebp),%eax
  8039f1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8039f5:	c7 04 24 68 3b 80 00 	movl   $0x803b68,(%esp)
  8039fc:	e8 15 19 00 00       	call   805316 <tcpip_callback_with_block>
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  803a01:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803a08:	00 
  803a09:	8b 03                	mov    (%ebx),%eax
  803a0b:	8b 40 10             	mov    0x10(%eax),%eax
  803a0e:	89 04 24             	mov    %eax,(%esp)
  803a11:	e8 20 9f 00 00       	call   80d936 <sys_arch_sem_wait>
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;
  803a16:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax

  sock_set_errno(sock, err);
  803a1a:	0f be d0             	movsbl %al,%edx
  803a1d:	89 53 10             	mov    %edx,0x10(%ebx)
  803a20:	89 15 a0 f5 b3 00    	mov    %edx,0xb3f5a0
  return err ? -1 : 0;
  803a26:	84 c0                	test   %al,%al
  803a28:	74 07                	je     803a31 <lwip_getsockopt+0x1ce>
  803a2a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803a2f:	eb 05                	jmp    803a36 <lwip_getsockopt+0x1d3>
  803a31:	b8 00 00 00 00       	mov    $0x0,%eax
}
  803a36:	83 c4 3c             	add    $0x3c,%esp
  803a39:	5b                   	pop    %ebx
  803a3a:	5e                   	pop    %esi
  803a3b:	5f                   	pop    %edi
  803a3c:	5d                   	pop    %ebp
  803a3d:	c3                   	ret    
  sys_arch_sem_wait(sock->conn->op_completed, 0);
  /* maybe lwip_getsockopt_internal has changed err */
  err = data.err;

  sock_set_errno(sock, err);
  return err ? -1 : 0;
  803a3e:	b8 16 00 00 00       	mov    $0x16,%eax
  803a43:	e9 73 ff ff ff       	jmp    8039bb <lwip_getsockopt+0x158>
  803a48:	b8 61 00 00 00       	mov    $0x61,%eax
  803a4d:	e9 69 ff ff ff       	jmp    8039bb <lwip_getsockopt+0x158>

00803a52 <lwip_setsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_setsockopt_internal(void *arg)
{
  803a52:	55                   	push   %ebp
  803a53:	89 e5                	mov    %esp,%ebp
  803a55:	53                   	push   %ebx
  803a56:	83 ec 14             	sub    $0x14,%esp
  803a59:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  const void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  803a5c:	85 c0                	test   %eax,%eax
  803a5e:	75 1c                	jne    803a7c <lwip_setsockopt_internal+0x2a>
  803a60:	c7 44 24 08 1e 2f 81 	movl   $0x812f1e,0x8(%esp)
  803a67:	00 
  803a68:	c7 44 24 04 ae 06 00 	movl   $0x6ae,0x4(%esp)
  803a6f:	00 
  803a70:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  803a77:	e8 58 cf ff ff       	call   8009d4 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  803a7c:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  803a7e:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  803a81:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803a84:	8b 40 08             	mov    0x8(%eax),%eax
  803a87:	83 f8 06             	cmp    $0x6,%eax
  803a8a:	0f 84 8a 00 00 00    	je     803b1a <lwip_setsockopt_internal+0xc8>
  803a90:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803a95:	74 0e                	je     803aa5 <lwip_setsockopt_internal+0x53>
  803a97:	85 c0                	test   %eax,%eax
  803a99:	74 5d                	je     803af8 <lwip_setsockopt_internal+0xa6>
  803a9b:	90                   	nop
  803a9c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803aa0:	e9 b0 00 00 00       	jmp    803b55 <lwip_setsockopt_internal+0x103>

/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803aa5:	83 f9 20             	cmp    $0x20,%ecx
  803aa8:	74 11                	je     803abb <lwip_setsockopt_internal+0x69>
  803aaa:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803ab0:	74 2b                	je     803add <lwip_setsockopt_internal+0x8b>
  803ab2:	83 f9 08             	cmp    $0x8,%ecx
  803ab5:	0f 85 9a 00 00 00    	jne    803b55 <lwip_setsockopt_internal+0x103>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /* UNIMPL case SO_USELOOPBACK: */
      if (*(int*)optval) {
  803abb:	83 3b 00             	cmpl   $0x0,(%ebx)
  803abe:	66 90                	xchg   %ax,%ax
  803ac0:	74 0e                	je     803ad0 <lwip_setsockopt_internal+0x7e>
        sock->conn->pcb.ip->so_options |= optname;
  803ac2:	8b 02                	mov    (%edx),%eax
  803ac4:	8b 40 08             	mov    0x8(%eax),%eax
  803ac7:	66 09 48 08          	or     %cx,0x8(%eax)
  803acb:	e9 85 00 00 00       	jmp    803b55 <lwip_setsockopt_internal+0x103>
      } else {
        sock->conn->pcb.ip->so_options &= ~optname;
  803ad0:	8b 02                	mov    (%edx),%eax
  803ad2:	8b 40 08             	mov    0x8(%eax),%eax
  803ad5:	f7 d1                	not    %ecx
  803ad7:	66 21 48 08          	and    %cx,0x8(%eax)
  803adb:	eb 78                	jmp    803b55 <lwip_setsockopt_internal+0x103>
      sock->conn->recv_bufsize = ( *(int*)optval );
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      if (*(int*)optval) {
  803add:	83 3b 00             	cmpl   $0x0,(%ebx)
  803ae0:	74 0b                	je     803aed <lwip_setsockopt_internal+0x9b>
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) | UDP_FLAGS_NOCHKSUM);
  803ae2:	8b 02                	mov    (%edx),%eax
  803ae4:	8b 40 08             	mov    0x8(%eax),%eax
  803ae7:	80 48 10 01          	orb    $0x1,0x10(%eax)
  803aeb:	eb 68                	jmp    803b55 <lwip_setsockopt_internal+0x103>
      } else {
        udp_setflags(sock->conn->pcb.udp, udp_flags(sock->conn->pcb.udp) & ~UDP_FLAGS_NOCHKSUM);
  803aed:	8b 02                	mov    (%edx),%eax
  803aef:	8b 40 08             	mov    0x8(%eax),%eax
  803af2:	80 60 10 fe          	andb   $0xfe,0x10(%eax)
  803af6:	eb 5d                	jmp    803b55 <lwip_setsockopt_internal+0x103>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803af8:	83 f9 01             	cmp    $0x1,%ecx
  803afb:	74 11                	je     803b0e <lwip_setsockopt_internal+0xbc>
  803afd:	83 f9 02             	cmp    $0x2,%ecx
  803b00:	75 53                	jne    803b55 <lwip_setsockopt_internal+0x103>
    case IP_TTL:
      sock->conn->pcb.ip->ttl = (u8_t)(*(int*)optval);
  803b02:	8b 02                	mov    (%edx),%eax
  803b04:	8b 40 08             	mov    0x8(%eax),%eax
  803b07:	8b 0b                	mov    (%ebx),%ecx
  803b09:	88 48 0b             	mov    %cl,0xb(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TTL, ..) -> %u\n",
                  s, sock->conn->pcb.ip->ttl));
      break;
  803b0c:	eb 47                	jmp    803b55 <lwip_setsockopt_internal+0x103>
    case IP_TOS:
      sock->conn->pcb.ip->tos = (u8_t)(*(int*)optval);
  803b0e:	8b 02                	mov    (%edx),%eax
  803b10:	8b 40 08             	mov    0x8(%eax),%eax
  803b13:	8b 0b                	mov    (%ebx),%ecx
  803b15:	88 48 0a             	mov    %cl,0xa(%eax)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_IP, IP_TOS, ..)-> %u\n",
  803b18:	eb 3b                	jmp    803b55 <lwip_setsockopt_internal+0x103>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803b1a:	83 f9 01             	cmp    $0x1,%ecx
  803b1d:	74 0b                	je     803b2a <lwip_setsockopt_internal+0xd8>
  803b1f:	83 f9 02             	cmp    $0x2,%ecx
  803b22:	75 31                	jne    803b55 <lwip_setsockopt_internal+0x103>
  803b24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803b28:	eb 1e                	jmp    803b48 <lwip_setsockopt_internal+0xf6>
    case TCP_NODELAY:
      if (*(int*)optval) {
  803b2a:	83 3b 00             	cmpl   $0x0,(%ebx)
  803b2d:	8d 76 00             	lea    0x0(%esi),%esi
  803b30:	74 0b                	je     803b3d <lwip_setsockopt_internal+0xeb>
        sock->conn->pcb.tcp->flags |= TF_NODELAY;
  803b32:	8b 02                	mov    (%edx),%eax
  803b34:	8b 40 08             	mov    0x8(%eax),%eax
  803b37:	80 48 20 40          	orb    $0x40,0x20(%eax)
  803b3b:	eb 18                	jmp    803b55 <lwip_setsockopt_internal+0x103>
      } else {
        sock->conn->pcb.tcp->flags &= ~TF_NODELAY;
  803b3d:	8b 02                	mov    (%edx),%eax
  803b3f:	8b 40 08             	mov    0x8(%eax),%eax
  803b42:	80 60 20 bf          	andb   $0xbf,0x20(%eax)
  803b46:	eb 0d                	jmp    803b55 <lwip_setsockopt_internal+0x103>
      }
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_setsockopt(%d, IPPROTO_TCP, TCP_NODELAY) -> %s\n",
                  s, (*(int *)optval)?"on":"off") );
      break;
    case TCP_KEEPALIVE:
      sock->conn->pcb.tcp->keep_idle = (u32_t)(*(int*)optval);
  803b48:	8b 02                	mov    (%edx),%eax
  803b4a:	8b 40 08             	mov    0x8(%eax),%eax
  803b4d:	8b 0b                	mov    (%ebx),%ecx
  803b4f:	89 88 9c 00 00 00    	mov    %ecx,0x9c(%eax)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  }  /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  803b55:	8b 02                	mov    (%edx),%eax
  803b57:	8b 40 10             	mov    0x10(%eax),%eax
  803b5a:	89 04 24             	mov    %eax,(%esp)
  803b5d:	e8 c5 a0 00 00       	call   80dc27 <sys_sem_signal>
}
  803b62:	83 c4 14             	add    $0x14,%esp
  803b65:	5b                   	pop    %ebx
  803b66:	5d                   	pop    %ebp
  803b67:	c3                   	ret    

00803b68 <lwip_getsockopt_internal>:
  return err ? -1 : 0;
}

static void
lwip_getsockopt_internal(void *arg)
{
  803b68:	55                   	push   %ebp
  803b69:	89 e5                	mov    %esp,%ebp
  803b6b:	53                   	push   %ebx
  803b6c:	83 ec 14             	sub    $0x14,%esp
  803b6f:	8b 45 08             	mov    0x8(%ebp),%eax
#endif /* LWIP_DEBUG */
  int level, optname;
  void *optval;
  struct lwip_setgetsockopt_data *data;

  LWIP_ASSERT("arg != NULL", arg != NULL);
  803b72:	85 c0                	test   %eax,%eax
  803b74:	75 1c                	jne    803b92 <lwip_getsockopt_internal+0x2a>
  803b76:	c7 44 24 08 1e 2f 81 	movl   $0x812f1e,0x8(%esp)
  803b7d:	00 
  803b7e:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  803b85:	00 
  803b86:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  803b8d:	e8 42 ce ff ff       	call   8009d4 <_panic>

  data = (struct lwip_setgetsockopt_data*)arg;
  sock = data->sock;
  803b92:	8b 10                	mov    (%eax),%edx
#ifdef LWIP_DEBUG
  s = data->s;
#endif /* LWIP_DEBUG */
  level = data->level;
  optname = data->optname;
  803b94:	8b 48 0c             	mov    0xc(%eax),%ecx
  optval = data->optval;
  803b97:	8b 58 10             	mov    0x10(%eax),%ebx

  switch (level) {
  803b9a:	8b 40 08             	mov    0x8(%eax),%eax
  803b9d:	83 f8 06             	cmp    $0x6,%eax
  803ba0:	0f 84 2f 01 00 00    	je     803cd5 <lwip_getsockopt_internal+0x16d>
  803ba6:	3d ff 0f 00 00       	cmp    $0xfff,%eax
  803bab:	74 10                	je     803bbd <lwip_getsockopt_internal+0x55>
  803bad:	85 c0                	test   %eax,%eax
  803baf:	0f 84 fc 00 00 00    	je     803cb1 <lwip_getsockopt_internal+0x149>
  803bb5:	8d 76 00             	lea    0x0(%esi),%esi
  803bb8:	e9 42 01 00 00       	jmp    803cff <lwip_getsockopt_internal+0x197>
   
/* Level: SOL_SOCKET */
  case SOL_SOCKET:
    switch (optname) {
  803bbd:	83 f9 20             	cmp    $0x20,%ecx
  803bc0:	74 48                	je     803c0a <lwip_getsockopt_internal+0xa2>
  803bc2:	83 f9 20             	cmp    $0x20,%ecx
  803bc5:	8d 76 00             	lea    0x0(%esi),%esi
  803bc8:	7f 18                	jg     803be2 <lwip_getsockopt_internal+0x7a>
  803bca:	83 f9 02             	cmp    $0x2,%ecx
  803bcd:	8d 76 00             	lea    0x0(%esi),%esi
  803bd0:	74 38                	je     803c0a <lwip_getsockopt_internal+0xa2>
  803bd2:	83 f9 08             	cmp    $0x8,%ecx
  803bd5:	0f 85 24 01 00 00    	jne    803cff <lwip_getsockopt_internal+0x197>
  803bdb:	90                   	nop
  803bdc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803be0:	eb 28                	jmp    803c0a <lwip_getsockopt_internal+0xa2>
  803be2:	81 f9 08 10 00 00    	cmp    $0x1008,%ecx
  803be8:	74 32                	je     803c1c <lwip_getsockopt_internal+0xb4>
  803bea:	81 f9 0a 10 00 00    	cmp    $0x100a,%ecx
  803bf0:	0f 84 ab 00 00 00    	je     803ca1 <lwip_getsockopt_internal+0x139>
  803bf6:	81 f9 07 10 00 00    	cmp    $0x1007,%ecx
  803bfc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803c00:	0f 85 f9 00 00 00    	jne    803cff <lwip_getsockopt_internal+0x197>
  803c06:	66 90                	xchg   %ax,%ax
  803c08:	eb 62                	jmp    803c6c <lwip_getsockopt_internal+0x104>
#if SO_REUSE
    case SO_REUSEADDR:
    case SO_REUSEPORT:
#endif /* SO_REUSE */
    /*case SO_USELOOPBACK: UNIMPL */
      *(int*)optval = sock->conn->pcb.ip->so_options & optname;
  803c0a:	8b 02                	mov    (%edx),%eax
  803c0c:	8b 40 08             	mov    0x8(%eax),%eax
  803c0f:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  803c13:	21 c1                	and    %eax,%ecx
  803c15:	89 0b                	mov    %ecx,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, optname=0x%x, ..) = %s\n",
                                  s, optname, (*(int*)optval?"on":"off")));
      break;
  803c17:	e9 e3 00 00 00       	jmp    803cff <lwip_getsockopt_internal+0x197>

    case SO_TYPE:
      switch (NETCONNTYPE_GROUP(sock->conn->type)) {
  803c1c:	8b 02                	mov    (%edx),%eax
  803c1e:	8b 08                	mov    (%eax),%ecx
  803c20:	89 c8                	mov    %ecx,%eax
  803c22:	25 f0 00 00 00       	and    $0xf0,%eax
  803c27:	83 f8 20             	cmp    $0x20,%eax
  803c2a:	74 29                	je     803c55 <lwip_getsockopt_internal+0xed>
  803c2c:	83 f8 40             	cmp    $0x40,%eax
  803c2f:	74 09                	je     803c3a <lwip_getsockopt_internal+0xd2>
  803c31:	83 f8 10             	cmp    $0x10,%eax
  803c34:	75 2f                	jne    803c65 <lwip_getsockopt_internal+0xfd>
  803c36:	66 90                	xchg   %ax,%ax
  803c38:	eb 0b                	jmp    803c45 <lwip_getsockopt_internal+0xdd>
      case NETCONN_RAW:
        *(int*)optval = SOCK_RAW;
  803c3a:	c7 03 03 00 00 00    	movl   $0x3,(%ebx)
        break;
  803c40:	e9 ba 00 00 00       	jmp    803cff <lwip_getsockopt_internal+0x197>
      case NETCONN_TCP:
        *(int*)optval = SOCK_STREAM;
  803c45:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
        break;
  803c4b:	90                   	nop
  803c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803c50:	e9 aa 00 00 00       	jmp    803cff <lwip_getsockopt_internal+0x197>
      case NETCONN_UDP:
        *(int*)optval = SOCK_DGRAM;
  803c55:	c7 03 02 00 00 00    	movl   $0x2,(%ebx)
        break;
  803c5b:	90                   	nop
  803c5c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  803c60:	e9 9a 00 00 00       	jmp    803cff <lwip_getsockopt_internal+0x197>
      default: /* unrecognized socket type */
        *(int*)optval = sock->conn->type;
  803c65:	89 0b                	mov    %ecx,(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG,
  803c67:	e9 93 00 00 00       	jmp    803cff <lwip_getsockopt_internal+0x197>
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_TYPE) = %d\n",
                  s, *(int *)optval));
      break;

    case SO_ERROR:
      if (sock->err == 0) {
  803c6c:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  803c70:	75 21                	jne    803c93 <lwip_getsockopt_internal+0x12b>
        sock_set_errno(sock, err_to_errno(sock->conn->err));
  803c72:	8b 02                	mov    (%edx),%eax
  803c74:	0f be 48 0c          	movsbl 0xc(%eax),%ecx
  803c78:	f7 d9                	neg    %ecx
  803c7a:	b8 05 00 00 00       	mov    $0x5,%eax
  803c7f:	83 f9 0e             	cmp    $0xe,%ecx
  803c82:	77 07                	ja     803c8b <lwip_getsockopt_internal+0x123>
  803c84:	8b 04 8d 00 30 81 00 	mov    0x813000(,%ecx,4),%eax
  803c8b:	89 42 10             	mov    %eax,0x10(%edx)
  803c8e:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
      } 
      *(int *)optval = sock->err;
  803c93:	8b 42 10             	mov    0x10(%edx),%eax
  803c96:	89 03                	mov    %eax,(%ebx)
      sock->err = 0;
  803c98:	c7 42 10 00 00 00 00 	movl   $0x0,0x10(%edx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, SOL_SOCKET, SO_ERROR) = %d\n",
                  s, *(int *)optval));
      break;
  803c9f:	eb 5e                	jmp    803cff <lwip_getsockopt_internal+0x197>
      *(int *)optval = sock->conn->recv_bufsize;
      break;
#endif /* LWIP_SO_RCVBUF */
#if LWIP_UDP
    case SO_NO_CHECK:
      *(int*)optval = (udp_flags(sock->conn->pcb.udp) & UDP_FLAGS_NOCHKSUM) ? 1 : 0;
  803ca1:	8b 02                	mov    (%edx),%eax
  803ca3:	8b 40 08             	mov    0x8(%eax),%eax
  803ca6:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  803caa:	83 e0 01             	and    $0x1,%eax
  803cad:	89 03                	mov    %eax,(%ebx)
  803caf:	eb 4e                	jmp    803cff <lwip_getsockopt_internal+0x197>
    }  /* switch (optname) */
    break;

/* Level: IPPROTO_IP */
  case IPPROTO_IP:
    switch (optname) {
  803cb1:	83 f9 01             	cmp    $0x1,%ecx
  803cb4:	74 12                	je     803cc8 <lwip_getsockopt_internal+0x160>
  803cb6:	83 f9 02             	cmp    $0x2,%ecx
  803cb9:	75 44                	jne    803cff <lwip_getsockopt_internal+0x197>
    case IP_TTL:
      *(int*)optval = sock->conn->pcb.ip->ttl;
  803cbb:	8b 02                	mov    (%edx),%eax
  803cbd:	8b 40 08             	mov    0x8(%eax),%eax
  803cc0:	0f b6 40 0b          	movzbl 0xb(%eax),%eax
  803cc4:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TTL) = %d\n",
                  s, *(int *)optval));
      break;
  803cc6:	eb 37                	jmp    803cff <lwip_getsockopt_internal+0x197>
    case IP_TOS:
      *(int*)optval = sock->conn->pcb.ip->tos;
  803cc8:	8b 02                	mov    (%edx),%eax
  803cca:	8b 40 08             	mov    0x8(%eax),%eax
  803ccd:	0f b6 40 0a          	movzbl 0xa(%eax),%eax
  803cd1:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_IP, IP_TOS) = %d\n",
  803cd3:	eb 2a                	jmp    803cff <lwip_getsockopt_internal+0x197>
    break;

#if LWIP_TCP
/* Level: IPPROTO_TCP */
  case IPPROTO_TCP:
    switch (optname) {
  803cd5:	83 f9 01             	cmp    $0x1,%ecx
  803cd8:	74 08                	je     803ce2 <lwip_getsockopt_internal+0x17a>
  803cda:	83 f9 02             	cmp    $0x2,%ecx
  803cdd:	75 20                	jne    803cff <lwip_getsockopt_internal+0x197>
  803cdf:	90                   	nop
  803ce0:	eb 10                	jmp    803cf2 <lwip_getsockopt_internal+0x18a>
    case TCP_NODELAY:
      *(int*)optval = (sock->conn->pcb.tcp->flags & TF_NODELAY);
  803ce2:	8b 02                	mov    (%edx),%eax
  803ce4:	8b 40 08             	mov    0x8(%eax),%eax
  803ce7:	0f b6 40 20          	movzbl 0x20(%eax),%eax
  803ceb:	83 e0 40             	and    $0x40,%eax
  803cee:	89 03                	mov    %eax,(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getsockopt(%d, IPPROTO_TCP, TCP_NODELAY) = %s\n",
                  s, (*(int*)optval)?"on":"off") );
      break;
  803cf0:	eb 0d                	jmp    803cff <lwip_getsockopt_internal+0x197>
    case TCP_KEEPALIVE:
      *(int*)optval = (int)sock->conn->pcb.tcp->keep_idle;
  803cf2:	8b 02                	mov    (%edx),%eax
  803cf4:	8b 40 08             	mov    0x8(%eax),%eax
  803cf7:	8b 80 9c 00 00 00    	mov    0x9c(%eax),%eax
  803cfd:	89 03                	mov    %eax,(%ebx)
      break;
    }  /* switch (optname) */
    break;
#endif /* LWIP_UDP */
  } /* switch (level) */
  sys_sem_signal(sock->conn->op_completed);
  803cff:	8b 02                	mov    (%edx),%eax
  803d01:	8b 40 10             	mov    0x10(%eax),%eax
  803d04:	89 04 24             	mov    %eax,(%esp)
  803d07:	e8 1b 9f 00 00       	call   80dc27 <sys_sem_signal>
}
  803d0c:	83 c4 14             	add    $0x14,%esp
  803d0f:	5b                   	pop    %ebx
  803d10:	5d                   	pop    %ebp
  803d11:	c3                   	ret    

00803d12 <lwip_selscan>:
 * @param exceptset not yet implemented
 * @return number of sockets that had events (read+write)
 */
static int
lwip_selscan(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset)
{
  803d12:	55                   	push   %ebp
  803d13:	89 e5                	mov    %esp,%ebp
  803d15:	57                   	push   %edi
  803d16:	56                   	push   %esi
  803d17:	53                   	push   %ebx
  803d18:	83 ec 3c             	sub    $0x3c,%esp
  803d1b:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  803d1e:	89 55 d0             	mov    %edx,-0x30(%ebp)
  803d21:	89 4d cc             	mov    %ecx,-0x34(%ebp)
  int i, nready = 0;
  fd_set lreadset, lwriteset, lexceptset;
  struct lwip_socket *p_sock;
  
  FD_ZERO(&lreadset);
  803d24:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d2b:	00 
  803d2c:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d33:	00 
  803d34:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  803d37:	89 04 24             	mov    %eax,(%esp)
  803d3a:	e8 77 d5 ff ff       	call   8012b6 <memset>
  FD_ZERO(&lwriteset);
  803d3f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d46:	00 
  803d47:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d4e:	00 
  803d4f:	8d 45 e0             	lea    -0x20(%ebp),%eax
  803d52:	89 04 24             	mov    %eax,(%esp)
  803d55:	e8 5c d5 ff ff       	call   8012b6 <memset>
  FD_ZERO(&lexceptset);
  803d5a:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803d61:	00 
  803d62:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803d69:	00 
  803d6a:	8d 45 dc             	lea    -0x24(%ebp),%eax
  803d6d:	89 04 24             	mov    %eax,(%esp)
  803d70:	e8 41 d5 ff ff       	call   8012b6 <memset>
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803d75:	c7 45 c8 00 00 00 00 	movl   $0x0,-0x38(%ebp)
  803d7c:	bb 00 00 00 00       	mov    $0x0,%ebx
  803d81:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  803d85:	0f 8e 84 00 00 00    	jle    803e0f <lwip_selscan+0xfd>
    if (FD_ISSET(i, readset)) {
  803d8b:	89 de                	mov    %ebx,%esi
  803d8d:	c1 fe 1f             	sar    $0x1f,%esi
  803d90:	c1 ee 1d             	shr    $0x1d,%esi
  803d93:	01 de                	add    %ebx,%esi
  803d95:	c1 fe 03             	sar    $0x3,%esi
  803d98:	89 df                	mov    %ebx,%edi
  803d9a:	83 e7 07             	and    $0x7,%edi
  803d9d:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803da0:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803da4:	0f a3 f8             	bt     %edi,%eax
  803da7:	73 2a                	jae    803dd3 <lwip_selscan+0xc1>
      /* See if netconn of this socket is ready for read */
      p_sock = get_socket(i);
  803da9:	89 d8                	mov    %ebx,%eax
  803dab:	e8 00 f8 ff ff       	call   8035b0 <get_socket>
      if (p_sock && (p_sock->lastdata || p_sock->rcvevent)) {
  803db0:	85 c0                	test   %eax,%eax
  803db2:	74 1f                	je     803dd3 <lwip_selscan+0xc1>
  803db4:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  803db8:	75 08                	jne    803dc2 <lwip_selscan+0xb0>
  803dba:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  803dbf:	90                   	nop
  803dc0:	74 11                	je     803dd3 <lwip_selscan+0xc1>
        FD_SET(i, &lreadset);
  803dc2:	b8 01 00 00 00       	mov    $0x1,%eax
  803dc7:	89 f9                	mov    %edi,%ecx
  803dc9:	d3 e0                	shl    %cl,%eax
  803dcb:	08 44 35 e4          	or     %al,-0x1c(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for reading\n", i));
        nready++;
  803dcf:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
      }
    }
    if (FD_ISSET(i, writeset)) {
  803dd3:	8b 55 cc             	mov    -0x34(%ebp),%edx
  803dd6:	0f b6 04 32          	movzbl (%edx,%esi,1),%eax
  803dda:	0f a3 f8             	bt     %edi,%eax
  803ddd:	73 24                	jae    803e03 <lwip_selscan+0xf1>
      /* See if netconn of this socket is ready for write */
      p_sock = get_socket(i);
  803ddf:	89 d8                	mov    %ebx,%eax
  803de1:	e8 ca f7 ff ff       	call   8035b0 <get_socket>
      if (p_sock && p_sock->sendevent) {
  803de6:	85 c0                	test   %eax,%eax
  803de8:	74 19                	je     803e03 <lwip_selscan+0xf1>
  803dea:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  803def:	90                   	nop
  803df0:	74 11                	je     803e03 <lwip_selscan+0xf1>
        FD_SET(i, &lwriteset);
  803df2:	b8 01 00 00 00       	mov    $0x1,%eax
  803df7:	89 f9                	mov    %edi,%ecx
  803df9:	d3 e0                	shl    %cl,%eax
  803dfb:	08 44 35 e0          	or     %al,-0x20(%ebp,%esi,1)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
  803dff:	83 45 c8 01          	addl   $0x1,-0x38(%ebp)
  FD_ZERO(&lwriteset);
  FD_ZERO(&lexceptset);
  
  /* Go through each socket in each list to count number of sockets which
  currently match */
  for(i = 0; i < maxfdp1; i++) {
  803e03:	83 c3 01             	add    $0x1,%ebx
  803e06:	39 5d d4             	cmp    %ebx,-0x2c(%ebp)
  803e09:	0f 8f 7c ff ff ff    	jg     803d8b <lwip_selscan+0x79>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_selscan: fd=%d ready for writing\n", i));
        nready++;
      }
    }
  }
  *readset = lreadset;
  803e0f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  803e12:	8b 55 d0             	mov    -0x30(%ebp),%edx
  803e15:	89 02                	mov    %eax,(%edx)
  *writeset = lwriteset;
  803e17:	8b 45 e0             	mov    -0x20(%ebp),%eax
  803e1a:	8b 4d cc             	mov    -0x34(%ebp),%ecx
  803e1d:	89 01                	mov    %eax,(%ecx)
  FD_ZERO(exceptset);
  803e1f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  803e26:	00 
  803e27:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e2e:	00 
  803e2f:	8b 45 08             	mov    0x8(%ebp),%eax
  803e32:	89 04 24             	mov    %eax,(%esp)
  803e35:	e8 7c d4 ff ff       	call   8012b6 <memset>
  
  return nready;
}
  803e3a:	8b 45 c8             	mov    -0x38(%ebp),%eax
  803e3d:	83 c4 3c             	add    $0x3c,%esp
  803e40:	5b                   	pop    %ebx
  803e41:	5e                   	pop    %esi
  803e42:	5f                   	pop    %edi
  803e43:	5d                   	pop    %ebp
  803e44:	c3                   	ret    

00803e45 <lwip_getaddrname>:
  return lwip_close(s); /* XXX temporary hack until proper implementation */
}

static int
lwip_getaddrname(int s, struct sockaddr *name, socklen_t *namelen, u8_t local)
{
  803e45:	55                   	push   %ebp
  803e46:	89 e5                	mov    %esp,%ebp
  803e48:	83 ec 58             	sub    $0x58,%esp
  803e4b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  803e4e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  803e51:	89 7d fc             	mov    %edi,-0x4(%ebp)
  803e54:	89 d7                	mov    %edx,%edi
  803e56:	89 ce                	mov    %ecx,%esi
  803e58:	0f b6 55 08          	movzbl 0x8(%ebp),%edx
  803e5c:	88 55 c7             	mov    %dl,-0x39(%ebp)
  struct lwip_socket *sock;
  struct sockaddr_in sin;
  struct ip_addr naddr;

  sock = get_socket(s);
  803e5f:	e8 4c f7 ff ff       	call   8035b0 <get_socket>
  803e64:	89 c3                	mov    %eax,%ebx
  if (!sock)
  803e66:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  803e6b:	85 db                	test   %ebx,%ebx
  803e6d:	0f 84 8f 00 00 00    	je     803f02 <lwip_getaddrname+0xbd>
    return -1;

  memset(&sin, 0, sizeof(sin));
  803e73:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  803e7a:	00 
  803e7b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  803e82:	00 
  803e83:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803e86:	89 04 24             	mov    %eax,(%esp)
  803e89:	e8 28 d4 ff ff       	call   8012b6 <memset>
  sin.sin_len = sizeof(sin);
  803e8e:	c6 45 d8 10          	movb   $0x10,-0x28(%ebp)
  sin.sin_family = AF_INET;
  803e92:	c6 45 d9 02          	movb   $0x2,-0x27(%ebp)

  /* get the IP address and port */
  netconn_getaddr(sock->conn, &naddr, &sin.sin_port, local);
  803e96:	0f b6 45 c7          	movzbl -0x39(%ebp),%eax
  803e9a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  803e9e:	8d 45 da             	lea    -0x26(%ebp),%eax
  803ea1:	89 44 24 08          	mov    %eax,0x8(%esp)
  803ea5:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  803ea8:	89 44 24 04          	mov    %eax,0x4(%esp)
  803eac:	8b 03                	mov    (%ebx),%eax
  803eae:	89 04 24             	mov    %eax,(%esp)
  803eb1:	e8 0d aa 00 00       	call   80e8c3 <netconn_getaddr>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_getaddrname(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%d)\n", sin.sin_port));

  sin.sin_port = htons(sin.sin_port);
  803eb6:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  803eba:	89 04 24             	mov    %eax,(%esp)
  803ebd:	e8 92 6e 00 00       	call   80ad54 <htons>
  803ec2:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  803ec6:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  803ec9:	89 45 dc             	mov    %eax,-0x24(%ebp)

  if (*namelen > sizeof(sin))
  803ecc:	83 3e 10             	cmpl   $0x10,(%esi)
  803ecf:	76 06                	jbe    803ed7 <lwip_getaddrname+0x92>
    *namelen = sizeof(sin);
  803ed1:	c7 06 10 00 00 00    	movl   $0x10,(%esi)

  SMEMCPY(name, &sin, *namelen);
  803ed7:	8b 06                	mov    (%esi),%eax
  803ed9:	89 44 24 08          	mov    %eax,0x8(%esp)
  803edd:	8d 45 d8             	lea    -0x28(%ebp),%eax
  803ee0:	89 44 24 04          	mov    %eax,0x4(%esp)
  803ee4:	89 3c 24             	mov    %edi,(%esp)
  803ee7:	e8 a5 d4 ff ff       	call   801391 <memcpy>
  sock_set_errno(sock, 0);
  803eec:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  803ef3:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  803efa:	00 00 00 
  803efd:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  803f02:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  803f05:	8b 75 f8             	mov    -0x8(%ebp),%esi
  803f08:	8b 7d fc             	mov    -0x4(%ebp),%edi
  803f0b:	89 ec                	mov    %ebp,%esp
  803f0d:	5d                   	pop    %ebp
  803f0e:	c3                   	ret    

00803f0f <lwip_getsockname>:
  return lwip_getaddrname(s, name, namelen, 0);
}

int
lwip_getsockname(int s, struct sockaddr *name, socklen_t *namelen)
{
  803f0f:	55                   	push   %ebp
  803f10:	89 e5                	mov    %esp,%ebp
  803f12:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 1);
  803f15:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  803f1c:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803f1f:	8b 55 0c             	mov    0xc(%ebp),%edx
  803f22:	8b 45 08             	mov    0x8(%ebp),%eax
  803f25:	e8 1b ff ff ff       	call   803e45 <lwip_getaddrname>
}
  803f2a:	c9                   	leave  
  803f2b:	c3                   	ret    

00803f2c <lwip_getpeername>:
  return 0;
}

int
lwip_getpeername(int s, struct sockaddr *name, socklen_t *namelen)
{
  803f2c:	55                   	push   %ebp
  803f2d:	89 e5                	mov    %esp,%ebp
  803f2f:	83 ec 18             	sub    $0x18,%esp
  return lwip_getaddrname(s, name, namelen, 0);
  803f32:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  803f39:	8b 4d 10             	mov    0x10(%ebp),%ecx
  803f3c:	8b 55 0c             	mov    0xc(%ebp),%edx
  803f3f:	8b 45 08             	mov    0x8(%ebp),%eax
  803f42:	e8 fe fe ff ff       	call   803e45 <lwip_getaddrname>
}
  803f47:	c9                   	leave  
  803f48:	c3                   	ret    

00803f49 <alloc_socket>:
 * @param newconn the netconn for which to allocate a socket
 * @return the index of the new socket; -1 on error
 */
static int
alloc_socket(struct netconn *newconn)
{
  803f49:	55                   	push   %ebp
  803f4a:	89 e5                	mov    %esp,%ebp
  803f4c:	56                   	push   %esi
  803f4d:	53                   	push   %ebx
  803f4e:	83 ec 10             	sub    $0x10,%esp
  803f51:	89 c6                	mov    %eax,%esi
  int i;

  /* Protect socket array */
  sys_sem_wait(socksem);
  803f53:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  803f58:	89 04 24             	mov    %eax,(%esp)
  803f5b:	e8 da 46 00 00       	call   80863a <sys_sem_wait>

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
    if (!sockets[i].conn) {
  803f60:	b8 34 94 81 00       	mov    $0x819434,%eax
  803f65:	bb 01 00 00 00       	mov    $0x1,%ebx
  803f6a:	83 3d 20 94 81 00 00 	cmpl   $0x0,0x819420
  803f71:	75 04                	jne    803f77 <alloc_socket+0x2e>
  803f73:	b3 00                	mov    $0x0,%bl
  803f75:	eb 05                	jmp    803f7c <alloc_socket+0x33>
  803f77:	83 38 00             	cmpl   $0x0,(%eax)
  803f7a:	75 4b                	jne    803fc7 <alloc_socket+0x7e>
      sockets[i].conn       = newconn;
  803f7c:	ba 20 94 81 00       	mov    $0x819420,%edx
  803f81:	8d 04 9b             	lea    (%ebx,%ebx,4),%eax
  803f84:	c1 e0 02             	shl    $0x2,%eax
  803f87:	89 34 10             	mov    %esi,(%eax,%edx,1)
      sockets[i].lastdata   = NULL;
  803f8a:	c7 44 10 04 00 00 00 	movl   $0x0,0x4(%eax,%edx,1)
  803f91:	00 
      sockets[i].lastoffset = 0;
  803f92:	66 c7 44 10 08 00 00 	movw   $0x0,0x8(%eax,%edx,1)
      sockets[i].rcvevent   = 0;
  803f99:	66 c7 44 10 0a 00 00 	movw   $0x0,0xa(%eax,%edx,1)
      sockets[i].sendevent  = 1; /* TCP send buf is empty */
  803fa0:	66 c7 44 10 0c 01 00 	movw   $0x1,0xc(%eax,%edx,1)
      sockets[i].flags      = 0;
  803fa7:	66 c7 44 10 0e 00 00 	movw   $0x0,0xe(%eax,%edx,1)
      sockets[i].err        = 0;
  803fae:	c7 80 30 94 81 00 00 	movl   $0x0,0x819430(%eax)
  803fb5:	00 00 00 
      sys_sem_signal(socksem);
  803fb8:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  803fbd:	89 04 24             	mov    %eax,(%esp)
  803fc0:	e8 62 9c 00 00       	call   80dc27 <sys_sem_signal>
      return i;
  803fc5:	eb 1d                	jmp    803fe4 <alloc_socket+0x9b>

  /* Protect socket array */
  sys_sem_wait(socksem);

  /* allocate a new socket identifier */
  for (i = 0; i < NUM_SOCKETS; ++i) {
  803fc7:	83 c3 01             	add    $0x1,%ebx
  803fca:	83 c0 14             	add    $0x14,%eax
  803fcd:	83 fb 20             	cmp    $0x20,%ebx
  803fd0:	75 a5                	jne    803f77 <alloc_socket+0x2e>
      sockets[i].err        = 0;
      sys_sem_signal(socksem);
      return i;
    }
  }
  sys_sem_signal(socksem);
  803fd2:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  803fd7:	89 04 24             	mov    %eax,(%esp)
  803fda:	e8 48 9c 00 00       	call   80dc27 <sys_sem_signal>
  803fdf:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  return -1;
}
  803fe4:	89 d8                	mov    %ebx,%eax
  803fe6:	83 c4 10             	add    $0x10,%esp
  803fe9:	5b                   	pop    %ebx
  803fea:	5e                   	pop    %esi
  803feb:	5d                   	pop    %ebp
  803fec:	c3                   	ret    

00803fed <event_callback>:
 * Callback registered in the netconn layer for each socket-netconn.
 * Processes recvevent (data available) and wakes up tasks waiting for select.
 */
static void
event_callback(struct netconn *conn, enum netconn_evt evt, u16_t len)
{
  803fed:	55                   	push   %ebp
  803fee:	89 e5                	mov    %esp,%ebp
  803ff0:	57                   	push   %edi
  803ff1:	56                   	push   %esi
  803ff2:	53                   	push   %ebx
  803ff3:	83 ec 2c             	sub    $0x2c,%esp
  803ff6:	8b 75 08             	mov    0x8(%ebp),%esi
  803ff9:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct lwip_select_cb *scb;

  LWIP_UNUSED_ARG(len);

  /* Get socket */
  if (conn) {
  803ffc:	85 f6                	test   %esi,%esi
  803ffe:	0f 84 75 01 00 00    	je     804179 <event_callback+0x18c>
    s = conn->socket;
  804004:	8b 5e 1c             	mov    0x1c(%esi),%ebx
    if (s < 0) {
  804007:	85 db                	test   %ebx,%ebx
  804009:	79 3d                	jns    804048 <event_callback+0x5b>
      /* Data comes in right away after an accept, even though
       * the server task might not have created a new socket yet.
       * Just count down (or up) if that's the case and we
       * will use the data later. Note that only receive events
       * can happen before the new socket is set up. */
      sys_sem_wait(socksem);
  80400b:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  804010:	89 04 24             	mov    %eax,(%esp)
  804013:	e8 22 46 00 00       	call   80863a <sys_sem_wait>
      if (conn->socket < 0) {
  804018:	8b 46 1c             	mov    0x1c(%esi),%eax
  80401b:	85 c0                	test   %eax,%eax
  80401d:	79 1c                	jns    80403b <event_callback+0x4e>
        if (evt == NETCONN_EVT_RCVPLUS) {
  80401f:	85 ff                	test   %edi,%edi
  804021:	75 06                	jne    804029 <event_callback+0x3c>
          conn->socket--;
  804023:	83 e8 01             	sub    $0x1,%eax
  804026:	89 46 1c             	mov    %eax,0x1c(%esi)
        }
        sys_sem_signal(socksem);
  804029:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  80402e:	89 04 24             	mov    %eax,(%esp)
  804031:	e8 f1 9b 00 00       	call   80dc27 <sys_sem_signal>
        return;
  804036:	e9 3e 01 00 00       	jmp    804179 <event_callback+0x18c>
      }
      sys_sem_signal(socksem);
  80403b:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  804040:	89 04 24             	mov    %eax,(%esp)
  804043:	e8 df 9b 00 00       	call   80dc27 <sys_sem_signal>
    }

    sock = get_socket(s);
  804048:	89 d8                	mov    %ebx,%eax
  80404a:	e8 61 f5 ff ff       	call   8035b0 <get_socket>
  80404f:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    if (!sock) {
  804052:	85 c0                	test   %eax,%eax
  804054:	0f 84 1f 01 00 00    	je     804179 <event_callback+0x18c>
    }
  } else {
    return;
  }

  sys_sem_wait(selectsem);
  80405a:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  80405f:	89 04 24             	mov    %eax,(%esp)
  804062:	e8 d3 45 00 00       	call   80863a <sys_sem_wait>
  /* Set event as required */
  switch (evt) {
  804067:	83 ff 01             	cmp    $0x1,%edi
  80406a:	74 20                	je     80408c <event_callback+0x9f>
  80406c:	83 ff 01             	cmp    $0x1,%edi
  80406f:	72 11                	jb     804082 <event_callback+0x95>
  804071:	83 ff 02             	cmp    $0x2,%edi
  804074:	74 20                	je     804096 <event_callback+0xa9>
  804076:	83 ff 03             	cmp    $0x3,%edi
  804079:	75 31                	jne    8040ac <event_callback+0xbf>
  80407b:	90                   	nop
  80407c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  804080:	eb 1f                	jmp    8040a1 <event_callback+0xb4>
    case NETCONN_EVT_RCVPLUS:
      sock->rcvevent++;
  804082:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804085:	66 83 40 0a 01       	addw   $0x1,0xa(%eax)
      break;
  80408a:	eb 3c                	jmp    8040c8 <event_callback+0xdb>
    case NETCONN_EVT_RCVMINUS:
      sock->rcvevent--;
  80408c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80408f:	66 83 68 0a 01       	subw   $0x1,0xa(%eax)
      break;
  804094:	eb 32                	jmp    8040c8 <event_callback+0xdb>
    case NETCONN_EVT_SENDPLUS:
      sock->sendevent = 1;
  804096:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804099:	66 c7 40 0c 01 00    	movw   $0x1,0xc(%eax)
      break;
  80409f:	eb 27                	jmp    8040c8 <event_callback+0xdb>
    case NETCONN_EVT_SENDMINUS:
      sock->sendevent = 0;
  8040a1:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8040a4:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
      break;
  8040aa:	eb 1c                	jmp    8040c8 <event_callback+0xdb>
    default:
      LWIP_ASSERT("unknown event", 0);
  8040ac:	c7 44 24 08 41 2f 81 	movl   $0x812f41,0x8(%esp)
  8040b3:	00 
  8040b4:	c7 44 24 04 17 04 00 	movl   $0x417,0x4(%esp)
  8040bb:	00 
  8040bc:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  8040c3:	e8 0c c9 ff ff       	call   8009d4 <_panic>
      break;
  }
  sys_sem_signal(selectsem);
  8040c8:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  8040cd:	89 04 24             	mov    %eax,(%esp)
  8040d0:	e8 52 9b 00 00       	call   80dc27 <sys_sem_signal>
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
      if (scb->sem_signalled == 0) {
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  8040d5:	89 de                	mov    %ebx,%esi
  8040d7:	c1 fe 1f             	sar    $0x1f,%esi
  8040da:	c1 ee 1d             	shr    $0x1d,%esi
  8040dd:	01 de                	add    %ebx,%esi
  8040df:	c1 fe 03             	sar    $0x3,%esi
  8040e2:	89 d9                	mov    %ebx,%ecx
  8040e4:	83 e1 07             	and    $0x7,%ecx
  8040e7:	b8 01 00 00 00       	mov    $0x1,%eax
  8040ec:	89 c7                	mov    %eax,%edi
  8040ee:	d3 e7                	shl    %cl,%edi
     signalling for the select. This means we need to go through the list
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
  8040f0:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  8040f5:	89 04 24             	mov    %eax,(%esp)
  8040f8:	e8 3d 45 00 00       	call   80863a <sys_sem_wait>
    for (scb = select_cb_list; scb; scb = scb->next) {
  8040fd:	8b 1d a0 96 81 00    	mov    0x8196a0,%ebx
  804103:	85 db                	test   %ebx,%ebx
  804105:	74 65                	je     80416c <event_callback+0x17f>
      if (scb->sem_signalled == 0) {
  804107:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  80410b:	75 32                	jne    80413f <event_callback+0x152>
        /* Test this select call for our socket */
        if (scb->readset && FD_ISSET(s, scb->readset))
  80410d:	8b 43 04             	mov    0x4(%ebx),%eax
  804110:	85 c0                	test   %eax,%eax
  804112:	74 12                	je     804126 <event_callback+0x139>
  804114:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  804118:	85 f8                	test   %edi,%eax
  80411a:	74 0a                	je     804126 <event_callback+0x139>
          if (sock->rcvevent)
  80411c:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80411f:	66 83 78 0a 00       	cmpw   $0x0,0xa(%eax)
  804124:	75 21                	jne    804147 <event_callback+0x15a>
            break;
        if (scb->writeset && FD_ISSET(s, scb->writeset))
  804126:	8b 43 08             	mov    0x8(%ebx),%eax
  804129:	85 c0                	test   %eax,%eax
  80412b:	74 12                	je     80413f <event_callback+0x152>
  80412d:	0f b6 04 30          	movzbl (%eax,%esi,1),%eax
  804131:	85 f8                	test   %edi,%eax
  804133:	74 0a                	je     80413f <event_callback+0x152>
          if (sock->sendevent)
  804135:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804138:	66 83 78 0c 00       	cmpw   $0x0,0xc(%eax)
  80413d:	75 08                	jne    804147 <event_callback+0x15a>
     multiple times ONLY IF a select was actually waiting. We go through
     the list the number of waiting select calls + 1. This list is
     expected to be small. */
  while (1) {
    sys_sem_wait(selectsem);
    for (scb = select_cb_list; scb; scb = scb->next) {
  80413f:	8b 1b                	mov    (%ebx),%ebx
  804141:	85 db                	test   %ebx,%ebx
  804143:	75 c2                	jne    804107 <event_callback+0x11a>
  804145:	eb 25                	jmp    80416c <event_callback+0x17f>
        if (scb->writeset && FD_ISSET(s, scb->writeset))
          if (sock->sendevent)
            break;
      }
    }
    if (scb) {
  804147:	85 db                	test   %ebx,%ebx
  804149:	74 21                	je     80416c <event_callback+0x17f>
      scb->sem_signalled = 1;
  80414b:	c7 43 10 01 00 00 00 	movl   $0x1,0x10(%ebx)
      sys_sem_signal(selectsem);
  804152:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  804157:	89 04 24             	mov    %eax,(%esp)
  80415a:	e8 c8 9a 00 00       	call   80dc27 <sys_sem_signal>
      sys_sem_signal(scb->sem);
  80415f:	8b 43 14             	mov    0x14(%ebx),%eax
  804162:	89 04 24             	mov    %eax,(%esp)
  804165:	e8 bd 9a 00 00       	call   80dc27 <sys_sem_signal>
    } else {
      sys_sem_signal(selectsem);
      break;
    }
  }
  80416a:	eb 84                	jmp    8040f0 <event_callback+0x103>
    if (scb) {
      scb->sem_signalled = 1;
      sys_sem_signal(selectsem);
      sys_sem_signal(scb->sem);
    } else {
      sys_sem_signal(selectsem);
  80416c:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  804171:	89 04 24             	mov    %eax,(%esp)
  804174:	e8 ae 9a 00 00       	call   80dc27 <sys_sem_signal>
      break;
    }
  }
}
  804179:	83 c4 2c             	add    $0x2c,%esp
  80417c:	5b                   	pop    %ebx
  80417d:	5e                   	pop    %esi
  80417e:	5f                   	pop    %edi
  80417f:	5d                   	pop    %ebp
  804180:	c3                   	ret    

00804181 <lwip_socket_init>:
 * Initialize this module. This function has to be called before any other
 * functions in this module!
 */
void
lwip_socket_init(void)
{
  804181:	55                   	push   %ebp
  804182:	89 e5                	mov    %esp,%ebp
  804184:	83 ec 18             	sub    $0x18,%esp
  socksem   = sys_sem_new(1);
  804187:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80418e:	e8 f2 98 00 00       	call   80da85 <sys_sem_new>
  804193:	a3 a4 96 81 00       	mov    %eax,0x8196a4
  selectsem = sys_sem_new(1);
  804198:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80419f:	e8 e1 98 00 00       	call   80da85 <sys_sem_new>
  8041a4:	a3 a8 96 81 00       	mov    %eax,0x8196a8
}
  8041a9:	c9                   	leave  
  8041aa:	c3                   	ret    

008041ab <lwip_select>:
 * Processing exceptset is not yet implemented.
 */
int
lwip_select(int maxfdp1, fd_set *readset, fd_set *writeset, fd_set *exceptset,
               struct timeval *timeout)
{
  8041ab:	55                   	push   %ebp
  8041ac:	89 e5                	mov    %esp,%ebp
  8041ae:	57                   	push   %edi
  8041af:	56                   	push   %esi
  8041b0:	53                   	push   %ebx
  8041b1:	83 ec 5c             	sub    $0x5c,%esp
  8041b4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  8041b7:	8b 75 10             	mov    0x10(%ebp),%esi
  8041ba:	8b 5d 14             	mov    0x14(%ebp),%ebx

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select(%d, %p, %p, %p, tvsec=%ld tvusec=%ld)\n",
                  maxfdp1, (void *)readset, (void *) writeset, (void *) exceptset,
                  timeout ? timeout->tv_sec : -1L, timeout ? timeout->tv_usec : -1L));

  select_cb.next = 0;
  8041bd:	c7 45 c4 00 00 00 00 	movl   $0x0,-0x3c(%ebp)
  select_cb.readset = readset;
  8041c4:	89 7d c8             	mov    %edi,-0x38(%ebp)
  select_cb.writeset = writeset;
  8041c7:	89 75 cc             	mov    %esi,-0x34(%ebp)
  select_cb.exceptset = exceptset;
  8041ca:	89 5d d0             	mov    %ebx,-0x30(%ebp)
  select_cb.sem_signalled = 0;
  8041cd:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)

  /* Protect ourselves searching through the list */
  sys_sem_wait(selectsem);
  8041d4:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  8041d9:	89 04 24             	mov    %eax,(%esp)
  8041dc:	e8 59 44 00 00       	call   80863a <sys_sem_wait>

  if (readset)
  8041e1:	85 ff                	test   %edi,%edi
  8041e3:	74 07                	je     8041ec <lwip_select+0x41>
    lreadset = *readset;
  8041e5:	8b 07                	mov    (%edi),%eax
  8041e7:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  8041ea:	eb 1b                	jmp    804207 <lwip_select+0x5c>
  else
    FD_ZERO(&lreadset);
  8041ec:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8041f3:	00 
  8041f4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8041fb:	00 
  8041fc:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  8041ff:	89 04 24             	mov    %eax,(%esp)
  804202:	e8 af d0 ff ff       	call   8012b6 <memset>
  if (writeset)
  804207:	85 f6                	test   %esi,%esi
  804209:	74 07                	je     804212 <lwip_select+0x67>
    lwriteset = *writeset;
  80420b:	8b 06                	mov    (%esi),%eax
  80420d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  804210:	eb 1b                	jmp    80422d <lwip_select+0x82>
  else
    FD_ZERO(&lwriteset);
  804212:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804219:	00 
  80421a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804221:	00 
  804222:	8d 45 e0             	lea    -0x20(%ebp),%eax
  804225:	89 04 24             	mov    %eax,(%esp)
  804228:	e8 89 d0 ff ff       	call   8012b6 <memset>
  if (exceptset)
  80422d:	85 db                	test   %ebx,%ebx
  80422f:	74 07                	je     804238 <lwip_select+0x8d>
    lexceptset = *exceptset;
  804231:	8b 03                	mov    (%ebx),%eax
  804233:	89 45 dc             	mov    %eax,-0x24(%ebp)
  804236:	eb 1b                	jmp    804253 <lwip_select+0xa8>
  else
    FD_ZERO(&lexceptset);
  804238:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80423f:	00 
  804240:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804247:	00 
  804248:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80424b:	89 04 24             	mov    %eax,(%esp)
  80424e:	e8 63 d0 ff ff       	call   8012b6 <memset>

  /* Go through each socket in each list to count number of sockets which
     currently match */
  nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  804253:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  804256:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  804259:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80425c:	89 04 24             	mov    %eax,(%esp)
  80425f:	8b 45 08             	mov    0x8(%ebp),%eax
  804262:	e8 ab fa ff ff       	call   803d12 <lwip_selscan>
  804267:	89 45 b0             	mov    %eax,-0x50(%ebp)

  /* If we don't have any current events, then suspend if we are supposed to */
  if (!nready) {
  80426a:	85 c0                	test   %eax,%eax
  80426c:	0f 85 29 02 00 00    	jne    80449b <lwip_select+0x2f0>
    if (timeout && timeout->tv_sec == 0 && timeout->tv_usec == 0) {
  804272:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  804276:	0f 84 86 00 00 00    	je     804302 <lwip_select+0x157>
  80427c:	8b 45 18             	mov    0x18(%ebp),%eax
  80427f:	83 38 00             	cmpl   $0x0,(%eax)
  804282:	0f 85 50 02 00 00    	jne    8044d8 <lwip_select+0x32d>
  804288:	83 78 04 00          	cmpl   $0x0,0x4(%eax)
  80428c:	0f 85 46 02 00 00    	jne    8044d8 <lwip_select+0x32d>
      sys_sem_signal(selectsem);
  804292:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  804297:	89 04 24             	mov    %eax,(%esp)
  80429a:	e8 88 99 00 00       	call   80dc27 <sys_sem_signal>
      if (readset)
  80429f:	85 ff                	test   %edi,%edi
  8042a1:	74 18                	je     8042bb <lwip_select+0x110>
        FD_ZERO(readset);
  8042a3:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8042aa:	00 
  8042ab:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8042b2:	00 
  8042b3:	89 3c 24             	mov    %edi,(%esp)
  8042b6:	e8 fb cf ff ff       	call   8012b6 <memset>
      if (writeset)
  8042bb:	85 f6                	test   %esi,%esi
  8042bd:	74 18                	je     8042d7 <lwip_select+0x12c>
        FD_ZERO(writeset);
  8042bf:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8042c6:	00 
  8042c7:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8042ce:	00 
  8042cf:	89 34 24             	mov    %esi,(%esp)
  8042d2:	e8 df cf ff ff       	call   8012b6 <memset>
      if (exceptset)
  8042d7:	85 db                	test   %ebx,%ebx
  8042d9:	74 18                	je     8042f3 <lwip_select+0x148>
        FD_ZERO(exceptset);
  8042db:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8042e2:	00 
  8042e3:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8042ea:	00 
  8042eb:	89 1c 24             	mov    %ebx,(%esp)
  8042ee:	e8 c3 cf ff ff       	call   8012b6 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: no timeout, returning 0\n"));
      set_errno(0);
  8042f3:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  8042fa:	00 00 00 
  
      return 0;
  8042fd:	e9 cb 01 00 00       	jmp    8044cd <lwip_select+0x322>
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  804302:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804309:	e8 77 97 00 00       	call   80da85 <sys_sem_new>
  80430e:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  804311:	a1 a0 96 81 00       	mov    0x8196a0,%eax
  804316:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  804319:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  80431c:	a3 a0 96 81 00       	mov    %eax,0x8196a0
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  804321:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  804326:	89 04 24             	mov    %eax,(%esp)
  804329:	e8 f9 98 00 00       	call   80dc27 <sys_sem_signal>
  80432e:	ba 00 00 00 00       	mov    $0x0,%edx
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
      if(msectimeout == 0)
        msectimeout = 1;
    }
    
    i = sys_sem_wait_timeout(select_cb.sem, msectimeout);
  804333:	89 54 24 04          	mov    %edx,0x4(%esp)
  804337:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80433a:	89 04 24             	mov    %eax,(%esp)
  80433d:	e8 87 43 00 00       	call   8086c9 <sys_sem_wait_timeout>
  804342:	89 45 b4             	mov    %eax,-0x4c(%ebp)
    
    /* Take us off the list */
    sys_sem_wait(selectsem);
  804345:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  80434a:	89 04 24             	mov    %eax,(%esp)
  80434d:	e8 e8 42 00 00       	call   80863a <sys_sem_wait>
    if (select_cb_list == &select_cb)
  804352:	a1 a0 96 81 00       	mov    0x8196a0,%eax
  804357:	8d 55 c4             	lea    -0x3c(%ebp),%edx
  80435a:	39 d0                	cmp    %edx,%eax
  80435c:	75 1f                	jne    80437d <lwip_select+0x1d2>
      select_cb_list = select_cb.next;
  80435e:	8b 45 c4             	mov    -0x3c(%ebp),%eax
  804361:	a3 a0 96 81 00       	mov    %eax,0x8196a0
  804366:	eb 27                	jmp    80438f <lwip_select+0x1e4>
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
        if (p_selcb->next == &select_cb) {
  804368:	8b 10                	mov    (%eax),%edx
  80436a:	39 ca                	cmp    %ecx,%edx
  80436c:	74 08                	je     804376 <lwip_select+0x1cb>
  80436e:	89 d0                	mov    %edx,%eax
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  804370:	85 c0                	test   %eax,%eax
  804372:	75 f4                	jne    804368 <lwip_select+0x1bd>
  804374:	eb 19                	jmp    80438f <lwip_select+0x1e4>
        if (p_selcb->next == &select_cb) {
          p_selcb->next = select_cb.next;
  804376:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804379:	89 10                	mov    %edx,(%eax)
          break;
  80437b:	eb 12                	jmp    80438f <lwip_select+0x1e4>
    /* Take us off the list */
    sys_sem_wait(selectsem);
    if (select_cb_list == &select_cb)
      select_cb_list = select_cb.next;
    else
      for (p_selcb = select_cb_list; p_selcb; p_selcb = p_selcb->next) {
  80437d:	85 c0                	test   %eax,%eax
  80437f:	90                   	nop
  804380:	74 0d                	je     80438f <lwip_select+0x1e4>
        if (p_selcb->next == &select_cb) {
  804382:	8b 10                	mov    (%eax),%edx
  804384:	8d 4d c4             	lea    -0x3c(%ebp),%ecx
  804387:	39 ca                	cmp    %ecx,%edx
  804389:	74 eb                	je     804376 <lwip_select+0x1cb>
  80438b:	89 d0                	mov    %edx,%eax
  80438d:	eb e1                	jmp    804370 <lwip_select+0x1c5>
          p_selcb->next = select_cb.next;
          break;
        }
      }
    
    sys_sem_signal(selectsem);
  80438f:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  804394:	89 04 24             	mov    %eax,(%esp)
  804397:	e8 8b 98 00 00       	call   80dc27 <sys_sem_signal>
    
    sys_sem_free(select_cb.sem);
  80439c:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80439f:	89 04 24             	mov    %eax,(%esp)
  8043a2:	e8 3c 92 00 00       	call   80d5e3 <sys_sem_free>
    if (i == 0)  {
  8043a7:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8043ab:	75 63                	jne    804410 <lwip_select+0x265>
      /* Timeout */
      if (readset)
  8043ad:	85 ff                	test   %edi,%edi
  8043af:	74 18                	je     8043c9 <lwip_select+0x21e>
        FD_ZERO(readset);
  8043b1:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8043b8:	00 
  8043b9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043c0:	00 
  8043c1:	89 3c 24             	mov    %edi,(%esp)
  8043c4:	e8 ed ce ff ff       	call   8012b6 <memset>
      if (writeset)
  8043c9:	85 f6                	test   %esi,%esi
  8043cb:	74 18                	je     8043e5 <lwip_select+0x23a>
        FD_ZERO(writeset);
  8043cd:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8043d4:	00 
  8043d5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043dc:	00 
  8043dd:	89 34 24             	mov    %esi,(%esp)
  8043e0:	e8 d1 ce ff ff       	call   8012b6 <memset>
      if (exceptset)
  8043e5:	85 db                	test   %ebx,%ebx
  8043e7:	74 18                	je     804401 <lwip_select+0x256>
        FD_ZERO(exceptset);
  8043e9:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  8043f0:	00 
  8043f1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8043f8:	00 
  8043f9:	89 1c 24             	mov    %ebx,(%esp)
  8043fc:	e8 b5 ce ff ff       	call   8012b6 <memset>
  
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: timeout expired\n"));
      set_errno(0);
  804401:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804408:	00 00 00 
  
      return 0;
  80440b:	e9 bd 00 00 00       	jmp    8044cd <lwip_select+0x322>
    }
    
    if (readset)
  804410:	85 ff                	test   %edi,%edi
  804412:	74 07                	je     80441b <lwip_select+0x270>
      lreadset = *readset;
  804414:	8b 07                	mov    (%edi),%eax
  804416:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  804419:	eb 1b                	jmp    804436 <lwip_select+0x28b>
    else
      FD_ZERO(&lreadset);
  80441b:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804422:	00 
  804423:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80442a:	00 
  80442b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80442e:	89 04 24             	mov    %eax,(%esp)
  804431:	e8 80 ce ff ff       	call   8012b6 <memset>
    if (writeset)
  804436:	85 f6                	test   %esi,%esi
  804438:	74 07                	je     804441 <lwip_select+0x296>
      lwriteset = *writeset;
  80443a:	8b 06                	mov    (%esi),%eax
  80443c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80443f:	eb 1b                	jmp    80445c <lwip_select+0x2b1>
    else
      FD_ZERO(&lwriteset);
  804441:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  804448:	00 
  804449:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804450:	00 
  804451:	8d 45 e0             	lea    -0x20(%ebp),%eax
  804454:	89 04 24             	mov    %eax,(%esp)
  804457:	e8 5a ce ff ff       	call   8012b6 <memset>
    if (exceptset)
  80445c:	85 db                	test   %ebx,%ebx
  80445e:	74 07                	je     804467 <lwip_select+0x2bc>
      lexceptset = *exceptset;
  804460:	8b 03                	mov    (%ebx),%eax
  804462:	89 45 dc             	mov    %eax,-0x24(%ebp)
  804465:	eb 1b                	jmp    804482 <lwip_select+0x2d7>
    else
      FD_ZERO(&lexceptset);
  804467:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80446e:	00 
  80446f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804476:	00 
  804477:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80447a:	89 04 24             	mov    %eax,(%esp)
  80447d:	e8 34 ce ff ff       	call   8012b6 <memset>
    
    /* See what's set */
    nready = lwip_selscan(maxfdp1, &lreadset, &lwriteset, &lexceptset);
  804482:	8d 4d e0             	lea    -0x20(%ebp),%ecx
  804485:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  804488:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80448b:	89 04 24             	mov    %eax,(%esp)
  80448e:	8b 45 08             	mov    0x8(%ebp),%eax
  804491:	e8 7c f8 ff ff       	call   803d12 <lwip_selscan>
  804496:	89 45 b0             	mov    %eax,-0x50(%ebp)
  804499:	eb 0d                	jmp    8044a8 <lwip_select+0x2fd>
  } else
    sys_sem_signal(selectsem);
  80449b:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  8044a0:	89 04 24             	mov    %eax,(%esp)
  8044a3:	e8 7f 97 00 00       	call   80dc27 <sys_sem_signal>
  
  if (readset)
  8044a8:	85 ff                	test   %edi,%edi
  8044aa:	74 05                	je     8044b1 <lwip_select+0x306>
    *readset = lreadset;
  8044ac:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8044af:	89 07                	mov    %eax,(%edi)
  if (writeset)
  8044b1:	85 f6                	test   %esi,%esi
  8044b3:	74 05                	je     8044ba <lwip_select+0x30f>
    *writeset = lwriteset;
  8044b5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  8044b8:	89 06                	mov    %eax,(%esi)
  if (exceptset)
  8044ba:	85 db                	test   %ebx,%ebx
  8044bc:	74 05                	je     8044c3 <lwip_select+0x318>
    *exceptset = lexceptset;
  8044be:	8b 45 dc             	mov    -0x24(%ebp),%eax
  8044c1:	89 03                	mov    %eax,(%ebx)
  
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_select: nready=%d\n", nready));
  set_errno(0);
  8044c3:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  8044ca:	00 00 00 
  
  return nready;
}
  8044cd:	8b 45 b0             	mov    -0x50(%ebp),%eax
  8044d0:	83 c4 5c             	add    $0x5c,%esp
  8044d3:	5b                   	pop    %ebx
  8044d4:	5e                   	pop    %esi
  8044d5:	5f                   	pop    %edi
  8044d6:	5d                   	pop    %ebp
  8044d7:	c3                   	ret    
    /* add our semaphore to list */
    /* We don't actually need any dynamic memory. Our entry on the
     * list is only valid while we are in this function, so it's ok
     * to use local variables */
    
    select_cb.sem = sys_sem_new(0);
  8044d8:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  8044df:	e8 a1 95 00 00       	call   80da85 <sys_sem_new>
  8044e4:	89 45 d8             	mov    %eax,-0x28(%ebp)
    /* Note that we are still protected */
    /* Put this select_cb on top of list */
    select_cb.next = select_cb_list;
  8044e7:	a1 a0 96 81 00       	mov    0x8196a0,%eax
  8044ec:	89 45 c4             	mov    %eax,-0x3c(%ebp)
    select_cb_list = &select_cb;
  8044ef:	8d 45 c4             	lea    -0x3c(%ebp),%eax
  8044f2:	a3 a0 96 81 00       	mov    %eax,0x8196a0
    
    /* Now we can safely unprotect */
    sys_sem_signal(selectsem);
  8044f7:	a1 a8 96 81 00       	mov    0x8196a8,%eax
  8044fc:	89 04 24             	mov    %eax,(%esp)
  8044ff:	e8 23 97 00 00       	call   80dc27 <sys_sem_signal>
    /* Now just wait to be woken */
    if (timeout == 0)
      /* Wait forever */
      msectimeout = 0;
    else {
      msectimeout =  ((timeout->tv_sec * 1000) + ((timeout->tv_usec + 500)/1000));
  804504:	8b 45 18             	mov    0x18(%ebp),%eax
  804507:	8b 48 04             	mov    0x4(%eax),%ecx
  80450a:	81 c1 f4 01 00 00    	add    $0x1f4,%ecx
  804510:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  804515:	89 c8                	mov    %ecx,%eax
  804517:	f7 ea                	imul   %edx
  804519:	c1 fa 06             	sar    $0x6,%edx
  80451c:	c1 f9 1f             	sar    $0x1f,%ecx
  80451f:	29 ca                	sub    %ecx,%edx
  804521:	8b 45 18             	mov    0x18(%ebp),%eax
  804524:	69 08 e8 03 00 00    	imul   $0x3e8,(%eax),%ecx
      if(msectimeout == 0)
  80452a:	01 ca                	add    %ecx,%edx
  80452c:	0f 85 01 fe ff ff    	jne    804333 <lwip_select+0x188>
  804532:	ba 01 00 00 00       	mov    $0x1,%edx
  804537:	e9 f7 fd ff ff       	jmp    804333 <lwip_select+0x188>

0080453c <lwip_socket>:
  return (err==ERR_OK?size:-1);
}

int
lwip_socket(int domain, int type, int protocol)
{
  80453c:	55                   	push   %ebp
  80453d:	89 e5                	mov    %esp,%ebp
  80453f:	56                   	push   %esi
  804540:	53                   	push   %ebx
  804541:	83 ec 10             	sub    $0x10,%esp
  804544:	8b 45 0c             	mov    0xc(%ebp),%eax
  804547:	8b 55 10             	mov    0x10(%ebp),%edx
  int i;

  LWIP_UNUSED_ARG(domain);

  /* create a netconn */
  switch (type) {
  80454a:	83 f8 02             	cmp    $0x2,%eax
  80454d:	74 32                	je     804581 <lwip_socket+0x45>
  80454f:	83 f8 03             	cmp    $0x3,%eax
  804552:	74 0e                	je     804562 <lwip_socket+0x26>
  804554:	83 f8 01             	cmp    $0x1,%eax
  804557:	75 73                	jne    8045cc <lwip_socket+0x90>
  804559:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  804560:	eb 4a                	jmp    8045ac <lwip_socket+0x70>
  case SOCK_RAW:
    conn = netconn_new_with_proto_and_callback(NETCONN_RAW, (u8_t)protocol, event_callback);
  804562:	c7 44 24 08 ed 3f 80 	movl   $0x803fed,0x8(%esp)
  804569:	00 
  80456a:	0f b6 d2             	movzbl %dl,%edx
  80456d:	89 54 24 04          	mov    %edx,0x4(%esp)
  804571:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  804578:	e8 5b a6 00 00       	call   80ebd8 <netconn_new_with_proto_and_callback>
  80457d:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_RAW, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  80457f:	eb 5c                	jmp    8045dd <lwip_socket+0xa1>
  case SOCK_DGRAM:
    conn = netconn_new_with_callback( (protocol == IPPROTO_UDPLITE) ?
  804581:	81 fa 88 00 00 00    	cmp    $0x88,%edx
  804587:	0f 94 c0             	sete   %al
  80458a:	0f b6 c0             	movzbl %al,%eax
  80458d:	83 c0 20             	add    $0x20,%eax
  804590:	c7 44 24 08 ed 3f 80 	movl   $0x803fed,0x8(%esp)
  804597:	00 
  804598:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80459f:	00 
  8045a0:	89 04 24             	mov    %eax,(%esp)
  8045a3:	e8 30 a6 00 00       	call   80ebd8 <netconn_new_with_proto_and_callback>
  8045a8:	89 c6                	mov    %eax,%esi
                 NETCONN_UDPLITE : NETCONN_UDP, event_callback);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_DGRAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8045aa:	eb 31                	jmp    8045dd <lwip_socket+0xa1>
  case SOCK_STREAM:
    conn = netconn_new_with_callback(NETCONN_TCP, event_callback);
  8045ac:	c7 44 24 08 ed 3f 80 	movl   $0x803fed,0x8(%esp)
  8045b3:	00 
  8045b4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8045bb:	00 
  8045bc:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  8045c3:	e8 10 a6 00 00       	call   80ebd8 <netconn_new_with_proto_and_callback>
  8045c8:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%s, SOCK_STREAM, %d) = ",
                                 domain == PF_INET ? "PF_INET" : "UNKNOWN", protocol));
    break;
  8045ca:	eb 11                	jmp    8045dd <lwip_socket+0xa1>
  default:
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_socket(%d, %d/UNKNOWN, %d) = -1\n",
                                 domain, type, protocol));
    set_errno(EINVAL);
  8045cc:	c7 05 a0 f5 b3 00 16 	movl   $0x16,0xb3f5a0
  8045d3:	00 00 00 
  8045d6:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  8045db:	eb 44                	jmp    804621 <lwip_socket+0xe5>
  }

  if (!conn) {
  8045dd:	85 f6                	test   %esi,%esi
  8045df:	75 11                	jne    8045f2 <lwip_socket+0xb6>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("-1 / ENOBUFS (could not create netconn)\n"));
    set_errno(ENOBUFS);
  8045e1:	c7 05 a0 f5 b3 00 69 	movl   $0x69,0xb3f5a0
  8045e8:	00 00 00 
  8045eb:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
    return -1;
  8045f0:	eb 2f                	jmp    804621 <lwip_socket+0xe5>
  }

  i = alloc_socket(conn);
  8045f2:	89 f0                	mov    %esi,%eax
  8045f4:	e8 50 f9 ff ff       	call   803f49 <alloc_socket>
  8045f9:	89 c3                	mov    %eax,%ebx

  if (i == -1) {
  8045fb:	83 f8 ff             	cmp    $0xffffffff,%eax
  8045fe:	75 14                	jne    804614 <lwip_socket+0xd8>
    netconn_delete(conn);
  804600:	89 34 24             	mov    %esi,(%esp)
  804603:	e8 93 a5 00 00       	call   80eb9b <netconn_delete>
    set_errno(ENFILE);
  804608:	c7 05 a0 f5 b3 00 17 	movl   $0x17,0xb3f5a0
  80460f:	00 00 00 
    return -1;
  804612:	eb 0d                	jmp    804621 <lwip_socket+0xe5>
  }
  conn->socket = i;
  804614:	89 46 1c             	mov    %eax,0x1c(%esi)
  LWIP_DEBUGF(SOCKETS_DEBUG, ("%d\n", i));
  set_errno(0);
  804617:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  80461e:	00 00 00 
  return i;
}
  804621:	89 d8                	mov    %ebx,%eax
  804623:	83 c4 10             	add    $0x10,%esp
  804626:	5b                   	pop    %ebx
  804627:	5e                   	pop    %esi
  804628:	5d                   	pop    %ebp
  804629:	c3                   	ret    

0080462a <lwip_send>:
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
}

int
lwip_send(int s, const void *data, int size, unsigned int flags)
{
  80462a:	55                   	push   %ebp
  80462b:	89 e5                	mov    %esp,%ebp
  80462d:	83 ec 38             	sub    $0x38,%esp
  804630:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  804633:	89 75 f8             	mov    %esi,-0x8(%ebp)
  804636:	89 7d fc             	mov    %edi,-0x4(%ebp)
  804639:	8b 7d 08             	mov    0x8(%ebp),%edi
  80463c:	8b 75 10             	mov    0x10(%ebp),%esi
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d, data=%p, size=%d, flags=0x%x)\n",
                              s, data, size, flags));

  sock = get_socket(s);
  80463f:	89 f8                	mov    %edi,%eax
  804641:	e8 6a ef ff ff       	call   8035b0 <get_socket>
  804646:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804648:	85 c0                	test   %eax,%eax
  80464a:	0f 84 80 00 00 00    	je     8046d0 <lwip_send+0xa6>
    return -1;

  if (sock->conn->type!=NETCONN_TCP) {
  804650:	8b 00                	mov    (%eax),%eax
  804652:	83 38 10             	cmpl   $0x10,(%eax)
  804655:	74 2e                	je     804685 <lwip_send+0x5b>
#if (LWIP_UDP || LWIP_RAW)
    return lwip_sendto(s, data, size, flags, NULL, 0);
  804657:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80465e:	00 
  80465f:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804666:	00 
  804667:	8b 45 14             	mov    0x14(%ebp),%eax
  80466a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80466e:	89 74 24 08          	mov    %esi,0x8(%esp)
  804672:	8b 55 0c             	mov    0xc(%ebp),%edx
  804675:	89 54 24 04          	mov    %edx,0x4(%esp)
  804679:	89 3c 24             	mov    %edi,(%esp)
  80467c:	e8 8c 00 00 00       	call   80470d <lwip_sendto>
  804681:	89 c6                	mov    %eax,%esi
  804683:	eb 50                	jmp    8046d5 <lwip_send+0xab>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  err = netconn_write(sock->conn, data, size, NETCONN_COPY | ((flags & MSG_MORE)?NETCONN_MORE:0));
  804685:	8b 55 14             	mov    0x14(%ebp),%edx
  804688:	83 e2 10             	and    $0x10,%edx
  80468b:	83 fa 01             	cmp    $0x1,%edx
  80468e:	19 d2                	sbb    %edx,%edx
  804690:	83 e2 fe             	and    $0xfffffffe,%edx
  804693:	83 c2 03             	add    $0x3,%edx
  804696:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80469a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80469e:	8b 55 0c             	mov    0xc(%ebp),%edx
  8046a1:	89 54 24 04          	mov    %edx,0x4(%esp)
  8046a5:	89 04 24             	mov    %eax,(%esp)
  8046a8:	e8 d9 9f 00 00       	call   80e686 <netconn_write>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_send(%d) err=%d size=%d\n", s, err, size));
  sock_set_errno(sock, err_to_errno(err));
  8046ad:	0f be c8             	movsbl %al,%ecx
  8046b0:	f7 d9                	neg    %ecx
  8046b2:	ba 05 00 00 00       	mov    $0x5,%edx
  8046b7:	83 f9 0e             	cmp    $0xe,%ecx
  8046ba:	77 07                	ja     8046c3 <lwip_send+0x99>
  8046bc:	8b 14 8d 00 30 81 00 	mov    0x813000(,%ecx,4),%edx
  8046c3:	89 53 10             	mov    %edx,0x10(%ebx)
  8046c6:	89 15 a0 f5 b3 00    	mov    %edx,0xb3f5a0
  return (err==ERR_OK?size:-1);
  8046cc:	84 c0                	test   %al,%al
  8046ce:	74 05                	je     8046d5 <lwip_send+0xab>
  8046d0:	be ff ff ff ff       	mov    $0xffffffff,%esi
}
  8046d5:	89 f0                	mov    %esi,%eax
  8046d7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8046da:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8046dd:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8046e0:	89 ec                	mov    %ebp,%esp
  8046e2:	5d                   	pop    %ebp
  8046e3:	c3                   	ret    

008046e4 <lwip_write>:
  return i;
}

int
lwip_write(int s, const void *data, int size)
{
  8046e4:	55                   	push   %ebp
  8046e5:	89 e5                	mov    %esp,%ebp
  8046e7:	83 ec 18             	sub    $0x18,%esp
  return lwip_send(s, data, size, 0);
  8046ea:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8046f1:	00 
  8046f2:	8b 45 10             	mov    0x10(%ebp),%eax
  8046f5:	89 44 24 08          	mov    %eax,0x8(%esp)
  8046f9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8046fc:	89 44 24 04          	mov    %eax,0x4(%esp)
  804700:	8b 45 08             	mov    0x8(%ebp),%eax
  804703:	89 04 24             	mov    %eax,(%esp)
  804706:	e8 1f ff ff ff       	call   80462a <lwip_send>
}
  80470b:	c9                   	leave  
  80470c:	c3                   	ret    

0080470d <lwip_sendto>:
}

int
lwip_sendto(int s, const void *data, int size, unsigned int flags,
       struct sockaddr *to, socklen_t tolen)
{
  80470d:	55                   	push   %ebp
  80470e:	89 e5                	mov    %esp,%ebp
  804710:	57                   	push   %edi
  804711:	56                   	push   %esi
  804712:	53                   	push   %ebx
  804713:	83 ec 3c             	sub    $0x3c,%esp
  804716:	8b 7d 10             	mov    0x10(%ebp),%edi
  804719:	8b 75 18             	mov    0x18(%ebp),%esi
#if !LWIP_TCPIP_CORE_LOCKING
  struct netbuf buf;
  u16_t remote_port;
#endif

  sock = get_socket(s);
  80471c:	8b 45 08             	mov    0x8(%ebp),%eax
  80471f:	e8 8c ee ff ff       	call   8035b0 <get_socket>
  804724:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804726:	85 c0                	test   %eax,%eax
  804728:	0f 84 2e 01 00 00    	je     80485c <lwip_sendto+0x14f>
    return -1;

  if (sock->conn->type==NETCONN_TCP) {
  80472e:	8b 00                	mov    (%eax),%eax
  804730:	83 38 10             	cmpl   $0x10,(%eax)
  804733:	75 24                	jne    804759 <lwip_sendto+0x4c>
#if LWIP_TCP
    return lwip_send(s, data, size, flags);
  804735:	8b 45 14             	mov    0x14(%ebp),%eax
  804738:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80473c:	89 7c 24 08          	mov    %edi,0x8(%esp)
  804740:	8b 45 0c             	mov    0xc(%ebp),%eax
  804743:	89 44 24 04          	mov    %eax,0x4(%esp)
  804747:	8b 45 08             	mov    0x8(%ebp),%eax
  80474a:	89 04 24             	mov    %eax,(%esp)
  80474d:	e8 d8 fe ff ff       	call   80462a <lwip_send>
  804752:	89 c7                	mov    %eax,%edi
  804754:	e9 08 01 00 00       	jmp    804861 <lwip_sendto+0x154>
    sock_set_errno(sock, err_to_errno(ERR_ARG));
    return -1;
#endif /* LWIP_TCP */
  }

  LWIP_ASSERT("lwip_sendto: size must fit in u16_t",
  804759:	81 ff ff ff 00 00    	cmp    $0xffff,%edi
  80475f:	76 1c                	jbe    80477d <lwip_sendto+0x70>
  804761:	c7 44 24 08 d4 2f 81 	movl   $0x812fd4,0x8(%esp)
  804768:	00 
  804769:	c7 44 24 04 97 02 00 	movl   $0x297,0x4(%esp)
  804770:	00 
  804771:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  804778:	e8 57 c2 ff ff       	call   8009d4 <_panic>
              ((size >= 0) && (size <= 0xffff)));
  LWIP_ERROR("lwip_sendto: invalid address", (((to == NULL) && (tolen == 0)) ||
  80477d:	85 f6                	test   %esi,%esi
  80477f:	0f 95 c0             	setne  %al
  804782:	75 06                	jne    80478a <lwip_sendto+0x7d>
  804784:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  804788:	74 2a                	je     8047b4 <lwip_sendto+0xa7>
  80478a:	83 7d 1c 10          	cmpl   $0x10,0x1c(%ebp)
  80478e:	66 90                	xchg   %ax,%ax
  804790:	75 06                	jne    804798 <lwip_sendto+0x8b>
  804792:	80 7e 01 02          	cmpb   $0x2,0x1(%esi)
  804796:	74 1c                	je     8047b4 <lwip_sendto+0xa7>
  804798:	c7 44 24 08 4f 2f 81 	movl   $0x812f4f,0x8(%esp)
  80479f:	00 
  8047a0:	c7 44 24 04 9b 02 00 	movl   $0x29b,0x4(%esp)
  8047a7:	00 
  8047a8:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  8047af:	e8 20 c2 ff ff       	call   8009d4 <_panic>
      pbuf_free(p);
    }
  }
#else
  /* initialize a buffer */
  buf.p = buf.ptr = NULL;
  8047b4:	c7 45 d8 00 00 00 00 	movl   $0x0,-0x28(%ebp)
  8047bb:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  if (to) {
  8047c2:	84 c0                	test   %al,%al
  8047c4:	74 1e                	je     8047e4 <lwip_sendto+0xd7>
    remote_addr.addr = ((struct sockaddr_in *)to)->sin_addr.s_addr;
  8047c6:	8b 46 04             	mov    0x4(%esi),%eax
  8047c9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    remote_port      = ntohs(((struct sockaddr_in *)to)->sin_port);
  8047cc:	0f b7 46 02          	movzwl 0x2(%esi),%eax
  8047d0:	89 04 24             	mov    %eax,(%esp)
  8047d3:	e8 89 65 00 00       	call   80ad61 <ntohs>
    buf.addr         = &remote_addr;
  8047d8:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  8047db:	89 55 dc             	mov    %edx,-0x24(%ebp)
    buf.port         = remote_port;
  8047de:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  8047e2:	eb 14                	jmp    8047f8 <lwip_sendto+0xeb>
  } else {
    remote_addr.addr = 0;
  8047e4:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    remote_port      = 0;
    buf.addr         = NULL;
  8047eb:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
    buf.port         = 0;
  8047f2:	66 c7 45 e0 00 00    	movw   $0x0,-0x20(%ebp)
              s, data, size, flags));
  //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", remote_port));
    
  /* make the buffer point to the data that should be sent */
  if ((err = netbuf_ref(&buf, data, size)) == ERR_OK) {
  8047f8:	0f b7 c7             	movzwl %di,%eax
  8047fb:	89 44 24 08          	mov    %eax,0x8(%esp)
  8047ff:	8b 45 0c             	mov    0xc(%ebp),%eax
  804802:	89 44 24 04          	mov    %eax,0x4(%esp)
  804806:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804809:	89 04 24             	mov    %eax,(%esp)
  80480c:	e8 ac 0e 00 00       	call   8056bd <netbuf_ref>
  804811:	0f be f0             	movsbl %al,%esi
  804814:	85 f6                	test   %esi,%esi
  804816:	75 14                	jne    80482c <lwip_sendto+0x11f>
    /* send the data */
    err = netconn_send(sock->conn, &buf);
  804818:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  80481b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80481f:	8b 03                	mov    (%ebx),%eax
  804821:	89 04 24             	mov    %eax,(%esp)
  804824:	e8 da 9e 00 00       	call   80e703 <netconn_send>
  804829:	0f be f0             	movsbl %al,%esi
  }

  /* deallocated the buffer */
  if (buf.p != NULL) {
  80482c:	8b 45 d4             	mov    -0x2c(%ebp),%eax
  80482f:	85 c0                	test   %eax,%eax
  804831:	74 08                	je     80483b <lwip_sendto+0x12e>
    pbuf_free(buf.p);
  804833:	89 04 24             	mov    %eax,(%esp)
  804836:	e8 1d 37 00 00       	call   807f58 <pbuf_free>
  }
#endif /* LWIP_TCPIP_CORE_LOCKING */
  sock_set_errno(sock, err_to_errno(err));
  80483b:	89 f2                	mov    %esi,%edx
  80483d:	f7 da                	neg    %edx
  80483f:	b8 05 00 00 00       	mov    $0x5,%eax
  804844:	83 fa 0e             	cmp    $0xe,%edx
  804847:	77 07                	ja     804850 <lwip_sendto+0x143>
  804849:	8b 04 95 00 30 81 00 	mov    0x813000(,%edx,4),%eax
  804850:	89 43 10             	mov    %eax,0x10(%ebx)
  804853:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  return (err==ERR_OK?size:-1);
  804858:	85 f6                	test   %esi,%esi
  80485a:	74 05                	je     804861 <lwip_sendto+0x154>
  80485c:	bf ff ff ff ff       	mov    $0xffffffff,%edi
}
  804861:	89 f8                	mov    %edi,%eax
  804863:	83 c4 3c             	add    $0x3c,%esp
  804866:	5b                   	pop    %ebx
  804867:	5e                   	pop    %esi
  804868:	5f                   	pop    %edi
  804869:	5d                   	pop    %ebp
  80486a:	c3                   	ret    

0080486b <lwip_recvfrom>:
}

int
lwip_recvfrom(int s, void *mem, int len, unsigned int flags,
        struct sockaddr *from, socklen_t *fromlen)
{
  80486b:	55                   	push   %ebp
  80486c:	89 e5                	mov    %esp,%ebp
  80486e:	57                   	push   %edi
  80486f:	56                   	push   %esi
  804870:	53                   	push   %ebx
  804871:	83 ec 5c             	sub    $0x5c,%esp
  804874:	8b 75 14             	mov    0x14(%ebp),%esi
  struct ip_addr     *addr;
  u16_t               port;
  u8_t                done = 0;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d, %p, %d, 0x%x, ..)\n", s, mem, len, flags));
  sock = get_socket(s);
  804877:	8b 45 08             	mov    0x8(%ebp),%eax
  80487a:	e8 31 ed ff ff       	call   8035b0 <get_socket>
  80487f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804881:	66 c7 45 c6 00 00    	movw   $0x0,-0x3a(%ebp)
  804887:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80488c:	85 db                	test   %ebx,%ebx
  80488e:	0f 84 15 02 00 00    	je     804aa9 <lwip_recvfrom+0x23e>
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  804894:	89 f0                	mov    %esi,%eax
  804896:	83 e0 08             	and    $0x8,%eax
  804899:	89 45 b0             	mov    %eax,-0x50(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  80489c:	83 e6 01             	and    $0x1,%esi
  80489f:	89 75 b4             	mov    %esi,-0x4c(%ebp)
    return -1;

  do {
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: top while sock->lastdata=%p\n", (void*)sock->lastdata));
    /* Check if there is data left from the last recv operation. */
    if (sock->lastdata) {
  8048a2:	8b 73 04             	mov    0x4(%ebx),%esi
  8048a5:	85 f6                	test   %esi,%esi
  8048a7:	75 7d                	jne    804926 <lwip_recvfrom+0xbb>
      buf = sock->lastdata;
    } else {
      /* If this is non-blocking call, then check first */
      if (((flags & MSG_DONTWAIT) || (sock->flags & O_NONBLOCK)) && !sock->rcvevent) {
  8048a9:	83 7d b0 00          	cmpl   $0x0,-0x50(%ebp)
  8048ad:	75 06                	jne    8048b5 <lwip_recvfrom+0x4a>
  8048af:	f6 43 0f 08          	testb  $0x8,0xf(%ebx)
  8048b3:	74 22                	je     8048d7 <lwip_recvfrom+0x6c>
  8048b5:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  8048ba:	75 1b                	jne    8048d7 <lwip_recvfrom+0x6c>
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): returning EWOULDBLOCK\n", s));
        sock_set_errno(sock, EWOULDBLOCK);
  8048bc:	c7 43 10 0b 00 00 00 	movl   $0xb,0x10(%ebx)
  8048c3:	c7 05 a0 f5 b3 00 0b 	movl   $0xb,0xb3f5a0
  8048ca:	00 00 00 
  8048cd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
        return -1;
  8048d2:	e9 d2 01 00 00       	jmp    804aa9 <lwip_recvfrom+0x23e>
      }

      /* No data was left from the previous operation, so we try to get
      some from the network. */
      sock->lastdata = buf = netconn_recv(sock->conn);
  8048d7:	8b 03                	mov    (%ebx),%eax
  8048d9:	89 04 24             	mov    %eax,(%esp)
  8048dc:	e8 08 a1 00 00       	call   80e9e9 <netconn_recv>
  8048e1:	89 c6                	mov    %eax,%esi
  8048e3:	89 43 04             	mov    %eax,0x4(%ebx)
      LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: netconn_recv netbuf=%p\n", (void*)buf));

      if (!buf) {
  8048e6:	85 c0                	test   %eax,%eax
  8048e8:	75 3c                	jne    804926 <lwip_recvfrom+0xbb>
        /* We should really do some error checking here. */
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom(%d): buf == NULL!\n", s));
        sock_set_errno(sock, (((sock->conn->pcb.ip!=NULL) && (sock->conn->err==ERR_OK))?ETIMEDOUT:err_to_errno(sock->conn->err)));
  8048ea:	8b 13                	mov    (%ebx),%edx
  8048ec:	83 7a 08 00          	cmpl   $0x0,0x8(%edx)
  8048f0:	74 0b                	je     8048fd <lwip_recvfrom+0x92>
  8048f2:	b8 6e 00 00 00       	mov    $0x6e,%eax
  8048f7:	80 7a 0c 00          	cmpb   $0x0,0xc(%edx)
  8048fb:	74 17                	je     804914 <lwip_recvfrom+0xa9>
  8048fd:	0f be 52 0c          	movsbl 0xc(%edx),%edx
  804901:	f7 da                	neg    %edx
  804903:	b8 05 00 00 00       	mov    $0x5,%eax
  804908:	83 fa 0e             	cmp    $0xe,%edx
  80490b:	77 07                	ja     804914 <lwip_recvfrom+0xa9>
  80490d:	8b 04 95 00 30 81 00 	mov    0x813000(,%edx,4),%eax
  804914:	89 43 10             	mov    %eax,0x10(%ebx)
  804917:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  80491c:	b8 00 00 00 00       	mov    $0x0,%eax
        return 0;
  804921:	e9 83 01 00 00       	jmp    804aa9 <lwip_recvfrom+0x23e>
      }
    }

    buflen = netbuf_len(buf);
  804926:	8b 06                	mov    (%esi),%eax
  804928:	0f b7 48 08          	movzwl 0x8(%eax),%ecx
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;
  80492c:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  804930:	66 29 d1             	sub    %dx,%cx
  804933:	66 89 4d c0          	mov    %cx,-0x40(%ebp)

    if (len > buflen) {
  804937:	0f b7 c9             	movzwl %cx,%ecx
  80493a:	89 4d bc             	mov    %ecx,-0x44(%ebp)
      copylen = buflen;
    } else {
      copylen = len;
  80493d:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
    buflen = netbuf_len(buf);
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: buflen=%d len=%d off=%d sock->lastoffset=%d\n", buflen, len, off, sock->lastoffset));

    buflen -= sock->lastoffset;

    if (len > buflen) {
  804941:	39 4d 10             	cmp    %ecx,0x10(%ebp)
  804944:	7e 04                	jle    80494a <lwip_recvfrom+0xdf>
  804946:	0f b7 7d c0          	movzwl -0x40(%ebp),%edi
      copylen = len;
    }

    /* copy the contents of the received buffer into
    the supplied memory pointer mem */
    netbuf_copy_partial(buf, (u8_t*)mem + off, copylen, sock->lastoffset);
  80494a:	0f b7 cf             	movzwl %di,%ecx
  80494d:	89 4d c0             	mov    %ecx,-0x40(%ebp)
  804950:	0f b7 d2             	movzwl %dx,%edx
  804953:	89 54 24 0c          	mov    %edx,0xc(%esp)
  804957:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80495b:	0f b7 55 c6          	movzwl -0x3a(%ebp),%edx
  80495f:	03 55 0c             	add    0xc(%ebp),%edx
  804962:	89 54 24 04          	mov    %edx,0x4(%esp)
  804966:	89 04 24             	mov    %eax,(%esp)
  804969:	e8 68 33 00 00       	call   807cd6 <pbuf_copy_partial>

    off += copylen;
  80496e:	66 01 7d c6          	add    %di,-0x3a(%ebp)

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  804972:	8b 03                	mov    (%ebx),%eax
  804974:	89 04 24             	mov    %eax,(%esp)
  804977:	e8 94 9c 00 00       	call   80e610 <netconn_type>
  80497c:	83 f8 10             	cmp    $0x10,%eax
  80497f:	75 1f                	jne    8049a0 <lwip_recvfrom+0x135>
      len -= copylen;
  804981:	8b 45 c0             	mov    -0x40(%ebp),%eax
  804984:	29 45 10             	sub    %eax,0x10(%ebp)
      if ( (len <= 0) || (buf->p->flags & PBUF_FLAG_PUSH) || !sock->rcvevent) {
  804987:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80498b:	7e 13                	jle    8049a0 <lwip_recvfrom+0x135>
  80498d:	8b 06                	mov    (%esi),%eax
  80498f:	f6 40 0d 01          	testb  $0x1,0xd(%eax)
  804993:	75 0b                	jne    8049a0 <lwip_recvfrom+0x135>
  804995:	c6 45 bb 00          	movb   $0x0,-0x45(%ebp)
  804999:	66 83 7b 0a 00       	cmpw   $0x0,0xa(%ebx)
  80499e:	75 04                	jne    8049a4 <lwip_recvfrom+0x139>
  8049a0:	c6 45 bb 01          	movb   $0x1,-0x45(%ebp)
    } else {
      done = 1;
    }

    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
  8049a4:	83 7d b4 00          	cmpl   $0x0,-0x4c(%ebp)
  8049a8:	75 39                	jne    8049e3 <lwip_recvfrom+0x178>
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8049aa:	8b 03                	mov    (%ebx),%eax
  8049ac:	83 38 10             	cmpl   $0x10,(%eax)
  8049af:	75 13                	jne    8049c4 <lwip_recvfrom+0x159>
  8049b1:	8b 45 bc             	mov    -0x44(%ebp),%eax
  8049b4:	2b 45 c0             	sub    -0x40(%ebp),%eax
  8049b7:	85 c0                	test   %eax,%eax
  8049b9:	7e 09                	jle    8049c4 <lwip_recvfrom+0x159>
        sock->lastdata = buf;
  8049bb:	89 73 04             	mov    %esi,0x4(%ebx)
        sock->lastoffset += copylen;
  8049be:	66 01 7b 08          	add    %di,0x8(%ebx)
    /* If we don't peek the incoming message... */
    if ((flags & MSG_PEEK)==0) {
      /* If this is a TCP socket, check if there is data left in the
         buffer. If so, it should be saved in the sock structure for next
         time around. */
      if ((sock->conn->type == NETCONN_TCP) && (buflen - copylen > 0)) {
  8049c2:	eb 15                	jmp    8049d9 <lwip_recvfrom+0x16e>
        sock->lastdata = buf;
        sock->lastoffset += copylen;
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: lastdata now netbuf=%p\n", (void*)buf));
      } else {
        sock->lastdata = NULL;
  8049c4:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
        sock->lastoffset = 0;
  8049cb:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
        LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_recvfrom: deleting netbuf=%p\n", (void*)buf));
        netbuf_delete(buf);
  8049d1:	89 34 24             	mov    %esi,(%esp)
  8049d4:	e8 a5 0c 00 00       	call   80567e <netbuf_delete>
      }
    } else {
      done = 1;
    }
  } while (!done);
  8049d9:	80 7d bb 00          	cmpb   $0x0,-0x45(%ebp)
  8049dd:	0f 84 bf fe ff ff    	je     8048a2 <lwip_recvfrom+0x37>

  /* Check to see from where the data was.*/
  if (from && fromlen) {
  8049e3:	83 7d 18 00          	cmpl   $0x0,0x18(%ebp)
  8049e7:	0f 84 a7 00 00 00    	je     804a94 <lwip_recvfrom+0x229>
  8049ed:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  8049f1:	0f 84 9d 00 00 00    	je     804a94 <lwip_recvfrom+0x229>
    struct sockaddr_in sin;

    if (netconn_type(sock->conn) == NETCONN_TCP) {
  8049f7:	8b 03                	mov    (%ebx),%eax
  8049f9:	89 04 24             	mov    %eax,(%esp)
  8049fc:	e8 0f 9c 00 00       	call   80e610 <netconn_type>
  804a01:	83 f8 10             	cmp    $0x10,%eax
  804a04:	75 22                	jne    804a28 <lwip_recvfrom+0x1bd>
      addr = (struct ip_addr*)&(sin.sin_addr.s_addr);
  804a06:	8d 7d d8             	lea    -0x28(%ebp),%edi
      netconn_getaddr(sock->conn, addr, &port, 0);
  804a09:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804a10:	00 
  804a11:	8d 45 e6             	lea    -0x1a(%ebp),%eax
  804a14:	89 44 24 08          	mov    %eax,0x8(%esp)
  804a18:	89 7c 24 04          	mov    %edi,0x4(%esp)
  804a1c:	8b 03                	mov    (%ebx),%eax
  804a1e:	89 04 24             	mov    %eax,(%esp)
  804a21:	e8 9d 9e 00 00       	call   80e8c3 <netconn_getaddr>
  804a26:	eb 0b                	jmp    804a33 <lwip_recvfrom+0x1c8>
    } else {
      addr = netbuf_fromaddr(buf);
  804a28:	8b 7e 08             	mov    0x8(%esi),%edi
      port = netbuf_fromport(buf);
  804a2b:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  804a2f:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
    }

    memset(&sin, 0, sizeof(sin));
  804a33:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804a3a:	00 
  804a3b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804a42:	00 
  804a43:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804a46:	89 04 24             	mov    %eax,(%esp)
  804a49:	e8 68 c8 ff ff       	call   8012b6 <memset>
    sin.sin_len = sizeof(sin);
  804a4e:	c6 45 d4 10          	movb   $0x10,-0x2c(%ebp)
    sin.sin_family = AF_INET;
  804a52:	c6 45 d5 02          	movb   $0x2,-0x2b(%ebp)
    sin.sin_port = htons(port);
  804a56:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  804a5a:	89 04 24             	mov    %eax,(%esp)
  804a5d:	e8 f2 62 00 00       	call   80ad54 <htons>
  804a62:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    sin.sin_addr.s_addr = addr->addr;
  804a66:	8b 07                	mov    (%edi),%eax
  804a68:	89 45 d8             	mov    %eax,-0x28(%ebp)

    if (*fromlen > sizeof(sin))
  804a6b:	8b 55 1c             	mov    0x1c(%ebp),%edx
  804a6e:	83 3a 10             	cmpl   $0x10,(%edx)
  804a71:	76 06                	jbe    804a79 <lwip_recvfrom+0x20e>
      *fromlen = sizeof(sin);
  804a73:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

    SMEMCPY(from, &sin, *fromlen);
  804a79:	8b 4d 1c             	mov    0x1c(%ebp),%ecx
  804a7c:	8b 01                	mov    (%ecx),%eax
  804a7e:	89 44 24 08          	mov    %eax,0x8(%esp)
  804a82:	8d 45 d4             	lea    -0x2c(%ebp),%eax
  804a85:	89 44 24 04          	mov    %eax,0x4(%esp)
  804a89:	8b 7d 18             	mov    0x18(%ebp),%edi
  804a8c:	89 3c 24             	mov    %edi,(%esp)
  804a8f:	e8 fd c8 ff ff       	call   801391 <memcpy>
    //ip_addr_debug_print(SOCKETS_DEBUG, addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u len=%u\n", port, off));
#endif /*  SOCKETS_DEBUG */
  }

  sock_set_errno(sock, 0);
  804a94:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804a9b:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804aa2:	00 00 00 
  return off;
  804aa5:	0f b7 45 c6          	movzwl -0x3a(%ebp),%eax
}
  804aa9:	83 c4 5c             	add    $0x5c,%esp
  804aac:	5b                   	pop    %ebx
  804aad:	5e                   	pop    %esi
  804aae:	5f                   	pop    %edi
  804aaf:	5d                   	pop    %ebp
  804ab0:	c3                   	ret    

00804ab1 <lwip_recv>:
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
}

int
lwip_recv(int s, void *mem, int len, unsigned int flags)
{
  804ab1:	55                   	push   %ebp
  804ab2:	89 e5                	mov    %esp,%ebp
  804ab4:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, flags, NULL, NULL);
  804ab7:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  804abe:	00 
  804abf:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804ac6:	00 
  804ac7:	8b 45 14             	mov    0x14(%ebp),%eax
  804aca:	89 44 24 0c          	mov    %eax,0xc(%esp)
  804ace:	8b 45 10             	mov    0x10(%ebp),%eax
  804ad1:	89 44 24 08          	mov    %eax,0x8(%esp)
  804ad5:	8b 45 0c             	mov    0xc(%ebp),%eax
  804ad8:	89 44 24 04          	mov    %eax,0x4(%esp)
  804adc:	8b 45 08             	mov    0x8(%ebp),%eax
  804adf:	89 04 24             	mov    %eax,(%esp)
  804ae2:	e8 84 fd ff ff       	call   80486b <lwip_recvfrom>
}
  804ae7:	c9                   	leave  
  804ae8:	c3                   	ret    

00804ae9 <lwip_read>:
  return off;
}

int
lwip_read(int s, void *mem, int len)
{
  804ae9:	55                   	push   %ebp
  804aea:	89 e5                	mov    %esp,%ebp
  804aec:	83 ec 28             	sub    $0x28,%esp
  return lwip_recvfrom(s, mem, len, 0, NULL, NULL);
  804aef:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  804af6:	00 
  804af7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  804afe:	00 
  804aff:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804b06:	00 
  804b07:	8b 45 10             	mov    0x10(%ebp),%eax
  804b0a:	89 44 24 08          	mov    %eax,0x8(%esp)
  804b0e:	8b 45 0c             	mov    0xc(%ebp),%eax
  804b11:	89 44 24 04          	mov    %eax,0x4(%esp)
  804b15:	8b 45 08             	mov    0x8(%ebp),%eax
  804b18:	89 04 24             	mov    %eax,(%esp)
  804b1b:	e8 4b fd ff ff       	call   80486b <lwip_recvfrom>
}
  804b20:	c9                   	leave  
  804b21:	c3                   	ret    

00804b22 <lwip_close>:
  return 0;
}

int
lwip_close(int s)
{
  804b22:	55                   	push   %ebp
  804b23:	89 e5                	mov    %esp,%ebp
  804b25:	53                   	push   %ebx
  804b26:	83 ec 14             	sub    $0x14,%esp
  struct lwip_socket *sock;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_close(%d)\n", s));

  sock = get_socket(s);
  804b29:	8b 45 08             	mov    0x8(%ebp),%eax
  804b2c:	e8 7f ea ff ff       	call   8035b0 <get_socket>
  804b31:	89 c3                	mov    %eax,%ebx
  if (!sock) {
  804b33:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804b38:	85 db                	test   %ebx,%ebx
  804b3a:	74 5c                	je     804b98 <lwip_close+0x76>
    return -1;
  }

  netconn_delete(sock->conn);
  804b3c:	8b 03                	mov    (%ebx),%eax
  804b3e:	89 04 24             	mov    %eax,(%esp)
  804b41:	e8 55 a0 00 00       	call   80eb9b <netconn_delete>

  sys_sem_wait(socksem);
  804b46:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  804b4b:	89 04 24             	mov    %eax,(%esp)
  804b4e:	e8 e7 3a 00 00       	call   80863a <sys_sem_wait>
  if (sock->lastdata) {
  804b53:	8b 43 04             	mov    0x4(%ebx),%eax
  804b56:	85 c0                	test   %eax,%eax
  804b58:	74 08                	je     804b62 <lwip_close+0x40>
    netbuf_delete(sock->lastdata);
  804b5a:	89 04 24             	mov    %eax,(%esp)
  804b5d:	e8 1c 0b 00 00       	call   80567e <netbuf_delete>
  }
  sock->lastdata   = NULL;
  804b62:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sock->lastoffset = 0;
  804b69:	66 c7 43 08 00 00    	movw   $0x0,0x8(%ebx)
  sock->conn       = NULL;
  804b6f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
  sock_set_errno(sock, 0);
  804b75:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804b7c:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804b83:	00 00 00 
  sys_sem_signal(socksem);
  804b86:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  804b8b:	89 04 24             	mov    %eax,(%esp)
  804b8e:	e8 94 90 00 00       	call   80dc27 <sys_sem_signal>
  804b93:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804b98:	83 c4 14             	add    $0x14,%esp
  804b9b:	5b                   	pop    %ebx
  804b9c:	5d                   	pop    %ebp
  804b9d:	c3                   	ret    

00804b9e <lwip_shutdown>:
 * Unimplemented: Close one end of a full-duplex connection.
 * Currently, the full connection is closed.
 */
int
lwip_shutdown(int s, int how)
{
  804b9e:	55                   	push   %ebp
  804b9f:	89 e5                	mov    %esp,%ebp
  804ba1:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(how);
  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_shutdown(%d, how=%d)\n", s, how));
  return lwip_close(s); /* XXX temporary hack until proper implementation */
  804ba4:	8b 45 08             	mov    0x8(%ebp),%eax
  804ba7:	89 04 24             	mov    %eax,(%esp)
  804baa:	e8 73 ff ff ff       	call   804b22 <lwip_close>
}
  804baf:	c9                   	leave  
  804bb0:	c3                   	ret    

00804bb1 <lwip_listen>:
 * @param backlog (ATTENTION: need TCP_LISTEN_BACKLOG=1)
 * @return 0 on success, non-zero on failure
 */
int
lwip_listen(int s, int backlog)
{
  804bb1:	55                   	push   %ebp
  804bb2:	89 e5                	mov    %esp,%ebp
  804bb4:	56                   	push   %esi
  804bb5:	53                   	push   %ebx
  804bb6:	83 ec 10             	sub    $0x10,%esp
  804bb9:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct lwip_socket *sock;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d, backlog=%d)\n", s, backlog));

  sock = get_socket(s);
  804bbc:	8b 45 08             	mov    0x8(%ebp),%eax
  804bbf:	e8 ec e9 ff ff       	call   8035b0 <get_socket>
  804bc4:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804bc6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804bcb:	85 db                	test   %ebx,%ebx
  804bcd:	74 6a                	je     804c39 <lwip_listen+0x88>
  804bcf:	89 f0                	mov    %esi,%eax
  804bd1:	c1 f8 1f             	sar    $0x1f,%eax
  804bd4:	f7 d0                	not    %eax
  }
  if (backlog > 0xff) {
    backlog = 0xff;
  }

  err = netconn_listen_with_backlog(sock->conn, backlog);
  804bd6:	21 c6                	and    %eax,%esi
  804bd8:	81 fe ff 00 00 00    	cmp    $0xff,%esi
  804bde:	7e 05                	jle    804be5 <lwip_listen+0x34>
  804be0:	be ff 00 00 00       	mov    $0xff,%esi
  804be5:	81 e6 ff 00 00 00    	and    $0xff,%esi
  804beb:	89 74 24 04          	mov    %esi,0x4(%esp)
  804bef:	8b 03                	mov    (%ebx),%eax
  804bf1:	89 04 24             	mov    %eax,(%esp)
  804bf4:	e8 8a 9b 00 00       	call   80e783 <netconn_listen_with_backlog>

  if (err != ERR_OK) {
  804bf9:	84 c0                	test   %al,%al
  804bfb:	74 26                	je     804c23 <lwip_listen+0x72>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_listen(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804bfd:	0f be c0             	movsbl %al,%eax
  804c00:	f7 d8                	neg    %eax
  804c02:	ba 05 00 00 00       	mov    $0x5,%edx
  804c07:	83 f8 0e             	cmp    $0xe,%eax
  804c0a:	77 07                	ja     804c13 <lwip_listen+0x62>
  804c0c:	8b 14 85 00 30 81 00 	mov    0x813000(,%eax,4),%edx
  804c13:	89 53 10             	mov    %edx,0x10(%ebx)
  804c16:	89 15 a0 f5 b3 00    	mov    %edx,0xb3f5a0
  804c1c:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804c21:	eb 16                	jmp    804c39 <lwip_listen+0x88>
  }

  sock_set_errno(sock, 0);
  804c23:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804c2a:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804c31:	00 00 00 
  804c34:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804c39:	83 c4 10             	add    $0x10,%esp
  804c3c:	5b                   	pop    %ebx
  804c3d:	5e                   	pop    %esi
  804c3e:	5d                   	pop    %ebp
  804c3f:	c3                   	ret    

00804c40 <lwip_connect>:
  return 0;
}

int
lwip_connect(int s, const struct sockaddr *name, socklen_t namelen)
{
  804c40:	55                   	push   %ebp
  804c41:	89 e5                	mov    %esp,%ebp
  804c43:	53                   	push   %ebx
  804c44:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  err_t err;

  sock = get_socket(s);
  804c47:	8b 45 08             	mov    0x8(%ebp),%eax
  804c4a:	e8 61 e9 ff ff       	call   8035b0 <get_socket>
  804c4f:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804c51:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804c56:	85 db                	test   %ebx,%ebx
  804c58:	0f 84 95 00 00 00    	je     804cf3 <lwip_connect+0xb3>
    return -1;

  LWIP_ERROR("lwip_connect: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804c5e:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804c62:	75 09                	jne    804c6d <lwip_connect+0x2d>
  804c64:	8b 45 0c             	mov    0xc(%ebp),%eax
  804c67:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804c6b:	74 1c                	je     804c89 <lwip_connect+0x49>
  804c6d:	c7 44 24 08 6c 2f 81 	movl   $0x812f6c,0x8(%esp)
  804c74:	00 
  804c75:	c7 44 24 04 86 01 00 	movl   $0x186,0x4(%esp)
  804c7c:	00 
  804c7d:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  804c84:	e8 4b bd ff ff       	call   8009d4 <_panic>
    err = netconn_disconnect(sock->conn);
  } else {
    struct ip_addr remote_addr;
    u16_t remote_port;

    remote_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804c89:	8b 50 04             	mov    0x4(%eax),%edx
  804c8c:	89 55 f4             	mov    %edx,-0xc(%ebp)

    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d, addr=", s));
    //ip_addr_debug_print(SOCKETS_DEBUG, &remote_addr);
    LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(remote_port)));

    err = netconn_connect(sock->conn, &remote_addr, ntohs(remote_port));
  804c8f:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804c93:	89 04 24             	mov    %eax,(%esp)
  804c96:	e8 c6 60 00 00       	call   80ad61 <ntohs>
  804c9b:	0f b7 c0             	movzwl %ax,%eax
  804c9e:	89 44 24 08          	mov    %eax,0x8(%esp)
  804ca2:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804ca5:	89 44 24 04          	mov    %eax,0x4(%esp)
  804ca9:	8b 03                	mov    (%ebx),%eax
  804cab:	89 04 24             	mov    %eax,(%esp)
  804cae:	e8 62 9b 00 00       	call   80e815 <netconn_connect>
  }

  if (err != ERR_OK) {
  804cb3:	84 c0                	test   %al,%al
  804cb5:	74 26                	je     804cdd <lwip_connect+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804cb7:	0f be c0             	movsbl %al,%eax
  804cba:	f7 d8                	neg    %eax
  804cbc:	ba 05 00 00 00       	mov    $0x5,%edx
  804cc1:	83 f8 0e             	cmp    $0xe,%eax
  804cc4:	77 07                	ja     804ccd <lwip_connect+0x8d>
  804cc6:	8b 14 85 00 30 81 00 	mov    0x813000(,%eax,4),%edx
  804ccd:	89 53 10             	mov    %edx,0x10(%ebx)
  804cd0:	89 15 a0 f5 b3 00    	mov    %edx,0xb3f5a0
  804cd6:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804cdb:	eb 16                	jmp    804cf3 <lwip_connect+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_connect(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804cdd:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804ce4:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804ceb:	00 00 00 
  804cee:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804cf3:	83 c4 24             	add    $0x24,%esp
  804cf6:	5b                   	pop    %ebx
  804cf7:	5d                   	pop    %ebp
  804cf8:	c3                   	ret    

00804cf9 <lwip_bind>:
  return newsock;
}

int
lwip_bind(int s, struct sockaddr *name, socklen_t namelen)
{
  804cf9:	55                   	push   %ebp
  804cfa:	89 e5                	mov    %esp,%ebp
  804cfc:	53                   	push   %ebx
  804cfd:	83 ec 24             	sub    $0x24,%esp
  struct lwip_socket *sock;
  struct ip_addr local_addr;
  u16_t local_port;
  err_t err;

  sock = get_socket(s);
  804d00:	8b 45 08             	mov    0x8(%ebp),%eax
  804d03:	e8 a8 e8 ff ff       	call   8035b0 <get_socket>
  804d08:	89 c3                	mov    %eax,%ebx
  if (!sock)
  804d0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  804d0f:	85 db                	test   %ebx,%ebx
  804d11:	0f 84 95 00 00 00    	je     804dac <lwip_bind+0xb3>
    return -1;

  LWIP_ERROR("lwip_bind: invalid address", ((namelen == sizeof(struct sockaddr_in)) &&
  804d17:	83 7d 10 10          	cmpl   $0x10,0x10(%ebp)
  804d1b:	75 09                	jne    804d26 <lwip_bind+0x2d>
  804d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  804d20:	80 78 01 02          	cmpb   $0x2,0x1(%eax)
  804d24:	74 1c                	je     804d42 <lwip_bind+0x49>
  804d26:	c7 44 24 08 8a 2f 81 	movl   $0x812f8a,0x8(%esp)
  804d2d:	00 
  804d2e:	c7 44 24 04 4a 01 00 	movl   $0x14a,0x4(%esp)
  804d35:	00 
  804d36:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  804d3d:	e8 92 bc ff ff       	call   8009d4 <_panic>
             ((((struct sockaddr_in *)name)->sin_family) == AF_INET)),
             sock_set_errno(sock, err_to_errno(ERR_ARG)); return -1;);

  local_addr.addr = ((struct sockaddr_in *)name)->sin_addr.s_addr;
  804d42:	8b 50 04             	mov    0x4(%eax),%edx
  804d45:	89 55 f4             	mov    %edx,-0xc(%ebp)

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d, addr=", s));
  //ip_addr_debug_print(SOCKETS_DEBUG, &local_addr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u)\n", ntohs(local_port)));

  err = netconn_bind(sock->conn, &local_addr, ntohs(local_port));
  804d48:	0f b7 40 02          	movzwl 0x2(%eax),%eax
  804d4c:	89 04 24             	mov    %eax,(%esp)
  804d4f:	e8 0d 60 00 00       	call   80ad61 <ntohs>
  804d54:	0f b7 c0             	movzwl %ax,%eax
  804d57:	89 44 24 08          	mov    %eax,0x8(%esp)
  804d5b:	8d 45 f4             	lea    -0xc(%ebp),%eax
  804d5e:	89 44 24 04          	mov    %eax,0x4(%esp)
  804d62:	8b 03                	mov    (%ebx),%eax
  804d64:	89 04 24             	mov    %eax,(%esp)
  804d67:	e8 00 9b 00 00       	call   80e86c <netconn_bind>

  if (err != ERR_OK) {
  804d6c:	84 c0                	test   %al,%al
  804d6e:	74 26                	je     804d96 <lwip_bind+0x9d>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) failed, err=%d\n", s, err));
    sock_set_errno(sock, err_to_errno(err));
  804d70:	0f be c0             	movsbl %al,%eax
  804d73:	f7 d8                	neg    %eax
  804d75:	ba 05 00 00 00       	mov    $0x5,%edx
  804d7a:	83 f8 0e             	cmp    $0xe,%eax
  804d7d:	77 07                	ja     804d86 <lwip_bind+0x8d>
  804d7f:	8b 14 85 00 30 81 00 	mov    0x813000(,%eax,4),%edx
  804d86:	89 53 10             	mov    %edx,0x10(%ebx)
  804d89:	89 15 a0 f5 b3 00    	mov    %edx,0xb3f5a0
  804d8f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return -1;
  804d94:	eb 16                	jmp    804dac <lwip_bind+0xb3>
  }

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_bind(%d) succeeded\n", s));
  sock_set_errno(sock, 0);
  804d96:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  804d9d:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804da4:	00 00 00 
  804da7:	b8 00 00 00 00       	mov    $0x0,%eax
  return 0;
}
  804dac:	83 c4 24             	add    $0x24,%esp
  804daf:	5b                   	pop    %ebx
  804db0:	5d                   	pop    %ebp
  804db1:	c3                   	ret    

00804db2 <lwip_accept>:
 * Exceptions are documented!
 */

int
lwip_accept(int s, struct sockaddr *addr, socklen_t *addrlen)
{
  804db2:	55                   	push   %ebp
  804db3:	89 e5                	mov    %esp,%ebp
  804db5:	57                   	push   %edi
  804db6:	56                   	push   %esi
  804db7:	53                   	push   %ebx
  804db8:	83 ec 4c             	sub    $0x4c,%esp
  int newsock;
  struct sockaddr_in sin;
  err_t err;

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d)...\n", s));
  sock = get_socket(s);
  804dbb:	8b 45 08             	mov    0x8(%ebp),%eax
  804dbe:	e8 ed e7 ff ff       	call   8035b0 <get_socket>
  804dc3:	89 c7                	mov    %eax,%edi
  if (!sock)
  804dc5:	be ff ff ff ff       	mov    $0xffffffff,%esi
  804dca:	85 c0                	test   %eax,%eax
  804dcc:	0f 84 ae 01 00 00    	je     804f80 <lwip_accept+0x1ce>
    return -1;

  newconn = netconn_accept(sock->conn);
  804dd2:	8b 00                	mov    (%eax),%eax
  804dd4:	89 04 24             	mov    %eax,(%esp)
  804dd7:	e8 83 9b 00 00       	call   80e95f <netconn_accept>
  804ddc:	89 c3                	mov    %eax,%ebx
  if (!newconn) {
  804dde:	85 c0                	test   %eax,%eax
  804de0:	75 2b                	jne    804e0d <lwip_accept+0x5b>
    LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) failed, err=%d\n", s, sock->conn->err));
    sock_set_errno(sock, err_to_errno(sock->conn->err));
  804de2:	8b 07                	mov    (%edi),%eax
  804de4:	0f be 50 0c          	movsbl 0xc(%eax),%edx
  804de8:	f7 da                	neg    %edx
  804dea:	b8 05 00 00 00       	mov    $0x5,%eax
  804def:	83 fa 0e             	cmp    $0xe,%edx
  804df2:	77 07                	ja     804dfb <lwip_accept+0x49>
  804df4:	8b 04 95 00 30 81 00 	mov    0x813000(,%edx,4),%eax
  804dfb:	89 47 10             	mov    %eax,0x10(%edi)
  804dfe:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  804e03:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804e08:	e9 73 01 00 00       	jmp    804f80 <lwip_accept+0x1ce>
  }

  /* get the IP address and port of the remote host */
  err = netconn_peer(newconn, &naddr, &port);
  804e0d:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804e14:	00 
  804e15:	8d 45 e2             	lea    -0x1e(%ebp),%eax
  804e18:	89 44 24 08          	mov    %eax,0x8(%esp)
  804e1c:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  804e1f:	89 44 24 04          	mov    %eax,0x4(%esp)
  804e23:	89 1c 24             	mov    %ebx,(%esp)
  804e26:	e8 98 9a 00 00       	call   80e8c3 <netconn_getaddr>
  804e2b:	89 c6                	mov    %eax,%esi
  if (err != ERR_OK) {
  804e2d:	84 c0                	test   %al,%al
  804e2f:	74 32                	je     804e63 <lwip_accept+0xb1>
    netconn_delete(newconn);
  804e31:	89 1c 24             	mov    %ebx,(%esp)
  804e34:	e8 62 9d 00 00       	call   80eb9b <netconn_delete>
    sock_set_errno(sock, err_to_errno(err));
  804e39:	89 f0                	mov    %esi,%eax
  804e3b:	0f be f0             	movsbl %al,%esi
  804e3e:	f7 de                	neg    %esi
  804e40:	b8 05 00 00 00       	mov    $0x5,%eax
  804e45:	83 fe 0e             	cmp    $0xe,%esi
  804e48:	77 07                	ja     804e51 <lwip_accept+0x9f>
  804e4a:	8b 04 b5 00 30 81 00 	mov    0x813000(,%esi,4),%eax
  804e51:	89 47 10             	mov    %eax,0x10(%edi)
  804e54:	a3 a0 f5 b3 00       	mov    %eax,0xb3f5a0
  804e59:	be ff ff ff ff       	mov    $0xffffffff,%esi
    return -1;
  804e5e:	e9 1d 01 00 00       	jmp    804f80 <lwip_accept+0x1ce>
  }

  memset(&sin, 0, sizeof(sin));
  804e63:	c7 44 24 08 10 00 00 	movl   $0x10,0x8(%esp)
  804e6a:	00 
  804e6b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  804e72:	00 
  804e73:	8d 45 d0             	lea    -0x30(%ebp),%eax
  804e76:	89 04 24             	mov    %eax,(%esp)
  804e79:	e8 38 c4 ff ff       	call   8012b6 <memset>
  sin.sin_len = sizeof(sin);
  804e7e:	c6 45 d0 10          	movb   $0x10,-0x30(%ebp)
  sin.sin_family = AF_INET;
  804e82:	c6 45 d1 02          	movb   $0x2,-0x2f(%ebp)
  sin.sin_port = htons(port);
  804e86:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  804e8a:	89 04 24             	mov    %eax,(%esp)
  804e8d:	e8 c2 5e 00 00       	call   80ad54 <htons>
  804e92:	66 89 45 d2          	mov    %ax,-0x2e(%ebp)
  sin.sin_addr.s_addr = naddr.addr;
  804e96:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  804e99:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  if (*addrlen > sizeof(sin))
  804e9c:	8b 55 10             	mov    0x10(%ebp),%edx
  804e9f:	83 3a 10             	cmpl   $0x10,(%edx)
  804ea2:	76 06                	jbe    804eaa <lwip_accept+0xf8>
    *addrlen = sizeof(sin);
  804ea4:	c7 02 10 00 00 00    	movl   $0x10,(%edx)

  SMEMCPY(addr, &sin, *addrlen);
  804eaa:	8b 55 10             	mov    0x10(%ebp),%edx
  804ead:	8b 02                	mov    (%edx),%eax
  804eaf:	89 44 24 08          	mov    %eax,0x8(%esp)
  804eb3:	8d 45 d0             	lea    -0x30(%ebp),%eax
  804eb6:	89 44 24 04          	mov    %eax,0x4(%esp)
  804eba:	8b 45 0c             	mov    0xc(%ebp),%eax
  804ebd:	89 04 24             	mov    %eax,(%esp)
  804ec0:	e8 cc c4 ff ff       	call   801391 <memcpy>

  newsock = alloc_socket(newconn);
  804ec5:	89 d8                	mov    %ebx,%eax
  804ec7:	e8 7d f0 ff ff       	call   803f49 <alloc_socket>
  804ecc:	89 c6                	mov    %eax,%esi
  if (newsock == -1) {
  804ece:	83 f8 ff             	cmp    $0xffffffff,%eax
  804ed1:	75 1e                	jne    804ef1 <lwip_accept+0x13f>
    netconn_delete(newconn);
  804ed3:	89 1c 24             	mov    %ebx,(%esp)
  804ed6:	e8 c0 9c 00 00       	call   80eb9b <netconn_delete>
    sock_set_errno(sock, ENFILE);
  804edb:	c7 47 10 17 00 00 00 	movl   $0x17,0x10(%edi)
  804ee2:	c7 05 a0 f5 b3 00 17 	movl   $0x17,0xb3f5a0
  804ee9:	00 00 00 
    return -1;
  804eec:	e9 8f 00 00 00       	jmp    804f80 <lwip_accept+0x1ce>
  }
  LWIP_ASSERT("invalid socket index", (newsock >= 0) && (newsock < NUM_SOCKETS));
  804ef1:	83 fe 1f             	cmp    $0x1f,%esi
  804ef4:	76 1c                	jbe    804f12 <lwip_accept+0x160>
  804ef6:	c7 44 24 08 a5 2f 81 	movl   $0x812fa5,0x8(%esp)
  804efd:	00 
  804efe:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  804f05:	00 
  804f06:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  804f0d:	e8 c2 ba ff ff       	call   8009d4 <_panic>
  newconn->callback = event_callback;
  804f12:	c7 43 2c ed 3f 80 00 	movl   $0x803fed,0x2c(%ebx)
  nsock = &sockets[newsock];
  804f19:	8d 04 80             	lea    (%eax,%eax,4),%eax
  804f1c:	8d 04 85 20 94 81 00 	lea    0x819420(,%eax,4),%eax
  804f23:	89 45 c4             	mov    %eax,-0x3c(%ebp)
  LWIP_ASSERT("invalid socket pointer", nsock != NULL);
  804f26:	85 c0                	test   %eax,%eax
  804f28:	75 1c                	jne    804f46 <lwip_accept+0x194>
  804f2a:	c7 44 24 08 ba 2f 81 	movl   $0x812fba,0x8(%esp)
  804f31:	00 
  804f32:	c7 44 24 04 28 01 00 	movl   $0x128,0x4(%esp)
  804f39:	00 
  804f3a:	c7 04 24 2a 2f 81 00 	movl   $0x812f2a,(%esp)
  804f41:	e8 8e ba ff ff       	call   8009d4 <_panic>

  sys_sem_wait(socksem);
  804f46:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  804f4b:	89 04 24             	mov    %eax,(%esp)
  804f4e:	e8 e7 36 00 00       	call   80863a <sys_sem_wait>
  /* See event_callback: If data comes in right away after an accept, even
   * though the server task might not have created a new socket yet.
   * In that case, newconn->socket is counted down (newconn->socket--),
   * so nsock->rcvevent is >= 1 here!
   */
  nsock->rcvevent += -1 - newconn->socket;
  804f53:	8b 43 1c             	mov    0x1c(%ebx),%eax
  804f56:	f7 d0                	not    %eax
  804f58:	8b 55 c4             	mov    -0x3c(%ebp),%edx
  804f5b:	66 01 42 0a          	add    %ax,0xa(%edx)
  newconn->socket = newsock;
  804f5f:	89 73 1c             	mov    %esi,0x1c(%ebx)
  sys_sem_signal(socksem);
  804f62:	a1 a4 96 81 00       	mov    0x8196a4,%eax
  804f67:	89 04 24             	mov    %eax,(%esp)
  804f6a:	e8 b8 8c 00 00       	call   80dc27 <sys_sem_signal>

  LWIP_DEBUGF(SOCKETS_DEBUG, ("lwip_accept(%d) returning new sock=%d addr=", s, newsock));
  //ip_addr_debug_print(SOCKETS_DEBUG, &naddr);
  LWIP_DEBUGF(SOCKETS_DEBUG, (" port=%u\n", port));

  sock_set_errno(sock, 0);
  804f6f:	c7 47 10 00 00 00 00 	movl   $0x0,0x10(%edi)
  804f76:	c7 05 a0 f5 b3 00 00 	movl   $0x0,0xb3f5a0
  804f7d:	00 00 00 
  return newsock;
}
  804f80:	89 f0                	mov    %esi,%eax
  804f82:	83 c4 4c             	add    $0x4c,%esp
  804f85:	5b                   	pop    %ebx
  804f86:	5e                   	pop    %esi
  804f87:	5f                   	pop    %edi
  804f88:	5d                   	pop    %ebp
  804f89:	c3                   	ret    
  804f8a:	00 00                	add    %al,(%eax)
  804f8c:	00 00                	add    %al,(%eax)
	...

00804f90 <pbuf_free_int>:
 *
 * @param p The pbuf (chain) to be dereferenced.
 */
static void
pbuf_free_int(void *p)
{
  804f90:	55                   	push   %ebp
  804f91:	89 e5                	mov    %esp,%ebp
  804f93:	83 ec 18             	sub    $0x18,%esp
  struct pbuf *q = p;
  pbuf_free(q);
  804f96:	8b 45 08             	mov    0x8(%ebp),%eax
  804f99:	89 04 24             	mov    %eax,(%esp)
  804f9c:	e8 b7 2f 00 00       	call   807f58 <pbuf_free>
}
  804fa1:	c9                   	leave  
  804fa2:	c3                   	ret    

00804fa3 <tcpip_init>:
 * @param initfunc a function to call when tcpip_thread is running and finished initializing
 * @param arg argument to pass to initfunc
 */
void
tcpip_init(void (* initfunc)(void *), void *arg)
{
  804fa3:	55                   	push   %ebp
  804fa4:	89 e5                	mov    %esp,%ebp
  804fa6:	83 ec 28             	sub    $0x28,%esp
  lwip_init();
  804fa9:	e8 62 08 00 00       	call   805810 <lwip_init>

  tcpip_init_done = initfunc;
  804fae:	8b 45 08             	mov    0x8(%ebp),%eax
  804fb1:	a3 ac 96 81 00       	mov    %eax,0x8196ac
  tcpip_init_done_arg = arg;
  804fb6:	8b 45 0c             	mov    0xc(%ebp),%eax
  804fb9:	a3 b0 96 81 00       	mov    %eax,0x8196b0
  mbox = sys_mbox_new(TCPIP_MBOX_SIZE);
  804fbe:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  804fc5:	e8 45 8b 00 00       	call   80db0f <sys_mbox_new>
  804fca:	a3 74 90 81 00       	mov    %eax,0x819074
#if LWIP_TCPIP_CORE_LOCKING
  lock_tcpip_core = sys_sem_new(1);
#endif /* LWIP_TCPIP_CORE_LOCKING */

  sys_thread_new(TCPIP_THREAD_NAME, tcpip_thread, NULL, TCPIP_THREAD_STACKSIZE, TCPIP_THREAD_PRIO);
  804fcf:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  804fd6:	00 
  804fd7:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  804fde:	00 
  804fdf:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  804fe6:	00 
  804fe7:	c7 44 24 04 46 50 80 	movl   $0x805046,0x4(%esp)
  804fee:	00 
  804fef:	c7 04 24 46 30 81 00 	movl   $0x813046,(%esp)
  804ff6:	e8 7f 88 00 00       	call   80d87a <sys_thread_new>
}
  804ffb:	c9                   	leave  
  804ffc:	c3                   	ret    

00804ffd <tcp_timer_needed>:
 * the reason is to have the TCP timer only running when
 * there are active (or time-wait) PCBs.
 */
void
tcp_timer_needed(void)
{
  804ffd:	55                   	push   %ebp
  804ffe:	89 e5                	mov    %esp,%ebp
  805000:	83 ec 18             	sub    $0x18,%esp
  /* timer is off but needed again? */
  if (!tcpip_tcp_timer_active && (tcp_active_pcbs || tcp_tw_pcbs)) {
  805003:	83 3d b4 96 81 00 00 	cmpl   $0x0,0x8196b4
  80500a:	75 38                	jne    805044 <tcp_timer_needed+0x47>
  80500c:	83 3d 08 f6 b3 00 00 	cmpl   $0x0,0xb3f608
  805013:	75 09                	jne    80501e <tcp_timer_needed+0x21>
  805015:	83 3d 1c f6 b3 00 00 	cmpl   $0x0,0xb3f61c
  80501c:	74 26                	je     805044 <tcp_timer_needed+0x47>
    /* enable and start timer */
    tcpip_tcp_timer_active = 1;
  80501e:	c7 05 b4 96 81 00 01 	movl   $0x1,0x8196b4
  805025:	00 00 00 
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  805028:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80502f:	00 
  805030:	c7 44 24 04 61 54 80 	movl   $0x805461,0x4(%esp)
  805037:	00 
  805038:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  80503f:	e8 26 35 00 00       	call   80856a <sys_timeout>
  }
}
  805044:	c9                   	leave  
  805045:	c3                   	ret    

00805046 <tcpip_thread>:
 *
 * @param arg unused argument
 */
static void
tcpip_thread(void *arg)
{
  805046:	55                   	push   %ebp
  805047:	89 e5                	mov    %esp,%ebp
  805049:	53                   	push   %ebx
  80504a:	83 ec 24             	sub    $0x24,%esp
  struct tcpip_msg *msg;
  LWIP_UNUSED_ARG(arg);

#if IP_REASSEMBLY
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  80504d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805054:	00 
  805055:	c7 44 24 04 3e 52 80 	movl   $0x80523e,0x4(%esp)
  80505c:	00 
  80505d:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  805064:	e8 01 35 00 00       	call   80856a <sys_timeout>
#endif /* IP_REASSEMBLY */
#if LWIP_ARP
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  805069:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805070:	00 
  805071:	c7 44 24 04 15 52 80 	movl   $0x805215,0x4(%esp)
  805078:	00 
  805079:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  805080:	e8 e5 34 00 00       	call   80856a <sys_timeout>
#endif /* LWIP_ARP */
#if LWIP_DHCP
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  805085:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80508c:	00 
  80508d:	c7 44 24 04 ec 51 80 	movl   $0x8051ec,0x4(%esp)
  805094:	00 
  805095:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80509c:	e8 c9 34 00 00       	call   80856a <sys_timeout>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8050a1:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8050a8:	00 
  8050a9:	c7 44 24 04 c3 51 80 	movl   $0x8051c3,0x4(%esp)
  8050b0:	00 
  8050b1:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8050b8:	e8 ad 34 00 00       	call   80856a <sys_timeout>
#endif /* LWIP_IGMP */
#if LWIP_DNS
  sys_timeout(DNS_TMR_INTERVAL, dns_timer, NULL);
#endif /* LWIP_DNS */

  if (tcpip_init_done != NULL) {
  8050bd:	a1 ac 96 81 00       	mov    0x8196ac,%eax
  8050c2:	85 c0                	test   %eax,%eax
  8050c4:	74 0b                	je     8050d1 <tcpip_thread+0x8b>
    tcpip_init_done(tcpip_init_done_arg);
  8050c6:	8b 15 b0 96 81 00    	mov    0x8196b0,%edx
  8050cc:	89 14 24             	mov    %edx,(%esp)
  8050cf:	ff d0                	call   *%eax
  }

  LOCK_TCPIP_CORE();
  while (1) {                          /* MAIN Loop */
    sys_mbox_fetch(mbox, (void *)&msg);
  8050d1:	8d 5d f4             	lea    -0xc(%ebp),%ebx
  8050d4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8050d8:	a1 74 90 81 00       	mov    0x819074,%eax
  8050dd:	89 04 24             	mov    %eax,(%esp)
  8050e0:	e8 77 36 00 00       	call   80875c <sys_mbox_fetch>
    switch (msg->type) {
  8050e5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8050e8:	8b 10                	mov    (%eax),%edx
  8050ea:	83 fa 01             	cmp    $0x1,%edx
  8050ed:	74 28                	je     805117 <tcpip_thread+0xd1>
  8050ef:	83 fa 01             	cmp    $0x1,%edx
  8050f2:	72 16                	jb     80510a <tcpip_thread+0xc4>
  8050f4:	83 fa 02             	cmp    $0x2,%edx
  8050f7:	74 5f                	je     805158 <tcpip_thread+0x112>
  8050f9:	83 fa 03             	cmp    $0x3,%edx
  8050fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  805100:	75 d2                	jne    8050d4 <tcpip_thread+0x8e>
  805102:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  805108:	eb 6f                	jmp    805179 <tcpip_thread+0x133>
#if LWIP_NETCONN
    case TCPIP_MSG_API:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: API message %p\n", (void *)msg));
      msg->msg.apimsg->function(&(msg->msg.apimsg->msg));
  80510a:	8b 40 08             	mov    0x8(%eax),%eax
  80510d:	8d 50 04             	lea    0x4(%eax),%edx
  805110:	89 14 24             	mov    %edx,(%esp)
  805113:	ff 10                	call   *(%eax)
      break;
  805115:	eb bd                	jmp    8050d4 <tcpip_thread+0x8e>
#endif /* LWIP_NETCONN */

    case TCPIP_MSG_INPKT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: PACKET %p\n", (void *)msg));
#if LWIP_ARP
      if (msg->msg.inp.netif->flags & NETIF_FLAG_ETHARP) {
  805117:	8b 50 0c             	mov    0xc(%eax),%edx
  80511a:	f6 42 2e 20          	testb  $0x20,0x2e(%edx)
  80511e:	74 11                	je     805131 <tcpip_thread+0xeb>
        ethernet_input(msg->msg.inp.p, msg->msg.inp.netif);
  805120:	89 54 24 04          	mov    %edx,0x4(%esp)
  805124:	8b 40 08             	mov    0x8(%eax),%eax
  805127:	89 04 24             	mov    %eax,(%esp)
  80512a:	e8 78 83 00 00       	call   80d4a7 <ethernet_input>
  80512f:	eb 0f                	jmp    805140 <tcpip_thread+0xfa>
      } else
#endif /* LWIP_ARP */
      { ip_input(msg->msg.inp.p, msg->msg.inp.netif);
  805131:	89 54 24 04          	mov    %edx,0x4(%esp)
  805135:	8b 40 08             	mov    0x8(%eax),%eax
  805138:	89 04 24             	mov    %eax,(%esp)
  80513b:	e8 d4 4a 00 00       	call   809c14 <ip_input>
      }
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  805140:	8b 45 f4             	mov    -0xc(%ebp),%eax
  805143:	89 44 24 04          	mov    %eax,0x4(%esp)
  805147:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80514e:	e8 6d 26 00 00       	call   8077c0 <memp_free>
      break;
  805153:	e9 7c ff ff ff       	jmp    8050d4 <tcpip_thread+0x8e>
      break;
#endif /* LWIP_NETIF_API */

    case TCPIP_MSG_CALLBACK:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: CALLBACK %p\n", (void *)msg));
      msg->msg.cb.f(msg->msg.cb.ctx);
  805158:	8b 50 0c             	mov    0xc(%eax),%edx
  80515b:	89 14 24             	mov    %edx,(%esp)
  80515e:	ff 50 08             	call   *0x8(%eax)
      memp_free(MEMP_TCPIP_MSG_API, msg);
  805161:	8b 45 f4             	mov    -0xc(%ebp),%eax
  805164:	89 44 24 04          	mov    %eax,0x4(%esp)
  805168:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80516f:	e8 4c 26 00 00       	call   8077c0 <memp_free>
      break;
  805174:	e9 5b ff ff ff       	jmp    8050d4 <tcpip_thread+0x8e>

    case TCPIP_MSG_TIMEOUT:
      LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip_thread: TIMEOUT %p\n", (void *)msg));

      if(msg->msg.tmo.msecs != 0xffffffff)
  805179:	8b 50 08             	mov    0x8(%eax),%edx
  80517c:	83 fa ff             	cmp    $0xffffffff,%edx
  80517f:	74 18                	je     805199 <tcpip_thread+0x153>
        sys_timeout (msg->msg.tmo.msecs, msg->msg.tmo.h, msg->msg.tmo.arg);
  805181:	8b 48 10             	mov    0x10(%eax),%ecx
  805184:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  805188:	8b 40 0c             	mov    0xc(%eax),%eax
  80518b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80518f:	89 14 24             	mov    %edx,(%esp)
  805192:	e8 d3 33 00 00       	call   80856a <sys_timeout>
  805197:	eb 12                	jmp    8051ab <tcpip_thread+0x165>
      else
        sys_untimeout (msg->msg.tmo.h, msg->msg.tmo.arg);
  805199:	8b 50 10             	mov    0x10(%eax),%edx
  80519c:	89 54 24 04          	mov    %edx,0x4(%esp)
  8051a0:	8b 40 0c             	mov    0xc(%eax),%eax
  8051a3:	89 04 24             	mov    %eax,(%esp)
  8051a6:	e8 32 33 00 00       	call   8084dd <sys_untimeout>
      memp_free(MEMP_TCPIP_MSG_API, msg);
  8051ab:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8051ae:	89 44 24 04          	mov    %eax,0x4(%esp)
  8051b2:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8051b9:	e8 02 26 00 00       	call   8077c0 <memp_free>
  8051be:	e9 11 ff ff ff       	jmp    8050d4 <tcpip_thread+0x8e>

008051c3 <dhcp_timer_fine>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_fine(void *arg)
{
  8051c3:	55                   	push   %ebp
  8051c4:	89 e5                	mov    %esp,%ebp
  8051c6:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_fine_tmr()\n"));
  dhcp_fine_tmr();
  8051c9:	e8 f4 1e 00 00       	call   8070c2 <dhcp_fine_tmr>
  sys_timeout(DHCP_FINE_TIMER_MSECS, dhcp_timer_fine, NULL);
  8051ce:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8051d5:	00 
  8051d6:	c7 44 24 04 c3 51 80 	movl   $0x8051c3,0x4(%esp)
  8051dd:	00 
  8051de:	c7 04 24 f4 01 00 00 	movl   $0x1f4,(%esp)
  8051e5:	e8 80 33 00 00       	call   80856a <sys_timeout>
}
  8051ea:	c9                   	leave  
  8051eb:	c3                   	ret    

008051ec <dhcp_timer_coarse>:
 *
 * @param arg unused argument
 */
static void
dhcp_timer_coarse(void *arg)
{
  8051ec:	55                   	push   %ebp
  8051ed:	89 e5                	mov    %esp,%ebp
  8051ef:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: dhcp_coarse_tmr()\n"));
  dhcp_coarse_tmr();
  8051f2:	e8 92 12 00 00       	call   806489 <dhcp_coarse_tmr>
  sys_timeout(DHCP_COARSE_TIMER_MSECS, dhcp_timer_coarse, NULL);
  8051f7:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8051fe:	00 
  8051ff:	c7 44 24 04 ec 51 80 	movl   $0x8051ec,0x4(%esp)
  805206:	00 
  805207:	c7 04 24 60 ea 00 00 	movl   $0xea60,(%esp)
  80520e:	e8 57 33 00 00       	call   80856a <sys_timeout>
}
  805213:	c9                   	leave  
  805214:	c3                   	ret    

00805215 <arp_timer>:
 *
 * @param arg unused argument
 */
static void
arp_timer(void *arg)
{
  805215:	55                   	push   %ebp
  805216:	89 e5                	mov    %esp,%ebp
  805218:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: etharp_tmr()\n"));
  etharp_tmr();
  80521b:	e8 5c 7e 00 00       	call   80d07c <etharp_tmr>
  sys_timeout(ARP_TMR_INTERVAL, arp_timer, NULL);
  805220:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805227:	00 
  805228:	c7 44 24 04 15 52 80 	movl   $0x805215,0x4(%esp)
  80522f:	00 
  805230:	c7 04 24 88 13 00 00 	movl   $0x1388,(%esp)
  805237:	e8 2e 33 00 00       	call   80856a <sys_timeout>
}
  80523c:	c9                   	leave  
  80523d:	c3                   	ret    

0080523e <ip_reass_timer>:
 *
 * @param arg unused argument
 */
static void
ip_reass_timer(void *arg)
{
  80523e:	55                   	push   %ebp
  80523f:	89 e5                	mov    %esp,%ebp
  805241:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);
  LWIP_DEBUGF(TCPIP_DEBUG, ("tcpip: ip_reass_tmr()\n"));
  ip_reass_tmr();
  805244:	e8 ac 50 00 00       	call   80a2f5 <ip_reass_tmr>
  sys_timeout(IP_TMR_INTERVAL, ip_reass_timer, NULL);
  805249:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805250:	00 
  805251:	c7 44 24 04 3e 52 80 	movl   $0x80523e,0x4(%esp)
  805258:	00 
  805259:	c7 04 24 e8 03 00 00 	movl   $0x3e8,(%esp)
  805260:	e8 05 33 00 00       	call   80856a <sys_timeout>
}
  805265:	c9                   	leave  
  805266:	c3                   	ret    

00805267 <tcpip_apimsg>:
 * @param apimsg a struct containing the function to call and its parameters
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_apimsg(struct api_msg *apimsg)
{
  805267:	55                   	push   %ebp
  805268:	89 e5                	mov    %esp,%ebp
  80526a:	53                   	push   %ebx
  80526b:	83 ec 34             	sub    $0x34,%esp
  80526e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcpip_msg msg;
  
  if (mbox != SYS_MBOX_NULL) {
  805271:	8b 15 74 90 81 00    	mov    0x819074,%edx
  805277:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80527c:	83 fa ff             	cmp    $0xffffffff,%edx
  80527f:	74 34                	je     8052b5 <tcpip_apimsg+0x4e>
    msg.type = TCPIP_MSG_API;
  805281:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    msg.msg.apimsg = apimsg;
  805288:	89 5d ec             	mov    %ebx,-0x14(%ebp)
    sys_mbox_post(mbox, &msg);
  80528b:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80528e:	89 44 24 04          	mov    %eax,0x4(%esp)
  805292:	89 14 24             	mov    %edx,(%esp)
  805295:	e8 ec 8b 00 00       	call   80de86 <sys_mbox_post>
    sys_arch_sem_wait(apimsg->msg.conn->op_completed, 0);
  80529a:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8052a1:	00 
  8052a2:	8b 43 04             	mov    0x4(%ebx),%eax
  8052a5:	8b 40 10             	mov    0x10(%eax),%eax
  8052a8:	89 04 24             	mov    %eax,(%esp)
  8052ab:	e8 86 86 00 00       	call   80d936 <sys_arch_sem_wait>
  8052b0:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  8052b5:	83 c4 34             	add    $0x34,%esp
  8052b8:	5b                   	pop    %ebx
  8052b9:	5d                   	pop    %ebp
  8052ba:	c3                   	ret    

008052bb <tcpip_timeout>:
  return ERR_VAL;
}

err_t
tcpip_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  8052bb:	55                   	push   %ebp
  8052bc:	89 e5                	mov    %esp,%ebp
  8052be:	83 ec 18             	sub    $0x18,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8052c1:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8052c6:	83 3d 74 90 81 00 ff 	cmpl   $0xffffffff,0x819074
  8052cd:	74 45                	je     805314 <tcpip_timeout+0x59>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  8052cf:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  8052d6:	e8 29 25 00 00       	call   807804 <memp_malloc>
  8052db:	89 c2                	mov    %eax,%edx
    if (msg == NULL) {
  8052dd:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8052e2:	85 d2                	test   %edx,%edx
  8052e4:	74 2e                	je     805314 <tcpip_timeout+0x59>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_TIMEOUT;
  8052e6:	c7 02 03 00 00 00    	movl   $0x3,(%edx)
    msg->msg.tmo.msecs = msecs;
  8052ec:	8b 45 08             	mov    0x8(%ebp),%eax
  8052ef:	89 42 08             	mov    %eax,0x8(%edx)
    msg->msg.tmo.h = h;
  8052f2:	8b 45 0c             	mov    0xc(%ebp),%eax
  8052f5:	89 42 0c             	mov    %eax,0xc(%edx)
    msg->msg.tmo.arg = arg;
  8052f8:	8b 45 10             	mov    0x10(%ebp),%eax
  8052fb:	89 42 10             	mov    %eax,0x10(%edx)
    sys_mbox_post(mbox, msg);
  8052fe:	89 54 24 04          	mov    %edx,0x4(%esp)
  805302:	a1 74 90 81 00       	mov    0x819074,%eax
  805307:	89 04 24             	mov    %eax,(%esp)
  80530a:	e8 77 8b 00 00       	call   80de86 <sys_mbox_post>
  80530f:	b8 00 00 00 00       	mov    $0x0,%eax
    return ERR_OK;
  }
  return ERR_VAL;
}
  805314:	c9                   	leave  
  805315:	c3                   	ret    

00805316 <tcpip_callback_with_block>:
 * @param block 1 to block until the request is posted, 0 to non-blocking mode
 * @return ERR_OK if the function was called, another err_t if not
 */
err_t
tcpip_callback_with_block(void (*f)(void *ctx), void *ctx, u8_t block)
{
  805316:	55                   	push   %ebp
  805317:	89 e5                	mov    %esp,%ebp
  805319:	83 ec 18             	sub    $0x18,%esp
  80531c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80531f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  805322:	0f b6 5d 10          	movzbl 0x10(%ebp),%ebx
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  805326:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80532b:	83 3d 74 90 81 00 ff 	cmpl   $0xffffffff,0x819074
  805332:	74 6f                	je     8053a3 <tcpip_callback_with_block+0x8d>
    msg = memp_malloc(MEMP_TCPIP_MSG_API);
  805334:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80533b:	e8 c4 24 00 00       	call   807804 <memp_malloc>
  805340:	89 c6                	mov    %eax,%esi
    if (msg == NULL) {
  805342:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  805347:	85 f6                	test   %esi,%esi
  805349:	74 58                	je     8053a3 <tcpip_callback_with_block+0x8d>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_CALLBACK;
  80534b:	c7 06 02 00 00 00    	movl   $0x2,(%esi)
    msg->msg.cb.f = f;
  805351:	8b 45 08             	mov    0x8(%ebp),%eax
  805354:	89 46 08             	mov    %eax,0x8(%esi)
    msg->msg.cb.ctx = ctx;
  805357:	8b 45 0c             	mov    0xc(%ebp),%eax
  80535a:	89 46 0c             	mov    %eax,0xc(%esi)
    if (block) {
  80535d:	84 db                	test   %bl,%bl
  80535f:	74 18                	je     805379 <tcpip_callback_with_block+0x63>
      sys_mbox_post(mbox, msg);
  805361:	89 74 24 04          	mov    %esi,0x4(%esp)
  805365:	a1 74 90 81 00       	mov    0x819074,%eax
  80536a:	89 04 24             	mov    %eax,(%esp)
  80536d:	e8 14 8b 00 00       	call   80de86 <sys_mbox_post>
  805372:	b8 00 00 00 00       	mov    $0x0,%eax
  805377:	eb 2a                	jmp    8053a3 <tcpip_callback_with_block+0x8d>
    } else {
      if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  805379:	89 74 24 04          	mov    %esi,0x4(%esp)
  80537d:	a1 74 90 81 00       	mov    0x819074,%eax
  805382:	89 04 24             	mov    %eax,(%esp)
  805385:	e8 2e 8a 00 00       	call   80ddb8 <sys_mbox_trypost>
  80538a:	84 c0                	test   %al,%al
  80538c:	74 15                	je     8053a3 <tcpip_callback_with_block+0x8d>
        memp_free(MEMP_TCPIP_MSG_API, msg);
  80538e:	89 74 24 04          	mov    %esi,0x4(%esp)
  805392:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  805399:	e8 22 24 00 00       	call   8077c0 <memp_free>
  80539e:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      }
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  8053a3:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8053a6:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8053a9:	89 ec                	mov    %ebp,%esp
  8053ab:	5d                   	pop    %ebp
  8053ac:	c3                   	ret    

008053ad <mem_free_callback>:
 * @param m the heap memory to free
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
mem_free_callback(void *m)
{
  8053ad:	55                   	push   %ebp
  8053ae:	89 e5                	mov    %esp,%ebp
  8053b0:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(mem_free, m, 0);
  8053b3:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8053ba:	00 
  8053bb:	8b 45 08             	mov    0x8(%ebp),%eax
  8053be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8053c2:	c7 04 24 4e 75 80 00 	movl   $0x80754e,(%esp)
  8053c9:	e8 48 ff ff ff       	call   805316 <tcpip_callback_with_block>
}
  8053ce:	c9                   	leave  
  8053cf:	c3                   	ret    

008053d0 <pbuf_free_callback>:
 * @param p The pbuf (chain) to be dereferenced.
 * @return ERR_OK if callback could be enqueued, an err_t if not
 */
err_t
pbuf_free_callback(struct pbuf *p)
{
  8053d0:	55                   	push   %ebp
  8053d1:	89 e5                	mov    %esp,%ebp
  8053d3:	83 ec 18             	sub    $0x18,%esp
  return tcpip_callback_with_block(pbuf_free_int, p, 0);
  8053d6:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8053dd:	00 
  8053de:	8b 45 08             	mov    0x8(%ebp),%eax
  8053e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  8053e5:	c7 04 24 90 4f 80 00 	movl   $0x804f90,(%esp)
  8053ec:	e8 25 ff ff ff       	call   805316 <tcpip_callback_with_block>
}
  8053f1:	c9                   	leave  
  8053f2:	c3                   	ret    

008053f3 <tcpip_input>:
 *          to an IP header (if netif doesn't got NETIF_FLAG_ETHARP flag)
 * @param inp the network interface on which the packet was received
 */
err_t
tcpip_input(struct pbuf *p, struct netif *inp)
{
  8053f3:	55                   	push   %ebp
  8053f4:	89 e5                	mov    %esp,%ebp
  8053f6:	53                   	push   %ebx
  8053f7:	83 ec 14             	sub    $0x14,%esp
  struct tcpip_msg *msg;

  if (mbox != SYS_MBOX_NULL) {
  8053fa:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  8053ff:	83 3d 74 90 81 00 ff 	cmpl   $0xffffffff,0x819074
  805406:	74 53                	je     80545b <tcpip_input+0x68>
    msg = memp_malloc(MEMP_TCPIP_MSG_INPKT);
  805408:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  80540f:	e8 f0 23 00 00       	call   807804 <memp_malloc>
  805414:	89 c3                	mov    %eax,%ebx
    if (msg == NULL) {
  805416:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80541b:	85 db                	test   %ebx,%ebx
  80541d:	74 3c                	je     80545b <tcpip_input+0x68>
      return ERR_MEM;
    }

    msg->type = TCPIP_MSG_INPKT;
  80541f:	c7 03 01 00 00 00    	movl   $0x1,(%ebx)
    msg->msg.inp.p = p;
  805425:	8b 45 08             	mov    0x8(%ebp),%eax
  805428:	89 43 08             	mov    %eax,0x8(%ebx)
    msg->msg.inp.netif = inp;
  80542b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80542e:	89 43 0c             	mov    %eax,0xc(%ebx)
    if (sys_mbox_trypost(mbox, msg) != ERR_OK) {
  805431:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  805435:	a1 74 90 81 00       	mov    0x819074,%eax
  80543a:	89 04 24             	mov    %eax,(%esp)
  80543d:	e8 76 89 00 00       	call   80ddb8 <sys_mbox_trypost>
  805442:	84 c0                	test   %al,%al
  805444:	74 15                	je     80545b <tcpip_input+0x68>
      memp_free(MEMP_TCPIP_MSG_INPKT, msg);
  805446:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80544a:	c7 04 24 09 00 00 00 	movl   $0x9,(%esp)
  805451:	e8 6a 23 00 00       	call   8077c0 <memp_free>
  805456:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
    }
    return ERR_OK;
  }
  return ERR_VAL;
}
  80545b:	83 c4 14             	add    $0x14,%esp
  80545e:	5b                   	pop    %ebx
  80545f:	5d                   	pop    %ebp
  805460:	c3                   	ret    

00805461 <tcpip_tcp_timer>:
 *
 * @param arg unused argument
 */
static void
tcpip_tcp_timer(void *arg)
{
  805461:	55                   	push   %ebp
  805462:	89 e5                	mov    %esp,%ebp
  805464:	83 ec 18             	sub    $0x18,%esp
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  805467:	e8 2c 43 00 00       	call   809798 <tcp_tmr>
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80546c:	83 3d 08 f6 b3 00 00 	cmpl   $0x0,0xb3f608
  805473:	75 09                	jne    80547e <tcpip_tcp_timer+0x1d>
  805475:	83 3d 1c f6 b3 00 00 	cmpl   $0x0,0xb3f61c
  80547c:	74 1e                	je     80549c <tcpip_tcp_timer+0x3b>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  80547e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805485:	00 
  805486:	c7 44 24 04 61 54 80 	movl   $0x805461,0x4(%esp)
  80548d:	00 
  80548e:	c7 04 24 fa 00 00 00 	movl   $0xfa,(%esp)
  805495:	e8 d0 30 00 00       	call   80856a <sys_timeout>
  LWIP_UNUSED_ARG(arg);

  /* call TCP timer handler */
  tcp_tmr();
  /* timer still needed? */
  if (tcp_active_pcbs || tcp_tw_pcbs) {
  80549a:	eb 0a                	jmp    8054a6 <tcpip_tcp_timer+0x45>
    /* restart timer */
    sys_timeout(TCP_TMR_INTERVAL, tcpip_tcp_timer, NULL);
  } else {
    /* disable timer */
    tcpip_tcp_timer_active = 0;
  80549c:	c7 05 b4 96 81 00 00 	movl   $0x0,0x8196b4
  8054a3:	00 00 00 
  }
}
  8054a6:	c9                   	leave  
  8054a7:	c3                   	ret    

008054a8 <netbuf_first>:
 *
 * @param buf the netbuf to modify
 */
void
netbuf_first(struct netbuf *buf)
{
  8054a8:	55                   	push   %ebp
  8054a9:	89 e5                	mov    %esp,%ebp
  8054ab:	83 ec 18             	sub    $0x18,%esp
  8054ae:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  8054b1:	85 c0                	test   %eax,%eax
  8054b3:	75 1c                	jne    8054d1 <netbuf_first+0x29>
  8054b5:	c7 44 24 08 53 30 81 	movl   $0x813053,0x8(%esp)
  8054bc:	00 
  8054bd:	c7 44 24 04 e7 00 00 	movl   $0xe7,0x4(%esp)
  8054c4:	00 
  8054c5:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  8054cc:	e8 03 b5 ff ff       	call   8009d4 <_panic>
  buf->ptr = buf->p;
  8054d1:	8b 10                	mov    (%eax),%edx
  8054d3:	89 50 04             	mov    %edx,0x4(%eax)
}
  8054d6:	c9                   	leave  
  8054d7:	c3                   	ret    

008054d8 <netbuf_next>:
 *         1  if moved to the next part but now there is no next part
 *         0  if moved to the next part and there are still more parts
 */
s8_t
netbuf_next(struct netbuf *buf)
{
  8054d8:	55                   	push   %ebp
  8054d9:	89 e5                	mov    %esp,%ebp
  8054db:	83 ec 18             	sub    $0x18,%esp
  8054de:	8b 55 08             	mov    0x8(%ebp),%edx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return -1;);
  8054e1:	85 d2                	test   %edx,%edx
  8054e3:	75 1c                	jne    805501 <netbuf_next+0x29>
  8054e5:	c7 44 24 08 53 30 81 	movl   $0x813053,0x8(%esp)
  8054ec:	00 
  8054ed:	c7 44 24 04 d2 00 00 	movl   $0xd2,0x4(%esp)
  8054f4:	00 
  8054f5:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  8054fc:	e8 d3 b4 ff ff       	call   8009d4 <_panic>
  if (buf->ptr->next == NULL) {
  805501:	8b 42 04             	mov    0x4(%edx),%eax
  805504:	8b 08                	mov    (%eax),%ecx
  805506:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80550b:	85 c9                	test   %ecx,%ecx
  80550d:	74 09                	je     805518 <netbuf_next+0x40>
    return -1;
  }
  buf->ptr = buf->ptr->next;
  80550f:	89 4a 04             	mov    %ecx,0x4(%edx)
  805512:	83 39 00             	cmpl   $0x0,(%ecx)
  805515:	0f 94 c0             	sete   %al
  if (buf->ptr->next == NULL) {
    return 1;
  }
  return 0;
}
  805518:	c9                   	leave  
  805519:	c3                   	ret    

0080551a <netbuf_data>:
 * @return ERR_OK if the information was retreived,
 *         ERR_BUF on error.
 */
err_t
netbuf_data(struct netbuf *buf, void **dataptr, u16_t *len)
{
  80551a:	55                   	push   %ebp
  80551b:	89 e5                	mov    %esp,%ebp
  80551d:	56                   	push   %esi
  80551e:	53                   	push   %ebx
  80551f:	83 ec 10             	sub    $0x10,%esp
  805522:	8b 55 08             	mov    0x8(%ebp),%edx
  805525:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  805528:	8b 4d 10             	mov    0x10(%ebp),%ecx
  LWIP_ERROR("netbuf_data: invalid buf", (buf != NULL), return ERR_ARG;);
  80552b:	85 d2                	test   %edx,%edx
  80552d:	75 1c                	jne    80554b <netbuf_data+0x31>
  80552f:	c7 44 24 08 82 30 81 	movl   $0x813082,0x8(%esp)
  805536:	00 
  805537:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  80553e:	00 
  80553f:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  805546:	e8 89 b4 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netbuf_data: invalid dataptr", (dataptr != NULL), return ERR_ARG;);
  80554b:	85 db                	test   %ebx,%ebx
  80554d:	75 1c                	jne    80556b <netbuf_data+0x51>
  80554f:	c7 44 24 08 9b 30 81 	movl   $0x81309b,0x8(%esp)
  805556:	00 
  805557:	c7 44 24 04 ba 00 00 	movl   $0xba,0x4(%esp)
  80555e:	00 
  80555f:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  805566:	e8 69 b4 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netbuf_data: invalid len", (len != NULL), return ERR_ARG;);
  80556b:	85 c9                	test   %ecx,%ecx
  80556d:	75 1c                	jne    80558b <netbuf_data+0x71>
  80556f:	c7 44 24 08 b8 30 81 	movl   $0x8130b8,0x8(%esp)
  805576:	00 
  805577:	c7 44 24 04 bb 00 00 	movl   $0xbb,0x4(%esp)
  80557e:	00 
  80557f:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  805586:	e8 49 b4 ff ff       	call   8009d4 <_panic>

  if (buf->ptr == NULL) {
  80558b:	8b 72 04             	mov    0x4(%edx),%esi
  80558e:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  805593:	85 f6                	test   %esi,%esi
  805595:	74 14                	je     8055ab <netbuf_data+0x91>
    return ERR_BUF;
  }
  *dataptr = buf->ptr->payload;
  805597:	8b 46 04             	mov    0x4(%esi),%eax
  80559a:	89 03                	mov    %eax,(%ebx)
  *len = buf->ptr->len;
  80559c:	8b 42 04             	mov    0x4(%edx),%eax
  80559f:	0f b7 40 0a          	movzwl 0xa(%eax),%eax
  8055a3:	66 89 01             	mov    %ax,(%ecx)
  8055a6:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  8055ab:	83 c4 10             	add    $0x10,%esp
  8055ae:	5b                   	pop    %ebx
  8055af:	5e                   	pop    %esi
  8055b0:	5d                   	pop    %ebp
  8055b1:	c3                   	ret    

008055b2 <netbuf_chain>:
 * @param head the first netbuf
 * @param tail netbuf to chain after head
 */
void
netbuf_chain(struct netbuf *head, struct netbuf *tail)
{
  8055b2:	55                   	push   %ebp
  8055b3:	89 e5                	mov    %esp,%ebp
  8055b5:	83 ec 18             	sub    $0x18,%esp
  8055b8:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8055bb:	89 75 fc             	mov    %esi,-0x4(%ebp)
  8055be:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8055c1:	8b 75 0c             	mov    0xc(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid head", (head != NULL), return;);
  8055c4:	85 db                	test   %ebx,%ebx
  8055c6:	75 1c                	jne    8055e4 <netbuf_chain+0x32>
  8055c8:	c7 44 24 08 d1 30 81 	movl   $0x8130d1,0x8(%esp)
  8055cf:	00 
  8055d0:	c7 44 24 04 a6 00 00 	movl   $0xa6,0x4(%esp)
  8055d7:	00 
  8055d8:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  8055df:	e8 f0 b3 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netbuf_chain: invalid tail", (tail != NULL), return;);
  8055e4:	85 f6                	test   %esi,%esi
  8055e6:	75 1c                	jne    805604 <netbuf_chain+0x52>
  8055e8:	c7 44 24 08 ea 30 81 	movl   $0x8130ea,0x8(%esp)
  8055ef:	00 
  8055f0:	c7 44 24 04 a7 00 00 	movl   $0xa7,0x4(%esp)
  8055f7:	00 
  8055f8:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  8055ff:	e8 d0 b3 ff ff       	call   8009d4 <_panic>
  pbuf_chain(head->p, tail->p);
  805604:	8b 06                	mov    (%esi),%eax
  805606:	89 44 24 04          	mov    %eax,0x4(%esp)
  80560a:	8b 03                	mov    (%ebx),%eax
  80560c:	89 04 24             	mov    %eax,(%esp)
  80560f:	e8 a8 25 00 00       	call   807bbc <pbuf_chain>
  head->ptr = head->p;
  805614:	8b 03                	mov    (%ebx),%eax
  805616:	89 43 04             	mov    %eax,0x4(%ebx)
  memp_free(MEMP_NETBUF, tail);
  805619:	89 74 24 04          	mov    %esi,0x4(%esp)
  80561d:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  805624:	e8 97 21 00 00       	call   8077c0 <memp_free>
}
  805629:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80562c:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80562f:	89 ec                	mov    %ebp,%esp
  805631:	5d                   	pop    %ebp
  805632:	c3                   	ret    

00805633 <netbuf_free>:
 *
 * @param buf pointer to the netbuf which contains the packet buffer to free
 */
void
netbuf_free(struct netbuf *buf)
{
  805633:	55                   	push   %ebp
  805634:	89 e5                	mov    %esp,%ebp
  805636:	53                   	push   %ebx
  805637:	83 ec 14             	sub    $0x14,%esp
  80563a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ERROR("netbuf_free: invalid buf", (buf != NULL), return;);
  80563d:	85 db                	test   %ebx,%ebx
  80563f:	75 1c                	jne    80565d <netbuf_free+0x2a>
  805641:	c7 44 24 08 53 30 81 	movl   $0x813053,0x8(%esp)
  805648:	00 
  805649:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  805650:	00 
  805651:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  805658:	e8 77 b3 ff ff       	call   8009d4 <_panic>
  if (buf->p != NULL) {
  80565d:	8b 03                	mov    (%ebx),%eax
  80565f:	85 c0                	test   %eax,%eax
  805661:	74 08                	je     80566b <netbuf_free+0x38>
    pbuf_free(buf->p);
  805663:	89 04 24             	mov    %eax,(%esp)
  805666:	e8 ed 28 00 00       	call   807f58 <pbuf_free>
  }
  buf->p = buf->ptr = NULL;
  80566b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805672:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
}
  805678:	83 c4 14             	add    $0x14,%esp
  80567b:	5b                   	pop    %ebx
  80567c:	5d                   	pop    %ebp
  80567d:	c3                   	ret    

0080567e <netbuf_delete>:
 *
 * @param buf pointer to a netbuf allocated by netbuf_new()
 */
void
netbuf_delete(struct netbuf *buf)
{
  80567e:	55                   	push   %ebp
  80567f:	89 e5                	mov    %esp,%ebp
  805681:	53                   	push   %ebx
  805682:	83 ec 14             	sub    $0x14,%esp
  805685:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (buf != NULL) {
  805688:	85 db                	test   %ebx,%ebx
  80568a:	74 2b                	je     8056b7 <netbuf_delete+0x39>
    if (buf->p != NULL) {
  80568c:	8b 03                	mov    (%ebx),%eax
  80568e:	85 c0                	test   %eax,%eax
  805690:	74 15                	je     8056a7 <netbuf_delete+0x29>
      pbuf_free(buf->p);
  805692:	89 04 24             	mov    %eax,(%esp)
  805695:	e8 be 28 00 00       	call   807f58 <pbuf_free>
      buf->p = buf->ptr = NULL;
  80569a:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  8056a1:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    }
    memp_free(MEMP_NETBUF, buf);
  8056a7:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8056ab:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8056b2:	e8 09 21 00 00       	call   8077c0 <memp_free>
  }
}
  8056b7:	83 c4 14             	add    $0x14,%esp
  8056ba:	5b                   	pop    %ebx
  8056bb:	5d                   	pop    %ebp
  8056bc:	c3                   	ret    

008056bd <netbuf_ref>:
 * @return ERR_OK if data is referenced
 *         ERR_MEM if data couldn't be referenced due to lack of memory
 */
err_t
netbuf_ref(struct netbuf *buf, const void *dataptr, u16_t size)
{
  8056bd:	55                   	push   %ebp
  8056be:	89 e5                	mov    %esp,%ebp
  8056c0:	56                   	push   %esi
  8056c1:	53                   	push   %ebx
  8056c2:	83 ec 10             	sub    $0x10,%esp
  8056c5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8056c8:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  LWIP_ERROR("netbuf_ref: invalid buf", (buf != NULL), return ERR_ARG;);
  8056cc:	85 db                	test   %ebx,%ebx
  8056ce:	75 1c                	jne    8056ec <netbuf_ref+0x2f>
  8056d0:	c7 44 24 08 05 31 81 	movl   $0x813105,0x8(%esp)
  8056d7:	00 
  8056d8:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  8056df:	00 
  8056e0:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  8056e7:	e8 e8 b2 ff ff       	call   8009d4 <_panic>
  if (buf->p != NULL) {
  8056ec:	8b 03                	mov    (%ebx),%eax
  8056ee:	85 c0                	test   %eax,%eax
  8056f0:	74 08                	je     8056fa <netbuf_ref+0x3d>
    pbuf_free(buf->p);
  8056f2:	89 04 24             	mov    %eax,(%esp)
  8056f5:	e8 5e 28 00 00       	call   807f58 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_REF);
  8056fa:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  805701:	00 
  805702:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  805709:	00 
  80570a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805711:	e8 fd 2a 00 00       	call   808213 <pbuf_alloc>
  805716:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  805718:	85 c0                	test   %eax,%eax
  80571a:	75 0e                	jne    80572a <netbuf_ref+0x6d>
    buf->ptr = NULL;
  80571c:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  805723:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  805728:	eb 1a                	jmp    805744 <netbuf_ref+0x87>
  }
  buf->p->payload = (void*)dataptr;
  80572a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80572d:	89 50 04             	mov    %edx,0x4(%eax)
  buf->p->len = buf->p->tot_len = size;
  805730:	8b 03                	mov    (%ebx),%eax
  805732:	66 89 70 08          	mov    %si,0x8(%eax)
  805736:	66 89 70 0a          	mov    %si,0xa(%eax)
  buf->ptr = buf->p;
  80573a:	8b 03                	mov    (%ebx),%eax
  80573c:	89 43 04             	mov    %eax,0x4(%ebx)
  80573f:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  805744:	83 c4 10             	add    $0x10,%esp
  805747:	5b                   	pop    %ebx
  805748:	5e                   	pop    %esi
  805749:	5d                   	pop    %ebp
  80574a:	c3                   	ret    

0080574b <netbuf_alloc>:
 * @return pointer to the allocated memory
 *         NULL if no memory could be allocated
 */
void *
netbuf_alloc(struct netbuf *buf, u16_t size)
{
  80574b:	55                   	push   %ebp
  80574c:	89 e5                	mov    %esp,%ebp
  80574e:	56                   	push   %esi
  80574f:	53                   	push   %ebx
  805750:	83 ec 10             	sub    $0x10,%esp
  805753:	8b 5d 08             	mov    0x8(%ebp),%ebx
  805756:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  LWIP_ERROR("netbuf_alloc: invalid buf", (buf != NULL), return NULL;);
  80575a:	85 db                	test   %ebx,%ebx
  80575c:	75 1c                	jne    80577a <netbuf_alloc+0x2f>
  80575e:	c7 44 24 08 1d 31 81 	movl   $0x81311d,0x8(%esp)
  805765:	00 
  805766:	c7 44 24 04 63 00 00 	movl   $0x63,0x4(%esp)
  80576d:	00 
  80576e:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  805775:	e8 5a b2 ff ff       	call   8009d4 <_panic>

  /* Deallocate any previously allocated memory. */
  if (buf->p != NULL) {
  80577a:	8b 03                	mov    (%ebx),%eax
  80577c:	85 c0                	test   %eax,%eax
  80577e:	74 08                	je     805788 <netbuf_alloc+0x3d>
    pbuf_free(buf->p);
  805780:	89 04 24             	mov    %eax,(%esp)
  805783:	e8 d0 27 00 00       	call   807f58 <pbuf_free>
  }
  buf->p = pbuf_alloc(PBUF_TRANSPORT, size, PBUF_RAM);
  805788:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80578f:	00 
  805790:	0f b7 c6             	movzwl %si,%eax
  805793:	89 44 24 04          	mov    %eax,0x4(%esp)
  805797:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80579e:	e8 70 2a 00 00       	call   808213 <pbuf_alloc>
  8057a3:	89 03                	mov    %eax,(%ebx)
  if (buf->p == NULL) {
  8057a5:	ba 00 00 00 00       	mov    $0x0,%edx
  8057aa:	85 c0                	test   %eax,%eax
  8057ac:	74 28                	je     8057d6 <netbuf_alloc+0x8b>
     return NULL;
  }
  LWIP_ASSERT("check that first pbuf can hold size",
  8057ae:	66 3b 70 0a          	cmp    0xa(%eax),%si
  8057b2:	76 1c                	jbe    8057d0 <netbuf_alloc+0x85>
  8057b4:	c7 44 24 08 38 31 81 	movl   $0x813138,0x8(%esp)
  8057bb:	00 
  8057bc:	c7 44 24 04 6e 00 00 	movl   $0x6e,0x4(%esp)
  8057c3:	00 
  8057c4:	c7 04 24 6c 30 81 00 	movl   $0x81306c,(%esp)
  8057cb:	e8 04 b2 ff ff       	call   8009d4 <_panic>
             (buf->p->len >= size));
  buf->ptr = buf->p;
  8057d0:	89 43 04             	mov    %eax,0x4(%ebx)
  return buf->p->payload;
  8057d3:	8b 50 04             	mov    0x4(%eax),%edx
}
  8057d6:	89 d0                	mov    %edx,%eax
  8057d8:	83 c4 10             	add    $0x10,%esp
  8057db:	5b                   	pop    %ebx
  8057dc:	5e                   	pop    %esi
  8057dd:	5d                   	pop    %ebp
  8057de:	c3                   	ret    

008057df <netbuf_new>:
 * @return a pointer to a new netbuf
 *         NULL on lack of memory
 */
struct
netbuf *netbuf_new(void)
{
  8057df:	55                   	push   %ebp
  8057e0:	89 e5                	mov    %esp,%ebp
  8057e2:	83 ec 18             	sub    $0x18,%esp
  struct netbuf *buf;

  buf = memp_malloc(MEMP_NETBUF);
  8057e5:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  8057ec:	e8 13 20 00 00       	call   807804 <memp_malloc>
  if (buf != NULL) {
  8057f1:	85 c0                	test   %eax,%eax
  8057f3:	74 14                	je     805809 <netbuf_new+0x2a>
    buf->p = NULL;
  8057f5:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    buf->ptr = NULL;
  8057fb:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    buf->addr = NULL;
  805802:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)
    return buf;
  } else {
    return NULL;
  }
}
  805809:	c9                   	leave  
  80580a:	c3                   	ret    
  80580b:	00 00                	add    %al,(%eax)
  80580d:	00 00                	add    %al,(%eax)
	...

00805810 <lwip_init>:
/**
 * Perform Sanity check of user-configurable values, and initialize all modules.
 */
void
lwip_init(void)
{
  805810:	55                   	push   %ebp
  805811:	89 e5                	mov    %esp,%ebp
  805813:	83 ec 08             	sub    $0x8,%esp
  /* Sanity check user-configurable values */
  lwip_sanity_check();

  /* Modules initialization */
  stats_init();
  sys_init();
  805816:	e8 35 7d 00 00       	call   80d550 <sys_init>
  mem_init();
  80581b:	e8 be 1e 00 00       	call   8076de <mem_init>
  memp_init();
  805820:	e8 17 1f 00 00       	call   80773c <memp_init>
  pbuf_init();
  netif_init();
#if LWIP_SOCKET
  lwip_socket_init();
  805825:	e8 57 e9 ff ff       	call   804181 <lwip_socket_init>
  igmp_init();
#endif /* LWIP_IGMP */
#if LWIP_DNS
  dns_init();
#endif /* LWIP_DNS */
}
  80582a:	c9                   	leave  
  80582b:	c3                   	ret    
  80582c:	00 00                	add    %al,(%eax)
	...

00805830 <dhcp_set_state>:
 *
 * TODO: we might also want to reset the timeout here?
 */
static void
dhcp_set_state(struct dhcp *dhcp, u8_t new_state)
{
  805830:	55                   	push   %ebp
  805831:	89 e5                	mov    %esp,%ebp
  if (new_state != dhcp->state) {
  805833:	38 10                	cmp    %dl,(%eax)
  805835:	74 06                	je     80583d <dhcp_set_state+0xd>
    dhcp->state = new_state;
  805837:	88 10                	mov    %dl,(%eax)
    dhcp->tries = 0;
  805839:	c6 40 01 00          	movb   $0x0,0x1(%eax)
  }
}
  80583d:	5d                   	pop    %ebp
  80583e:	c3                   	ret    

0080583f <dhcp_get_option_ptr>:
 *
 * @return a byte offset into the UDP message where the option was found, or
 * zero if the given option was not found.
 */
static u8_t *dhcp_get_option_ptr(struct dhcp *dhcp, u8_t option_type)
{
  80583f:	55                   	push   %ebp
  805840:	89 e5                	mov    %esp,%ebp
  805842:	57                   	push   %edi
  805843:	56                   	push   %esi
  805844:	53                   	push   %ebx
  805845:	83 ec 08             	sub    $0x8,%esp
  805848:	88 55 f3             	mov    %dl,-0xd(%ebp)
  u8_t overload = DHCP_OVERLOAD_NONE;

  /* options available? */
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
  80584b:	8b 70 14             	mov    0x14(%eax),%esi
  80584e:	85 f6                	test   %esi,%esi
  805850:	0f 84 e6 00 00 00    	je     80593c <dhcp_get_option_ptr+0xfd>
  805856:	0f b7 78 18          	movzwl 0x18(%eax),%edi
  80585a:	66 85 ff             	test   %di,%di
  80585d:	0f 84 d9 00 00 00    	je     80593c <dhcp_get_option_ptr+0xfd>
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  805863:	0f b6 0e             	movzbl (%esi),%ecx
  805866:	80 f9 ff             	cmp    $0xff,%cl
  805869:	0f 84 cd 00 00 00    	je     80593c <dhcp_get_option_ptr+0xfd>
  80586f:	89 f3                	mov    %esi,%ebx
  805871:	ba 00 00 00 00       	mov    $0x0,%edx
  805876:	c6 45 f2 00          	movb   $0x0,-0xe(%ebp)
      /* LWIP_DEBUGF(DHCP_DEBUG, ("msg_offset=%"U16_F", q->len=%"U16_F, msg_offset, q->len)); */
      /* are the sname and/or file field overloaded with options? */
      if (options[offset] == DHCP_OPTION_OVERLOAD) {
  80587a:	80 f9 34             	cmp    $0x34,%cl
  80587d:	75 12                	jne    805891 <dhcp_get_option_ptr+0x52>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("overloaded message detected\n"));
        /* skip option type and length */
        offset += 2;
  80587f:	8d 4a 02             	lea    0x2(%edx),%ecx
        overload = options[offset++];
  805882:	0f b7 c9             	movzwl %cx,%ecx
  805885:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  805889:	88 4d f2             	mov    %cl,-0xe(%ebp)
  80588c:	83 c2 03             	add    $0x3,%edx
  80588f:	eb 17                	jmp    8058a8 <dhcp_get_option_ptr+0x69>
      }
      /* requested option found */
      else if (options[offset] == option_type) {
  805891:	3a 4d f3             	cmp    -0xd(%ebp),%cl
  805894:	0f 84 a7 00 00 00    	je     805941 <dhcp_get_option_ptr+0x102>
        return &options[offset];
      /* skip option */
      } else {
         LWIP_DEBUGF(DHCP_DEBUG, ("skipping option %"U16_F" in options\n", options[offset]));
        /* skip option type */
        offset++;
  80589a:	8d 4a 01             	lea    0x1(%edx),%ecx
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
  80589d:	0f b7 c9             	movzwl %cx,%ecx
  8058a0:	0f b6 0c 0e          	movzbl (%esi,%ecx,1),%ecx
  8058a4:	8d 54 0a 02          	lea    0x2(%edx,%ecx,1),%edx
  if ((dhcp->options_in != NULL) && (dhcp->options_in_len > 0)) {
    /* start with options field */
    u8_t *options = (u8_t *)dhcp->options_in;
    u16_t offset = 0;
    /* at least 1 byte to read and no end marker, then at least 3 bytes to read? */
    while ((offset < dhcp->options_in_len) && (options[offset] != DHCP_OPTION_END)) {
  8058a8:	66 39 d7             	cmp    %dx,%di
  8058ab:	76 0e                	jbe    8058bb <dhcp_get_option_ptr+0x7c>
  8058ad:	0f b7 da             	movzwl %dx,%ebx
  8058b0:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  8058b3:	0f b6 0b             	movzbl (%ebx),%ecx
  8058b6:	80 f9 ff             	cmp    $0xff,%cl
  8058b9:	75 bf                	jne    80587a <dhcp_get_option_ptr+0x3b>
        /* skip option length, and then length bytes */
        offset += 1 + options[offset];
      }
    }
    /* is this an overloaded message? */
    if (overload != DHCP_OVERLOAD_NONE) {
  8058bb:	80 7d f2 00          	cmpb   $0x0,-0xe(%ebp)
  8058bf:	74 7b                	je     80593c <dhcp_get_option_ptr+0xfd>
      u16_t field_len;
      if (overload == DHCP_OVERLOAD_FILE) {
  8058c1:	80 7d f2 01          	cmpb   $0x1,-0xe(%ebp)
  8058c5:	75 0d                	jne    8058d4 <dhcp_get_option_ptr+0x95>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded file field\n"));
        options = (u8_t *)&dhcp->msg_in->file;
  8058c7:	8b 58 10             	mov    0x10(%eax),%ebx
  8058ca:	83 c3 6c             	add    $0x6c,%ebx
  8058cd:	b9 80 00 00 00       	mov    $0x80,%ecx
  8058d2:	eb 1e                	jmp    8058f2 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_FILE_LEN;
      } else if (overload == DHCP_OVERLOAD_SNAME) {
  8058d4:	80 7d f2 02          	cmpb   $0x2,-0xe(%ebp)
  8058d8:	75 0d                	jne    8058e7 <dhcp_get_option_ptr+0xa8>
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8058da:	8b 58 10             	mov    0x10(%eax),%ebx
  8058dd:	83 c3 2c             	add    $0x2c,%ebx
  8058e0:	b9 40 00 00 00       	mov    $0x40,%ecx
  8058e5:	eb 0b                	jmp    8058f2 <dhcp_get_option_ptr+0xb3>
        field_len = DHCP_SNAME_LEN;
      /* TODO: check if else if () is necessary */
      } else {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("overloaded sname and file field\n"));
        options = (u8_t *)&dhcp->msg_in->sname;
  8058e7:	8b 58 10             	mov    0x10(%eax),%ebx
  8058ea:	83 c3 2c             	add    $0x2c,%ebx
  8058ed:	b9 c0 00 00 00       	mov    $0xc0,%ecx
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  8058f2:	0f b6 13             	movzbl (%ebx),%edx
  8058f5:	80 fa ff             	cmp    $0xff,%dl
  8058f8:	74 42                	je     80593c <dhcp_get_option_ptr+0xfd>
        if (options[offset] == option_type) {
  8058fa:	b8 00 00 00 00       	mov    $0x0,%eax
  8058ff:	38 55 f3             	cmp    %dl,-0xd(%ebp)
  805902:	75 0e                	jne    805912 <dhcp_get_option_ptr+0xd3>
  805904:	eb 3b                	jmp    805941 <dhcp_get_option_ptr+0x102>
  805906:	89 f9                	mov    %edi,%ecx
  805908:	38 d1                	cmp    %dl,%cl
  80590a:	75 0e                	jne    80591a <dhcp_get_option_ptr+0xdb>
  80590c:	89 f3                	mov    %esi,%ebx
  80590e:	66 90                	xchg   %ax,%ax
  805910:	eb 2f                	jmp    805941 <dhcp_get_option_ptr+0x102>
  805912:	66 89 4d ee          	mov    %cx,-0x12(%ebp)
  805916:	0f b6 7d f3          	movzbl -0xd(%ebp),%edi
          return &options[offset];
        /* skip option */
        } else {
          LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("skipping option %"U16_F"\n", options[offset]));
          /* skip option type */
          offset++;
  80591a:	8d 50 01             	lea    0x1(%eax),%edx
          offset += 1 + options[offset];
  80591d:	0f b7 d2             	movzwl %dx,%edx
  805920:	0f b6 14 13          	movzbl (%ebx,%edx,1),%edx
  805924:	8d 44 02 02          	lea    0x2(%edx,%eax,1),%eax
        field_len = DHCP_FILE_LEN + DHCP_SNAME_LEN;
      }
      offset = 0;

      /* at least 1 byte to read and no end marker */
      while ((offset < field_len) && (options[offset] != DHCP_OPTION_END)) {
  805928:	66 39 45 ee          	cmp    %ax,-0x12(%ebp)
  80592c:	76 0e                	jbe    80593c <dhcp_get_option_ptr+0xfd>
  80592e:	0f b7 f0             	movzwl %ax,%esi
  805931:	8d 34 33             	lea    (%ebx,%esi,1),%esi
  805934:	0f b6 16             	movzbl (%esi),%edx
  805937:	80 fa ff             	cmp    $0xff,%dl
  80593a:	75 ca                	jne    805906 <dhcp_get_option_ptr+0xc7>
  80593c:	bb 00 00 00 00       	mov    $0x0,%ebx
        }
      }
    }
  }
  return NULL;
}
  805941:	89 d8                	mov    %ebx,%eax
  805943:	83 c4 08             	add    $0x8,%esp
  805946:	5b                   	pop    %ebx
  805947:	5e                   	pop    %esi
  805948:	5f                   	pop    %edi
  805949:	5d                   	pop    %ebp
  80594a:	c3                   	ret    

0080594b <dhcp_get_option_byte>:
 *
 * @return byte value at the given address.
 */
static u8_t
dhcp_get_option_byte(u8_t *ptr)
{
  80594b:	55                   	push   %ebp
  80594c:	89 e5                	mov    %esp,%ebp
  80594e:	0f b6 00             	movzbl (%eax),%eax
  LWIP_DEBUGF(DHCP_DEBUG, ("option byte value=%"U16_F"\n", (u16_t)(*ptr)));
  return *ptr;
}
  805951:	5d                   	pop    %ebp
  805952:	c3                   	ret    

00805953 <dhcp_get_option_long>:
 * @param ptr pointer obtained by dhcp_get_option_ptr().
 *
 * @return byte value at the given address.
 */
static u32_t dhcp_get_option_long(u8_t *ptr)
{
  805953:	55                   	push   %ebp
  805954:	89 e5                	mov    %esp,%ebp
  805956:	53                   	push   %ebx
  u32_t value;
  value = (u32_t)(*ptr++) << 24;
  805957:	0f b6 10             	movzbl (%eax),%edx
  80595a:	c1 e2 18             	shl    $0x18,%edx
  value |= (u32_t)(*ptr++) << 16;
  80595d:	0f b6 58 01          	movzbl 0x1(%eax),%ebx
  805961:	c1 e3 10             	shl    $0x10,%ebx
  805964:	09 d3                	or     %edx,%ebx
  805966:	8d 50 02             	lea    0x2(%eax),%edx
  value |= (u32_t)(*ptr++) << 8;
  805969:	0f b6 0a             	movzbl (%edx),%ecx
  80596c:	c1 e1 08             	shl    $0x8,%ecx
  80596f:	89 d8                	mov    %ebx,%eax
  805971:	09 c8                	or     %ecx,%eax
  805973:	0f b6 52 01          	movzbl 0x1(%edx),%edx
  805977:	09 d0                	or     %edx,%eax
  value |= (u32_t)(*ptr++);
  LWIP_DEBUGF(DHCP_DEBUG, ("option long value=%"U32_F"\n", value));
  return value;
}
  805979:	5b                   	pop    %ebx
  80597a:	5d                   	pop    %ebp
  80597b:	c3                   	ret    

0080597c <dhcp_option>:
 * DHCP message.
 *
 */
static void
dhcp_option(struct dhcp *dhcp, u8_t option_type, u8_t option_len)
{
  80597c:	55                   	push   %ebp
  80597d:	89 e5                	mov    %esp,%ebp
  80597f:	83 ec 28             	sub    $0x28,%esp
  805982:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805985:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805988:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option: dhcp->options_out_len + 2 + option_len <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U + option_len <= DHCP_OPTIONS_LEN);
  80598b:	0f b7 58 24          	movzwl 0x24(%eax),%ebx
  80598f:	0f b7 fb             	movzwl %bx,%edi
  805992:	0f b6 f1             	movzbl %cl,%esi
  805995:	8d 74 37 02          	lea    0x2(%edi,%esi,1),%esi
  805999:	83 fe 44             	cmp    $0x44,%esi
  80599c:	76 1c                	jbe    8059ba <dhcp_option+0x3e>
  80599e:	c7 44 24 08 5c 31 81 	movl   $0x81315c,0x8(%esp)
  8059a5:	00 
  8059a6:	c7 44 24 04 5a 04 00 	movl   $0x45a,0x4(%esp)
  8059ad:	00 
  8059ae:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  8059b5:	e8 1a b0 ff ff       	call   8009d4 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = option_type;
  8059ba:	8b 78 20             	mov    0x20(%eax),%edi
  8059bd:	0f b7 f3             	movzwl %bx,%esi
  8059c0:	88 94 37 f0 00 00 00 	mov    %dl,0xf0(%edi,%esi,1)
  8059c7:	8d 53 01             	lea    0x1(%ebx),%edx
  dhcp->msg_out->options[dhcp->options_out_len++] = option_len;
  8059ca:	8b 70 20             	mov    0x20(%eax),%esi
  8059cd:	0f b7 d2             	movzwl %dx,%edx
  8059d0:	88 8c 16 f0 00 00 00 	mov    %cl,0xf0(%esi,%edx,1)
  8059d7:	83 c3 02             	add    $0x2,%ebx
  8059da:	66 89 58 24          	mov    %bx,0x24(%eax)
}
  8059de:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8059e1:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8059e4:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8059e7:	89 ec                	mov    %ebp,%esp
  8059e9:	5d                   	pop    %ebp
  8059ea:	c3                   	ret    

008059eb <dhcp_option_byte>:
 * Concatenate a single byte to the outgoing DHCP message.
 *
 */
static void
dhcp_option_byte(struct dhcp *dhcp, u8_t value)
{
  8059eb:	55                   	push   %ebp
  8059ec:	89 e5                	mov    %esp,%ebp
  8059ee:	83 ec 18             	sub    $0x18,%esp
  8059f1:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8059f4:	89 75 fc             	mov    %esi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_byte: dhcp->options_out_len < DHCP_OPTIONS_LEN", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  8059f7:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  8059fb:	66 83 f9 43          	cmp    $0x43,%cx
  8059ff:	76 1c                	jbe    805a1d <dhcp_option_byte+0x32>
  805a01:	c7 44 24 08 a4 31 81 	movl   $0x8131a4,0x8(%esp)
  805a08:	00 
  805a09:	c7 44 24 04 65 04 00 	movl   $0x465,0x4(%esp)
  805a10:	00 
  805a11:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805a18:	e8 b7 af ff ff       	call   8009d4 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
  805a1d:	8b 70 20             	mov    0x20(%eax),%esi
  805a20:	0f b7 d9             	movzwl %cx,%ebx
  805a23:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805a2a:	83 c1 01             	add    $0x1,%ecx
  805a2d:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805a31:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  805a34:	8b 75 fc             	mov    -0x4(%ebp),%esi
  805a37:	89 ec                	mov    %ebp,%esp
  805a39:	5d                   	pop    %ebp
  805a3a:	c3                   	ret    

00805a3b <dhcp_option_trailer>:
 *
 * @param dhcp DHCP state structure
 */
static void
dhcp_option_trailer(struct dhcp *dhcp)
{
  805a3b:	55                   	push   %ebp
  805a3c:	89 e5                	mov    %esp,%ebp
  805a3e:	53                   	push   %ebx
  805a3f:	83 ec 14             	sub    $0x14,%esp
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  805a42:	85 c0                	test   %eax,%eax
  805a44:	75 1c                	jne    805a62 <dhcp_option_trailer+0x27>
  805a46:	c7 44 24 08 e0 31 81 	movl   $0x8131e0,0x8(%esp)
  805a4d:	00 
  805a4e:	c7 44 24 04 80 05 00 	movl   $0x580,0x4(%esp)
  805a55:	00 
  805a56:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805a5d:	e8 72 af ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  805a62:	8b 48 20             	mov    0x20(%eax),%ecx
  805a65:	85 c9                	test   %ecx,%ecx
  805a67:	75 1c                	jne    805a85 <dhcp_option_trailer+0x4a>
  805a69:	c7 44 24 08 04 32 81 	movl   $0x813204,0x8(%esp)
  805a70:	00 
  805a71:	c7 44 24 04 81 05 00 	movl   $0x581,0x4(%esp)
  805a78:	00 
  805a79:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805a80:	e8 4f af ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805a85:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805a89:	66 83 fa 43          	cmp    $0x43,%dx
  805a8d:	76 1c                	jbe    805aab <dhcp_option_trailer+0x70>
  805a8f:	c7 44 24 08 30 32 81 	movl   $0x813230,0x8(%esp)
  805a96:	00 
  805a97:	c7 44 24 04 82 05 00 	movl   $0x582,0x4(%esp)
  805a9e:	00 
  805a9f:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805aa6:	e8 29 af ff ff       	call   8009d4 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  805aab:	0f b7 da             	movzwl %dx,%ebx
  805aae:	c6 84 19 f0 00 00 00 	movb   $0xff,0xf0(%ecx,%ebx,1)
  805ab5:	ff 
  805ab6:	83 c2 01             	add    $0x1,%edx
  805ab9:	66 89 50 24          	mov    %dx,0x24(%eax)
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805abd:	eb 31                	jmp    805af0 <dhcp_option_trailer+0xb5>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  805abf:	c7 44 24 08 30 32 81 	movl   $0x813230,0x8(%esp)
  805ac6:	00 
  805ac7:	c7 44 24 04 87 05 00 	movl   $0x587,0x4(%esp)
  805ace:	00 
  805acf:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805ad6:	e8 f9 ae ff ff       	call   8009d4 <_panic>
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  805adb:	8b 58 20             	mov    0x20(%eax),%ebx
  805ade:	0f b7 ca             	movzwl %dx,%ecx
  805ae1:	c6 84 0b f0 00 00 00 	movb   $0x0,0xf0(%ebx,%ecx,1)
  805ae8:	00 
  805ae9:	83 c2 01             	add    $0x1,%edx
  805aec:	66 89 50 24          	mov    %dx,0x24(%eax)
  LWIP_ERROR("dhcp_option_trailer: dhcp != NULL", (dhcp != NULL), return;);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->msg_out != NULL\n", dhcp->msg_out != NULL);
  LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
  dhcp->msg_out->options[dhcp->options_out_len++] = DHCP_OPTION_END;
  /* packet is too small, or not 4 byte aligned? */
  while ((dhcp->options_out_len < DHCP_MIN_OPTIONS_LEN) || (dhcp->options_out_len & 3)) {
  805af0:	0f b7 50 24          	movzwl 0x24(%eax),%edx
  805af4:	66 83 fa 43          	cmp    $0x43,%dx
  805af8:	76 e1                	jbe    805adb <dhcp_option_trailer+0xa0>
  805afa:	f6 c2 03             	test   $0x3,%dl
  805afd:	75 c0                	jne    805abf <dhcp_option_trailer+0x84>
    /* LWIP_DEBUGF(DHCP_DEBUG,("dhcp_option_trailer:dhcp->options_out_len=%"U16_F", DHCP_OPTIONS_LEN=%"U16_F, dhcp->options_out_len, DHCP_OPTIONS_LEN)); */
    LWIP_ASSERT("dhcp_option_trailer: dhcp->options_out_len < DHCP_OPTIONS_LEN\n", dhcp->options_out_len < DHCP_OPTIONS_LEN);
    /* add a fill/padding byte */
    dhcp->msg_out->options[dhcp->options_out_len++] = 0;
  }
}
  805aff:	83 c4 14             	add    $0x14,%esp
  805b02:	5b                   	pop    %ebx
  805b03:	5d                   	pop    %ebp
  805b04:	c3                   	ret    

00805b05 <dhcp_option_short>:
  dhcp->msg_out->options[dhcp->options_out_len++] = value;
}

static void
dhcp_option_short(struct dhcp *dhcp, u16_t value)
{
  805b05:	55                   	push   %ebp
  805b06:	89 e5                	mov    %esp,%ebp
  805b08:	83 ec 48             	sub    $0x48,%esp
  805b0b:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805b0e:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805b11:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_short: dhcp->options_out_len + 2 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 2U <= DHCP_OPTIONS_LEN);
  805b14:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805b18:	0f b7 d9             	movzwl %cx,%ebx
  805b1b:	83 c3 02             	add    $0x2,%ebx
  805b1e:	83 fb 44             	cmp    $0x44,%ebx
  805b21:	76 1c                	jbe    805b3f <dhcp_option_short+0x3a>
  805b23:	c7 44 24 08 70 32 81 	movl   $0x813270,0x8(%esp)
  805b2a:	00 
  805b2b:	c7 44 24 04 6c 04 00 	movl   $0x46c,0x4(%esp)
  805b32:	00 
  805b33:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805b3a:	e8 95 ae ff ff       	call   8009d4 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff00U) >> 8);
  805b3f:	0f b7 d9             	movzwl %cx,%ebx
  805b42:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805b45:	89 d6                	mov    %edx,%esi
  805b47:	66 c1 ee 08          	shr    $0x8,%si
  805b4b:	66 89 75 d6          	mov    %si,-0x2a(%ebp)
  805b4f:	0f b6 5d d6          	movzbl -0x2a(%ebp),%ebx
  805b53:	8b 78 20             	mov    0x20(%eax),%edi
  805b56:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805b59:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805b60:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t) (value & 0x00ffU);
  805b63:	8b 70 20             	mov    0x20(%eax),%esi
  805b66:	0f b7 db             	movzwl %bx,%ebx
  805b69:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805b70:	83 c1 02             	add    $0x2,%ecx
  805b73:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805b77:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805b7a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805b7d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805b80:	89 ec                	mov    %ebp,%esp
  805b82:	5d                   	pop    %ebp
  805b83:	c3                   	ret    

00805b84 <dhcp_option_long>:

static void
dhcp_option_long(struct dhcp *dhcp, u32_t value)
{
  805b84:	55                   	push   %ebp
  805b85:	89 e5                	mov    %esp,%ebp
  805b87:	83 ec 48             	sub    $0x48,%esp
  805b8a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  805b8d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  805b90:	89 7d fc             	mov    %edi,-0x4(%ebp)
  LWIP_ASSERT("dhcp_option_long: dhcp->options_out_len + 4 <= DHCP_OPTIONS_LEN", dhcp->options_out_len + 4U <= DHCP_OPTIONS_LEN);
  805b93:	0f b7 48 24          	movzwl 0x24(%eax),%ecx
  805b97:	0f b7 d9             	movzwl %cx,%ebx
  805b9a:	83 c3 04             	add    $0x4,%ebx
  805b9d:	83 fb 44             	cmp    $0x44,%ebx
  805ba0:	76 1c                	jbe    805bbe <dhcp_option_long+0x3a>
  805ba2:	c7 44 24 08 b4 32 81 	movl   $0x8132b4,0x8(%esp)
  805ba9:	00 
  805baa:	c7 44 24 04 74 04 00 	movl   $0x474,0x4(%esp)
  805bb1:	00 
  805bb2:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805bb9:	e8 16 ae ff ff       	call   8009d4 <_panic>
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0xff000000UL) >> 24);
  805bbe:	0f b7 d9             	movzwl %cx,%ebx
  805bc1:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805bc4:	89 d6                	mov    %edx,%esi
  805bc6:	c1 ee 18             	shr    $0x18,%esi
  805bc9:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  805bcc:	0f b6 5d d4          	movzbl -0x2c(%ebp),%ebx
  805bd0:	8b 78 20             	mov    0x20(%eax),%edi
  805bd3:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805bd6:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805bdd:	8d 59 01             	lea    0x1(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x00ff0000UL) >> 16);
  805be0:	0f b7 db             	movzwl %bx,%ebx
  805be3:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805be6:	89 d3                	mov    %edx,%ebx
  805be8:	c1 eb 10             	shr    $0x10,%ebx
  805beb:	8b 78 20             	mov    0x20(%eax),%edi
  805bee:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805bf1:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805bf8:	8d 59 02             	lea    0x2(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x0000ff00UL) >> 8);
  805bfb:	0f b7 db             	movzwl %bx,%ebx
  805bfe:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805c01:	0f b6 de             	movzbl %dh,%ebx
  805c04:	8b 78 20             	mov    0x20(%eax),%edi
  805c07:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  805c0a:	88 9c 37 f0 00 00 00 	mov    %bl,0xf0(%edi,%esi,1)
  805c11:	8d 59 03             	lea    0x3(%ecx),%ebx
  dhcp->msg_out->options[dhcp->options_out_len++] = (u8_t)((value & 0x000000ffUL));
  805c14:	8b 70 20             	mov    0x20(%eax),%esi
  805c17:	0f b7 db             	movzwl %bx,%ebx
  805c1a:	88 94 1e f0 00 00 00 	mov    %dl,0xf0(%esi,%ebx,1)
  805c21:	83 c1 04             	add    $0x4,%ecx
  805c24:	66 89 48 24          	mov    %cx,0x24(%eax)
}
  805c28:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  805c2b:	8b 75 f8             	mov    -0x8(%ebp),%esi
  805c2e:	8b 7d fc             	mov    -0x4(%ebp),%edi
  805c31:	89 ec                	mov    %ebp,%esp
  805c33:	5d                   	pop    %ebp
  805c34:	c3                   	ret    

00805c35 <dhcp_delete_request>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_delete_request(struct netif *netif)
{
  805c35:	55                   	push   %ebp
  805c36:	89 e5                	mov    %esp,%ebp
  805c38:	53                   	push   %ebx
  805c39:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp;
  LWIP_ERROR("dhcp_delete_request: netif != NULL", (netif != NULL), return;);
  805c3c:	85 c0                	test   %eax,%eax
  805c3e:	75 1c                	jne    805c5c <dhcp_delete_request+0x27>
  805c40:	c7 44 24 08 f4 32 81 	movl   $0x8132f4,0x8(%esp)
  805c47:	00 
  805c48:	c7 44 24 04 69 05 00 	movl   $0x569,0x4(%esp)
  805c4f:	00 
  805c50:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805c57:	e8 78 ad ff ff       	call   8009d4 <_panic>
  dhcp = netif->dhcp;
  805c5c:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_delete_request: dhcp != NULL", (dhcp != NULL), return;);
  805c5f:	85 db                	test   %ebx,%ebx
  805c61:	75 1c                	jne    805c7f <dhcp_delete_request+0x4a>
  805c63:	c7 44 24 08 18 33 81 	movl   $0x813318,0x8(%esp)
  805c6a:	00 
  805c6b:	c7 44 24 04 6b 05 00 	movl   $0x56b,0x4(%esp)
  805c72:	00 
  805c73:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805c7a:	e8 55 ad ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->p_out != NULL", dhcp->p_out != NULL);
  805c7f:	8b 43 1c             	mov    0x1c(%ebx),%eax
  805c82:	85 c0                	test   %eax,%eax
  805c84:	75 1c                	jne    805ca2 <dhcp_delete_request+0x6d>
  805c86:	c7 44 24 08 3c 33 81 	movl   $0x81333c,0x8(%esp)
  805c8d:	00 
  805c8e:	c7 44 24 04 6c 05 00 	movl   $0x56c,0x4(%esp)
  805c95:	00 
  805c96:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805c9d:	e8 32 ad ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("dhcp_delete_request: dhcp->msg_out != NULL", dhcp->msg_out != NULL);
  805ca2:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805ca6:	75 1c                	jne    805cc4 <dhcp_delete_request+0x8f>
  805ca8:	c7 44 24 08 68 33 81 	movl   $0x813368,0x8(%esp)
  805caf:	00 
  805cb0:	c7 44 24 04 6d 05 00 	movl   $0x56d,0x4(%esp)
  805cb7:	00 
  805cb8:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805cbf:	e8 10 ad ff ff       	call   8009d4 <_panic>
  if (dhcp->p_out != NULL) {
    pbuf_free(dhcp->p_out);
  805cc4:	89 04 24             	mov    %eax,(%esp)
  805cc7:	e8 8c 22 00 00       	call   807f58 <pbuf_free>
  }
  dhcp->p_out = NULL;
  805ccc:	c7 43 1c 00 00 00 00 	movl   $0x0,0x1c(%ebx)
  dhcp->msg_out = NULL;
  805cd3:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
}
  805cda:	83 c4 14             	add    $0x14,%esp
  805cdd:	5b                   	pop    %ebx
  805cde:	5d                   	pop    %ebp
  805cdf:	c3                   	ret    

00805ce0 <dhcp_free_reply>:
 * Free the incoming DHCP message including contiguous copy of
 * its DHCP options.
 *
 */
static void dhcp_free_reply(struct dhcp *dhcp)
{
  805ce0:	55                   	push   %ebp
  805ce1:	89 e5                	mov    %esp,%ebp
  805ce3:	53                   	push   %ebx
  805ce4:	83 ec 14             	sub    $0x14,%esp
  805ce7:	89 c3                	mov    %eax,%ebx
  if (dhcp->msg_in != NULL) {
  805ce9:	8b 40 10             	mov    0x10(%eax),%eax
  805cec:	85 c0                	test   %eax,%eax
  805cee:	74 0f                	je     805cff <dhcp_free_reply+0x1f>
    mem_free((void *)dhcp->msg_in);
  805cf0:	89 04 24             	mov    %eax,(%esp)
  805cf3:	e8 56 18 00 00       	call   80754e <mem_free>
    dhcp->msg_in = NULL;
  805cf8:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)
  }
  if (dhcp->options_in) {
  805cff:	8b 43 14             	mov    0x14(%ebx),%eax
  805d02:	85 c0                	test   %eax,%eax
  805d04:	74 15                	je     805d1b <dhcp_free_reply+0x3b>
    mem_free((void *)dhcp->options_in);
  805d06:	89 04 24             	mov    %eax,(%esp)
  805d09:	e8 40 18 00 00       	call   80754e <mem_free>
    dhcp->options_in = NULL;
  805d0e:	c7 43 14 00 00 00 00 	movl   $0x0,0x14(%ebx)
    dhcp->options_in_len = 0;
  805d15:	66 c7 43 18 00 00    	movw   $0x0,0x18(%ebx)
  }
  LWIP_DEBUGF(DHCP_DEBUG, ("dhcp_free_reply(): free'd\n"));
}
  805d1b:	83 c4 14             	add    $0x14,%esp
  805d1e:	5b                   	pop    %ebx
  805d1f:	5d                   	pop    %ebp
  805d20:	c3                   	ret    

00805d21 <dhcp_stop>:
 *
 * @param netif The network interface to stop DHCP on
 */
void
dhcp_stop(struct netif *netif)
{
  805d21:	55                   	push   %ebp
  805d22:	89 e5                	mov    %esp,%ebp
  805d24:	56                   	push   %esi
  805d25:	53                   	push   %ebx
  805d26:	83 ec 10             	sub    $0x10,%esp
  805d29:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805d2c:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_ERROR("dhcp_stop: netif != NULL", (netif != NULL), return;);
  805d2f:	85 f6                	test   %esi,%esi
  805d31:	75 1c                	jne    805d4f <dhcp_stop+0x2e>
  805d33:	c7 44 24 08 bf 34 81 	movl   $0x8134bf,0x8(%esp)
  805d3a:	00 
  805d3b:	c7 44 24 04 2c 04 00 	movl   $0x42c,0x4(%esp)
  805d42:	00 
  805d43:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805d4a:	e8 85 ac ff ff       	call   8009d4 <_panic>
  /* Remove the flag that says this netif is handled by DHCP. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  805d4f:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_stop()\n"));
  /* netif is DHCP configured? */
  if (dhcp != NULL) {
  805d53:	85 db                	test   %ebx,%ebx
  805d55:	74 42                	je     805d99 <dhcp_stop+0x78>
    if (dhcp->pcb != NULL) {
  805d57:	8b 43 08             	mov    0x8(%ebx),%eax
  805d5a:	85 c0                	test   %eax,%eax
  805d5c:	74 0f                	je     805d6d <dhcp_stop+0x4c>
      udp_remove(dhcp->pcb);
  805d5e:	89 04 24             	mov    %eax,(%esp)
  805d61:	e8 e6 63 00 00       	call   80c14c <udp_remove>
      dhcp->pcb = NULL;
  805d66:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    }
    if (dhcp->p != NULL) {
  805d6d:	8b 43 0c             	mov    0xc(%ebx),%eax
  805d70:	85 c0                	test   %eax,%eax
  805d72:	74 0f                	je     805d83 <dhcp_stop+0x62>
      pbuf_free(dhcp->p);
  805d74:	89 04 24             	mov    %eax,(%esp)
  805d77:	e8 dc 21 00 00       	call   807f58 <pbuf_free>
      dhcp->p = NULL;
  805d7c:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    }
    /* free unfolded reply */
    dhcp_free_reply(dhcp);
  805d83:	89 d8                	mov    %ebx,%eax
  805d85:	e8 56 ff ff ff       	call   805ce0 <dhcp_free_reply>
    mem_free((void *)dhcp);
  805d8a:	89 1c 24             	mov    %ebx,(%esp)
  805d8d:	e8 bc 17 00 00       	call   80754e <mem_free>
    netif->dhcp = NULL;
  805d92:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  }
}
  805d99:	83 c4 10             	add    $0x10,%esp
  805d9c:	5b                   	pop    %ebx
  805d9d:	5e                   	pop    %esi
  805d9e:	5d                   	pop    %ebp
  805d9f:	c3                   	ret    

00805da0 <dhcp_create_request>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_create_request(struct netif *netif)
{
  805da0:	55                   	push   %ebp
  805da1:	89 e5                	mov    %esp,%ebp
  805da3:	57                   	push   %edi
  805da4:	56                   	push   %esi
  805da5:	53                   	push   %ebx
  805da6:	83 ec 2c             	sub    $0x2c,%esp
  805da9:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp;
  u16_t i;
  LWIP_ERROR("dhcp_create_request: netif != NULL", (netif != NULL), return ERR_ARG;);
  805dab:	85 c0                	test   %eax,%eax
  805dad:	75 1c                	jne    805dcb <dhcp_create_request+0x2b>
  805daf:	c7 44 24 08 94 33 81 	movl   $0x813394,0x8(%esp)
  805db6:	00 
  805db7:	c7 44 24 04 2d 05 00 	movl   $0x52d,0x4(%esp)
  805dbe:	00 
  805dbf:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805dc6:	e8 09 ac ff ff       	call   8009d4 <_panic>
  dhcp = netif->dhcp;
  805dcb:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_create_request: dhcp != NULL", (dhcp != NULL), return ERR_VAL;);
  805dce:	85 db                	test   %ebx,%ebx
  805dd0:	75 1c                	jne    805dee <dhcp_create_request+0x4e>
  805dd2:	c7 44 24 08 b8 33 81 	movl   $0x8133b8,0x8(%esp)
  805dd9:	00 
  805dda:	c7 44 24 04 2f 05 00 	movl   $0x52f,0x4(%esp)
  805de1:	00 
  805de2:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805de9:	e8 e6 ab ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->p_out == NULL", dhcp->p_out == NULL);
  805dee:	83 7b 1c 00          	cmpl   $0x0,0x1c(%ebx)
  805df2:	74 1c                	je     805e10 <dhcp_create_request+0x70>
  805df4:	c7 44 24 08 dc 33 81 	movl   $0x8133dc,0x8(%esp)
  805dfb:	00 
  805dfc:	c7 44 24 04 30 05 00 	movl   $0x530,0x4(%esp)
  805e03:	00 
  805e04:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805e0b:	e8 c4 ab ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("dhcp_create_request: dhcp->msg_out == NULL", dhcp->msg_out == NULL);
  805e10:	83 7b 20 00          	cmpl   $0x0,0x20(%ebx)
  805e14:	74 1c                	je     805e32 <dhcp_create_request+0x92>
  805e16:	c7 44 24 08 08 34 81 	movl   $0x813408,0x8(%esp)
  805e1d:	00 
  805e1e:	c7 44 24 04 31 05 00 	movl   $0x531,0x4(%esp)
  805e25:	00 
  805e26:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805e2d:	e8 a2 ab ff ff       	call   8009d4 <_panic>
  dhcp->p_out = pbuf_alloc(PBUF_TRANSPORT, sizeof(struct dhcp_msg), PBUF_RAM);
  805e32:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  805e39:	00 
  805e3a:	c7 44 24 04 34 01 00 	movl   $0x134,0x4(%esp)
  805e41:	00 
  805e42:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  805e49:	e8 c5 23 00 00       	call   808213 <pbuf_alloc>
  805e4e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  if (dhcp->p_out == NULL) {
  805e51:	ba ff ff ff ff       	mov    $0xffffffff,%edx
  805e56:	85 c0                	test   %eax,%eax
  805e58:	0f 84 2d 01 00 00    	je     805f8b <dhcp_create_request+0x1eb>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_create_request(): could not allocate pbuf\n"));
    return ERR_MEM;
  }
  LWIP_ASSERT("dhcp_create_request: check that first pbuf can hold struct dhcp_msg",
  805e5e:	66 81 78 0a 33 01    	cmpw   $0x133,0xa(%eax)
  805e64:	77 1c                	ja     805e82 <dhcp_create_request+0xe2>
  805e66:	c7 44 24 08 34 34 81 	movl   $0x813434,0x8(%esp)
  805e6d:	00 
  805e6e:	c7 44 24 04 38 05 00 	movl   $0x538,0x4(%esp)
  805e75:	00 
  805e76:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  805e7d:	e8 52 ab ff ff       	call   8009d4 <_panic>
           (dhcp->p_out->len >= sizeof(struct dhcp_msg)));

  /* give unique transaction identifier to this request */
  dhcp->xid = xid++;
  805e82:	8b 15 78 90 81 00    	mov    0x819078,%edx
  805e88:	89 53 04             	mov    %edx,0x4(%ebx)
  805e8b:	83 c2 01             	add    $0x1,%edx
  805e8e:	89 15 78 90 81 00    	mov    %edx,0x819078
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("transaction id xid++(%"X32_F") dhcp->xid(%"U32_F")\n",xid,dhcp->xid));

  dhcp->msg_out = (struct dhcp_msg *)dhcp->p_out->payload;
  805e94:	8b 40 04             	mov    0x4(%eax),%eax
  805e97:	89 43 20             	mov    %eax,0x20(%ebx)

  dhcp->msg_out->op = DHCP_BOOTREQUEST;
  805e9a:	c6 00 01             	movb   $0x1,(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->htype = DHCP_HTYPE_ETH;
  805e9d:	8b 43 20             	mov    0x20(%ebx),%eax
  805ea0:	c6 40 01 01          	movb   $0x1,0x1(%eax)
  /* TODO: make link layer independent */
  dhcp->msg_out->hlen = DHCP_HLEN_ETH;
  805ea4:	8b 43 20             	mov    0x20(%ebx),%eax
  805ea7:	c6 40 02 06          	movb   $0x6,0x2(%eax)
  dhcp->msg_out->hops = 0;
  805eab:	8b 43 20             	mov    0x20(%ebx),%eax
  805eae:	c6 40 03 00          	movb   $0x0,0x3(%eax)
  dhcp->msg_out->xid = htonl(dhcp->xid);
  805eb2:	8b 73 20             	mov    0x20(%ebx),%esi
  805eb5:	8b 43 04             	mov    0x4(%ebx),%eax
  805eb8:	89 04 24             	mov    %eax,(%esp)
  805ebb:	e8 b5 4e 00 00       	call   80ad75 <htonl>
  805ec0:	89 46 04             	mov    %eax,0x4(%esi)
  dhcp->msg_out->secs = 0;
  805ec3:	8b 43 20             	mov    0x20(%ebx),%eax
  805ec6:	66 c7 40 08 00 00    	movw   $0x0,0x8(%eax)
  dhcp->msg_out->flags = 0;
  805ecc:	8b 43 20             	mov    0x20(%ebx),%eax
  805ecf:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  805ed5:	8b 43 20             	mov    0x20(%ebx),%eax
  805ed8:	8b 57 04             	mov    0x4(%edi),%edx
  805edb:	89 50 0c             	mov    %edx,0xc(%eax)
  dhcp->msg_out->yiaddr.addr = 0;
  805ede:	8b 43 20             	mov    0x20(%ebx),%eax
  805ee1:	c7 40 10 00 00 00 00 	movl   $0x0,0x10(%eax)
  dhcp->msg_out->siaddr.addr = 0;
  805ee8:	8b 43 20             	mov    0x20(%ebx),%eax
  805eeb:	c7 40 14 00 00 00 00 	movl   $0x0,0x14(%eax)
  dhcp->msg_out->giaddr.addr = 0;
  805ef2:	8b 43 20             	mov    0x20(%ebx),%eax
  805ef5:	c7 40 18 00 00 00 00 	movl   $0x0,0x18(%eax)
  805efc:	b8 00 00 00 00       	mov    $0x0,%eax
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  805f01:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  805f04:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  805f07:	8b 5a 20             	mov    0x20(%edx),%ebx
  805f0a:	89 c1                	mov    %eax,%ecx
  805f0c:	0f b6 77 24          	movzbl 0x24(%edi),%esi
  805f10:	ba 00 00 00 00       	mov    $0x0,%edx
  805f15:	66 39 c6             	cmp    %ax,%si
  805f18:	76 05                	jbe    805f1f <dhcp_create_request+0x17f>
  805f1a:	0f b6 54 07 25       	movzbl 0x25(%edi,%eax,1),%edx
  805f1f:	88 54 0b 1c          	mov    %dl,0x1c(%ebx,%ecx,1)
  805f23:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->flags = 0;
  dhcp->msg_out->ciaddr.addr = netif->ip_addr.addr;
  dhcp->msg_out->yiaddr.addr = 0;
  dhcp->msg_out->siaddr.addr = 0;
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
  805f26:	83 f8 10             	cmp    $0x10,%eax
  805f29:	75 d9                	jne    805f04 <dhcp_create_request+0x164>
  805f2b:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  805f2e:	b0 00                	mov    $0x0,%al
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  805f30:	8b 53 20             	mov    0x20(%ebx),%edx
  805f33:	c6 44 02 2c 00       	movb   $0x0,0x2c(%edx,%eax,1)
  805f38:	83 c0 01             	add    $0x1,%eax
  dhcp->msg_out->giaddr.addr = 0;
  for (i = 0; i < DHCP_CHADDR_LEN; i++) {
    /* copy netif hardware address, pad with zeroes */
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
  805f3b:	83 f8 40             	cmp    $0x40,%eax
  805f3e:	75 f0                	jne    805f30 <dhcp_create_request+0x190>
  805f40:	b0 00                	mov    $0x0,%al
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
    dhcp->msg_out->file[i] = 0;
  805f42:	8b 53 20             	mov    0x20(%ebx),%edx
  805f45:	c6 44 02 6c 00       	movb   $0x0,0x6c(%edx,%eax,1)
  805f4a:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->chaddr[i] = (i < netif->hwaddr_len) ? netif->hwaddr[i] : 0/* pad byte*/;
  }
  for (i = 0; i < DHCP_SNAME_LEN; i++) {
    dhcp->msg_out->sname[i] = 0;
  }
  for (i = 0; i < DHCP_FILE_LEN; i++) {
  805f4d:	3d 80 00 00 00       	cmp    $0x80,%eax
  805f52:	75 ee                	jne    805f42 <dhcp_create_request+0x1a2>
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  805f54:	8b 73 20             	mov    0x20(%ebx),%esi
  805f57:	c7 04 24 63 53 82 63 	movl   $0x63825363,(%esp)
  805f5e:	e8 12 4e 00 00       	call   80ad75 <htonl>
  805f63:	89 86 ec 00 00 00    	mov    %eax,0xec(%esi)
  dhcp->options_out_len = 0;
  805f69:	66 c7 43 24 00 00    	movw   $0x0,0x24(%ebx)
  805f6f:	b8 00 00 00 00       	mov    $0x0,%eax
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  805f74:	8b 53 20             	mov    0x20(%ebx),%edx
  805f77:	88 84 02 f0 00 00 00 	mov    %al,0xf0(%edx,%eax,1)
  805f7e:	83 c0 01             	add    $0x1,%eax
    dhcp->msg_out->file[i] = 0;
  }
  dhcp->msg_out->cookie = htonl(0x63825363UL);
  dhcp->options_out_len = 0;
  /* fill options field with an incrementing array (for debugging purposes) */
  for (i = 0; i < DHCP_OPTIONS_LEN; i++) {
  805f81:	83 f8 44             	cmp    $0x44,%eax
  805f84:	75 ee                	jne    805f74 <dhcp_create_request+0x1d4>
  805f86:	ba 00 00 00 00       	mov    $0x0,%edx
    dhcp->msg_out->options[i] = (u8_t)i; /* for debugging only, no matter if truncated */
  }
  return ERR_OK;
}
  805f8b:	89 d0                	mov    %edx,%eax
  805f8d:	83 c4 2c             	add    $0x2c,%esp
  805f90:	5b                   	pop    %ebx
  805f91:	5e                   	pop    %esi
  805f92:	5f                   	pop    %edi
  805f93:	5d                   	pop    %ebp
  805f94:	c3                   	ret    

00805f95 <dhcp_release>:
 *
 * @param netif network interface which must release its lease
 */
err_t
dhcp_release(struct netif *netif)
{
  805f95:	55                   	push   %ebp
  805f96:	89 e5                	mov    %esp,%ebp
  805f98:	57                   	push   %edi
  805f99:	56                   	push   %esi
  805f9a:	53                   	push   %ebx
  805f9b:	83 ec 3c             	sub    $0x3c,%esp
  805f9e:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp = netif->dhcp;
  805fa1:	8b 5e 20             	mov    0x20(%esi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_release()\n"));

  /* idle DHCP client */
  dhcp_set_state(dhcp, DHCP_OFF);
  805fa4:	ba 0d 00 00 00       	mov    $0xd,%edx
  805fa9:	89 d8                	mov    %ebx,%eax
  805fab:	e8 80 f8 ff ff       	call   805830 <dhcp_set_state>
  /* clean old DHCP offer */
  dhcp->server_ip_addr.addr = 0;
  805fb0:	c7 43 2c 00 00 00 00 	movl   $0x0,0x2c(%ebx)
  dhcp->offered_ip_addr.addr = dhcp->offered_sn_mask.addr = 0;
  805fb7:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  805fbe:	c7 43 30 00 00 00 00 	movl   $0x0,0x30(%ebx)
  dhcp->offered_gw_addr.addr = dhcp->offered_bc_addr.addr = 0;
  805fc5:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)
  805fcc:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_t0_lease = dhcp->offered_t1_renew = dhcp->offered_t2_rebind = 0;
  805fd3:	c7 43 54 00 00 00 00 	movl   $0x0,0x54(%ebx)
  805fda:	c7 43 50 00 00 00 00 	movl   $0x0,0x50(%ebx)
  805fe1:	c7 43 4c 00 00 00 00 	movl   $0x0,0x4c(%ebx)
  dhcp->dns_count = 0;
  805fe8:	c7 43 40 00 00 00 00 	movl   $0x0,0x40(%ebx)
  
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  805fef:	89 f0                	mov    %esi,%eax
  805ff1:	e8 aa fd ff ff       	call   805da0 <dhcp_create_request>
  805ff6:	89 c7                	mov    %eax,%edi
  if (result == ERR_OK) {
  805ff8:	84 c0                	test   %al,%al
  805ffa:	0f 85 87 00 00 00    	jne    806087 <dhcp_release+0xf2>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806000:	b9 01 00 00 00       	mov    $0x1,%ecx
  806005:	ba 35 00 00 00       	mov    $0x35,%edx
  80600a:	89 d8                	mov    %ebx,%eax
  80600c:	e8 6b f9 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_RELEASE);
  806011:	ba 07 00 00 00       	mov    $0x7,%edx
  806016:	89 d8                	mov    %ebx,%eax
  806018:	e8 ce f9 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  80601d:	89 d8                	mov    %ebx,%eax
  80601f:	e8 17 fa ff ff       	call   805a3b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806024:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806028:	66 05 f0 00          	add    $0xf0,%ax
  80602c:	0f b7 c0             	movzwl %ax,%eax
  80602f:	89 44 24 04          	mov    %eax,0x4(%esp)
  806033:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806036:	89 04 24             	mov    %eax,(%esp)
  806039:	e8 a2 20 00 00       	call   8080e0 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80603e:	8d 43 2c             	lea    0x2c(%ebx),%eax
  806041:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806044:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80604b:	00 
  80604c:	89 44 24 04          	mov    %eax,0x4(%esp)
  806050:	8b 43 08             	mov    0x8(%ebx),%eax
  806053:	89 04 24             	mov    %eax,(%esp)
  806056:	e8 03 62 00 00       	call   80c25e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  80605b:	89 74 24 10          	mov    %esi,0x10(%esp)
  80605f:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806066:	00 
  806067:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80606a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80606e:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806071:	89 44 24 04          	mov    %eax,0x4(%esp)
  806075:	8b 43 08             	mov    0x8(%ebx),%eax
  806078:	89 04 24             	mov    %eax,(%esp)
  80607b:	e8 60 62 00 00       	call   80c2e0 <udp_sendto_if>
    dhcp_delete_request(netif);
  806080:	89 f0                	mov    %esi,%eax
  806082:	e8 ae fb ff ff       	call   805c35 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release: RELEASED, DHCP_OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_release: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806087:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  80608b:	83 c1 01             	add    $0x1,%ecx
  80608e:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  806091:	ba 10 27 00 00       	mov    $0x2710,%edx
  806096:	80 f9 09             	cmp    $0x9,%cl
  806099:	77 08                	ja     8060a3 <dhcp_release+0x10e>
  80609b:	0f b6 c9             	movzbl %cl,%ecx
  80609e:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8060a3:	0f b7 d2             	movzwl %dx,%edx
  8060a6:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8060ac:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8060b1:	89 d0                	mov    %edx,%eax
  8060b3:	f7 e9                	imul   %ecx
  8060b5:	c1 fa 05             	sar    $0x5,%edx
  8060b8:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_release(): set request timeout %"U16_F" msecs\n", msecs));
  /* bring the interface down */
  netif_set_down(netif);
  8060bc:	89 34 24             	mov    %esi,(%esp)
  8060bf:	e8 84 18 00 00       	call   807948 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  8060c4:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  8060cb:	00 
  8060cc:	89 34 24             	mov    %esi,(%esp)
  8060cf:	e8 d0 18 00 00       	call   8079a4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  8060d4:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  8060db:	00 
  8060dc:	89 34 24             	mov    %esi,(%esp)
  8060df:	e8 cb 17 00 00       	call   8078af <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY);
  8060e4:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  8060eb:	00 
  8060ec:	89 34 24             	mov    %esi,(%esp)
  8060ef:	e8 d4 17 00 00       	call   8078c8 <netif_set_netmask>
  
  /* TODO: netif_down(netif); */
  return result;
}
  8060f4:	89 f8                	mov    %edi,%eax
  8060f6:	83 c4 3c             	add    $0x3c,%esp
  8060f9:	5b                   	pop    %ebx
  8060fa:	5e                   	pop    %esi
  8060fb:	5f                   	pop    %edi
  8060fc:	5d                   	pop    %ebp
  8060fd:	c3                   	ret    

008060fe <dhcp_renew>:
 *
 * @param netif network interface which must renew its lease
 */
err_t
dhcp_renew(struct netif *netif)
{
  8060fe:	55                   	push   %ebp
  8060ff:	89 e5                	mov    %esp,%ebp
  806101:	83 ec 48             	sub    $0x48,%esp
  806104:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  806107:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80610a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80610d:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct dhcp *dhcp = netif->dhcp;
  806110:	8b 5f 20             	mov    0x20(%edi),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_renew()\n"));
  dhcp_set_state(dhcp, DHCP_RENEWING);
  806113:	ba 05 00 00 00       	mov    $0x5,%edx
  806118:	89 d8                	mov    %ebx,%eax
  80611a:	e8 11 f7 ff ff       	call   805830 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80611f:	89 f8                	mov    %edi,%eax
  806121:	e8 7a fc ff ff       	call   805da0 <dhcp_create_request>
  806126:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806128:	84 c0                	test   %al,%al
  80612a:	0f 85 a4 00 00 00    	jne    8061d4 <dhcp_renew+0xd6>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806130:	b9 01 00 00 00       	mov    $0x1,%ecx
  806135:	ba 35 00 00 00       	mov    $0x35,%edx
  80613a:	89 d8                	mov    %ebx,%eax
  80613c:	e8 3b f8 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  806141:	ba 03 00 00 00       	mov    $0x3,%edx
  806146:	89 d8                	mov    %ebx,%eax
  806148:	e8 9e f8 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80614d:	b9 02 00 00 00       	mov    $0x2,%ecx
  806152:	ba 39 00 00 00       	mov    $0x39,%edx
  806157:	89 d8                	mov    %ebx,%eax
  806159:	e8 1e f8 ff ff       	call   80597c <dhcp_option>
    /* TODO: use netif->mtu in some way */
    dhcp_option_short(dhcp, 576);
  80615e:	ba 40 02 00 00       	mov    $0x240,%edx
  806163:	89 d8                	mov    %ebx,%eax
  806165:	e8 9b f9 ff ff       	call   805b05 <dhcp_option_short>
#if 0
    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif
    /* append DHCP message trailer */
    dhcp_option_trailer(dhcp);
  80616a:	89 d8                	mov    %ebx,%eax
  80616c:	e8 ca f8 ff ff       	call   805a3b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806171:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  806175:	66 05 f0 00          	add    $0xf0,%ax
  806179:	0f b7 c0             	movzwl %ax,%eax
  80617c:	89 44 24 04          	mov    %eax,0x4(%esp)
  806180:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806183:	89 04 24             	mov    %eax,(%esp)
  806186:	e8 55 1f 00 00       	call   8080e0 <pbuf_realloc>

    udp_connect(dhcp->pcb, &dhcp->server_ip_addr, DHCP_SERVER_PORT);
  80618b:	8d 43 2c             	lea    0x2c(%ebx),%eax
  80618e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806191:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806198:	00 
  806199:	89 44 24 04          	mov    %eax,0x4(%esp)
  80619d:	8b 43 08             	mov    0x8(%ebx),%eax
  8061a0:	89 04 24             	mov    %eax,(%esp)
  8061a3:	e8 b6 60 00 00       	call   80c25e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, &dhcp->server_ip_addr, DHCP_SERVER_PORT, netif);
  8061a8:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8061ac:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8061b3:	00 
  8061b4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8061b7:	89 44 24 08          	mov    %eax,0x8(%esp)
  8061bb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8061be:	89 44 24 04          	mov    %eax,0x4(%esp)
  8061c2:	8b 43 08             	mov    0x8(%ebx),%eax
  8061c5:	89 04 24             	mov    %eax,(%esp)
  8061c8:	e8 13 61 00 00       	call   80c2e0 <udp_sendto_if>
    dhcp_delete_request(netif);
  8061cd:	89 f8                	mov    %edi,%eax
  8061cf:	e8 61 fa ff ff       	call   805c35 <dhcp_delete_request>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew: RENEWING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_renew: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8061d4:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8061d8:	83 c1 01             	add    $0x1,%ecx
  8061db:	88 4b 01             	mov    %cl,0x1(%ebx)
  /* back-off on retries, but to a maximum of 20 seconds */
  msecs = dhcp->tries < 10 ? dhcp->tries * 2000 : 20 * 1000;
  8061de:	ba 20 4e 00 00       	mov    $0x4e20,%edx
  8061e3:	80 f9 09             	cmp    $0x9,%cl
  8061e6:	77 08                	ja     8061f0 <dhcp_renew+0xf2>
  8061e8:	0f b6 c9             	movzbl %cl,%ecx
  8061eb:	66 69 d1 d0 07       	imul   $0x7d0,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8061f0:	0f b7 d2             	movzwl %dx,%edx
  8061f3:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8061f9:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8061fe:	89 d0                	mov    %edx,%eax
  806200:	f7 e9                	imul   %ecx
  806202:	c1 fa 05             	sar    $0x5,%edx
  806205:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_renew(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806209:	89 f0                	mov    %esi,%eax
  80620b:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80620e:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806211:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806214:	89 ec                	mov    %ebp,%esp
  806216:	5d                   	pop    %ebp
  806217:	c3                   	ret    

00806218 <dhcp_discover>:
 *
 * @param netif the netif under DHCP control
 */
static err_t
dhcp_discover(struct netif *netif)
{
  806218:	55                   	push   %ebp
  806219:	89 e5                	mov    %esp,%ebp
  80621b:	57                   	push   %edi
  80621c:	56                   	push   %esi
  80621d:	53                   	push   %ebx
  80621e:	83 ec 2c             	sub    $0x2c,%esp
  806221:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  806223:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_discover()\n"));
  ip_addr_set(&dhcp->offered_ip_addr, IP_ADDR_ANY);
  806226:	a1 8c 3d 81 00       	mov    0x813d8c,%eax
  80622b:	89 43 30             	mov    %eax,0x30(%ebx)
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80622e:	89 f8                	mov    %edi,%eax
  806230:	e8 6b fb ff ff       	call   805da0 <dhcp_create_request>
  806235:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806237:	84 c0                	test   %al,%al
  806239:	0f 85 f0 00 00 00    	jne    80632f <dhcp_discover+0x117>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: making request\n"));
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80623f:	b9 01 00 00 00       	mov    $0x1,%ecx
  806244:	ba 35 00 00 00       	mov    $0x35,%edx
  806249:	89 d8                	mov    %ebx,%eax
  80624b:	e8 2c f7 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DISCOVER);
  806250:	ba 01 00 00 00       	mov    $0x1,%edx
  806255:	89 d8                	mov    %ebx,%eax
  806257:	e8 8f f7 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  80625c:	b9 02 00 00 00       	mov    $0x2,%ecx
  806261:	ba 39 00 00 00       	mov    $0x39,%edx
  806266:	89 d8                	mov    %ebx,%eax
  806268:	e8 0f f7 ff ff       	call   80597c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80626d:	ba 40 02 00 00       	mov    $0x240,%edx
  806272:	89 d8                	mov    %ebx,%eax
  806274:	e8 8c f8 ff ff       	call   805b05 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  806279:	b9 04 00 00 00       	mov    $0x4,%ecx
  80627e:	ba 37 00 00 00       	mov    $0x37,%edx
  806283:	89 d8                	mov    %ebx,%eax
  806285:	e8 f2 f6 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  80628a:	ba 01 00 00 00       	mov    $0x1,%edx
  80628f:	89 d8                	mov    %ebx,%eax
  806291:	e8 55 f7 ff ff       	call   8059eb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  806296:	ba 03 00 00 00       	mov    $0x3,%edx
  80629b:	89 d8                	mov    %ebx,%eax
  80629d:	e8 49 f7 ff ff       	call   8059eb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  8062a2:	ba 1c 00 00 00       	mov    $0x1c,%edx
  8062a7:	89 d8                	mov    %ebx,%eax
  8062a9:	e8 3d f7 ff ff       	call   8059eb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  8062ae:	ba 06 00 00 00       	mov    $0x6,%edx
  8062b3:	89 d8                	mov    %ebx,%eax
  8062b5:	e8 31 f7 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option_trailer(dhcp);
  8062ba:	89 d8                	mov    %ebx,%eax
  8062bc:	e8 7a f7 ff ff       	call   805a3b <dhcp_option_trailer>

    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: realloc()ing\n"));
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8062c1:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8062c5:	66 05 f0 00          	add    $0xf0,%ax
  8062c9:	0f b7 c0             	movzwl %ax,%eax
  8062cc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8062d0:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8062d3:	89 04 24             	mov    %eax,(%esp)
  8062d6:	e8 05 1e 00 00       	call   8080e0 <pbuf_realloc>

    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8062db:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8062e2:	00 
  8062e3:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  8062ea:	00 
  8062eb:	8b 43 08             	mov    0x8(%ebx),%eax
  8062ee:	89 04 24             	mov    %eax,(%esp)
  8062f1:	e8 68 5f 00 00       	call   80c25e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: sendto(DISCOVER, IP_ADDR_BROADCAST, DHCP_SERVER_PORT)\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8062f6:	89 7c 24 10          	mov    %edi,0x10(%esp)
  8062fa:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806301:	00 
  806302:	c7 44 24 08 90 3d 81 	movl   $0x813d90,0x8(%esp)
  806309:	00 
  80630a:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80630d:	89 44 24 04          	mov    %eax,0x4(%esp)
  806311:	8b 43 08             	mov    0x8(%ebx),%eax
  806314:	89 04 24             	mov    %eax,(%esp)
  806317:	e8 c4 5f 00 00       	call   80c2e0 <udp_sendto_if>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_discover: deleting()ing\n"));
    dhcp_delete_request(netif);
  80631c:	89 f8                	mov    %edi,%eax
  80631e:	e8 12 f9 ff ff       	call   805c35 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover: SELECTING\n"));
    dhcp_set_state(dhcp, DHCP_SELECTING);
  806323:	ba 06 00 00 00       	mov    $0x6,%edx
  806328:	89 d8                	mov    %ebx,%eax
  80632a:	e8 01 f5 ff ff       	call   805830 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_discover: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80632f:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  806333:	83 c1 01             	add    $0x1,%ecx
  806336:	88 4b 01             	mov    %cl,0x1(%ebx)
  if(dhcp->tries >= 9 && dhcp->autoip_coop_state == DHCP_AUTOIP_COOP_STATE_OFF) {
    dhcp->autoip_coop_state = DHCP_AUTOIP_COOP_STATE_ON;
    autoip_start(netif);
  }
#endif /* LWIP_DHCP_AUTOIP_COOP */
  msecs = dhcp->tries < 4 ? (dhcp->tries + 1) * 1000 : 10 * 1000;
  806339:	ba 10 27 00 00       	mov    $0x2710,%edx
  80633e:	80 f9 03             	cmp    $0x3,%cl
  806341:	77 0b                	ja     80634e <dhcp_discover+0x136>
  806343:	0f b6 d1             	movzbl %cl,%edx
  806346:	83 c2 01             	add    $0x1,%edx
  806349:	66 69 d2 e8 03       	imul   $0x3e8,%dx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80634e:	0f b7 d2             	movzwl %dx,%edx
  806351:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  806357:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80635c:	89 d0                	mov    %edx,%eax
  80635e:	f7 e9                	imul   %ecx
  806360:	c1 fa 05             	sar    $0x5,%edx
  806363:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_discover(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  806367:	89 f0                	mov    %esi,%eax
  806369:	83 c4 2c             	add    $0x2c,%esp
  80636c:	5b                   	pop    %ebx
  80636d:	5e                   	pop    %esi
  80636e:	5f                   	pop    %edi
  80636f:	5d                   	pop    %ebp
  806370:	c3                   	ret    

00806371 <dhcp_rebind>:
 *
 * @param netif network interface which must rebind with a DHCP server
 */
static err_t
dhcp_rebind(struct netif *netif)
{
  806371:	55                   	push   %ebp
  806372:	89 e5                	mov    %esp,%ebp
  806374:	83 ec 38             	sub    $0x38,%esp
  806377:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80637a:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80637d:	89 7d fc             	mov    %edi,-0x4(%ebp)
  806380:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  806382:	8b 58 20             	mov    0x20(%eax),%ebx
  err_t result;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind()\n"));
  dhcp_set_state(dhcp, DHCP_REBINDING);
  806385:	ba 04 00 00 00       	mov    $0x4,%edx
  80638a:	89 d8                	mov    %ebx,%eax
  80638c:	e8 9f f4 ff ff       	call   805830 <dhcp_set_state>

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806391:	89 f8                	mov    %edi,%eax
  806393:	e8 08 fa ff ff       	call   805da0 <dhcp_create_request>
  806398:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  80639a:	84 c0                	test   %al,%al
  80639c:	0f 85 a3 00 00 00    	jne    806445 <dhcp_rebind+0xd4>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  8063a2:	b9 01 00 00 00       	mov    $0x1,%ecx
  8063a7:	ba 35 00 00 00       	mov    $0x35,%edx
  8063ac:	89 d8                	mov    %ebx,%eax
  8063ae:	e8 c9 f5 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  8063b3:	ba 03 00 00 00       	mov    $0x3,%edx
  8063b8:	89 d8                	mov    %ebx,%eax
  8063ba:	e8 2c f6 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  8063bf:	b9 02 00 00 00       	mov    $0x2,%ecx
  8063c4:	ba 39 00 00 00       	mov    $0x39,%edx
  8063c9:	89 d8                	mov    %ebx,%eax
  8063cb:	e8 ac f5 ff ff       	call   80597c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8063d0:	ba 40 02 00 00       	mov    $0x240,%edx
  8063d5:	89 d8                	mov    %ebx,%eax
  8063d7:	e8 29 f7 ff ff       	call   805b05 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
#endif

    dhcp_option_trailer(dhcp);
  8063dc:	89 d8                	mov    %ebx,%eax
  8063de:	e8 58 f6 ff ff       	call   805a3b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8063e3:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8063e7:	66 05 f0 00          	add    $0xf0,%ax
  8063eb:	0f b7 c0             	movzwl %ax,%eax
  8063ee:	89 44 24 04          	mov    %eax,0x4(%esp)
  8063f2:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8063f5:	89 04 24             	mov    %eax,(%esp)
  8063f8:	e8 e3 1c 00 00       	call   8080e0 <pbuf_realloc>

    /* broadcast to server */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8063fd:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806404:	00 
  806405:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  80640c:	00 
  80640d:	8b 43 08             	mov    0x8(%ebx),%eax
  806410:	89 04 24             	mov    %eax,(%esp)
  806413:	e8 46 5e 00 00       	call   80c25e <udp_connect>
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806418:	89 7c 24 10          	mov    %edi,0x10(%esp)
  80641c:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806423:	00 
  806424:	c7 44 24 08 90 3d 81 	movl   $0x813d90,0x8(%esp)
  80642b:	00 
  80642c:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80642f:	89 44 24 04          	mov    %eax,0x4(%esp)
  806433:	8b 43 08             	mov    0x8(%ebx),%eax
  806436:	89 04 24             	mov    %eax,(%esp)
  806439:	e8 a2 5e 00 00       	call   80c2e0 <udp_sendto_if>
    dhcp_delete_request(netif);
  80643e:	89 f8                	mov    %edi,%eax
  806440:	e8 f0 f7 ff ff       	call   805c35 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind: REBINDING\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_rebind: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  806445:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  806449:	83 c1 01             	add    $0x1,%ecx
  80644c:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 10 ? dhcp->tries * 1000 : 10 * 1000;
  80644f:	ba 10 27 00 00       	mov    $0x2710,%edx
  806454:	80 f9 09             	cmp    $0x9,%cl
  806457:	77 08                	ja     806461 <dhcp_rebind+0xf0>
  806459:	0f b6 c9             	movzbl %cl,%ecx
  80645c:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806461:	0f b7 d2             	movzwl %dx,%edx
  806464:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  80646a:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  80646f:	89 d0                	mov    %edx,%eax
  806471:	f7 e9                	imul   %ecx
  806473:	c1 fa 05             	sar    $0x5,%edx
  806476:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_rebind(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  80647a:	89 f0                	mov    %esi,%eax
  80647c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80647f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806482:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806485:	89 ec                	mov    %ebp,%esp
  806487:	5d                   	pop    %ebp
  806488:	c3                   	ret    

00806489 <dhcp_coarse_tmr>:
 * The DHCP timer that checks for lease renewal/rebind timeouts.
 *
 */
void
dhcp_coarse_tmr()
{
  806489:	55                   	push   %ebp
  80648a:	89 e5                	mov    %esp,%ebp
  80648c:	53                   	push   %ebx
  80648d:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  806490:	8b 1d 00 f6 b3 00    	mov    0xb3f600,%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  806496:	85 db                	test   %ebx,%ebx
  806498:	74 67                	je     806501 <dhcp_coarse_tmr+0x78>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  80649a:	8b 43 20             	mov    0x20(%ebx),%eax
  80649d:	85 c0                	test   %eax,%eax
  80649f:	74 5a                	je     8064fb <dhcp_coarse_tmr+0x72>
      /* timer is active (non zero), and triggers (zeroes) now? */
      if (netif->dhcp->t2_timeout-- == 1) {
  8064a1:	0f b7 50 2a          	movzwl 0x2a(%eax),%edx
  8064a5:	8d 4a ff             	lea    -0x1(%edx),%ecx
  8064a8:	66 89 48 2a          	mov    %cx,0x2a(%eax)
  8064ac:	66 83 fa 01          	cmp    $0x1,%dx
  8064b0:	75 1b                	jne    8064cd <dhcp_coarse_tmr+0x44>
static void
dhcp_t2_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8064b2:	8b 43 20             	mov    0x20(%ebx),%eax
  8064b5:	0f b6 00             	movzbl (%eax),%eax
  8064b8:	3c 01                	cmp    $0x1,%al
  8064ba:	74 08                	je     8064c4 <dhcp_coarse_tmr+0x3b>
  8064bc:	3c 0a                	cmp    $0xa,%al
  8064be:	74 04                	je     8064c4 <dhcp_coarse_tmr+0x3b>
  8064c0:	3c 05                	cmp    $0x5,%al
  8064c2:	75 37                	jne    8064fb <dhcp_coarse_tmr+0x72>
    /* just retry to rebind */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t2_timeout(): must rebind\n"));
    dhcp_rebind(netif);
  8064c4:	89 d8                	mov    %ebx,%eax
  8064c6:	e8 a6 fe ff ff       	call   806371 <dhcp_rebind>
  8064cb:	eb 2e                	jmp    8064fb <dhcp_coarse_tmr+0x72>
      if (netif->dhcp->t2_timeout-- == 1) {
        LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_coarse_tmr(): t2 timeout\n"));
        /* this clients' rebind timeout triggered */
        dhcp_t2_timeout(netif);
      /* timer is active (non zero), and triggers (zeroes) now */
      } else if (netif->dhcp->t1_timeout-- == 1) {
  8064cd:	8b 53 20             	mov    0x20(%ebx),%edx
  8064d0:	0f b7 42 28          	movzwl 0x28(%edx),%eax
  8064d4:	8d 48 ff             	lea    -0x1(%eax),%ecx
  8064d7:	66 89 4a 28          	mov    %cx,0x28(%edx)
  8064db:	66 83 f8 01          	cmp    $0x1,%ax
  8064df:	75 1a                	jne    8064fb <dhcp_coarse_tmr+0x72>
static void
dhcp_t1_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_t1_timeout()\n"));
  if ((dhcp->state == DHCP_REQUESTING) || (dhcp->state == DHCP_BOUND) || (dhcp->state == DHCP_RENEWING)) {
  8064e1:	8b 43 20             	mov    0x20(%ebx),%eax
  8064e4:	0f b6 00             	movzbl (%eax),%eax
  8064e7:	3c 01                	cmp    $0x1,%al
  8064e9:	74 08                	je     8064f3 <dhcp_coarse_tmr+0x6a>
  8064eb:	3c 0a                	cmp    $0xa,%al
  8064ed:	74 04                	je     8064f3 <dhcp_coarse_tmr+0x6a>
  8064ef:	3c 05                	cmp    $0x5,%al
  8064f1:	75 08                	jne    8064fb <dhcp_coarse_tmr+0x72>
    /* just retry to renew - note that the rebind timer (t2) will
     * eventually time-out if renew tries fail. */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_t1_timeout(): must renew\n"));
    dhcp_renew(netif);
  8064f3:	89 1c 24             	mov    %ebx,(%esp)
  8064f6:	e8 03 fc ff ff       	call   8060fe <dhcp_renew>
        /* this clients' renewal timeout triggered */
        dhcp_t1_timeout(netif);
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  8064fb:	8b 1b                	mov    (%ebx),%ebx
dhcp_coarse_tmr()
{
  struct netif *netif = netif_list;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_coarse_tmr()\n"));
  /* iterate through all network interfaces */
  while (netif != NULL) {
  8064fd:	85 db                	test   %ebx,%ebx
  8064ff:	75 99                	jne    80649a <dhcp_coarse_tmr+0x11>
      }
    }
    /* proceed to next netif */
    netif = netif->next;
  }
}
  806501:	83 c4 14             	add    $0x14,%esp
  806504:	5b                   	pop    %ebx
  806505:	5d                   	pop    %ebp
  806506:	c3                   	ret    

00806507 <dhcp_arp_reply>:
 *
 * @param netif the network interface on which the reply was received
 * @param addr The IP address we received a reply from
 */
void dhcp_arp_reply(struct netif *netif, struct ip_addr *addr)
{
  806507:	55                   	push   %ebp
  806508:	89 e5                	mov    %esp,%ebp
  80650a:	83 ec 28             	sub    $0x28,%esp
  80650d:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  806510:	89 75 fc             	mov    %esi,-0x4(%ebp)
  806513:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  806516:	85 f6                	test   %esi,%esi
  806518:	75 1c                	jne    806536 <dhcp_arp_reply+0x2f>
  80651a:	c7 44 24 08 e3 34 81 	movl   $0x8134e3,0x8(%esp)
  806521:	00 
  806522:	c7 44 24 04 b5 02 00 	movl   $0x2b5,0x4(%esp)
  806529:	00 
  80652a:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806531:	e8 9e a4 ff ff       	call   8009d4 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_arp_reply()\n"));
  /* is a DHCP client doing an ARP check? */
  if ((netif->dhcp != NULL) && (netif->dhcp->state == DHCP_CHECKING)) {
  806536:	8b 5e 20             	mov    0x20(%esi),%ebx
  806539:	85 db                	test   %ebx,%ebx
  80653b:	0f 84 04 01 00 00    	je     806645 <dhcp_arp_reply+0x13e>
  806541:	80 3b 08             	cmpb   $0x8,(%ebx)
  806544:	0f 85 fb 00 00 00    	jne    806645 <dhcp_arp_reply+0x13e>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_arp_reply(): CHECKING, arp reply for 0x%08"X32_F"\n", addr->addr));
    /* did a host respond with the address we
       were offered by the DHCP server? */
    if (ip_addr_cmp(addr, &netif->dhcp->offered_ip_addr)) {
  80654a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80654d:	8b 00                	mov    (%eax),%eax
  80654f:	3b 43 30             	cmp    0x30(%ebx),%eax
  806552:	0f 85 ed 00 00 00    	jne    806645 <dhcp_arp_reply+0x13e>
{
  struct dhcp *dhcp = netif->dhcp;
  err_t result = ERR_OK;
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_decline()\n"));
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  806558:	ba 0c 00 00 00       	mov    $0xc,%edx
  80655d:	89 d8                	mov    %ebx,%eax
  80655f:	e8 cc f2 ff ff       	call   805830 <dhcp_set_state>
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806564:	89 f0                	mov    %esi,%eax
  806566:	e8 35 f8 ff ff       	call   805da0 <dhcp_create_request>
  if (result == ERR_OK) {
  80656b:	84 c0                	test   %al,%al
  80656d:	0f 85 c8 00 00 00    	jne    80663b <dhcp_arp_reply+0x134>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806573:	b9 01 00 00 00       	mov    $0x1,%ecx
  806578:	ba 35 00 00 00       	mov    $0x35,%edx
  80657d:	89 d8                	mov    %ebx,%eax
  80657f:	e8 f8 f3 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_DECLINE);
  806584:	ba 04 00 00 00       	mov    $0x4,%edx
  806589:	89 d8                	mov    %ebx,%eax
  80658b:	e8 5b f4 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806590:	b9 02 00 00 00       	mov    $0x2,%ecx
  806595:	ba 39 00 00 00       	mov    $0x39,%edx
  80659a:	89 d8                	mov    %ebx,%eax
  80659c:	e8 db f3 ff ff       	call   80597c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  8065a1:	ba 40 02 00 00       	mov    $0x240,%edx
  8065a6:	89 d8                	mov    %ebx,%eax
  8065a8:	e8 58 f5 ff ff       	call   805b05 <dhcp_option_short>

    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8065ad:	b9 04 00 00 00       	mov    $0x4,%ecx
  8065b2:	ba 32 00 00 00       	mov    $0x32,%edx
  8065b7:	89 d8                	mov    %ebx,%eax
  8065b9:	e8 be f3 ff ff       	call   80597c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8065be:	8b 43 30             	mov    0x30(%ebx),%eax
  8065c1:	89 04 24             	mov    %eax,(%esp)
  8065c4:	e8 d1 49 00 00       	call   80af9a <ntohl>
  8065c9:	89 c2                	mov    %eax,%edx
  8065cb:	89 d8                	mov    %ebx,%eax
  8065cd:	e8 b2 f5 ff ff       	call   805b84 <dhcp_option_long>

    dhcp_option_trailer(dhcp);
  8065d2:	89 d8                	mov    %ebx,%eax
  8065d4:	e8 62 f4 ff ff       	call   805a3b <dhcp_option_trailer>
    /* resize pbuf to reflect true size of options */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  8065d9:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  8065dd:	66 05 f0 00          	add    $0xf0,%ax
  8065e1:	0f b7 c0             	movzwl %ax,%eax
  8065e4:	89 44 24 04          	mov    %eax,0x4(%esp)
  8065e8:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8065eb:	89 04 24             	mov    %eax,(%esp)
  8065ee:	e8 ed 1a 00 00       	call   8080e0 <pbuf_realloc>

    /* @todo: should we really connect here? we are performing sendto() */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  8065f3:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8065fa:	00 
  8065fb:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  806602:	00 
  806603:	8b 43 08             	mov    0x8(%ebx),%eax
  806606:	89 04 24             	mov    %eax,(%esp)
  806609:	e8 50 5c 00 00       	call   80c25e <udp_connect>
    /* per section 4.4.4, broadcast DECLINE messages */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  80660e:	89 74 24 10          	mov    %esi,0x10(%esp)
  806612:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  806619:	00 
  80661a:	c7 44 24 08 90 3d 81 	movl   $0x813d90,0x8(%esp)
  806621:	00 
  806622:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806625:	89 44 24 04          	mov    %eax,0x4(%esp)
  806629:	8b 43 08             	mov    0x8(%ebx),%eax
  80662c:	89 04 24             	mov    %eax,(%esp)
  80662f:	e8 ac 5c 00 00       	call   80c2e0 <udp_sendto_if>
    dhcp_delete_request(netif);
  806634:	89 f0                	mov    %esi,%eax
  806636:	e8 fa f5 ff ff       	call   805c35 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_decline: BACKING OFF\n"));
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_decline: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  80663b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 10*1000;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  80663f:	66 c7 43 26 14 00    	movw   $0x14,0x26(%ebx)
      /* we will not accept the offered address */
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 1, ("dhcp_arp_reply(): arp reply matched with offered address, declining\n"));
      dhcp_decline(netif);
    }
  }
}
  806645:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  806648:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80664b:	89 ec                	mov    %ebp,%esp
  80664d:	5d                   	pop    %ebp
  80664e:	c3                   	ret    

0080664f <dhcp_select>:
 * @param netif the netif under DHCP control
 * @return lwIP specific error (see error.h)
 */
static err_t
dhcp_select(struct netif *netif)
{
  80664f:	55                   	push   %ebp
  806650:	89 e5                	mov    %esp,%ebp
  806652:	57                   	push   %edi
  806653:	56                   	push   %esi
  806654:	53                   	push   %ebx
  806655:	83 ec 2c             	sub    $0x2c,%esp
  806658:	89 c7                	mov    %eax,%edi
  struct dhcp *dhcp = netif->dhcp;
  80665a:	8b 58 20             	mov    0x20(%eax),%ebx
#endif /* LWIP_NETIF_HOSTNAME */

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_select(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  80665d:	e8 3e f7 ff ff       	call   805da0 <dhcp_create_request>
  806662:	89 c6                	mov    %eax,%esi
  if (result == ERR_OK) {
  806664:	84 c0                	test   %al,%al
  806666:	0f 85 3a 01 00 00    	jne    8067a6 <dhcp_select+0x157>
    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  80666c:	b9 01 00 00 00       	mov    $0x1,%ecx
  806671:	ba 35 00 00 00       	mov    $0x35,%edx
  806676:	89 d8                	mov    %ebx,%eax
  806678:	e8 ff f2 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_REQUEST);
  80667d:	ba 03 00 00 00       	mov    $0x3,%edx
  806682:	89 d8                	mov    %ebx,%eax
  806684:	e8 62 f3 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806689:	b9 02 00 00 00       	mov    $0x2,%ecx
  80668e:	ba 39 00 00 00       	mov    $0x39,%edx
  806693:	89 d8                	mov    %ebx,%eax
  806695:	e8 e2 f2 ff ff       	call   80597c <dhcp_option>
    dhcp_option_short(dhcp, 576);
  80669a:	ba 40 02 00 00       	mov    $0x240,%edx
  80669f:	89 d8                	mov    %ebx,%eax
  8066a1:	e8 5f f4 ff ff       	call   805b05 <dhcp_option_short>

    /* MUST request the offered IP address */
    dhcp_option(dhcp, DHCP_OPTION_REQUESTED_IP, 4);
  8066a6:	b9 04 00 00 00       	mov    $0x4,%ecx
  8066ab:	ba 32 00 00 00       	mov    $0x32,%edx
  8066b0:	89 d8                	mov    %ebx,%eax
  8066b2:	e8 c5 f2 ff ff       	call   80597c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->offered_ip_addr.addr));
  8066b7:	8b 43 30             	mov    0x30(%ebx),%eax
  8066ba:	89 04 24             	mov    %eax,(%esp)
  8066bd:	e8 d8 48 00 00       	call   80af9a <ntohl>
  8066c2:	89 c2                	mov    %eax,%edx
  8066c4:	89 d8                	mov    %ebx,%eax
  8066c6:	e8 b9 f4 ff ff       	call   805b84 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_SERVER_ID, 4);
  8066cb:	b9 04 00 00 00       	mov    $0x4,%ecx
  8066d0:	ba 36 00 00 00       	mov    $0x36,%edx
  8066d5:	89 d8                	mov    %ebx,%eax
  8066d7:	e8 a0 f2 ff ff       	call   80597c <dhcp_option>
    dhcp_option_long(dhcp, ntohl(dhcp->server_ip_addr.addr));
  8066dc:	8b 43 2c             	mov    0x2c(%ebx),%eax
  8066df:	89 04 24             	mov    %eax,(%esp)
  8066e2:	e8 b3 48 00 00       	call   80af9a <ntohl>
  8066e7:	89 c2                	mov    %eax,%edx
  8066e9:	89 d8                	mov    %ebx,%eax
  8066eb:	e8 94 f4 ff ff       	call   805b84 <dhcp_option_long>

    dhcp_option(dhcp, DHCP_OPTION_PARAMETER_REQUEST_LIST, 4/*num options*/);
  8066f0:	b9 04 00 00 00       	mov    $0x4,%ecx
  8066f5:	ba 37 00 00 00       	mov    $0x37,%edx
  8066fa:	89 d8                	mov    %ebx,%eax
  8066fc:	e8 7b f2 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_OPTION_SUBNET_MASK);
  806701:	ba 01 00 00 00       	mov    $0x1,%edx
  806706:	89 d8                	mov    %ebx,%eax
  806708:	e8 de f2 ff ff       	call   8059eb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_ROUTER);
  80670d:	ba 03 00 00 00       	mov    $0x3,%edx
  806712:	89 d8                	mov    %ebx,%eax
  806714:	e8 d2 f2 ff ff       	call   8059eb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_BROADCAST);
  806719:	ba 1c 00 00 00       	mov    $0x1c,%edx
  80671e:	89 d8                	mov    %ebx,%eax
  806720:	e8 c6 f2 ff ff       	call   8059eb <dhcp_option_byte>
    dhcp_option_byte(dhcp, DHCP_OPTION_DNS_SERVER);
  806725:	ba 06 00 00 00       	mov    $0x6,%edx
  80672a:	89 d8                	mov    %ebx,%eax
  80672c:	e8 ba f2 ff ff       	call   8059eb <dhcp_option_byte>
        dhcp_option_byte(dhcp, *p++);
      }
    }
#endif /* LWIP_NETIF_HOSTNAME */

    dhcp_option_trailer(dhcp);
  806731:	89 d8                	mov    %ebx,%eax
  806733:	e8 03 f3 ff ff       	call   805a3b <dhcp_option_trailer>
    /* shrink the pbuf to the actual content length */
    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806738:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80673c:	66 05 f0 00          	add    $0xf0,%ax
  806740:	0f b7 c0             	movzwl %ax,%eax
  806743:	89 44 24 04          	mov    %eax,0x4(%esp)
  806747:	8b 43 1c             	mov    0x1c(%ebx),%eax
  80674a:	89 04 24             	mov    %eax,(%esp)
  80674d:	e8 8e 19 00 00       	call   8080e0 <pbuf_realloc>

    /* TODO: we really should bind to a specific local interface here
       but we cannot specify an unconfigured netif as it is addressless */
    /* send broadcast to any DHCP server */
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  806752:	89 7c 24 10          	mov    %edi,0x10(%esp)
  806756:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  80675d:	00 
  80675e:	c7 44 24 08 90 3d 81 	movl   $0x813d90,0x8(%esp)
  806765:	00 
  806766:	8b 43 1c             	mov    0x1c(%ebx),%eax
  806769:	89 44 24 04          	mov    %eax,0x4(%esp)
  80676d:	8b 43 08             	mov    0x8(%ebx),%eax
  806770:	89 04 24             	mov    %eax,(%esp)
  806773:	e8 68 5b 00 00       	call   80c2e0 <udp_sendto_if>
    /* reconnect to any (or to server here?!) */
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806778:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  80677f:	00 
  806780:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  806787:	00 
  806788:	8b 43 08             	mov    0x8(%ebx),%eax
  80678b:	89 04 24             	mov    %eax,(%esp)
  80678e:	e8 cb 5a 00 00       	call   80c25e <udp_connect>
    dhcp_delete_request(netif);
  806793:	89 f8                	mov    %edi,%eax
  806795:	e8 9b f4 ff ff       	call   805c35 <dhcp_delete_request>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_select: REQUESTING\n"));
    dhcp_set_state(dhcp, DHCP_REQUESTING);
  80679a:	ba 01 00 00 00       	mov    $0x1,%edx
  80679f:	89 d8                	mov    %ebx,%eax
  8067a1:	e8 8a f0 ff ff       	call   805830 <dhcp_set_state>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_select: could not allocate DHCP request\n"));
  }
  dhcp->tries++;
  8067a6:	0f b6 4b 01          	movzbl 0x1(%ebx),%ecx
  8067aa:	83 c1 01             	add    $0x1,%ecx
  8067ad:	88 4b 01             	mov    %cl,0x1(%ebx)
  msecs = dhcp->tries < 4 ? dhcp->tries * 1000 : 4 * 1000;
  8067b0:	ba a0 0f 00 00       	mov    $0xfa0,%edx
  8067b5:	80 f9 03             	cmp    $0x3,%cl
  8067b8:	77 08                	ja     8067c2 <dhcp_select+0x173>
  8067ba:	0f b6 c9             	movzbl %cl,%ecx
  8067bd:	66 69 d1 e8 03       	imul   $0x3e8,%cx,%dx
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  8067c2:	0f b7 d2             	movzwl %dx,%edx
  8067c5:	81 c2 f3 01 00 00    	add    $0x1f3,%edx
  8067cb:	b9 d3 4d 62 10       	mov    $0x10624dd3,%ecx
  8067d0:	89 d0                	mov    %edx,%eax
  8067d2:	f7 e9                	imul   %ecx
  8067d4:	c1 fa 05             	sar    $0x5,%edx
  8067d7:	66 89 53 26          	mov    %dx,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_select(): set request timeout %"U16_F" msecs\n", msecs));
  return result;
}
  8067db:	89 f0                	mov    %esi,%eax
  8067dd:	83 c4 2c             	add    $0x2c,%esp
  8067e0:	5b                   	pop    %ebx
  8067e1:	5e                   	pop    %esi
  8067e2:	5f                   	pop    %edi
  8067e3:	5d                   	pop    %ebp
  8067e4:	c3                   	ret    

008067e5 <dhcp_inform>:
 *
 * @param netif The lwIP network interface
 */
void
dhcp_inform(struct netif *netif)
{
  8067e5:	55                   	push   %ebp
  8067e6:	89 e5                	mov    %esp,%ebp
  8067e8:	83 ec 38             	sub    $0x38,%esp
  8067eb:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8067ee:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8067f1:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8067f4:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp, *old_dhcp = netif->dhcp;
  8067f7:	8b 7e 20             	mov    0x20(%esi),%edi
  err_t result = ERR_OK;
  dhcp = mem_malloc(sizeof(struct dhcp));
  8067fa:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  806801:	e8 ba 09 00 00       	call   8071c0 <mem_malloc>
  806806:	89 c3                	mov    %eax,%ebx
  if (dhcp == NULL) {
  806808:	85 c0                	test   %eax,%eax
  80680a:	0f 84 40 01 00 00    	je     806950 <dhcp_inform+0x16b>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not allocate dhcp\n"));
    return;
  }
  netif->dhcp = dhcp;
  806810:	89 46 20             	mov    %eax,0x20(%esi)
  memset(dhcp, 0, sizeof(struct dhcp));
  806813:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  80681a:	00 
  80681b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  806822:	00 
  806823:	89 04 24             	mov    %eax,(%esp)
  806826:	e8 8b aa ff ff       	call   8012b6 <memset>

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): allocated dhcp\n"));
  dhcp->pcb = udp_new();
  80682b:	e8 df 58 00 00       	call   80c10f <udp_new>
  806830:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  806833:	85 c0                	test   %eax,%eax
  806835:	75 0e                	jne    806845 <dhcp_inform+0x60>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform(): could not obtain pcb"));
    mem_free((void *)dhcp);
  806837:	89 1c 24             	mov    %ebx,(%esp)
  80683a:	e8 0f 0d 00 00       	call   80754e <mem_free>
    return;
  80683f:	90                   	nop
  806840:	e9 0b 01 00 00       	jmp    806950 <dhcp_inform+0x16b>
  }
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_inform(): created new udp pcb\n"));
  /* create and initialize the DHCP message header */
  result = dhcp_create_request(netif);
  806845:	89 f0                	mov    %esi,%eax
  806847:	e8 54 f5 ff ff       	call   805da0 <dhcp_create_request>
  if (result == ERR_OK) {
  80684c:	84 c0                	test   %al,%al
  80684e:	66 90                	xchg   %ax,%ax
  806850:	0f 85 d9 00 00 00    	jne    80692f <dhcp_inform+0x14a>

    dhcp_option(dhcp, DHCP_OPTION_MESSAGE_TYPE, DHCP_OPTION_MESSAGE_TYPE_LEN);
  806856:	b9 01 00 00 00       	mov    $0x1,%ecx
  80685b:	ba 35 00 00 00       	mov    $0x35,%edx
  806860:	89 d8                	mov    %ebx,%eax
  806862:	e8 15 f1 ff ff       	call   80597c <dhcp_option>
    dhcp_option_byte(dhcp, DHCP_INFORM);
  806867:	ba 08 00 00 00       	mov    $0x8,%edx
  80686c:	89 d8                	mov    %ebx,%eax
  80686e:	e8 78 f1 ff ff       	call   8059eb <dhcp_option_byte>

    dhcp_option(dhcp, DHCP_OPTION_MAX_MSG_SIZE, DHCP_OPTION_MAX_MSG_SIZE_LEN);
  806873:	b9 02 00 00 00       	mov    $0x2,%ecx
  806878:	ba 39 00 00 00       	mov    $0x39,%edx
  80687d:	89 d8                	mov    %ebx,%eax
  80687f:	e8 f8 f0 ff ff       	call   80597c <dhcp_option>
    /* TODO: use netif->mtu ?! */
    dhcp_option_short(dhcp, 576);
  806884:	ba 40 02 00 00       	mov    $0x240,%edx
  806889:	89 d8                	mov    %ebx,%eax
  80688b:	e8 75 f2 ff ff       	call   805b05 <dhcp_option_short>

    dhcp_option_trailer(dhcp);
  806890:	89 d8                	mov    %ebx,%eax
  806892:	e8 a4 f1 ff ff       	call   805a3b <dhcp_option_trailer>

    pbuf_realloc(dhcp->p_out, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN + dhcp->options_out_len);
  806897:	0f b7 43 24          	movzwl 0x24(%ebx),%eax
  80689b:	66 05 f0 00          	add    $0xf0,%ax
  80689f:	0f b7 c0             	movzwl %ax,%eax
  8068a2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8068a6:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8068a9:	89 04 24             	mov    %eax,(%esp)
  8068ac:	e8 2f 18 00 00       	call   8080e0 <pbuf_realloc>

    udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8068b1:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  8068b8:	00 
  8068b9:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  8068c0:	00 
  8068c1:	8b 43 08             	mov    0x8(%ebx),%eax
  8068c4:	89 04 24             	mov    %eax,(%esp)
  8068c7:	e8 cc 58 00 00       	call   80c198 <udp_bind>
    udp_connect(dhcp->pcb, IP_ADDR_BROADCAST, DHCP_SERVER_PORT);
  8068cc:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  8068d3:	00 
  8068d4:	c7 44 24 04 90 3d 81 	movl   $0x813d90,0x4(%esp)
  8068db:	00 
  8068dc:	8b 43 08             	mov    0x8(%ebx),%eax
  8068df:	89 04 24             	mov    %eax,(%esp)
  8068e2:	e8 77 59 00 00       	call   80c25e <udp_connect>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_inform: INFORMING\n"));
    udp_sendto_if(dhcp->pcb, dhcp->p_out, IP_ADDR_BROADCAST, DHCP_SERVER_PORT, netif);
  8068e7:	89 74 24 10          	mov    %esi,0x10(%esp)
  8068eb:	c7 44 24 0c 43 00 00 	movl   $0x43,0xc(%esp)
  8068f2:	00 
  8068f3:	c7 44 24 08 90 3d 81 	movl   $0x813d90,0x8(%esp)
  8068fa:	00 
  8068fb:	8b 43 1c             	mov    0x1c(%ebx),%eax
  8068fe:	89 44 24 04          	mov    %eax,0x4(%esp)
  806902:	8b 43 08             	mov    0x8(%ebx),%eax
  806905:	89 04 24             	mov    %eax,(%esp)
  806908:	e8 d3 59 00 00       	call   80c2e0 <udp_sendto_if>
    udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  80690d:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806914:	00 
  806915:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  80691c:	00 
  80691d:	8b 43 08             	mov    0x8(%ebx),%eax
  806920:	89 04 24             	mov    %eax,(%esp)
  806923:	e8 36 59 00 00       	call   80c25e <udp_connect>
    dhcp_delete_request(netif);
  806928:	89 f0                	mov    %esi,%eax
  80692a:	e8 06 f3 ff ff       	call   805c35 <dhcp_delete_request>
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_inform: could not allocate DHCP request\n"));
  }

  if (dhcp != NULL) {
    if (dhcp->pcb != NULL) {
  80692f:	8b 43 08             	mov    0x8(%ebx),%eax
  806932:	85 c0                	test   %eax,%eax
  806934:	74 08                	je     80693e <dhcp_inform+0x159>
      udp_remove(dhcp->pcb);
  806936:	89 04 24             	mov    %eax,(%esp)
  806939:	e8 0e 58 00 00       	call   80c14c <udp_remove>
    }
    dhcp->pcb = NULL;
  80693e:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mem_free((void *)dhcp);
  806945:	89 1c 24             	mov    %ebx,(%esp)
  806948:	e8 01 0c 00 00       	call   80754e <mem_free>
    netif->dhcp = old_dhcp;
  80694d:	89 7e 20             	mov    %edi,0x20(%esi)
  }
}
  806950:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  806953:	8b 75 f8             	mov    -0x8(%ebp),%esi
  806956:	8b 7d fc             	mov    -0x4(%ebp),%edi
  806959:	89 ec                	mov    %ebp,%esp
  80695b:	5d                   	pop    %ebp
  80695c:	c3                   	ret    

0080695d <dhcp_start>:
 * - ERR_OK - No error
 * - ERR_MEM - Out of memory
 */
err_t
dhcp_start(struct netif *netif)
{
  80695d:	55                   	push   %ebp
  80695e:	89 e5                	mov    %esp,%ebp
  806960:	56                   	push   %esi
  806961:	53                   	push   %ebx
  806962:	83 ec 10             	sub    $0x10,%esp
  806965:	8b 75 08             	mov    0x8(%ebp),%esi
  struct dhcp *dhcp;
  err_t result = ERR_OK;

  LWIP_ERROR("netif != NULL", (netif != NULL), return ERR_ARG;);
  806968:	85 f6                	test   %esi,%esi
  80696a:	75 1c                	jne    806988 <dhcp_start+0x2b>
  80696c:	c7 44 24 08 e3 34 81 	movl   $0x8134e3,0x8(%esp)
  806973:	00 
  806974:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  80697b:	00 
  80697c:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806983:	e8 4c a0 ff ff       	call   8009d4 <_panic>
  dhcp = netif->dhcp;
  806988:	8b 5e 20             	mov    0x20(%esi),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_start(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Remove the flag that says this netif is handled by DHCP,
     it is set when we succeeded starting. */
  netif->flags &= ~NETIF_FLAG_DHCP;
  80698b:	80 66 2e f7          	andb   $0xf7,0x2e(%esi)

  /* no DHCP client attached yet? */
  if (dhcp == NULL) {
  80698f:	85 db                	test   %ebx,%ebx
  806991:	75 1e                	jne    8069b1 <dhcp_start+0x54>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting new DHCP client\n"));
    dhcp = mem_malloc(sizeof(struct dhcp));
  806993:	c7 04 24 58 00 00 00 	movl   $0x58,(%esp)
  80699a:	e8 21 08 00 00       	call   8071c0 <mem_malloc>
  80699f:	89 c3                	mov    %eax,%ebx
    if (dhcp == NULL) {
  8069a1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  8069a6:	85 db                	test   %ebx,%ebx
  8069a8:	0f 84 a5 00 00 00    	je     806a53 <dhcp_start+0xf6>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): could not allocate dhcp\n"));
      return ERR_MEM;
    }
    /* store this dhcp client in the netif */
    netif->dhcp = dhcp;
  8069ae:	89 5e 20             	mov    %ebx,0x20(%esi)
  } else {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE | 3, ("dhcp_start(): restarting DHCP configuration\n"));
  }
    
  /* clear data structure */
  memset(dhcp, 0, sizeof(struct dhcp));
  8069b1:	c7 44 24 08 58 00 00 	movl   $0x58,0x8(%esp)
  8069b8:	00 
  8069b9:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8069c0:	00 
  8069c1:	89 1c 24             	mov    %ebx,(%esp)
  8069c4:	e8 ed a8 ff ff       	call   8012b6 <memset>
  /* allocate UDP PCB */
  dhcp->pcb = udp_new();
  8069c9:	e8 41 57 00 00       	call   80c10f <udp_new>
  8069ce:	89 43 08             	mov    %eax,0x8(%ebx)
  if (dhcp->pcb == NULL) {
  8069d1:	85 c0                	test   %eax,%eax
  8069d3:	75 16                	jne    8069eb <dhcp_start+0x8e>
    LWIP_DEBUGF(DHCP_DEBUG  | LWIP_DBG_TRACE, ("dhcp_start(): could not obtain pcb\n"));
    mem_free((void *)dhcp);
  8069d5:	89 1c 24             	mov    %ebx,(%esp)
  8069d8:	e8 71 0b 00 00       	call   80754e <mem_free>
    netif->dhcp = dhcp = NULL;
  8069dd:	c7 46 20 00 00 00 00 	movl   $0x0,0x20(%esi)
  8069e4:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  8069e9:	eb 68                	jmp    806a53 <dhcp_start+0xf6>
  }
  /* set up local and remote port for the pcb */
  udp_bind(dhcp->pcb, IP_ADDR_ANY, DHCP_CLIENT_PORT);
  8069eb:	c7 44 24 08 44 00 00 	movl   $0x44,0x8(%esp)
  8069f2:	00 
  8069f3:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  8069fa:	00 
  8069fb:	89 04 24             	mov    %eax,(%esp)
  8069fe:	e8 95 57 00 00       	call   80c198 <udp_bind>
  udp_connect(dhcp->pcb, IP_ADDR_ANY, DHCP_SERVER_PORT);
  806a03:	c7 44 24 08 43 00 00 	movl   $0x43,0x8(%esp)
  806a0a:	00 
  806a0b:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  806a12:	00 
  806a13:	8b 43 08             	mov    0x8(%ebx),%eax
  806a16:	89 04 24             	mov    %eax,(%esp)
  806a19:	e8 40 58 00 00       	call   80c25e <udp_connect>
  /* set up the recv callback and argument */
  udp_recv(dhcp->pcb, dhcp_recv, netif);
  806a1e:	89 74 24 08          	mov    %esi,0x8(%esp)
  806a22:	c7 44 24 04 32 6c 80 	movl   $0x806c32,0x4(%esp)
  806a29:	00 
  806a2a:	8b 43 08             	mov    0x8(%ebx),%eax
  806a2d:	89 04 24             	mov    %eax,(%esp)
  806a30:	e8 c6 56 00 00       	call   80c0fb <udp_recv>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_start(): starting DHCP configuration\n"));
  /* (re)start the DHCP negotiation */
  result = dhcp_discover(netif);
  806a35:	89 f0                	mov    %esi,%eax
  806a37:	e8 dc f7 ff ff       	call   806218 <dhcp_discover>
  if (result != ERR_OK) {
  806a3c:	84 c0                	test   %al,%al
  806a3e:	74 0f                	je     806a4f <dhcp_start+0xf2>
    /* free resources allocated above */
    dhcp_stop(netif);
  806a40:	89 34 24             	mov    %esi,(%esp)
  806a43:	e8 d9 f2 ff ff       	call   805d21 <dhcp_stop>
  806a48:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  806a4d:	eb 04                	jmp    806a53 <dhcp_start+0xf6>
  }
  /* Set the flag that says this netif is handled by DHCP. */
  netif->flags |= NETIF_FLAG_DHCP;
  806a4f:	80 4e 2e 08          	orb    $0x8,0x2e(%esi)
  return result;
}
  806a53:	83 c4 10             	add    $0x10,%esp
  806a56:	5b                   	pop    %ebx
  806a57:	5e                   	pop    %esi
  806a58:	5d                   	pop    %ebp
  806a59:	c3                   	ret    

00806a5a <dhcp_check>:
 *
 * @param netif the netif under DHCP control
 */
static void
dhcp_check(struct netif *netif)
{
  806a5a:	55                   	push   %ebp
  806a5b:	89 e5                	mov    %esp,%ebp
  806a5d:	53                   	push   %ebx
  806a5e:	83 ec 14             	sub    $0x14,%esp
  struct dhcp *dhcp = netif->dhcp;
  806a61:	8b 58 20             	mov    0x20(%eax),%ebx
  u16_t msecs;
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_check(netif=%p) %c%c\n", (void *)netif, (s16_t)netif->name[0],
    (s16_t)netif->name[1]));
  /* create an ARP query for the offered IP address, expecting that no host
     responds, as the IP address should not be in use. */
  result = etharp_query(netif, &dhcp->offered_ip_addr, NULL);
  806a64:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  806a6b:	00 
  806a6c:	8d 53 30             	lea    0x30(%ebx),%edx
  806a6f:	89 54 24 04          	mov    %edx,0x4(%esp)
  806a73:	89 04 24             	mov    %eax,(%esp)
  806a76:	e8 9c 62 00 00       	call   80cd17 <etharp_query>
  if (result != ERR_OK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_check: could not perform ARP query\n"));
  }
  dhcp->tries++;
  806a7b:	80 43 01 01          	addb   $0x1,0x1(%ebx)
  msecs = 500;
  dhcp->request_timeout = (msecs + DHCP_FINE_TIMER_MSECS - 1) / DHCP_FINE_TIMER_MSECS;
  806a7f:	66 c7 43 26 01 00    	movw   $0x1,0x26(%ebx)
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_check(): set request timeout %"U16_F" msecs\n", msecs));
  dhcp_set_state(dhcp, DHCP_CHECKING);
  806a85:	ba 08 00 00 00       	mov    $0x8,%edx
  806a8a:	89 d8                	mov    %ebx,%eax
  806a8c:	e8 9f ed ff ff       	call   805830 <dhcp_set_state>
}
  806a91:	83 c4 14             	add    $0x14,%esp
  806a94:	5b                   	pop    %ebx
  806a95:	5d                   	pop    %ebp
  806a96:	c3                   	ret    

00806a97 <dhcp_bind>:
 *
 * @param netif network interface to bind to the offered address
 */
static void
dhcp_bind(struct netif *netif)
{
  806a97:	55                   	push   %ebp
  806a98:	89 e5                	mov    %esp,%ebp
  806a9a:	57                   	push   %edi
  806a9b:	56                   	push   %esi
  806a9c:	53                   	push   %ebx
  806a9d:	83 ec 2c             	sub    $0x2c,%esp
  806aa0:	89 c6                	mov    %eax,%esi
  u32_t timeout;
  struct dhcp *dhcp;
  struct ip_addr sn_mask, gw_addr;
  LWIP_ERROR("dhcp_bind: netif != NULL", (netif != NULL), return;);
  806aa2:	85 c0                	test   %eax,%eax
  806aa4:	75 1c                	jne    806ac2 <dhcp_bind+0x2b>
  806aa6:	c7 44 24 08 d8 34 81 	movl   $0x8134d8,0x8(%esp)
  806aad:	00 
  806aae:	c7 44 24 04 3d 03 00 	movl   $0x33d,0x4(%esp)
  806ab5:	00 
  806ab6:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806abd:	e8 12 9f ff ff       	call   8009d4 <_panic>
  dhcp = netif->dhcp;
  806ac2:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_ERROR("dhcp_bind: dhcp != NULL", (dhcp != NULL), return;);
  806ac5:	85 db                	test   %ebx,%ebx
  806ac7:	75 1c                	jne    806ae5 <dhcp_bind+0x4e>
  806ac9:	c7 44 24 08 f1 34 81 	movl   $0x8134f1,0x8(%esp)
  806ad0:	00 
  806ad1:	c7 44 24 04 3f 03 00 	movl   $0x33f,0x4(%esp)
  806ad8:	00 
  806ad9:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806ae0:	e8 ef 9e ff ff       	call   8009d4 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_bind(netif=%p) %c%c%"U16_F"\n", (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));

  /* temporary DHCP lease? */
  if (dhcp->offered_t1_renew != 0xffffffffUL) {
  806ae5:	8b 53 50             	mov    0x50(%ebx),%edx
  806ae8:	83 fa ff             	cmp    $0xffffffff,%edx
  806aeb:	74 2b                	je     806b18 <dhcp_bind+0x81>
    /* set renewal period timer */
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t1 renewal timer %"U32_F" secs\n", dhcp->offered_t1_renew));
    timeout = (dhcp->offered_t1_renew + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806aed:	83 c2 1e             	add    $0x1e,%edx
  806af0:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806af5:	89 d0                	mov    %edx,%eax
  806af7:	f7 e1                	mul    %ecx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t1_timeout = (u16_t)timeout;
  806af9:	c1 ea 05             	shr    $0x5,%edx
  806afc:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806b02:	76 05                	jbe    806b09 <dhcp_bind+0x72>
  806b04:	ba ff ff 00 00       	mov    $0xffff,%edx
  806b09:	66 89 53 28          	mov    %dx,0x28(%ebx)
    if (dhcp->t1_timeout == 0) {
  806b0d:	66 85 d2             	test   %dx,%dx
  806b10:	75 06                	jne    806b18 <dhcp_bind+0x81>
      dhcp->t1_timeout = 1;
  806b12:	66 c7 43 28 01 00    	movw   $0x1,0x28(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t1_renew*1000));
  }
  /* set renewal period timer */
  if (dhcp->offered_t2_rebind != 0xffffffffUL) {
  806b18:	8b 53 54             	mov    0x54(%ebx),%edx
  806b1b:	83 fa ff             	cmp    $0xffffffff,%edx
  806b1e:	74 2b                	je     806b4b <dhcp_bind+0xb4>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_bind(): t2 rebind timer %"U32_F" secs\n", dhcp->offered_t2_rebind));
    timeout = (dhcp->offered_t2_rebind + DHCP_COARSE_TIMER_SECS / 2) / DHCP_COARSE_TIMER_SECS;
  806b20:	83 c2 1e             	add    $0x1e,%edx
  806b23:	b9 89 88 88 88       	mov    $0x88888889,%ecx
  806b28:	89 d0                	mov    %edx,%eax
  806b2a:	f7 e1                	mul    %ecx
    if(timeout > 0xffff) {
      timeout = 0xffff;
    }
    dhcp->t2_timeout = (u16_t)timeout;
  806b2c:	c1 ea 05             	shr    $0x5,%edx
  806b2f:	81 fa ff ff 00 00    	cmp    $0xffff,%edx
  806b35:	76 05                	jbe    806b3c <dhcp_bind+0xa5>
  806b37:	ba ff ff 00 00       	mov    $0xffff,%edx
  806b3c:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
    if (dhcp->t2_timeout == 0) {
  806b40:	66 85 d2             	test   %dx,%dx
  806b43:	75 06                	jne    806b4b <dhcp_bind+0xb4>
      dhcp->t2_timeout = 1;
  806b45:	66 c7 43 2a 01 00    	movw   $0x1,0x2a(%ebx)
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  806b4b:	83 fb cc             	cmp    $0xffffffcc,%ebx
  806b4e:	0f 84 c7 00 00 00    	je     806c1b <dhcp_bind+0x184>
  806b54:	8b 43 34             	mov    0x34(%ebx),%eax
  806b57:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* subnet mask not given? */
  /* TODO: this is not a valid check. what if the network mask is 0? */
  if (sn_mask.addr == 0) {
  806b5a:	85 c0                	test   %eax,%eax
  806b5c:	75 4b                	jne    806ba9 <dhcp_bind+0x112>
    /* choose a safe subnet mask given the network class */
    u8_t first_octet = ip4_addr1(&sn_mask);
  806b5e:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  806b65:	e8 30 44 00 00       	call   80af9a <ntohl>
  806b6a:	c1 e8 18             	shr    $0x18,%eax
    if (first_octet <= 127) {
  806b6d:	84 c0                	test   %al,%al
  806b6f:	78 11                	js     806b82 <dhcp_bind+0xeb>
      sn_mask.addr = htonl(0xff000000);
  806b71:	c7 04 24 00 00 00 ff 	movl   $0xff000000,(%esp)
  806b78:	e8 f8 41 00 00       	call   80ad75 <htonl>
  806b7d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806b80:	eb 27                	jmp    806ba9 <dhcp_bind+0x112>
    } else if (first_octet >= 192) {
  806b82:	3c bf                	cmp    $0xbf,%al
  806b84:	76 14                	jbe    806b9a <dhcp_bind+0x103>
      sn_mask.addr = htonl(0xffffff00);
  806b86:	c7 04 24 00 ff ff ff 	movl   $0xffffff00,(%esp)
  806b8d:	8d 76 00             	lea    0x0(%esi),%esi
  806b90:	e8 e0 41 00 00       	call   80ad75 <htonl>
  806b95:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  806b98:	eb 0f                	jmp    806ba9 <dhcp_bind+0x112>
    } else {
      sn_mask.addr = htonl(0xffff0000);
  806b9a:	c7 04 24 00 00 ff ff 	movl   $0xffff0000,(%esp)
  806ba1:	e8 cf 41 00 00       	call   80ad75 <htonl>
  806ba6:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806ba9:	83 fb c8             	cmp    $0xffffffc8,%ebx
  806bac:	74 79                	je     806c27 <dhcp_bind+0x190>
  806bae:	8b 43 38             	mov    0x38(%ebx),%eax
  806bb1:	89 45 e0             	mov    %eax,-0x20(%ebp)
  /* gateway address not given? */
  if (gw_addr.addr == 0) {
  806bb4:	85 c0                	test   %eax,%eax
  806bb6:	75 1a                	jne    806bd2 <dhcp_bind+0x13b>
    /* copy network address */
    gw_addr.addr = (dhcp->offered_ip_addr.addr & sn_mask.addr);
  806bb8:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  806bbb:	23 7b 30             	and    0x30(%ebx),%edi
  806bbe:	89 7d e0             	mov    %edi,-0x20(%ebp)
    /* use first host address on network as gateway */
    gw_addr.addr |= htonl(0x00000001);
  806bc1:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  806bc8:	e8 a8 41 00 00       	call   80ad75 <htonl>
  806bcd:	09 c7                	or     %eax,%edi
  806bcf:	89 7d e0             	mov    %edi,-0x20(%ebp)
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): IP: 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));
  netif_set_ipaddr(netif, &dhcp->offered_ip_addr);
  806bd2:	8d 43 30             	lea    0x30(%ebx),%eax
  806bd5:	89 44 24 04          	mov    %eax,0x4(%esp)
  806bd9:	89 34 24             	mov    %esi,(%esp)
  806bdc:	e8 c3 0d 00 00       	call   8079a4 <netif_set_ipaddr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): SN: 0x%08"X32_F"\n", sn_mask.addr));
  netif_set_netmask(netif, &sn_mask);
  806be1:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  806be4:	89 44 24 04          	mov    %eax,0x4(%esp)
  806be8:	89 34 24             	mov    %esi,(%esp)
  806beb:	e8 d8 0c 00 00       	call   8078c8 <netif_set_netmask>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_bind(): GW: 0x%08"X32_F"\n", gw_addr.addr));
  netif_set_gw(netif, &gw_addr);
  806bf0:	8d 45 e0             	lea    -0x20(%ebp),%eax
  806bf3:	89 44 24 04          	mov    %eax,0x4(%esp)
  806bf7:	89 34 24             	mov    %esi,(%esp)
  806bfa:	e8 b0 0c 00 00       	call   8078af <netif_set_gw>
  /* bring the interface up */
  netif_set_up(netif);
  806bff:	89 34 24             	mov    %esi,(%esp)
  806c02:	e8 67 0d 00 00       	call   80796e <netif_set_up>
  /* netif is now bound to DHCP leased address */
  dhcp_set_state(dhcp, DHCP_BOUND);
  806c07:	ba 0a 00 00 00       	mov    $0xa,%edx
  806c0c:	89 d8                	mov    %ebx,%eax
  806c0e:	e8 1d ec ff ff       	call   805830 <dhcp_set_state>
}
  806c13:	83 c4 2c             	add    $0x2c,%esp
  806c16:	5b                   	pop    %ebx
  806c17:	5e                   	pop    %esi
  806c18:	5f                   	pop    %edi
  806c19:	5d                   	pop    %ebp
  806c1a:	c3                   	ret    
      dhcp->t2_timeout = 1;
    }
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_bind(): set request timeout %"U32_F" msecs\n", dhcp->offered_t2_rebind*1000));
  }
  /* copy offered network mask */
  ip_addr_set(&sn_mask, &dhcp->offered_sn_mask);
  806c1b:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  806c22:	e9 37 ff ff ff       	jmp    806b5e <dhcp_bind+0xc7>
    } else {
      sn_mask.addr = htonl(0xffff0000);
    }
  }

  ip_addr_set(&gw_addr, &dhcp->offered_gw_addr);
  806c27:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  806c2e:	66 90                	xchg   %ax,%ax
  806c30:	eb 86                	jmp    806bb8 <dhcp_bind+0x121>

00806c32 <dhcp_recv>:

/**
 * If an incoming DHCP message is in response to us, then trigger the state machine
 */
static void dhcp_recv(void *arg, struct udp_pcb *pcb, struct pbuf *p, struct ip_addr *addr, u16_t port)
{
  806c32:	55                   	push   %ebp
  806c33:	89 e5                	mov    %esp,%ebp
  806c35:	57                   	push   %edi
  806c36:	56                   	push   %esi
  806c37:	53                   	push   %ebx
  806c38:	83 ec 2c             	sub    $0x2c,%esp
  struct netif *netif = (struct netif *)arg;
  806c3b:	8b 45 08             	mov    0x8(%ebp),%eax
  806c3e:	89 45 e0             	mov    %eax,-0x20(%ebp)
  struct dhcp *dhcp = netif->dhcp;
  806c41:	8b 50 20             	mov    0x20(%eax),%edx
  806c44:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  struct dhcp_msg *reply_msg = (struct dhcp_msg *)p->payload;
  806c47:	8b 4d 10             	mov    0x10(%ebp),%ecx
  806c4a:	8b 71 04             	mov    0x4(%ecx),%esi
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("pbuf->tot_len = %"U16_F"\n", p->tot_len));
  /* prevent warnings about unused arguments */
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(addr);
  LWIP_UNUSED_ARG(port);
  dhcp->p = p;
  806c4d:	89 4a 0c             	mov    %ecx,0xc(%edx)
  /* TODO: check packet length before reading them */
  if (reply_msg->op != DHCP_BOOTREPLY) {
  806c50:	80 3e 02             	cmpb   $0x2,(%esi)
  806c53:	0f 85 33 04 00 00    	jne    80708c <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806c59:	0f b6 78 24          	movzbl 0x24(%eax),%edi
  806c5d:	89 fb                	mov    %edi,%ebx
  806c5f:	84 db                	test   %bl,%bl
  806c61:	74 35                	je     806c98 <dhcp_recv+0x66>
    if (netif->hwaddr[i] != reply_msg->chaddr[i]) {
  806c63:	0f b6 48 25          	movzbl 0x25(%eax),%ecx
  806c67:	89 c2                	mov    %eax,%edx
  806c69:	b8 00 00 00 00       	mov    $0x0,%eax
  806c6e:	3a 4e 1c             	cmp    0x1c(%esi),%cl
  806c71:	74 1c                	je     806c8f <dhcp_recv+0x5d>
  806c73:	e9 14 04 00 00       	jmp    80708c <dhcp_recv+0x45a>
  806c78:	0f b6 5a 26          	movzbl 0x26(%edx),%ebx
  806c7c:	0f b6 4c 06 1d       	movzbl 0x1d(%esi,%eax,1),%ecx
  806c81:	83 c0 01             	add    $0x1,%eax
  806c84:	83 c2 01             	add    $0x1,%edx
  806c87:	38 cb                	cmp    %cl,%bl
  806c89:	0f 85 fd 03 00 00    	jne    80708c <dhcp_recv+0x45a>
  if (reply_msg->op != DHCP_BOOTREPLY) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("not a DHCP reply message, but type %"U16_F"\n", (u16_t)reply_msg->op));
    goto free_pbuf_and_return;
  }
  /* iterate through hardware address and match against DHCP message */
  for (i = 0; i < netif->hwaddr_len; i++) {
  806c8f:	8d 48 01             	lea    0x1(%eax),%ecx
  806c92:	89 fb                	mov    %edi,%ebx
  806c94:	38 cb                	cmp    %cl,%bl
  806c96:	77 e0                	ja     806c78 <dhcp_recv+0x46>
        (u16_t)i, (u16_t)netif->hwaddr[i], (u16_t)i, (u16_t)reply_msg->chaddr[i]));
      goto free_pbuf_and_return;
    }
  }
  /* match transaction ID against what we expected */
  if (ntohl(reply_msg->xid) != dhcp->xid) {
  806c98:	8b 46 04             	mov    0x4(%esi),%eax
  806c9b:	89 04 24             	mov    %eax,(%esp)
  806c9e:	e8 f7 42 00 00       	call   80af9a <ntohl>
  806ca3:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806ca6:	3b 42 04             	cmp    0x4(%edx),%eax
  806ca9:	0f 85 dd 03 00 00    	jne    80708c <dhcp_recv+0x45a>
 */
static err_t
dhcp_unfold_reply(struct dhcp *dhcp)
{
  u16_t ret;
  LWIP_ERROR("dhcp != NULL", (dhcp != NULL), return ERR_ARG;);
  806caf:	85 d2                	test   %edx,%edx
  806cb1:	75 1c                	jne    806ccf <dhcp_recv+0x9d>
  806cb3:	c7 44 24 08 fc 34 81 	movl   $0x8134fc,0x8(%esp)
  806cba:	00 
  806cbb:	c7 44 24 04 89 04 00 	movl   $0x489,0x4(%esp)
  806cc2:	00 
  806cc3:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806cca:	e8 05 9d ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("dhcp->p != NULL", (dhcp->p != NULL), return ERR_VAL;);
  806ccf:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806cd2:	83 79 0c 00          	cmpl   $0x0,0xc(%ecx)
  806cd6:	75 1c                	jne    806cf4 <dhcp_recv+0xc2>
  806cd8:	c7 44 24 08 09 35 81 	movl   $0x813509,0x8(%esp)
  806cdf:	00 
  806ce0:	c7 44 24 04 8a 04 00 	movl   $0x48a,0x4(%esp)
  806ce7:	00 
  806ce8:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806cef:	e8 e0 9c ff ff       	call   8009d4 <_panic>
  /* free any left-overs from previous unfolds */
  dhcp_free_reply(dhcp);
  806cf4:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  806cf7:	e8 e4 ef ff ff       	call   805ce0 <dhcp_free_reply>
  /* options present? */
  if (dhcp->p->tot_len > (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN)) {
  806cfc:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806cff:	8b 43 0c             	mov    0xc(%ebx),%eax
  806d02:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  806d06:	66 3d f0 00          	cmp    $0xf0,%ax
  806d0a:	76 1e                	jbe    806d2a <dhcp_recv+0xf8>
    dhcp->options_in_len = dhcp->p->tot_len - (sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806d0c:	66 2d f0 00          	sub    $0xf0,%ax
  806d10:	66 89 43 18          	mov    %ax,0x18(%ebx)
    dhcp->options_in = mem_malloc(dhcp->options_in_len);
  806d14:	0f b7 c0             	movzwl %ax,%eax
  806d17:	89 04 24             	mov    %eax,(%esp)
  806d1a:	e8 a1 04 00 00       	call   8071c0 <mem_malloc>
  806d1f:	89 43 14             	mov    %eax,0x14(%ebx)
    if (dhcp->options_in == NULL) {
  806d22:	85 c0                	test   %eax,%eax
  806d24:	0f 84 62 03 00 00    	je     80708c <dhcp_recv+0x45a>
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->options\n"));
      return ERR_MEM;
    }
  }
  dhcp->msg_in = mem_malloc(sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806d2a:	c7 04 24 f0 00 00 00 	movl   $0xf0,(%esp)
  806d31:	e8 8a 04 00 00       	call   8071c0 <mem_malloc>
  806d36:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806d39:	89 42 10             	mov    %eax,0x10(%edx)
  if (dhcp->msg_in == NULL) {
  806d3c:	85 c0                	test   %eax,%eax
  806d3e:	75 1a                	jne    806d5a <dhcp_recv+0x128>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 2, ("dhcp_unfold_reply(): could not allocate dhcp->msg_in\n"));
    mem_free((void *)dhcp->options_in);
  806d40:	8b 42 14             	mov    0x14(%edx),%eax
  806d43:	89 04 24             	mov    %eax,(%esp)
  806d46:	e8 03 08 00 00       	call   80754e <mem_free>
    dhcp->options_in = NULL;
  806d4b:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806d4e:	c7 41 14 00 00 00 00 	movl   $0x0,0x14(%ecx)
  806d55:	e9 32 03 00 00       	jmp    80708c <dhcp_recv+0x45a>
    return ERR_MEM;
  }

  /** copy the DHCP message without options */
  ret = pbuf_copy_partial(dhcp->p, dhcp->msg_in, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN, 0);
  806d5a:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  806d61:	00 
  806d62:	c7 44 24 08 f0 00 00 	movl   $0xf0,0x8(%esp)
  806d69:	00 
  806d6a:	89 44 24 04          	mov    %eax,0x4(%esp)
  806d6e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806d71:	8b 43 0c             	mov    0xc(%ebx),%eax
  806d74:	89 04 24             	mov    %eax,(%esp)
  806d77:	e8 5a 0f 00 00       	call   807cd6 <pbuf_copy_partial>
  LWIP_ASSERT("ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN", ret == sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806d7c:	66 3d f0 00          	cmp    $0xf0,%ax
  806d80:	74 1c                	je     806d9e <dhcp_recv+0x16c>
  806d82:	c7 44 24 08 78 34 81 	movl   $0x813478,0x8(%esp)
  806d89:	00 
  806d8a:	c7 44 24 04 a0 04 00 	movl   $0x4a0,0x4(%esp)
  806d91:	00 
  806d92:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806d99:	e8 36 9c ff ff       	call   8009d4 <_panic>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_unfold_reply(): copied %"U16_F" bytes into dhcp->msg_in[]\n",
     sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN));

  if (dhcp->options_in != NULL) {
  806d9e:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806da1:	8b 42 14             	mov    0x14(%edx),%eax
  806da4:	85 c0                	test   %eax,%eax
  806da6:	0f 84 fd 02 00 00    	je     8070a9 <dhcp_recv+0x477>
    /** copy the DHCP options */
    ret = pbuf_copy_partial(dhcp->p, dhcp->options_in, dhcp->options_in_len, sizeof(struct dhcp_msg) - DHCP_OPTIONS_LEN);
  806dac:	c7 44 24 0c f0 00 00 	movl   $0xf0,0xc(%esp)
  806db3:	00 
  806db4:	89 d1                	mov    %edx,%ecx
  806db6:	0f b7 52 18          	movzwl 0x18(%edx),%edx
  806dba:	89 54 24 08          	mov    %edx,0x8(%esp)
  806dbe:	89 44 24 04          	mov    %eax,0x4(%esp)
  806dc2:	8b 41 0c             	mov    0xc(%ecx),%eax
  806dc5:	89 04 24             	mov    %eax,(%esp)
  806dc8:	e8 09 0f 00 00       	call   807cd6 <pbuf_copy_partial>
    LWIP_ASSERT("ret == dhcp->options_in_len", ret == dhcp->options_in_len);
  806dcd:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806dd0:	66 3b 43 18          	cmp    0x18(%ebx),%ax
  806dd4:	0f 84 cf 02 00 00    	je     8070a9 <dhcp_recv+0x477>
  806dda:	c7 44 24 08 19 35 81 	movl   $0x813519,0x8(%esp)
  806de1:	00 
  806de2:	c7 44 24 04 a7 04 00 	movl   $0x4a7,0x4(%esp)
  806de9:	00 
  806dea:	c7 04 24 aa 34 81 00 	movl   $0x8134aa,(%esp)
  806df1:	e8 de 9b ff ff       	call   8009d4 <_panic>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OPTION_MESSAGE_TYPE option not found\n"));
    goto free_pbuf_and_return;
  }

  /* read DHCP message type */
  msg_type = dhcp_get_option_byte(options_ptr + 2);
  806df6:	83 c0 02             	add    $0x2,%eax
  806df9:	e8 4d eb ff ff       	call   80594b <dhcp_get_option_byte>
  /* message type is DHCP ACK? */
  if (msg_type == DHCP_ACK) {
  806dfe:	3c 05                	cmp    $0x5,%al
  806e00:	0f 85 a6 01 00 00    	jne    806fac <dhcp_recv+0x37a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
  806e06:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806e09:	0f b6 02             	movzbl (%edx),%eax
  806e0c:	3c 01                	cmp    $0x1,%al
  806e0e:	0f 85 77 01 00 00    	jne    806f8b <dhcp_recv+0x359>
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_ack(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806e14:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  806e17:	8b 59 20             	mov    0x20(%ecx),%ebx
  u8_t *option_ptr;
  /* clear options we might not get from the ACK */
  dhcp->offered_sn_mask.addr = 0;
  806e1a:	c7 43 34 00 00 00 00 	movl   $0x0,0x34(%ebx)
  dhcp->offered_gw_addr.addr = 0;
  806e21:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
  dhcp->offered_bc_addr.addr = 0;
  806e28:	c7 43 3c 00 00 00 00 	movl   $0x0,0x3c(%ebx)

  /* lease time given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_LEASE_TIME);
  806e2f:	ba 33 00 00 00       	mov    $0x33,%edx
  806e34:	89 d8                	mov    %ebx,%eax
  806e36:	e8 04 ea ff ff       	call   80583f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806e3b:	85 c0                	test   %eax,%eax
  806e3d:	74 0b                	je     806e4a <dhcp_recv+0x218>
    /* remember offered lease time */
    dhcp->offered_t0_lease = dhcp_get_option_long(option_ptr + 2);
  806e3f:	83 c0 02             	add    $0x2,%eax
  806e42:	e8 0c eb ff ff       	call   805953 <dhcp_get_option_long>
  806e47:	89 43 4c             	mov    %eax,0x4c(%ebx)
  }
  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T1);
  806e4a:	ba 3a 00 00 00       	mov    $0x3a,%edx
  806e4f:	89 d8                	mov    %ebx,%eax
  806e51:	e8 e9 e9 ff ff       	call   80583f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806e56:	85 c0                	test   %eax,%eax
  806e58:	74 0d                	je     806e67 <dhcp_recv+0x235>
    /* remember given renewal period */
    dhcp->offered_t1_renew = dhcp_get_option_long(option_ptr + 2);
  806e5a:	83 c0 02             	add    $0x2,%eax
  806e5d:	e8 f1 ea ff ff       	call   805953 <dhcp_get_option_long>
  806e62:	89 43 50             	mov    %eax,0x50(%ebx)
  806e65:	eb 08                	jmp    806e6f <dhcp_recv+0x23d>
  } else {
    /* calculate safe periods for renewal */
    dhcp->offered_t1_renew = dhcp->offered_t0_lease / 2;
  806e67:	8b 43 4c             	mov    0x4c(%ebx),%eax
  806e6a:	d1 e8                	shr    %eax
  806e6c:	89 43 50             	mov    %eax,0x50(%ebx)
  }

  /* renewal period given? */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_T2);
  806e6f:	ba 3b 00 00 00       	mov    $0x3b,%edx
  806e74:	89 d8                	mov    %ebx,%eax
  806e76:	e8 c4 e9 ff ff       	call   80583f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806e7b:	85 c0                	test   %eax,%eax
  806e7d:	74 0d                	je     806e8c <dhcp_recv+0x25a>
    /* remember given rebind period */
    dhcp->offered_t2_rebind = dhcp_get_option_long(option_ptr + 2);
  806e7f:	83 c0 02             	add    $0x2,%eax
  806e82:	e8 cc ea ff ff       	call   805953 <dhcp_get_option_long>
  806e87:	89 43 54             	mov    %eax,0x54(%ebx)
  806e8a:	eb 06                	jmp    806e92 <dhcp_recv+0x260>
  } else {
    /* calculate safe periods for rebinding */
    dhcp->offered_t2_rebind = dhcp->offered_t0_lease;
  806e8c:	8b 43 4c             	mov    0x4c(%ebx),%eax
  806e8f:	89 43 54             	mov    %eax,0x54(%ebx)
  }

  /* (y)our internet address */
  ip_addr_set(&dhcp->offered_ip_addr, &dhcp->msg_in->yiaddr);
  806e92:	8b 53 10             	mov    0x10(%ebx),%edx
  806e95:	b8 00 00 00 00       	mov    $0x0,%eax
  806e9a:	83 fa f0             	cmp    $0xfffffff0,%edx
  806e9d:	74 03                	je     806ea2 <dhcp_recv+0x270>
  806e9f:	8b 42 10             	mov    0x10(%edx),%eax
  806ea2:	89 43 30             	mov    %eax,0x30(%ebx)
    strcpy(dhcp->boot_file_name, dhcp->msg_in->file);
  }
#endif

  /* subnet mask */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SUBNET_MASK);
  806ea5:	ba 01 00 00 00       	mov    $0x1,%edx
  806eaa:	89 d8                	mov    %ebx,%eax
  806eac:	e8 8e e9 ff ff       	call   80583f <dhcp_get_option_ptr>
  /* subnet mask given? */
  if (option_ptr != NULL) {
  806eb1:	85 c0                	test   %eax,%eax
  806eb3:	74 13                	je     806ec8 <dhcp_recv+0x296>
    dhcp->offered_sn_mask.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806eb5:	83 c0 02             	add    $0x2,%eax
  806eb8:	e8 96 ea ff ff       	call   805953 <dhcp_get_option_long>
  806ebd:	89 04 24             	mov    %eax,(%esp)
  806ec0:	e8 b0 3e 00 00       	call   80ad75 <htonl>
  806ec5:	89 43 34             	mov    %eax,0x34(%ebx)
  }

  /* gateway router */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_ROUTER);
  806ec8:	ba 03 00 00 00       	mov    $0x3,%edx
  806ecd:	89 d8                	mov    %ebx,%eax
  806ecf:	e8 6b e9 ff ff       	call   80583f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806ed4:	85 c0                	test   %eax,%eax
  806ed6:	74 13                	je     806eeb <dhcp_recv+0x2b9>
    dhcp->offered_gw_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806ed8:	83 c0 02             	add    $0x2,%eax
  806edb:	e8 73 ea ff ff       	call   805953 <dhcp_get_option_long>
  806ee0:	89 04 24             	mov    %eax,(%esp)
  806ee3:	e8 8d 3e 00 00       	call   80ad75 <htonl>
  806ee8:	89 43 38             	mov    %eax,0x38(%ebx)
  }

  /* broadcast address */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_BROADCAST);
  806eeb:	ba 1c 00 00 00       	mov    $0x1c,%edx
  806ef0:	89 d8                	mov    %ebx,%eax
  806ef2:	e8 48 e9 ff ff       	call   80583f <dhcp_get_option_ptr>
  if (option_ptr != NULL) {
  806ef7:	85 c0                	test   %eax,%eax
  806ef9:	74 13                	je     806f0e <dhcp_recv+0x2dc>
    dhcp->offered_bc_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  806efb:	83 c0 02             	add    $0x2,%eax
  806efe:	e8 50 ea ff ff       	call   805953 <dhcp_get_option_long>
  806f03:	89 04 24             	mov    %eax,(%esp)
  806f06:	e8 6a 3e 00 00       	call   80ad75 <htonl>
  806f0b:	89 43 3c             	mov    %eax,0x3c(%ebx)
  }
  
  /* DNS servers */
  option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_DNS_SERVER);
  806f0e:	ba 06 00 00 00       	mov    $0x6,%edx
  806f13:	89 d8                	mov    %ebx,%eax
  806f15:	e8 25 e9 ff ff       	call   80583f <dhcp_get_option_ptr>
  806f1a:	89 c6                	mov    %eax,%esi
  if (option_ptr != NULL) {
  806f1c:	85 c0                	test   %eax,%eax
  806f1e:	74 55                	je     806f75 <dhcp_recv+0x343>
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
  806f20:	8d 40 01             	lea    0x1(%eax),%eax
  806f23:	e8 23 ea ff ff       	call   80594b <dhcp_get_option_byte>
  806f28:	c0 e8 02             	shr    $0x2,%al
  806f2b:	0f b6 c0             	movzbl %al,%eax
  806f2e:	89 43 40             	mov    %eax,0x40(%ebx)
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
  806f31:	83 f8 02             	cmp    $0x2,%eax
  806f34:	76 07                	jbe    806f3d <dhcp_recv+0x30b>
      dhcp->dns_count = DHCP_MAX_DNS;
  806f36:	c7 43 40 02 00 00 00 	movl   $0x2,0x40(%ebx)
  806f3d:	bf 00 00 00 00       	mov    $0x0,%edi
  806f42:	89 f8                	mov    %edi,%eax
  806f44:	89 f7                	mov    %esi,%edi
  806f46:	89 de                	mov    %ebx,%esi
  806f48:	89 c3                	mov    %eax,%ebx
  806f4a:	eb 21                	jmp    806f6d <dhcp_recv+0x33b>
    for (n = 0; n < dhcp->dns_count; n++) {
      dhcp->offered_dns_addr[n].addr = htonl(dhcp_get_option_long(&option_ptr[2 + n * 4]));
  806f4c:	0f b6 c3             	movzbl %bl,%eax
  806f4f:	89 45 dc             	mov    %eax,-0x24(%ebp)
  806f52:	8d 44 87 02          	lea    0x2(%edi,%eax,4),%eax
  806f56:	e8 f8 e9 ff ff       	call   805953 <dhcp_get_option_long>
  806f5b:	89 04 24             	mov    %eax,(%esp)
  806f5e:	e8 12 3e 00 00       	call   80ad75 <htonl>
  806f63:	8b 55 dc             	mov    -0x24(%ebp),%edx
  806f66:	89 44 96 44          	mov    %eax,0x44(%esi,%edx,4)
    u8_t n;
    dhcp->dns_count = dhcp_get_option_byte(&option_ptr[1]) / (u32_t)sizeof(struct ip_addr);
    /* limit to at most DHCP_MAX_DNS DNS servers */
    if (dhcp->dns_count > DHCP_MAX_DNS)
      dhcp->dns_count = DHCP_MAX_DNS;
    for (n = 0; n < dhcp->dns_count; n++) {
  806f6a:	83 c3 01             	add    $0x1,%ebx
  806f6d:	0f b6 c3             	movzbl %bl,%eax
  806f70:	3b 46 40             	cmp    0x40(%esi),%eax
  806f73:	72 d7                	jb     806f4c <dhcp_recv+0x31a>
  if (msg_type == DHCP_ACK) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_ACK received\n"));
    /* in requesting state? */
    if (dhcp->state == DHCP_REQUESTING) {
      dhcp_handle_ack(netif);
      dhcp->request_timeout = 0;
  806f75:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806f78:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
#if DHCP_DOES_ARP_CHECK
      /* check if the acknowledged lease address is already in use */
      dhcp_check(netif);
  806f7e:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806f81:	e8 d4 fa ff ff       	call   806a5a <dhcp_check>
  806f86:	e9 01 01 00 00       	jmp    80708c <dhcp_recv+0x45a>
      /* bind interface to the acknowledged lease address */
      dhcp_bind(netif);
#endif
    }
    /* already bound to the given lease address? */
    else if ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING)) {
  806f8b:	83 e8 03             	sub    $0x3,%eax
  806f8e:	3c 02                	cmp    $0x2,%al
  806f90:	0f 87 f6 00 00 00    	ja     80708c <dhcp_recv+0x45a>
      dhcp->request_timeout = 0;
  806f96:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  806f99:	66 c7 43 26 00 00    	movw   $0x0,0x26(%ebx)
      dhcp_bind(netif);
  806f9f:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806fa2:	e8 f0 fa ff ff       	call   806a97 <dhcp_bind>
  806fa7:	e9 e0 00 00 00       	jmp    80708c <dhcp_recv+0x45a>
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806fac:	3c 06                	cmp    $0x6,%al
  806fae:	0f 85 80 00 00 00    	jne    807034 <dhcp_recv+0x402>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
  806fb4:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  806fb7:	0f b6 02             	movzbl (%edx),%eax
      dhcp->request_timeout = 0;
      dhcp_bind(netif);
    }
  }
  /* received a DHCP_NAK in appropriate state? */
  else if ((msg_type == DHCP_NAK) &&
  806fba:	3c 03                	cmp    $0x3,%al
  806fbc:	74 10                	je     806fce <dhcp_recv+0x39c>
  806fbe:	3c 01                	cmp    $0x1,%al
  806fc0:	74 0c                	je     806fce <dhcp_recv+0x39c>
  806fc2:	3c 04                	cmp    $0x4,%al
  806fc4:	74 08                	je     806fce <dhcp_recv+0x39c>
  806fc6:	3c 05                	cmp    $0x5,%al
  806fc8:	0f 85 be 00 00 00    	jne    80708c <dhcp_recv+0x45a>
    ((dhcp->state == DHCP_REBOOTING) || (dhcp->state == DHCP_REQUESTING) ||
     (dhcp->state == DHCP_REBINDING) || (dhcp->state == DHCP_RENEWING  ))) {
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
  806fce:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  806fd1:	66 c7 41 26 00 00    	movw   $0x0,0x26(%ecx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_nak(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  806fd7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  806fda:	8b 58 20             	mov    0x20(%eax),%ebx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_nak(netif=%p) %c%c%"U16_F"\n", 
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  /* Set the interface down since the address must no longer be used, as per RFC2131 */
  netif_set_down(netif);
  806fdd:	89 04 24             	mov    %eax,(%esp)
  806fe0:	e8 63 09 00 00       	call   807948 <netif_set_down>
  /* remove IP address from interface */
  netif_set_ipaddr(netif, IP_ADDR_ANY);
  806fe5:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  806fec:	00 
  806fed:	8b 55 e0             	mov    -0x20(%ebp),%edx
  806ff0:	89 14 24             	mov    %edx,(%esp)
  806ff3:	e8 ac 09 00 00       	call   8079a4 <netif_set_ipaddr>
  netif_set_gw(netif, IP_ADDR_ANY);
  806ff8:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  806fff:	00 
  807000:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  807003:	89 0c 24             	mov    %ecx,(%esp)
  807006:	e8 a4 08 00 00       	call   8078af <netif_set_gw>
  netif_set_netmask(netif, IP_ADDR_ANY); 
  80700b:	c7 44 24 04 8c 3d 81 	movl   $0x813d8c,0x4(%esp)
  807012:	00 
  807013:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807016:	89 04 24             	mov    %eax,(%esp)
  807019:	e8 aa 08 00 00       	call   8078c8 <netif_set_netmask>
  /* Change to a defined state */
  dhcp_set_state(dhcp, DHCP_BACKING_OFF);
  80701e:	ba 0c 00 00 00       	mov    $0xc,%edx
  807023:	89 d8                	mov    %ebx,%eax
  807025:	e8 06 e8 ff ff       	call   805830 <dhcp_set_state>
  /* We can immediately restart discovery */
  dhcp_discover(netif);
  80702a:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80702d:	e8 e6 f1 ff ff       	call   806218 <dhcp_discover>
  807032:	eb 58                	jmp    80708c <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_NAK received\n"));
    dhcp->request_timeout = 0;
    dhcp_handle_nak(netif);
  }
  /* received a DHCP_OFFER in DHCP_SELECTING state? */
  else if ((msg_type == DHCP_OFFER) && (dhcp->state == DHCP_SELECTING)) {
  807034:	3c 02                	cmp    $0x2,%al
  807036:	75 54                	jne    80708c <dhcp_recv+0x45a>
  807038:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80703b:	80 3a 06             	cmpb   $0x6,(%edx)
  80703e:	66 90                	xchg   %ax,%ax
  807040:	75 4a                	jne    80708c <dhcp_recv+0x45a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 1, ("DHCP_OFFER received in DHCP_SELECTING state\n"));
    dhcp->request_timeout = 0;
  807042:	66 c7 42 26 00 00    	movw   $0x0,0x26(%edx)
 * @param netif the netif under DHCP control
 */
static void
dhcp_handle_offer(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807048:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80704b:	8b 59 20             	mov    0x20(%ecx),%ebx
  /* obtain the server address */
  u8_t *option_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_SERVER_ID);
  80704e:	ba 36 00 00 00       	mov    $0x36,%edx
  807053:	89 d8                	mov    %ebx,%eax
  807055:	e8 e5 e7 ff ff       	call   80583f <dhcp_get_option_ptr>
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_handle_offer(netif=%p) %c%c%"U16_F"\n",
    (void*)netif, netif->name[0], netif->name[1], (u16_t)netif->num));
  if (option_ptr != NULL) {
  80705a:	85 c0                	test   %eax,%eax
  80705c:	74 2e                	je     80708c <dhcp_recv+0x45a>
    dhcp->server_ip_addr.addr = htonl(dhcp_get_option_long(&option_ptr[2]));
  80705e:	83 c0 02             	add    $0x2,%eax
  807061:	e8 ed e8 ff ff       	call   805953 <dhcp_get_option_long>
  807066:	89 04 24             	mov    %eax,(%esp)
  807069:	e8 07 3d 00 00       	call   80ad75 <htonl>
  80706e:	89 43 2c             	mov    %eax,0x2c(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): server 0x%08"X32_F"\n", dhcp->server_ip_addr.addr));
    /* remember offered address */
    ip_addr_set(&dhcp->offered_ip_addr, (struct ip_addr *)&dhcp->msg_in->yiaddr);
  807071:	8b 53 10             	mov    0x10(%ebx),%edx
  807074:	b8 00 00 00 00       	mov    $0x0,%eax
  807079:	83 fa f0             	cmp    $0xfffffff0,%edx
  80707c:	74 03                	je     807081 <dhcp_recv+0x44f>
  80707e:	8b 42 10             	mov    0x10(%edx),%eax
  807081:	89 43 30             	mov    %eax,0x30(%ebx)
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_STATE, ("dhcp_handle_offer(): offer for 0x%08"X32_F"\n", dhcp->offered_ip_addr.addr));

    dhcp_select(netif);
  807084:	8b 45 e0             	mov    -0x20(%ebp),%eax
  807087:	e8 c3 f5 ff ff       	call   80664f <dhcp_select>
    dhcp->request_timeout = 0;
    /* remember offered lease */
    dhcp_handle_offer(netif);
  }
free_pbuf_and_return:
  pbuf_free(p);
  80708c:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80708f:	89 1c 24             	mov    %ebx,(%esp)
  807092:	e8 c1 0e 00 00       	call   807f58 <pbuf_free>
  dhcp->p = NULL;
  807097:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80709a:	c7 40 0c 00 00 00 00 	movl   $0x0,0xc(%eax)
}
  8070a1:	83 c4 2c             	add    $0x2c,%esp
  8070a4:	5b                   	pop    %ebx
  8070a5:	5e                   	pop    %esi
  8070a6:	5f                   	pop    %edi
  8070a7:	5d                   	pop    %ebp
  8070a8:	c3                   	ret    
    goto free_pbuf_and_return;
  }

  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("searching DHCP_OPTION_MESSAGE_TYPE\n"));
  /* obtain pointer to DHCP message type */
  options_ptr = dhcp_get_option_ptr(dhcp, DHCP_OPTION_MESSAGE_TYPE);
  8070a9:	ba 35 00 00 00       	mov    $0x35,%edx
  8070ae:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  8070b1:	e8 89 e7 ff ff       	call   80583f <dhcp_get_option_ptr>
  if (options_ptr == NULL) {
  8070b6:	85 c0                	test   %eax,%eax
  8070b8:	0f 85 38 fd ff ff    	jne    806df6 <dhcp_recv+0x1c4>
  8070be:	66 90                	xchg   %ax,%ax
  8070c0:	eb ca                	jmp    80708c <dhcp_recv+0x45a>

008070c2 <dhcp_fine_tmr>:
 * This timer checks whether an outstanding DHCP request is timed out.
 * 
 */
void
dhcp_fine_tmr()
{
  8070c2:	55                   	push   %ebp
  8070c3:	89 e5                	mov    %esp,%ebp
  8070c5:	53                   	push   %ebx
  8070c6:	83 ec 14             	sub    $0x14,%esp
  struct netif *netif = netif_list;
  8070c9:	8b 1d 00 f6 b3 00    	mov    0xb3f600,%ebx
  /* loop through netif's */
  while (netif != NULL) {
  8070cf:	85 db                	test   %ebx,%ebx
  8070d1:	0f 84 dd 00 00 00    	je     8071b4 <dhcp_fine_tmr+0xf2>
    /* only act on DHCP configured interfaces */
    if (netif->dhcp != NULL) {
  8070d7:	8b 43 20             	mov    0x20(%ebx),%eax
  8070da:	85 c0                	test   %eax,%eax
  8070dc:	0f 84 c8 00 00 00    	je     8071aa <dhcp_fine_tmr+0xe8>
      /* timer is active (non zero), and is about to trigger now */      
      if (netif->dhcp->request_timeout > 1) {
  8070e2:	0f b7 50 26          	movzwl 0x26(%eax),%edx
  8070e6:	66 83 fa 01          	cmp    $0x1,%dx
  8070ea:	76 0c                	jbe    8070f8 <dhcp_fine_tmr+0x36>
        netif->dhcp->request_timeout--;
  8070ec:	83 ea 01             	sub    $0x1,%edx
  8070ef:	66 89 50 26          	mov    %dx,0x26(%eax)
  8070f3:	e9 b2 00 00 00       	jmp    8071aa <dhcp_fine_tmr+0xe8>
      }
      else if (netif->dhcp->request_timeout == 1) {
  8070f8:	66 83 fa 01          	cmp    $0x1,%dx
  8070fc:	0f 85 a8 00 00 00    	jne    8071aa <dhcp_fine_tmr+0xe8>
        netif->dhcp->request_timeout--;
  807102:	66 c7 40 26 00 00    	movw   $0x0,0x26(%eax)
 * @param netif the netif under DHCP control
 */
static void
dhcp_timeout(struct netif *netif)
{
  struct dhcp *dhcp = netif->dhcp;
  807108:	8b 53 20             	mov    0x20(%ebx),%edx
  LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | 3, ("dhcp_timeout()\n"));
  /* back-off period has passed, or server selection timed out */
  if ((dhcp->state == DHCP_BACKING_OFF) || (dhcp->state == DHCP_SELECTING)) {
  80710b:	0f b6 02             	movzbl (%edx),%eax
  80710e:	3c 0c                	cmp    $0xc,%al
  807110:	74 04                	je     807116 <dhcp_fine_tmr+0x54>
  807112:	3c 06                	cmp    $0x6,%al
  807114:	75 0f                	jne    807125 <dhcp_fine_tmr+0x63>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE, ("dhcp_timeout(): restarting discovery\n"));
    dhcp_discover(netif);
  807116:	89 d8                	mov    %ebx,%eax
  807118:	e8 fb f0 ff ff       	call   806218 <dhcp_discover>
  80711d:	8d 76 00             	lea    0x0(%esi),%esi
  807120:	e9 85 00 00 00       	jmp    8071aa <dhcp_fine_tmr+0xe8>
  /* receiving the requested lease timed out */
  } else if (dhcp->state == DHCP_REQUESTING) {
  807125:	3c 01                	cmp    $0x1,%al
  807127:	75 23                	jne    80714c <dhcp_fine_tmr+0x8a>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, DHCP request timed out\n"));
    if (dhcp->tries <= 5) {
  807129:	80 7a 01 05          	cmpb   $0x5,0x1(%edx)
  80712d:	8d 76 00             	lea    0x0(%esi),%esi
  807130:	77 09                	ja     80713b <dhcp_fine_tmr+0x79>
      dhcp_select(netif);
  807132:	89 d8                	mov    %ebx,%eax
  807134:	e8 16 f5 ff ff       	call   80664f <dhcp_select>
  807139:	eb 6f                	jmp    8071aa <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REQUESTING, releasing, restarting\n"));
      dhcp_release(netif);
  80713b:	89 1c 24             	mov    %ebx,(%esp)
  80713e:	e8 52 ee ff ff       	call   805f95 <dhcp_release>
      dhcp_discover(netif);
  807143:	89 d8                	mov    %ebx,%eax
  807145:	e8 ce f0 ff ff       	call   806218 <dhcp_discover>
  80714a:	eb 5e                	jmp    8071aa <dhcp_fine_tmr+0xe8>
    }
  /* received no ARP reply for the offered address (which is good) */
  } else if (dhcp->state == DHCP_CHECKING) {
  80714c:	3c 08                	cmp    $0x8,%al
  80714e:	66 90                	xchg   %ax,%ax
  807150:	75 20                	jne    807172 <dhcp_fine_tmr+0xb0>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): CHECKING, ARP request timed out\n"));
    if (dhcp->tries <= 1) {
  807152:	80 7a 01 01          	cmpb   $0x1,0x1(%edx)
  807156:	66 90                	xchg   %ax,%ax
  807158:	77 0d                	ja     807167 <dhcp_fine_tmr+0xa5>
      dhcp_check(netif);
  80715a:	89 d8                	mov    %ebx,%eax
  80715c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  807160:	e8 f5 f8 ff ff       	call   806a5a <dhcp_check>
  807165:	eb 43                	jmp    8071aa <dhcp_fine_tmr+0xe8>
    /* no ARP replies on the offered address,
       looks like the IP address is indeed free */
    } else {
      /* bind the interface to the offered address */
      dhcp_bind(netif);
  807167:	89 d8                	mov    %ebx,%eax
  807169:	e8 29 f9 ff ff       	call   806a97 <dhcp_bind>
  80716e:	66 90                	xchg   %ax,%ax
  807170:	eb 38                	jmp    8071aa <dhcp_fine_tmr+0xe8>
    }
  }
  /* did not get response to renew request? */
  else if (dhcp->state == DHCP_RENEWING) {
  807172:	3c 05                	cmp    $0x5,%al
  807174:	75 11                	jne    807187 <dhcp_fine_tmr+0xc5>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RENEWING, DHCP request timed out\n"));
    /* just retry renewal */
    /* note that the rebind timer will eventually time-out if renew does not work */
    dhcp_renew(netif);
  807176:	89 1c 24             	mov    %ebx,(%esp)
  807179:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  807180:	e8 79 ef ff ff       	call   8060fe <dhcp_renew>
  807185:	eb 23                	jmp    8071aa <dhcp_fine_tmr+0xe8>
  /* did not get response to rebind request? */
  } else if (dhcp->state == DHCP_REBINDING) {
  807187:	3c 04                	cmp    $0x4,%al
  807189:	75 1f                	jne    8071aa <dhcp_fine_tmr+0xe8>
    LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): REBINDING, DHCP request timed out\n"));
    if (dhcp->tries <= 8) {
  80718b:	80 7a 01 08          	cmpb   $0x8,0x1(%edx)
  80718f:	90                   	nop
  807190:	77 09                	ja     80719b <dhcp_fine_tmr+0xd9>
      dhcp_rebind(netif);
  807192:	89 d8                	mov    %ebx,%eax
  807194:	e8 d8 f1 ff ff       	call   806371 <dhcp_rebind>
  807199:	eb 0f                	jmp    8071aa <dhcp_fine_tmr+0xe8>
    } else {
      LWIP_DEBUGF(DHCP_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("dhcp_timeout(): RELEASING, DISCOVERING\n"));
      dhcp_release(netif);
  80719b:	89 1c 24             	mov    %ebx,(%esp)
  80719e:	e8 f2 ed ff ff       	call   805f95 <dhcp_release>
      dhcp_discover(netif);
  8071a3:	89 d8                	mov    %ebx,%eax
  8071a5:	e8 6e f0 ff ff       	call   806218 <dhcp_discover>
        /* this clients' request timeout triggered */
        dhcp_timeout(netif);
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  8071aa:	8b 1b                	mov    (%ebx),%ebx
void
dhcp_fine_tmr()
{
  struct netif *netif = netif_list;
  /* loop through netif's */
  while (netif != NULL) {
  8071ac:	85 db                	test   %ebx,%ebx
  8071ae:	0f 85 23 ff ff ff    	jne    8070d7 <dhcp_fine_tmr+0x15>
      }
    }
    /* proceed to next network interface */
    netif = netif->next;
  }
}
  8071b4:	83 c4 14             	add    $0x14,%esp
  8071b7:	5b                   	pop    %ebx
  8071b8:	5d                   	pop    %ebp
  8071b9:	c3                   	ret    
  8071ba:	00 00                	add    %al,(%eax)
  8071bc:	00 00                	add    %al,(%eax)
	...

008071c0 <mem_malloc>:
 *
 * Note that the returned value will always be aligned (as defined by MEM_ALIGNMENT).
 */
void *
mem_malloc(mem_size_t size)
{
  8071c0:	55                   	push   %ebp
  8071c1:	89 e5                	mov    %esp,%ebp
  8071c3:	83 ec 38             	sub    $0x38,%esp
  8071c6:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8071c9:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8071cc:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8071cf:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  u8_t local_mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_ALLOC_DECL_PROTECT();

  if (size == 0) {
  8071d2:	85 c0                	test   %eax,%eax
  8071d4:	0f 84 be 01 00 00    	je     807398 <mem_malloc+0x1d8>
    return NULL;
  }

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  size = LWIP_MEM_ALIGN_SIZE(size);
  8071da:	83 c0 03             	add    $0x3,%eax
  8071dd:	83 e0 fc             	and    $0xfffffffc,%eax
  8071e0:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(size < MIN_SIZE_ALIGNED) {
  8071e3:	83 f8 0b             	cmp    $0xb,%eax
  8071e6:	77 09                	ja     8071f1 <mem_malloc+0x31>
  8071e8:	c7 45 e4 0c 00 00 00 	movl   $0xc,-0x1c(%ebp)
  8071ef:	eb 0d                	jmp    8071fe <mem_malloc+0x3e>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    size = MIN_SIZE_ALIGNED;
  }

  if (size > MEM_SIZE_ALIGNED) {
  8071f1:	81 7d e4 00 00 22 00 	cmpl   $0x220000,-0x1c(%ebp)
  8071f8:	0f 87 9a 01 00 00    	ja     807398 <mem_malloc+0x1d8>
    return NULL;
  }

  /* protect the heap from concurrent access */
  sys_arch_sem_wait(mem_sem, 0);
  8071fe:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807205:	00 
  807206:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  80720b:	89 04 24             	mov    %eax,(%esp)
  80720e:	e8 23 67 00 00       	call   80d936 <sys_arch_sem_wait>
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  807213:	a1 e4 96 a3 00       	mov    0xa396e4,%eax
  807218:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80721b:	8b 15 dc 96 a3 00    	mov    0xa396dc,%edx
  807221:	29 d0                	sub    %edx,%eax
  807223:	b9 00 00 22 00       	mov    $0x220000,%ecx
  807228:	2b 4d e4             	sub    -0x1c(%ebp),%ecx
  80722b:	39 c8                	cmp    %ecx,%eax
  80722d:	0f 83 51 01 00 00    	jae    807384 <mem_malloc+0x1c4>
         ptr = ((struct mem *)&ram[ptr])->next) {
      mem = (struct mem *)&ram[ptr];
  807233:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807236:	8b 75 e0             	mov    -0x20(%ebp),%esi
  807239:	8d 1c 02             	lea    (%edx,%eax,1),%ebx
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80723c:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  807240:	0f 85 34 01 00 00    	jne    80737a <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
  807246:	8b 3b                	mov    (%ebx),%edi
  807248:	83 ef 0c             	sub    $0xc,%edi
  80724b:	29 c7                	sub    %eax,%edi
        local_mem_free_count = mem_free_count;
      }
      mem_free_count = 0;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

      if ((!mem->used) &&
  80724d:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  807250:	0f 87 24 01 00 00    	ja     80737a <mem_malloc+0x1ba>
          (mem->next - (ptr + SIZEOF_STRUCT_MEM)) >= size) {
        /* mem is not used and at least perfect fit is possible:
         * mem->next - (ptr + SIZEOF_STRUCT_MEM) gives us the 'user data size' of mem */

        if (mem->next - (ptr + SIZEOF_STRUCT_MEM) >= (size + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED)) {
  807256:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807259:	83 c2 18             	add    $0x18,%edx
  80725c:	39 d7                	cmp    %edx,%edi
  80725e:	72 2a                	jb     80728a <mem_malloc+0xca>
           * struct mem would fit in but no data between mem2 and mem2->next
           * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
           *       region that couldn't hold data, but when mem->next gets freed,
           *       the 2 regions would be combined, resulting in more free memory
           */
          ptr2 = ptr + SIZEOF_STRUCT_MEM + size;
  807260:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  807263:	8d 4c 02 0c          	lea    0xc(%edx,%eax,1),%ecx
          /* create mem2 struct */
          mem2 = (struct mem *)&ram[ptr2];
  807267:	8d 14 0e             	lea    (%esi,%ecx,1),%edx
          mem2->used = 0;
  80726a:	c6 42 08 00          	movb   $0x0,0x8(%edx)
          mem2->next = mem->next;
  80726e:	8b 3b                	mov    (%ebx),%edi
  807270:	89 3a                	mov    %edi,(%edx)
          mem2->prev = ptr;
  807272:	89 42 04             	mov    %eax,0x4(%edx)
          /* and insert it between mem and mem->next */
          mem->next = ptr2;
  807275:	89 0b                	mov    %ecx,(%ebx)
          mem->used = 1;
  807277:	c6 43 08 01          	movb   $0x1,0x8(%ebx)

          if (mem2->next != MEM_SIZE_ALIGNED) {
  80727b:	8b 02                	mov    (%edx),%eax
  80727d:	3d 00 00 22 00       	cmp    $0x220000,%eax
  807282:	74 0a                	je     80728e <mem_malloc+0xce>
            ((struct mem *)&ram[mem2->next])->prev = ptr2;
  807284:	89 4c 06 04          	mov    %ecx,0x4(%esi,%eax,1)
  807288:	eb 04                	jmp    80728e <mem_malloc+0xce>
           * take care of this).
           * -> near fit or excact fit: do not split, no mem2 creation
           * also can't move mem->next directly behind mem, since mem->next
           * will always be used at this point!
           */
          mem->used = 1;
  80728a:	c6 43 08 01          	movb   $0x1,0x8(%ebx)
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
  80728e:	39 5d dc             	cmp    %ebx,-0x24(%ebp)
  807291:	75 67                	jne    8072fa <mem_malloc+0x13a>
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  807293:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  807296:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  80729a:	84 c0                	test   %al,%al
  80729c:	74 31                	je     8072cf <mem_malloc+0x10f>
  80729e:	8b 15 e0 96 a3 00    	mov    0xa396e0,%edx
  8072a4:	39 d1                	cmp    %edx,%ecx
  8072a6:	74 52                	je     8072fa <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
  8072a8:	8b 01                	mov    (%ecx),%eax
  8072aa:	8d 0c 06             	lea    (%esi,%eax,1),%ecx
          MEM_STATS_INC_USED(used, mem->next - ((u8_t *)mem - ram));
        }

        if (mem == lfree) {
          /* Find next free block after mem and update lowest free pointer */
          while (lfree->used && lfree != ram_end) {
  8072ad:	0f b6 41 08          	movzbl 0x8(%ecx),%eax
  8072b1:	84 c0                	test   %al,%al
  8072b3:	75 0b                	jne    8072c0 <mem_malloc+0x100>
  8072b5:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  8072b8:	89 0d e4 96 a3 00    	mov    %ecx,0xa396e4
  8072be:	eb 0f                	jmp    8072cf <mem_malloc+0x10f>
  8072c0:	39 d1                	cmp    %edx,%ecx
  8072c2:	75 e4                	jne    8072a8 <mem_malloc+0xe8>
  8072c4:	89 4d dc             	mov    %ecx,-0x24(%ebp)
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  return NULL;
  8072c7:	89 0d e4 96 a3 00    	mov    %ecx,0xa396e4
  8072cd:	eb 2b                	jmp    8072fa <mem_malloc+0x13a>
            LWIP_MEM_ALLOC_UNPROTECT();
            /* prevent high interrupt latency... */
            LWIP_MEM_ALLOC_PROTECT();
            lfree = (struct mem *)&ram[lfree->next];
          }
          LWIP_ASSERT("mem_malloc: !lfree->used", ((lfree == ram_end) || (!lfree->used)));
  8072cf:	8b 55 dc             	mov    -0x24(%ebp),%edx
  8072d2:	3b 15 e0 96 a3 00    	cmp    0xa396e0,%edx
  8072d8:	74 20                	je     8072fa <mem_malloc+0x13a>
  8072da:	84 c0                	test   %al,%al
  8072dc:	74 1c                	je     8072fa <mem_malloc+0x13a>
  8072de:	c7 44 24 08 35 35 81 	movl   $0x813535,0x8(%esp)
  8072e5:	00 
  8072e6:	c7 44 24 04 46 02 00 	movl   $0x246,0x4(%esp)
  8072ed:	00 
  8072ee:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  8072f5:	e8 da 96 ff ff       	call   8009d4 <_panic>
        }
        LWIP_MEM_ALLOC_UNPROTECT();
        sys_sem_signal(mem_sem);
  8072fa:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  8072ff:	89 04 24             	mov    %eax,(%esp)
  807302:	e8 20 69 00 00       	call   80dc27 <sys_sem_signal>
        LWIP_ASSERT("mem_malloc: allocated memory not above ram_end.",
  807307:	89 d8                	mov    %ebx,%eax
  807309:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80730c:	8d 54 0b 0c          	lea    0xc(%ebx,%ecx,1),%edx
  807310:	39 15 e0 96 a3 00    	cmp    %edx,0xa396e0
  807316:	73 1c                	jae    807334 <mem_malloc+0x174>
  807318:	c7 44 24 08 d8 35 81 	movl   $0x8135d8,0x8(%esp)
  80731f:	00 
  807320:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  807327:	00 
  807328:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  80732f:	e8 a0 96 ff ff       	call   8009d4 <_panic>
         (mem_ptr_t)mem + SIZEOF_STRUCT_MEM + size <= (mem_ptr_t)ram_end);
        LWIP_ASSERT("mem_malloc: allocated memory properly aligned.",
  807334:	f6 c3 03             	test   $0x3,%bl
  807337:	74 1c                	je     807355 <mem_malloc+0x195>
  807339:	c7 44 24 08 08 36 81 	movl   $0x813608,0x8(%esp)
  807340:	00 
  807341:	c7 44 24 04 4d 02 00 	movl   $0x24d,0x4(%esp)
  807348:	00 
  807349:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  807350:	e8 7f 96 ff ff       	call   8009d4 <_panic>
         (unsigned long)((u8_t *)mem + SIZEOF_STRUCT_MEM) % MEM_ALIGNMENT == 0);
        LWIP_ASSERT("mem_malloc: sanity check alignment",
  807355:	a8 03                	test   $0x3,%al
  807357:	74 1c                	je     807375 <mem_malloc+0x1b5>
  807359:	c7 44 24 08 38 36 81 	movl   $0x813638,0x8(%esp)
  807360:	00 
  807361:	c7 44 24 04 4f 02 00 	movl   $0x24f,0x4(%esp)
  807368:	00 
  807369:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  807370:	e8 5f 96 ff ff       	call   8009d4 <_panic>
          (((mem_ptr_t)mem) & (MEM_ALIGNMENT-1)) == 0);

        return (u8_t *)mem + SIZEOF_STRUCT_MEM;
  807375:	8d 43 0c             	lea    0xc(%ebx),%eax
  807378:	eb 23                	jmp    80739d <mem_malloc+0x1dd>

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
         ptr = ((struct mem *)&ram[ptr])->next) {
  80737a:	8b 03                	mov    (%ebx),%eax
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */

    /* Scan through the heap searching for a free block that is big enough,
     * beginning with the lowest free block.
     */
    for (ptr = (u8_t *)lfree - ram; ptr < MEM_SIZE_ALIGNED - size;
  80737c:	39 c1                	cmp    %eax,%ecx
  80737e:	0f 87 b2 fe ff ff    	ja     807236 <mem_malloc+0x76>
  } while(local_mem_free_count != 0);
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_DEBUGF(MEM_DEBUG | 2, ("mem_malloc: could not allocate %"S16_F" bytes\n", (s16_t)size));
  MEM_STATS_INC(err);
  LWIP_MEM_ALLOC_UNPROTECT();
  sys_sem_signal(mem_sem);
  807384:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  807389:	89 04 24             	mov    %eax,(%esp)
  80738c:	e8 96 68 00 00       	call   80dc27 <sys_sem_signal>
  807391:	b8 00 00 00 00       	mov    $0x0,%eax
  return NULL;
  807396:	eb 05                	jmp    80739d <mem_malloc+0x1dd>
  807398:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80739d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8073a0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8073a3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8073a6:	89 ec                	mov    %ebp,%esp
  8073a8:	5d                   	pop    %ebp
  8073a9:	c3                   	ret    

008073aa <mem_calloc>:
 * @param count number of objects to allocate
 * @param size size of the objects to allocate
 * @return pointer to allocated memory / NULL pointer if there is an error
 */
void *mem_calloc(mem_size_t count, mem_size_t size)
{
  8073aa:	55                   	push   %ebp
  8073ab:	89 e5                	mov    %esp,%ebp
  8073ad:	83 ec 18             	sub    $0x18,%esp
  8073b0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  8073b3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  void *p;

  /* allocate 'count' objects of size 'size' */
  p = mem_malloc(count * size);
  8073b6:	8b 75 0c             	mov    0xc(%ebp),%esi
  8073b9:	0f af 75 08          	imul   0x8(%ebp),%esi
  8073bd:	89 34 24             	mov    %esi,(%esp)
  8073c0:	e8 fb fd ff ff       	call   8071c0 <mem_malloc>
  8073c5:	89 c3                	mov    %eax,%ebx
  if (p) {
  8073c7:	85 c0                	test   %eax,%eax
  8073c9:	74 14                	je     8073df <mem_calloc+0x35>
    /* zero the memory */
    memset(p, 0, count * size);
  8073cb:	89 74 24 08          	mov    %esi,0x8(%esp)
  8073cf:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8073d6:	00 
  8073d7:	89 04 24             	mov    %eax,(%esp)
  8073da:	e8 d7 9e ff ff       	call   8012b6 <memset>
  }
  return p;
}
  8073df:	89 d8                	mov    %ebx,%eax
  8073e1:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8073e4:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8073e7:	89 ec                	mov    %ebp,%esp
  8073e9:	5d                   	pop    %ebp
  8073ea:	c3                   	ret    

008073eb <mem_realloc>:
 *         or NULL if newsize is > old size, in which case rmem is NOT touched
 *         or freed!
 */
void *
mem_realloc(void *rmem, mem_size_t newsize)
{
  8073eb:	55                   	push   %ebp
  8073ec:	89 e5                	mov    %esp,%ebp
  8073ee:	83 ec 38             	sub    $0x38,%esp
  8073f1:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  8073f4:	89 75 f8             	mov    %esi,-0x8(%ebp)
  8073f7:	89 7d fc             	mov    %edi,-0x4(%ebp)
  8073fa:	8b 75 08             	mov    0x8(%ebp),%esi
  /* use the FREE_PROTECT here: it protects with sem OR SYS_ARCH_PROTECT */
  LWIP_MEM_FREE_DECL_PROTECT();

  /* Expand the size of the allocated memory region so that we can
     adjust for alignment. */
  newsize = LWIP_MEM_ALIGN_SIZE(newsize);
  8073fd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  807400:	83 c3 03             	add    $0x3,%ebx
  807403:	83 e3 fc             	and    $0xfffffffc,%ebx

  if(newsize < MIN_SIZE_ALIGNED) {
  807406:	83 fb 0b             	cmp    $0xb,%ebx
  807409:	77 07                	ja     807412 <mem_realloc+0x27>
  80740b:	bb 0c 00 00 00       	mov    $0xc,%ebx
  807410:	eb 13                	jmp    807425 <mem_realloc+0x3a>
    /* every data block must be at least MIN_SIZE_ALIGNED long */
    newsize = MIN_SIZE_ALIGNED;
  }

  if (newsize > MEM_SIZE_ALIGNED) {
  807412:	81 fb 00 00 22 00    	cmp    $0x220000,%ebx
  807418:	76 0b                	jbe    807425 <mem_realloc+0x3a>
  80741a:	be 00 00 00 00       	mov    $0x0,%esi
  80741f:	90                   	nop
  807420:	e9 1a 01 00 00       	jmp    80753f <mem_realloc+0x154>
    return NULL;
  }

  LWIP_ASSERT("mem_realloc: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  807425:	a1 dc 96 a3 00       	mov    0xa396dc,%eax
  80742a:	39 c6                	cmp    %eax,%esi
  80742c:	72 08                	jb     807436 <mem_realloc+0x4b>
  80742e:	3b 35 e0 96 a3 00    	cmp    0xa396e0,%esi
  807434:	72 1c                	jb     807452 <mem_realloc+0x67>
  807436:	c7 44 24 08 62 35 81 	movl   $0x813562,0x8(%esp)
  80743d:	00 
  80743e:	c7 44 24 04 79 01 00 	movl   $0x179,0x4(%esp)
  807445:	00 
  807446:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  80744d:	e8 82 95 ff ff       	call   8009d4 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return rmem;
  }
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  807452:	8d 7e f4             	lea    -0xc(%esi),%edi
  /* ... and its offset pointer */
  ptr = (u8_t *)mem - ram;
  807455:	89 fa                	mov    %edi,%edx
  807457:	29 c2                	sub    %eax,%edx
  807459:	89 55 e0             	mov    %edx,-0x20(%ebp)

  size = mem->next - ptr - SIZEOF_STRUCT_MEM;
  80745c:	8b 07                	mov    (%edi),%eax
  80745e:	83 e8 0c             	sub    $0xc,%eax
  807461:	29 d0                	sub    %edx,%eax
  807463:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  LWIP_ASSERT("mem_realloc can only shrink memory", newsize <= size);
  807466:	39 d8                	cmp    %ebx,%eax
  807468:	73 1c                	jae    807486 <mem_realloc+0x9b>
  80746a:	c7 44 24 08 5c 36 81 	movl   $0x81365c,0x8(%esp)
  807471:	00 
  807472:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  807479:	00 
  80747a:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  807481:	e8 4e 95 ff ff       	call   8009d4 <_panic>
  if (newsize > size) {
    /* not supported */
    return NULL;
  }
  if (newsize == size) {
  807486:	3b 5d e4             	cmp    -0x1c(%ebp),%ebx
  807489:	0f 84 b0 00 00 00    	je     80753f <mem_realloc+0x154>
    /* No change in size, simply return */
    return rmem;
  }

  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  80748f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  807496:	00 
  807497:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  80749c:	89 04 24             	mov    %eax,(%esp)
  80749f:	e8 92 64 00 00       	call   80d936 <sys_arch_sem_wait>

  MEM_STATS_DEC_USED(used, (size - newsize));

  mem2 = (struct mem *)&ram[mem->next];
  8074a4:	a1 dc 96 a3 00       	mov    0xa396dc,%eax
  8074a9:	89 c2                	mov    %eax,%edx
  8074ab:	03 17                	add    (%edi),%edx
  if(mem2->used == 0) {
  8074ad:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8074b1:	75 41                	jne    8074f4 <mem_realloc+0x109>
    /* The next struct is unused, we can simply move it at little */
    mem_size_t next;
    /* remember the old next pointer */
    next = mem2->next;
  8074b3:	8b 0a                	mov    (%edx),%ecx
  8074b5:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
    /* create new struct mem which is moved directly after the shrinked mem */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8074b8:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8074bb:	8d 5c 0b 0c          	lea    0xc(%ebx,%ecx,1),%ebx
    if (lfree == mem2) {
  8074bf:	39 15 e4 96 a3 00    	cmp    %edx,0xa396e4
  8074c5:	75 09                	jne    8074d0 <mem_realloc+0xe5>
      lfree = (struct mem *)&ram[ptr2];
  8074c7:	8d 14 18             	lea    (%eax,%ebx,1),%edx
  8074ca:	89 15 e4 96 a3 00    	mov    %edx,0xa396e4
    }
    mem2 = (struct mem *)&ram[ptr2];
  8074d0:	8d 14 18             	lea    (%eax,%ebx,1),%edx
    mem2->used = 0;
  8074d3:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    /* restore the next pointer */
    mem2->next = next;
  8074d7:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  8074da:	89 0a                	mov    %ecx,(%edx)
    /* link it back to mem */
    mem2->prev = ptr;
  8074dc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  8074df:	89 4a 04             	mov    %ecx,0x4(%edx)
    /* link mem to it */
    mem->next = ptr2;
  8074e2:	89 1f                	mov    %ebx,(%edi)
    /* last thing to restore linked list: as we have moved mem2,
     * let 'mem2->next->prev' point to mem2 again. but only if mem2->next is not
     * the end of the heap */
    if (mem2->next != MEM_SIZE_ALIGNED) {
  8074e4:	8b 12                	mov    (%edx),%edx
  8074e6:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  8074ec:	74 44                	je     807532 <mem_realloc+0x147>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  8074ee:	89 5c 10 04          	mov    %ebx,0x4(%eax,%edx,1)
  8074f2:	eb 3e                	jmp    807532 <mem_realloc+0x147>
    }
    /* no need to plug holes, we've already done that */
  } else if (newsize + SIZEOF_STRUCT_MEM + MIN_SIZE_ALIGNED <= size) {
  8074f4:	8d 53 18             	lea    0x18(%ebx),%edx
  8074f7:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  8074fa:	72 36                	jb     807532 <mem_realloc+0x147>
     * Old size ('size') must be big enough to contain at least 'newsize' plus a struct mem
     * ('SIZEOF_STRUCT_MEM') with some data ('MIN_SIZE_ALIGNED').
     * @todo we could leave out MIN_SIZE_ALIGNED. We would create an empty
     *       region that couldn't hold data, but when mem->next gets freed,
     *       the 2 regions would be combined, resulting in more free memory */
    ptr2 = ptr + SIZEOF_STRUCT_MEM + newsize;
  8074fc:	8b 55 e0             	mov    -0x20(%ebp),%edx
  8074ff:	8d 4c 13 0c          	lea    0xc(%ebx,%edx,1),%ecx
    mem2 = (struct mem *)&ram[ptr2];
  807503:	8d 14 08             	lea    (%eax,%ecx,1),%edx
    if (mem2 < lfree) {
  807506:	3b 15 e4 96 a3 00    	cmp    0xa396e4,%edx
  80750c:	73 06                	jae    807514 <mem_realloc+0x129>
      lfree = mem2;
  80750e:	89 15 e4 96 a3 00    	mov    %edx,0xa396e4
    }
    mem2->used = 0;
  807514:	c6 42 08 00          	movb   $0x0,0x8(%edx)
    mem2->next = mem->next;
  807518:	8b 1f                	mov    (%edi),%ebx
  80751a:	89 1a                	mov    %ebx,(%edx)
    mem2->prev = ptr;
  80751c:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80751f:	89 5a 04             	mov    %ebx,0x4(%edx)
    mem->next = ptr2;
  807522:	89 0f                	mov    %ecx,(%edi)
    if (mem2->next != MEM_SIZE_ALIGNED) {
  807524:	8b 12                	mov    (%edx),%edx
  807526:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  80752c:	74 04                	je     807532 <mem_realloc+0x147>
      ((struct mem *)&ram[mem2->next])->prev = ptr2;
  80752e:	89 4c 10 04          	mov    %ecx,0x4(%eax,%edx,1)
    -> the remaining space stays unused since it is too small
  } */
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  807532:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  807537:	89 04 24             	mov    %eax,(%esp)
  80753a:	e8 e8 66 00 00       	call   80dc27 <sys_sem_signal>
  return rmem;
}
  80753f:	89 f0                	mov    %esi,%eax
  807541:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  807544:	8b 75 f8             	mov    -0x8(%ebp),%esi
  807547:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80754a:	89 ec                	mov    %ebp,%esp
  80754c:	5d                   	pop    %ebp
  80754d:	c3                   	ret    

0080754e <mem_free>:
 * @param rmem is the data portion of a struct mem as returned by a previous
 *             call to mem_malloc()
 */
void
mem_free(void *rmem)
{
  80754e:	55                   	push   %ebp
  80754f:	89 e5                	mov    %esp,%ebp
  807551:	83 ec 18             	sub    $0x18,%esp
  807554:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807557:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80755a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct mem *mem;
  LWIP_MEM_FREE_DECL_PROTECT();

  if (rmem == NULL) {
  80755d:	85 db                	test   %ebx,%ebx
  80755f:	0f 84 6f 01 00 00    	je     8076d4 <mem_free+0x186>
    LWIP_DEBUGF(MEM_DEBUG | LWIP_DBG_TRACE | 2, ("mem_free(p == NULL) was called.\n"));
    return;
  }
  LWIP_ASSERT("mem_free: sanity check alignment", (((mem_ptr_t)rmem) & (MEM_ALIGNMENT-1)) == 0);
  807565:	f6 c3 03             	test   $0x3,%bl
  807568:	74 1c                	je     807586 <mem_free+0x38>
  80756a:	c7 44 24 08 80 36 81 	movl   $0x813680,0x8(%esp)
  807571:	00 
  807572:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  807579:	00 
  80757a:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  807581:	e8 4e 94 ff ff       	call   8009d4 <_panic>

  LWIP_ASSERT("mem_free: legal memory", (u8_t *)rmem >= (u8_t *)ram &&
  807586:	3b 1d dc 96 a3 00    	cmp    0xa396dc,%ebx
  80758c:	72 08                	jb     807596 <mem_free+0x48>
  80758e:	3b 1d e0 96 a3 00    	cmp    0xa396e0,%ebx
  807594:	72 1c                	jb     8075b2 <mem_free+0x64>
  807596:	c7 44 24 08 7c 35 81 	movl   $0x81357c,0x8(%esp)
  80759d:	00 
  80759e:	c7 44 24 04 33 01 00 	movl   $0x133,0x4(%esp)
  8075a5:	00 
  8075a6:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  8075ad:	e8 22 94 ff ff       	call   8009d4 <_panic>
    MEM_STATS_INC(illegal);
    SYS_ARCH_UNPROTECT(lev);
    return;
  }
  /* protect the heap from concurrent access */
  LWIP_MEM_FREE_PROTECT();
  8075b2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  8075b9:	00 
  8075ba:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  8075bf:	89 04 24             	mov    %eax,(%esp)
  8075c2:	e8 6f 63 00 00       	call   80d936 <sys_arch_sem_wait>
  /* Get the corresponding struct mem ... */
  mem = (struct mem *)((u8_t *)rmem - SIZEOF_STRUCT_MEM);
  8075c7:	83 eb 0c             	sub    $0xc,%ebx
  /* ... which has to be in a used state ... */
  LWIP_ASSERT("mem_free: mem->used", mem->used);
  8075ca:	80 7b 08 00          	cmpb   $0x0,0x8(%ebx)
  8075ce:	75 1c                	jne    8075ec <mem_free+0x9e>
  8075d0:	c7 44 24 08 93 35 81 	movl   $0x813593,0x8(%esp)
  8075d7:	00 
  8075d8:	c7 44 24 04 43 01 00 	movl   $0x143,0x4(%esp)
  8075df:	00 
  8075e0:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  8075e7:	e8 e8 93 ff ff       	call   8009d4 <_panic>
  /* ... and is now unused. */
  mem->used = 0;
  8075ec:	c6 43 08 00          	movb   $0x0,0x8(%ebx)

  if (mem < lfree) {
  8075f0:	3b 1d e4 96 a3 00    	cmp    0xa396e4,%ebx
  8075f6:	73 06                	jae    8075fe <mem_free+0xb0>
    /* the newly freed struct is now the lowest */
    lfree = mem;
  8075f8:	89 1d e4 96 a3 00    	mov    %ebx,0xa396e4
plug_holes(struct mem *mem)
{
  struct mem *nmem;
  struct mem *pmem;

  LWIP_ASSERT("plug_holes: mem >= ram", (u8_t *)mem >= ram);
  8075fe:	a1 dc 96 a3 00       	mov    0xa396dc,%eax
  807603:	39 c3                	cmp    %eax,%ebx
  807605:	73 1c                	jae    807623 <mem_free+0xd5>
  807607:	c7 44 24 08 a7 35 81 	movl   $0x8135a7,0x8(%esp)
  80760e:	00 
  80760f:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  807616:	00 
  807617:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  80761e:	e8 b1 93 ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("plug_holes: mem < ram_end", (u8_t *)mem < (u8_t *)ram_end);
  807623:	8b 35 e0 96 a3 00    	mov    0xa396e0,%esi
  807629:	39 f3                	cmp    %esi,%ebx
  80762b:	72 1c                	jb     807649 <mem_free+0xfb>
  80762d:	c7 44 24 08 be 35 81 	movl   $0x8135be,0x8(%esp)
  807634:	00 
  807635:	c7 44 24 04 e4 00 00 	movl   $0xe4,0x4(%esp)
  80763c:	00 
  80763d:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  807644:	e8 8b 93 ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("plug_holes: mem->used == 0", mem->used == 0);

  /* plug hole forward */
  LWIP_ASSERT("plug_holes: mem->next <= MEM_SIZE_ALIGNED", mem->next <= MEM_SIZE_ALIGNED);
  807649:	8b 13                	mov    (%ebx),%edx
  80764b:	81 fa 00 00 22 00    	cmp    $0x220000,%edx
  807651:	76 1c                	jbe    80766f <mem_free+0x121>
  807653:	c7 44 24 08 a4 36 81 	movl   $0x8136a4,0x8(%esp)
  80765a:	00 
  80765b:	c7 44 24 04 e8 00 00 	movl   $0xe8,0x4(%esp)
  807662:	00 
  807663:	c7 04 24 4e 35 81 00 	movl   $0x81354e,(%esp)
  80766a:	e8 65 93 ff ff       	call   8009d4 <_panic>

  nmem = (struct mem *)&ram[mem->next];
  80766f:	89 c1                	mov    %eax,%ecx
  807671:	8d 14 10             	lea    (%eax,%edx,1),%edx
  if (mem != nmem && nmem->used == 0 && (u8_t *)nmem != (u8_t *)ram_end) {
  807674:	39 d3                	cmp    %edx,%ebx
  807676:	74 26                	je     80769e <mem_free+0x150>
  807678:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  80767c:	75 20                	jne    80769e <mem_free+0x150>
  80767e:	39 d6                	cmp    %edx,%esi
  807680:	74 1c                	je     80769e <mem_free+0x150>
    /* if mem->next is unused and not end of ram, combine mem and mem->next */
    if (lfree == nmem) {
  807682:	3b 15 e4 96 a3 00    	cmp    0xa396e4,%edx
  807688:	75 06                	jne    807690 <mem_free+0x142>
      lfree = mem;
  80768a:	89 1d e4 96 a3 00    	mov    %ebx,0xa396e4
    }
    mem->next = nmem->next;
  807690:	8b 32                	mov    (%edx),%esi
  807692:	89 33                	mov    %esi,(%ebx)
    ((struct mem *)&ram[nmem->next])->prev = (u8_t *)mem - ram;
  807694:	8b 12                	mov    (%edx),%edx
  807696:	89 de                	mov    %ebx,%esi
  807698:	29 c6                	sub    %eax,%esi
  80769a:	89 74 11 04          	mov    %esi,0x4(%ecx,%edx,1)
  }

  /* plug hole backward */
  pmem = (struct mem *)&ram[mem->prev];
  80769e:	89 ca                	mov    %ecx,%edx
  8076a0:	03 53 04             	add    0x4(%ebx),%edx
  if (pmem != mem && pmem->used == 0) {
  8076a3:	39 d3                	cmp    %edx,%ebx
  8076a5:	74 20                	je     8076c7 <mem_free+0x179>
  8076a7:	80 7a 08 00          	cmpb   $0x0,0x8(%edx)
  8076ab:	75 1a                	jne    8076c7 <mem_free+0x179>
    /* if mem->prev is unused, combine mem and mem->prev */
    if (lfree == mem) {
  8076ad:	3b 1d e4 96 a3 00    	cmp    0xa396e4,%ebx
  8076b3:	75 06                	jne    8076bb <mem_free+0x16d>
      lfree = pmem;
  8076b5:	89 15 e4 96 a3 00    	mov    %edx,0xa396e4
    }
    pmem->next = mem->next;
  8076bb:	8b 33                	mov    (%ebx),%esi
  8076bd:	89 32                	mov    %esi,(%edx)
    ((struct mem *)&ram[mem->next])->prev = (u8_t *)pmem - ram;
  8076bf:	8b 1b                	mov    (%ebx),%ebx
  8076c1:	29 c2                	sub    %eax,%edx
  8076c3:	89 54 19 04          	mov    %edx,0x4(%ecx,%ebx,1)
  /* finally, see if prev or next are free also */
  plug_holes(mem);
#if LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT
  mem_free_count = 1;
#endif /* LWIP_ALLOW_MEM_FREE_FROM_OTHER_CONTEXT */
  LWIP_MEM_FREE_UNPROTECT();
  8076c7:	a1 e8 96 a3 00       	mov    0xa396e8,%eax
  8076cc:	89 04 24             	mov    %eax,(%esp)
  8076cf:	e8 53 65 00 00       	call   80dc27 <sys_sem_signal>
}
  8076d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  8076d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  8076da:	89 ec                	mov    %ebp,%esp
  8076dc:	5d                   	pop    %ebp
  8076dd:	c3                   	ret    

008076de <mem_init>:
/**
 * Zero the heap and initialize start, end and lowest-free
 */
void
mem_init(void)
{
  8076de:	55                   	push   %ebp
  8076df:	89 e5                	mov    %esp,%ebp
  8076e1:	83 ec 18             	sub    $0x18,%esp

  LWIP_ASSERT("Sanity check alignment",
    (SIZEOF_STRUCT_MEM & (MEM_ALIGNMENT-1)) == 0);

  /* align the heap */
  ram = LWIP_MEM_ALIGN(ram_heap);
  8076e4:	b8 c3 96 81 00       	mov    $0x8196c3,%eax
  8076e9:	83 e0 fc             	and    $0xfffffffc,%eax
  8076ec:	a3 dc 96 a3 00       	mov    %eax,0xa396dc
  /* initialize the start of the heap */
  mem = (struct mem *)ram;
  mem->next = MEM_SIZE_ALIGNED;
  8076f1:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  mem->prev = 0;
  8076f7:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
  mem->used = 0;
  8076fe:	c6 40 08 00          	movb   $0x0,0x8(%eax)
  /* initialize the end of the heap */
  ram_end = (struct mem *)&ram[MEM_SIZE_ALIGNED];
  807702:	05 00 00 22 00       	add    $0x220000,%eax
  807707:	a3 e0 96 a3 00       	mov    %eax,0xa396e0
  ram_end->used = 1;
  80770c:	c6 40 08 01          	movb   $0x1,0x8(%eax)
  ram_end->next = MEM_SIZE_ALIGNED;
  807710:	c7 00 00 00 22 00    	movl   $0x220000,(%eax)
  ram_end->prev = MEM_SIZE_ALIGNED;
  807716:	c7 40 04 00 00 22 00 	movl   $0x220000,0x4(%eax)

  mem_sem = sys_sem_new(1);
  80771d:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  807724:	e8 5c 63 00 00       	call   80da85 <sys_sem_new>
  807729:	a3 e8 96 a3 00       	mov    %eax,0xa396e8

  /* initialize the lowest-free pointer to the start of the heap */
  lfree = (struct mem *)ram;
  80772e:	a1 dc 96 a3 00       	mov    0xa396dc,%eax
  807733:	a3 e4 96 a3 00       	mov    %eax,0xa396e4

  MEM_STATS_AVAIL(avail, MEM_SIZE_ALIGNED);
}
  807738:	c9                   	leave  
  807739:	c3                   	ret    
	...

0080773c <memp_init>:
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
{
  80773c:	55                   	push   %ebp
  80773d:	89 e5                	mov    %esp,%ebp
  80773f:	57                   	push   %edi
  807740:	56                   	push   %esi
  807741:	53                   	push   %ebx
  807742:	83 ec 04             	sub    $0x4,%esp
    MEMP_STATS_AVAIL(max, i, 0);
    MEMP_STATS_AVAIL(err, i, 0);
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  807745:	b8 43 97 a3 00       	mov    $0xa39743,%eax
  80774a:	83 e0 fc             	and    $0xfffffffc,%eax
  80774d:	89 45 f0             	mov    %eax,-0x10(%ebp)
  807750:	bf 00 00 00 00       	mov    $0x0,%edi
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
  807755:	c7 84 3f 00 97 a3 00 	movl   $0x0,0xa39700(%edi,%edi,1)
  80775c:	00 00 00 00 
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  807760:	0f b7 9f 62 37 81 00 	movzwl 0x813762(%edi),%ebx
  807767:	8b 45 f0             	mov    -0x10(%ebp),%eax
  80776a:	66 85 db             	test   %bx,%bx
  80776d:	74 3c                	je     8077ab <memp_init+0x6f>
      memp->next = memp_tab[i];
      memp_tab[i] = memp;
      memp = (struct memp *)((u8_t *)memp + MEMP_SIZE + memp_sizes[i]);
  80776f:	0f b7 b7 46 37 81 00 	movzwl 0x813746(%edi),%esi
  807776:	b9 00 00 00 00       	mov    $0x0,%ecx
  80777b:	ba 00 00 00 00       	mov    $0x0,%edx
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
      memp->next = memp_tab[i];
  807780:	89 08                	mov    %ecx,(%eax)
  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
    memp_tab[i] = NULL;
    /* create a linked list of memp elements */
    for (j = 0; j < memp_num[i]; ++j) {
  807782:	83 c2 01             	add    $0x1,%edx
  807785:	89 c1                	mov    %eax,%ecx
  807787:	8d 04 30             	lea    (%eax,%esi,1),%eax
  80778a:	66 39 da             	cmp    %bx,%dx
  80778d:	72 f1                	jb     807780 <memp_init+0x44>
 * Initialize this module.
 * 
 * Carves out memp_memory into linked lists for each pool-type.
 */
void
memp_init(void)
  80778f:	83 eb 01             	sub    $0x1,%ebx
  807792:	0f b7 db             	movzwl %bx,%ebx
  807795:	8d 43 01             	lea    0x1(%ebx),%eax
  807798:	0f af c6             	imul   %esi,%eax
  80779b:	03 45 f0             	add    -0x10(%ebp),%eax
  80779e:	0f af de             	imul   %esi,%ebx
  8077a1:	03 5d f0             	add    -0x10(%ebp),%ebx
  8077a4:	89 9c 3f 00 97 a3 00 	mov    %ebx,0xa39700(%edi,%edi,1)
  8077ab:	83 c7 02             	add    $0x2,%edi
    MEMP_STATS_AVAIL(avail, i, memp_num[i]);
  }

  memp = LWIP_MEM_ALIGN(memp_memory);
  /* for every pool: */
  for (i = 0; i < MEMP_MAX; ++i) {
  8077ae:	83 ff 1c             	cmp    $0x1c,%edi
  8077b1:	74 05                	je     8077b8 <memp_init+0x7c>
  8077b3:	89 45 f0             	mov    %eax,-0x10(%ebp)
  8077b6:	eb 9d                	jmp    807755 <memp_init+0x19>
#if MEMP_OVERFLOW_CHECK
  memp_overflow_init();
  /* check everything a first time to see if it worked */
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK */
}
  8077b8:	83 c4 04             	add    $0x4,%esp
  8077bb:	5b                   	pop    %ebx
  8077bc:	5e                   	pop    %esi
  8077bd:	5f                   	pop    %edi
  8077be:	5d                   	pop    %ebp
  8077bf:	c3                   	ret    

008077c0 <memp_free>:
 * @param type the pool where to put mem
 * @param mem the memp element to free
 */
void
memp_free(memp_t type, void *mem)
{
  8077c0:	55                   	push   %ebp
  8077c1:	89 e5                	mov    %esp,%ebp
  8077c3:	53                   	push   %ebx
  8077c4:	83 ec 14             	sub    $0x14,%esp
  8077c7:	8b 55 08             	mov    0x8(%ebp),%edx
  8077ca:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);

  if (mem == NULL) {
  8077cd:	85 c0                	test   %eax,%eax
  8077cf:	74 2d                	je     8077fe <memp_free+0x3e>
    return;
  }
  LWIP_ASSERT("memp_free: mem properly aligned",
  8077d1:	a8 03                	test   $0x3,%al
  8077d3:	74 1c                	je     8077f1 <memp_free+0x31>
  8077d5:	c7 44 24 08 d0 36 81 	movl   $0x8136d0,0x8(%esp)
  8077dc:	00 
  8077dd:	c7 44 24 04 5b 01 00 	movl   $0x15b,0x4(%esp)
  8077e4:	00 
  8077e5:	c7 04 24 13 37 81 00 	movl   $0x813713,(%esp)
  8077ec:	e8 e3 91 ff ff       	call   8009d4 <_panic>
#endif /* MEMP_OVERFLOW_CHECK >= 2 */
#endif /* MEMP_OVERFLOW_CHECK */

  MEMP_STATS_DEC(used, type); 
  
  memp->next = memp_tab[type]; 
  8077f1:	b9 00 97 a3 00       	mov    $0xa39700,%ecx
  8077f6:	8b 1c 91             	mov    (%ecx,%edx,4),%ebx
  8077f9:	89 18                	mov    %ebx,(%eax)
  memp_tab[type] = memp;
  8077fb:	89 04 91             	mov    %eax,(%ecx,%edx,4)
#if MEMP_SANITY_CHECK
  LWIP_ASSERT("memp sanity", memp_sanity());
#endif /* MEMP_SANITY_CHECK */

  SYS_ARCH_UNPROTECT(old_level);
}
  8077fe:	83 c4 14             	add    $0x14,%esp
  807801:	5b                   	pop    %ebx
  807802:	5d                   	pop    %ebp
  807803:	c3                   	ret    

00807804 <memp_malloc>:
#if !MEMP_OVERFLOW_CHECK
memp_malloc(memp_t type)
#else
memp_malloc_fn(memp_t type, const char* file, const int line)
#endif
{
  807804:	55                   	push   %ebp
  807805:	89 e5                	mov    %esp,%ebp
  807807:	83 ec 18             	sub    $0x18,%esp
  80780a:	8b 55 08             	mov    0x8(%ebp),%edx
  struct memp *memp;
  SYS_ARCH_DECL_PROTECT(old_level);
 
  LWIP_ERROR("memp_malloc: type < MEMP_MAX", (type < MEMP_MAX), return NULL;);
  80780d:	83 fa 0d             	cmp    $0xd,%edx
  807810:	76 1c                	jbe    80782e <memp_malloc+0x2a>
  807812:	c7 44 24 08 28 37 81 	movl   $0x813728,0x8(%esp)
  807819:	00 
  80781a:	c7 44 24 04 2d 01 00 	movl   $0x12d,0x4(%esp)
  807821:	00 
  807822:	c7 04 24 13 37 81 00 	movl   $0x813713,(%esp)
  807829:	e8 a6 91 ff ff       	call   8009d4 <_panic>
  SYS_ARCH_PROTECT(old_level);
#if MEMP_OVERFLOW_CHECK >= 2
  memp_overflow_check_all();
#endif /* MEMP_OVERFLOW_CHECK >= 2 */

  memp = memp_tab[type];
  80782e:	8b 04 95 00 97 a3 00 	mov    0xa39700(,%edx,4),%eax
  
  if (memp != NULL) {    
  807835:	85 c0                	test   %eax,%eax
  807837:	74 29                	je     807862 <memp_malloc+0x5e>
    memp_tab[type] = memp->next;    
  807839:	8b 08                	mov    (%eax),%ecx
  80783b:	89 0c 95 00 97 a3 00 	mov    %ecx,0xa39700(,%edx,4)
    memp->next = NULL;
    memp->file = file;
    memp->line = line;
#endif /* MEMP_OVERFLOW_CHECK */
    MEMP_STATS_INC_USED(used, type);
    LWIP_ASSERT("memp_malloc: memp properly aligned",
  807842:	a8 03                	test   $0x3,%al
  807844:	74 1c                	je     807862 <memp_malloc+0x5e>
  807846:	c7 44 24 08 f0 36 81 	movl   $0x8136f0,0x8(%esp)
  80784d:	00 
  80784e:	c7 44 24 04 3f 01 00 	movl   $0x13f,0x4(%esp)
  807855:	00 
  807856:	c7 04 24 13 37 81 00 	movl   $0x813713,(%esp)
  80785d:	e8 72 91 ff ff       	call   8009d4 <_panic>
  }

  SYS_ARCH_UNPROTECT(old_level);

  return memp;
}
  807862:	c9                   	leave  
  807863:	c3                   	ret    
	...

00807870 <netif_find>:
 * @param name the name of the netif (like netif->name) plus concatenated number
 * in ascii representation (e.g. 'en0')
 */
struct netif *
netif_find(char *name)
{
  807870:	55                   	push   %ebp
  807871:	89 e5                	mov    %esp,%ebp
  807873:	53                   	push   %ebx
  807874:	8b 55 08             	mov    0x8(%ebp),%edx
  struct netif *netif;
  u8_t num;

  if (name == NULL) {
  807877:	b8 00 00 00 00       	mov    $0x0,%eax
  80787c:	85 d2                	test   %edx,%edx
  80787e:	74 2c                	je     8078ac <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';
  807880:	0f b6 5a 02          	movzbl 0x2(%edx),%ebx
  807884:	83 eb 30             	sub    $0x30,%ebx

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  807887:	a1 00 f6 b3 00       	mov    0xb3f600,%eax
  80788c:	85 c0                	test   %eax,%eax
  80788e:	74 1c                	je     8078ac <netif_find+0x3c>
    if (num == netif->num &&
  807890:	38 58 31             	cmp    %bl,0x31(%eax)
  807893:	75 11                	jne    8078a6 <netif_find+0x36>
       name[0] == netif->name[0] &&
  807895:	0f b6 0a             	movzbl (%edx),%ecx
  807898:	3a 48 2f             	cmp    0x2f(%eax),%cl
  80789b:	75 09                	jne    8078a6 <netif_find+0x36>
       name[1] == netif->name[1]) {
  80789d:	0f b6 4a 01          	movzbl 0x1(%edx),%ecx
  8078a1:	3a 48 30             	cmp    0x30(%eax),%cl
  8078a4:	74 06                	je     8078ac <netif_find+0x3c>
    return NULL;
  }

  num = name[2] - '0';

  for(netif = netif_list; netif != NULL; netif = netif->next) {
  8078a6:	8b 00                	mov    (%eax),%eax
  8078a8:	85 c0                	test   %eax,%eax
  8078aa:	75 e4                	jne    807890 <netif_find+0x20>
      return netif;
    }
  }
  LWIP_DEBUGF(NETIF_DEBUG, ("netif_find: didn't find %c%c\n", name[0], name[1]));
  return NULL;
}
  8078ac:	5b                   	pop    %ebx
  8078ad:	5d                   	pop    %ebp
  8078ae:	c3                   	ret    

008078af <netif_set_gw>:
 *
 * @note call netif_set_addr() if you also want to change ip address and netmask
 */
void
netif_set_gw(struct netif *netif, struct ip_addr *gw)
{
  8078af:	55                   	push   %ebp
  8078b0:	89 e5                	mov    %esp,%ebp
  8078b2:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&(netif->gw), gw);
  8078b5:	b8 00 00 00 00       	mov    $0x0,%eax
  8078ba:	85 d2                	test   %edx,%edx
  8078bc:	74 02                	je     8078c0 <netif_set_gw+0x11>
  8078be:	8b 02                	mov    (%edx),%eax
  8078c0:	8b 55 08             	mov    0x8(%ebp),%edx
  8078c3:	89 42 0c             	mov    %eax,0xc(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->gw),
    ip4_addr2(&netif->gw),
    ip4_addr3(&netif->gw),
    ip4_addr4(&netif->gw)));
}
  8078c6:	5d                   	pop    %ebp
  8078c7:	c3                   	ret    

008078c8 <netif_set_netmask>:
 * @note call netif_set_addr() if you also want to change ip address and
 * default gateway
 */
void
netif_set_netmask(struct netif *netif, struct ip_addr *netmask)
{
  8078c8:	55                   	push   %ebp
  8078c9:	89 e5                	mov    %esp,%ebp
  8078cb:	8b 55 0c             	mov    0xc(%ebp),%edx
  snmp_delete_iprteidx_tree(0, netif);
  /* set new netmask to netif */
  ip_addr_set(&(netif->netmask), netmask);
  8078ce:	b8 00 00 00 00       	mov    $0x0,%eax
  8078d3:	85 d2                	test   %edx,%edx
  8078d5:	74 02                	je     8078d9 <netif_set_netmask+0x11>
  8078d7:	8b 02                	mov    (%edx),%eax
  8078d9:	8b 55 08             	mov    0x8(%ebp),%edx
  8078dc:	89 42 08             	mov    %eax,0x8(%edx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->netmask),
    ip4_addr2(&netif->netmask),
    ip4_addr3(&netif->netmask),
    ip4_addr4(&netif->netmask)));
}
  8078df:	5d                   	pop    %ebp
  8078e0:	c3                   	ret    

008078e1 <netif_set_default>:
 *
 * @param netif the default network interface
 */
void
netif_set_default(struct netif *netif)
{
  8078e1:	55                   	push   %ebp
  8078e2:	89 e5                	mov    %esp,%ebp
  else
  {
    /* install default route */
    snmp_insert_iprteidx_tree(1, netif);
  }
  netif_default = netif;
  8078e4:	8b 45 08             	mov    0x8(%ebp),%eax
  8078e7:	a3 04 f6 b3 00       	mov    %eax,0xb3f604
  LWIP_DEBUGF(NETIF_DEBUG, ("netif: setting default interface %c%c\n",
           netif ? netif->name[0] : '\'', netif ? netif->name[1] : '\''));
}
  8078ec:	5d                   	pop    %ebp
  8078ed:	c3                   	ret    

008078ee <netif_remove>:
 * Remove a network interface from the list of lwIP netifs.
 *
 * @param netif the network interface to remove
 */
void netif_remove(struct netif * netif)
{
  8078ee:	55                   	push   %ebp
  8078ef:	89 e5                	mov    %esp,%ebp
  8078f1:	83 ec 04             	sub    $0x4,%esp
  8078f4:	8b 4d 08             	mov    0x8(%ebp),%ecx
  if ( netif == NULL ) return;
  8078f7:	85 c9                	test   %ecx,%ecx
  8078f9:	74 4b                	je     807946 <netif_remove+0x58>
#endif /* LWIP_IGMP */

  snmp_delete_ipaddridx_tree(netif);

  /*  is it the first netif? */
  if (netif_list == netif) {
  8078fb:	a1 00 f6 b3 00       	mov    0xb3f600,%eax
  807900:	39 c8                	cmp    %ecx,%eax
  807902:	75 1e                	jne    807922 <netif_remove+0x34>
    netif_list = netif->next;
  807904:	8b 00                	mov    (%eax),%eax
  807906:	a3 00 f6 b3 00       	mov    %eax,0xb3f600
  80790b:	eb 25                	jmp    807932 <netif_remove+0x44>
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
      if (tmpNetif->next == netif) {
  80790d:	8b 10                	mov    (%eax),%edx
  80790f:	39 ca                	cmp    %ecx,%edx
  807911:	74 08                	je     80791b <netif_remove+0x2d>
  807913:	89 d0                	mov    %edx,%eax
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807915:	85 c0                	test   %eax,%eax
  807917:	75 f4                	jne    80790d <netif_remove+0x1f>
  807919:	eb 2b                	jmp    807946 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
        tmpNetif->next = netif->next;
  80791b:	8b 11                	mov    (%ecx),%edx
  80791d:	89 10                	mov    %edx,(%eax)
  80791f:	90                   	nop
  807920:	eb 10                	jmp    807932 <netif_remove+0x44>
    snmp_dec_iflist();
  }
  else {
    /*  look for netif further down the list */
    struct netif * tmpNetif;
    for (tmpNetif = netif_list; tmpNetif != NULL; tmpNetif = tmpNetif->next) {
  807922:	85 c0                	test   %eax,%eax
  807924:	74 20                	je     807946 <netif_remove+0x58>
      if (tmpNetif->next == netif) {
  807926:	8b 10                	mov    (%eax),%edx
  807928:	39 ca                	cmp    %ecx,%edx
  80792a:	74 ef                	je     80791b <netif_remove+0x2d>
  80792c:	89 d0                	mov    %edx,%eax
  80792e:	66 90                	xchg   %ax,%ax
  807930:	eb e3                	jmp    807915 <netif_remove+0x27>
    }
    if (tmpNetif == NULL)
      return; /*  we didn't find any netif today */
  }
  /* this netif is default? */
  if (netif_default == netif)
  807932:	39 0d 04 f6 b3 00    	cmp    %ecx,0xb3f604
  807938:	75 0c                	jne    807946 <netif_remove+0x58>
    /* reset default netif */
    netif_set_default(NULL);
  80793a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  807941:	e8 9b ff ff ff       	call   8078e1 <netif_set_default>
  LWIP_DEBUGF( NETIF_DEBUG, ("netif_remove: removed netif\n") );
}
  807946:	c9                   	leave  
  807947:	c3                   	ret    

00807948 <netif_set_down>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_down(struct netif *netif)
{
  807948:	55                   	push   %ebp
  807949:	89 e5                	mov    %esp,%ebp
  80794b:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( netif->flags & NETIF_FLAG_UP )
  80794e:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  807952:	f6 c2 01             	test   $0x1,%dl
  807955:	74 06                	je     80795d <netif_set_down+0x15>
    {
      netif->flags &= ~NETIF_FLAG_UP;
  807957:	83 e2 fe             	and    $0xfffffffe,%edx
  80795a:	88 50 2e             	mov    %dl,0x2e(%eax)
#endif
      
      NETIF_LINK_CALLBACK(netif);
      NETIF_STATUS_CALLBACK(netif);
    }
}
  80795d:	5d                   	pop    %ebp
  80795e:	c3                   	ret    

0080795f <netif_is_up>:

/**
 * Ask if an interface is up
 */ 
u8_t netif_is_up(struct netif *netif)
{
  80795f:	55                   	push   %ebp
  807960:	89 e5                	mov    %esp,%ebp
  807962:	8b 45 08             	mov    0x8(%ebp),%eax
  807965:	0f b6 40 2e          	movzbl 0x2e(%eax),%eax
  807969:	83 e0 01             	and    $0x1,%eax
  return (netif->flags & NETIF_FLAG_UP)?1:0;
}
  80796c:	5d                   	pop    %ebp
  80796d:	c3                   	ret    

0080796e <netif_set_up>:
 * up once configured.
 * 
 * @see dhcp_start()
 */ 
void netif_set_up(struct netif *netif)
{
  80796e:	55                   	push   %ebp
  80796f:	89 e5                	mov    %esp,%ebp
  807971:	83 ec 18             	sub    $0x18,%esp
  807974:	8b 45 08             	mov    0x8(%ebp),%eax
  if ( !(netif->flags & NETIF_FLAG_UP )) {
  807977:	0f b6 50 2e          	movzbl 0x2e(%eax),%edx
  80797b:	f6 c2 01             	test   $0x1,%dl
  80797e:	75 22                	jne    8079a2 <netif_set_up+0x34>
    netif->flags |= NETIF_FLAG_UP;
  807980:	83 ca 01             	or     $0x1,%edx
  807983:	88 50 2e             	mov    %dl,0x2e(%eax)
    /** For Ethernet network interfaces, we would like to send a
     *  "gratuitous ARP"; this is an ARP packet sent by a node in order
     *  to spontaneously cause other nodes to update an entry in their
     *  ARP cache. From RFC 3220 "IP Mobility Support for IPv4" section 4.6.
     */ 
    if (netif->flags & NETIF_FLAG_ETHARP) {
  807986:	f6 c2 20             	test   $0x20,%dl
  807989:	74 17                	je     8079a2 <netif_set_up+0x34>
      etharp_query(netif, &(netif->ip_addr), NULL);
  80798b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  807992:	00 
  807993:	8d 50 04             	lea    0x4(%eax),%edx
  807996:	89 54 24 04          	mov    %edx,0x4(%esp)
  80799a:	89 04 24             	mov    %eax,(%esp)
  80799d:	e8 75 53 00 00       	call   80cd17 <etharp_query>
    }
#endif /* LWIP_ARP */
    
  }
}
  8079a2:	c9                   	leave  
  8079a3:	c3                   	ret    

008079a4 <netif_set_ipaddr>:
 * @note call netif_set_addr() if you also want to change netmask and
 * default gateway
 */
void
netif_set_ipaddr(struct netif *netif, struct ip_addr *ipaddr)
{
  8079a4:	55                   	push   %ebp
  8079a5:	89 e5                	mov    %esp,%ebp
  8079a7:	57                   	push   %edi
  8079a8:	56                   	push   %esi
  8079a9:	53                   	push   %ebx
  8079aa:	83 ec 1c             	sub    $0x1c,%esp
  8079ad:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8079b0:	8b 75 0c             	mov    0xc(%ebp),%esi
#if LWIP_TCP
  struct tcp_pcb *pcb;
  struct tcp_pcb_listen *lpcb;

  /* address is actually being changed? */
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  8079b3:	8b 06                	mov    (%esi),%eax
  8079b5:	3b 43 04             	cmp    0x4(%ebx),%eax
  8079b8:	74 54                	je     807a0e <netif_set_ipaddr+0x6a>
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
  8079ba:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
    while (pcb != NULL) {
  8079bf:	85 c0                	test   %eax,%eax
  8079c1:	74 1d                	je     8079e0 <netif_set_ipaddr+0x3c>
      /* PCB bound to current local interface address? */
      if (ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  8079c3:	8b 10                	mov    (%eax),%edx
  8079c5:	3b 53 04             	cmp    0x4(%ebx),%edx
  8079c8:	75 0f                	jne    8079d9 <netif_set_ipaddr+0x35>
        /* this connection must be aborted */
        struct tcp_pcb *next = pcb->next;
  8079ca:	8b 78 0c             	mov    0xc(%eax),%edi
        LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: aborting TCP pcb %p\n", (void *)pcb));
        tcp_abort(pcb);
  8079cd:	89 04 24             	mov    %eax,(%esp)
  8079d0:	e8 a9 16 00 00       	call   80907e <tcp_abort>
  8079d5:	89 f8                	mov    %edi,%eax
  8079d7:	eb 03                	jmp    8079dc <netif_set_ipaddr+0x38>
        pcb = next;
      } else {
        pcb = pcb->next;
  8079d9:	8b 40 0c             	mov    0xc(%eax),%eax
  if ((ip_addr_cmp(ipaddr, &(netif->ip_addr))) == 0)
  {
    /* extern struct tcp_pcb *tcp_active_pcbs; defined by tcp.h */
    LWIP_DEBUGF(NETIF_DEBUG | 1, ("netif_set_ipaddr: netif address being changed\n"));
    pcb = tcp_active_pcbs;
    while (pcb != NULL) {
  8079dc:	85 c0                	test   %eax,%eax
  8079de:	75 e3                	jne    8079c3 <netif_set_ipaddr+0x1f>
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8079e0:	a1 10 f6 b3 00       	mov    0xb3f610,%eax
  8079e5:	85 c0                	test   %eax,%eax
  8079e7:	74 25                	je     807a0e <netif_set_ipaddr+0x6a>
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8079e9:	b9 00 00 00 00       	mov    $0x0,%ecx
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      /* PCB bound to current local interface address? */
      if ((!(ip_addr_isany(&(lpcb->local_ip)))) &&
  8079ee:	85 c0                	test   %eax,%eax
  8079f0:	74 15                	je     807a07 <netif_set_ipaddr+0x63>
  8079f2:	8b 10                	mov    (%eax),%edx
  8079f4:	85 d2                	test   %edx,%edx
  8079f6:	74 0f                	je     807a07 <netif_set_ipaddr+0x63>
          (ip_addr_cmp(&(lpcb->local_ip), &(netif->ip_addr)))) {
  8079f8:	3b 53 04             	cmp    0x4(%ebx),%edx
  8079fb:	75 0a                	jne    807a07 <netif_set_ipaddr+0x63>
        /* The PCB is listening to the old ipaddr and
         * is set to listen to the new one instead */
        ip_addr_set(&(lpcb->local_ip), ipaddr);
  8079fd:	89 ca                	mov    %ecx,%edx
  8079ff:	85 f6                	test   %esi,%esi
  807a01:	74 02                	je     807a05 <netif_set_ipaddr+0x61>
  807a03:	8b 16                	mov    (%esi),%edx
  807a05:	89 10                	mov    %edx,(%eax)
        pcb = next;
      } else {
        pcb = pcb->next;
      }
    }
    for (lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  807a07:	8b 40 0c             	mov    0xc(%eax),%eax
  807a0a:	85 c0                	test   %eax,%eax
  807a0c:	75 e0                	jne    8079ee <netif_set_ipaddr+0x4a>
  }
#endif
  snmp_delete_ipaddridx_tree(netif);
  snmp_delete_iprteidx_tree(0,netif);
  /* set new IP address to netif */
  ip_addr_set(&(netif->ip_addr), ipaddr);
  807a0e:	b8 00 00 00 00       	mov    $0x0,%eax
  807a13:	85 f6                	test   %esi,%esi
  807a15:	74 02                	je     807a19 <netif_set_ipaddr+0x75>
  807a17:	8b 06                	mov    (%esi),%eax
  807a19:	89 43 04             	mov    %eax,0x4(%ebx)
    netif->name[0], netif->name[1],
    ip4_addr1(&netif->ip_addr),
    ip4_addr2(&netif->ip_addr),
    ip4_addr3(&netif->ip_addr),
    ip4_addr4(&netif->ip_addr)));
}
  807a1c:	83 c4 1c             	add    $0x1c,%esp
  807a1f:	5b                   	pop    %ebx
  807a20:	5e                   	pop    %esi
  807a21:	5f                   	pop    %edi
  807a22:	5d                   	pop    %ebp
  807a23:	c3                   	ret    

00807a24 <netif_set_addr>:
 * @param gw the new default gateway
 */
void
netif_set_addr(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
    struct ip_addr *gw)
{
  807a24:	55                   	push   %ebp
  807a25:	89 e5                	mov    %esp,%ebp
  807a27:	53                   	push   %ebx
  807a28:	83 ec 14             	sub    $0x14,%esp
  807a2b:	8b 5d 08             	mov    0x8(%ebp),%ebx
  netif_set_ipaddr(netif, ipaddr);
  807a2e:	8b 45 0c             	mov    0xc(%ebp),%eax
  807a31:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a35:	89 1c 24             	mov    %ebx,(%esp)
  807a38:	e8 67 ff ff ff       	call   8079a4 <netif_set_ipaddr>
  netif_set_netmask(netif, netmask);
  807a3d:	8b 45 10             	mov    0x10(%ebp),%eax
  807a40:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a44:	89 1c 24             	mov    %ebx,(%esp)
  807a47:	e8 7c fe ff ff       	call   8078c8 <netif_set_netmask>
  netif_set_gw(netif, gw);
  807a4c:	8b 45 14             	mov    0x14(%ebp),%eax
  807a4f:	89 44 24 04          	mov    %eax,0x4(%esp)
  807a53:	89 1c 24             	mov    %ebx,(%esp)
  807a56:	e8 54 fe ff ff       	call   8078af <netif_set_gw>
}
  807a5b:	83 c4 14             	add    $0x14,%esp
  807a5e:	5b                   	pop    %ebx
  807a5f:	5d                   	pop    %ebp
  807a60:	c3                   	ret    

00807a61 <netif_add>:
netif_add(struct netif *netif, struct ip_addr *ipaddr, struct ip_addr *netmask,
  struct ip_addr *gw,
  void *state,
  err_t (* init)(struct netif *netif),
  err_t (* input)(struct pbuf *p, struct netif *netif))
{
  807a61:	55                   	push   %ebp
  807a62:	89 e5                	mov    %esp,%ebp
  807a64:	53                   	push   %ebx
  807a65:	83 ec 14             	sub    $0x14,%esp
  807a68:	8b 5d 08             	mov    0x8(%ebp),%ebx
  static u8_t netifnum = 0;

  /* reset new interface configuration state */
  netif->ip_addr.addr = 0;
  807a6b:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  netif->netmask.addr = 0;
  807a72:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netif->gw.addr = 0;
  807a79:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  netif->flags = 0;
  807a80:	c6 43 2e 00          	movb   $0x0,0x2e(%ebx)
#if LWIP_DHCP
  /* netif not under DHCP control by default */
  netif->dhcp = NULL;
  807a84:	c7 43 20 00 00 00 00 	movl   $0x0,0x20(%ebx)
  netif->loop_first = NULL;
  netif->loop_last = NULL;
#endif /* ENABLE_LOOPBACK */

  /* remember netif specific state information data */
  netif->state = state;
  807a8b:	8b 45 18             	mov    0x18(%ebp),%eax
  807a8e:	89 43 1c             	mov    %eax,0x1c(%ebx)
  netif->num = netifnum++;
  807a91:	0f b6 05 a4 87 b3 00 	movzbl 0xb387a4,%eax
  807a98:	88 43 31             	mov    %al,0x31(%ebx)
  807a9b:	83 c0 01             	add    $0x1,%eax
  807a9e:	a2 a4 87 b3 00       	mov    %al,0xb387a4
  netif->input = input;
  807aa3:	8b 45 20             	mov    0x20(%ebp),%eax
  807aa6:	89 43 10             	mov    %eax,0x10(%ebx)
#endif /* LWIP_NETIF_HWADDRHINT*/
#if ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS
  netif->loop_cnt_current = 0;
#endif /* ENABLE_LOOPBACK && LWIP_LOOPBACK_MAX_PBUFS */

  netif_set_addr(netif, ipaddr, netmask, gw);
  807aa9:	8b 45 14             	mov    0x14(%ebp),%eax
  807aac:	89 44 24 0c          	mov    %eax,0xc(%esp)
  807ab0:	8b 45 10             	mov    0x10(%ebp),%eax
  807ab3:	89 44 24 08          	mov    %eax,0x8(%esp)
  807ab7:	8b 45 0c             	mov    0xc(%ebp),%eax
  807aba:	89 44 24 04          	mov    %eax,0x4(%esp)
  807abe:	89 1c 24             	mov    %ebx,(%esp)
  807ac1:	e8 5e ff ff ff       	call   807a24 <netif_set_addr>

  /* call user specified initialization function for netif */
  if (init(netif) != ERR_OK) {
  807ac6:	89 1c 24             	mov    %ebx,(%esp)
  807ac9:	ff 55 1c             	call   *0x1c(%ebp)
  807acc:	84 c0                	test   %al,%al
  807ace:	74 07                	je     807ad7 <netif_add+0x76>
  807ad0:	bb 00 00 00 00       	mov    $0x0,%ebx
  807ad5:	eb 0d                	jmp    807ae4 <netif_add+0x83>
    return NULL;
  }

  /* add this netif to the list */
  netif->next = netif_list;
  807ad7:	a1 00 f6 b3 00       	mov    0xb3f600,%eax
  807adc:	89 03                	mov    %eax,(%ebx)
  netif_list = netif;
  807ade:	89 1d 00 f6 b3 00    	mov    %ebx,0xb3f600
  ip_addr_debug_print(NETIF_DEBUG, netmask);
  LWIP_DEBUGF(NETIF_DEBUG, (" gw "));
  ip_addr_debug_print(NETIF_DEBUG, gw);
  LWIP_DEBUGF(NETIF_DEBUG, ("\n"));
  return netif;
}
  807ae4:	89 d8                	mov    %ebx,%eax
  807ae6:	83 c4 14             	add    $0x14,%esp
  807ae9:	5b                   	pop    %ebx
  807aea:	5d                   	pop    %ebp
  807aeb:	c3                   	ret    
  807aec:	00 00                	add    %al,(%eax)
	...

00807af0 <pbuf_clen>:
 * @return the number of pbufs in a chain
 */

u8_t
pbuf_clen(struct pbuf *p)
{
  807af0:	55                   	push   %ebp
  807af1:	89 e5                	mov    %esp,%ebp
  807af3:	8b 55 08             	mov    0x8(%ebp),%edx
  u8_t len;

  len = 0;
  while (p != NULL) {
  807af6:	b8 00 00 00 00       	mov    $0x0,%eax
  807afb:	85 d2                	test   %edx,%edx
  807afd:	74 09                	je     807b08 <pbuf_clen+0x18>
    ++len;
  807aff:	83 c0 01             	add    $0x1,%eax
    p = p->next;
  807b02:	8b 12                	mov    (%edx),%edx
pbuf_clen(struct pbuf *p)
{
  u8_t len;

  len = 0;
  while (p != NULL) {
  807b04:	85 d2                	test   %edx,%edx
  807b06:	75 f7                	jne    807aff <pbuf_clen+0xf>
    ++len;
    p = p->next;
  }
  return len;
}
  807b08:	5d                   	pop    %ebp
  807b09:	c3                   	ret    

00807b0a <pbuf_ref>:
 * @param p pbuf to increase reference counter of
 *
 */
void
pbuf_ref(struct pbuf *p)
{
  807b0a:	55                   	push   %ebp
  807b0b:	89 e5                	mov    %esp,%ebp
  807b0d:	8b 45 08             	mov    0x8(%ebp),%eax
  SYS_ARCH_DECL_PROTECT(old_level);
  /* pbuf given? */
  if (p != NULL) {
  807b10:	85 c0                	test   %eax,%eax
  807b12:	74 05                	je     807b19 <pbuf_ref+0xf>
    SYS_ARCH_PROTECT(old_level);
    ++(p->ref);
  807b14:	66 83 40 0e 01       	addw   $0x1,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
  }
}
  807b19:	5d                   	pop    %ebp
  807b1a:	c3                   	ret    

00807b1b <pbuf_cat>:
 * @see pbuf_chain()
 */

void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  807b1b:	55                   	push   %ebp
  807b1c:	89 e5                	mov    %esp,%ebp
  807b1e:	53                   	push   %ebx
  807b1f:	83 ec 14             	sub    $0x14,%esp
  807b22:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807b25:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807b28:	85 db                	test   %ebx,%ebx
  807b2a:	74 0e                	je     807b3a <pbuf_cat+0x1f>
  807b2c:	85 c9                	test   %ecx,%ecx
  807b2e:	74 0a                	je     807b3a <pbuf_cat+0x1f>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807b30:	8b 13                	mov    (%ebx),%edx
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807b32:	89 d8                	mov    %ebx,%eax
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807b34:	85 d2                	test   %edx,%edx
  807b36:	75 1e                	jne    807b56 <pbuf_cat+0x3b>
  807b38:	eb 2c                	jmp    807b66 <pbuf_cat+0x4b>
void
pbuf_cat(struct pbuf *h, struct pbuf *t)
{
  struct pbuf *p;

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
  807b3a:	c7 44 24 08 80 37 81 	movl   $0x813780,0x8(%esp)
  807b41:	00 
  807b42:	c7 44 24 04 42 02 00 	movl   $0x242,0x4(%esp)
  807b49:	00 
  807b4a:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807b51:	e8 7e 8e ff ff       	call   8009d4 <_panic>
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  807b56:	0f b7 51 08          	movzwl 0x8(%ecx),%edx
  807b5a:	66 01 50 08          	add    %dx,0x8(%eax)

  LWIP_ERROR("(h != NULL) && (t != NULL) (programmer violates API)",
             ((h != NULL) && (t != NULL)), return;);

  /* proceed to last pbuf of chain */
  for (p = h; p->next != NULL; p = p->next) {
  807b5e:	8b 00                	mov    (%eax),%eax
  807b60:	8b 10                	mov    (%eax),%edx
  807b62:	85 d2                	test   %edx,%edx
  807b64:	75 f0                	jne    807b56 <pbuf_cat+0x3b>
    /* add total length of second chain to all totals of first chain */
    p->tot_len += t->tot_len;
  }
  /* { p is last pbuf of first h chain, p->next == NULL } */
  LWIP_ASSERT("p->tot_len == p->len (of last pbuf in chain)", p->tot_len == p->len);
  807b66:	0f b7 58 08          	movzwl 0x8(%eax),%ebx
  807b6a:	66 3b 58 0a          	cmp    0xa(%eax),%bx
  807b6e:	74 1c                	je     807b8c <pbuf_cat+0x71>
  807b70:	c7 44 24 08 b8 37 81 	movl   $0x8137b8,0x8(%esp)
  807b77:	00 
  807b78:	c7 44 24 04 4a 02 00 	movl   $0x24a,0x4(%esp)
  807b7f:	00 
  807b80:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807b87:	e8 48 8e ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("p->next == NULL", p->next == NULL);
  807b8c:	85 d2                	test   %edx,%edx
  807b8e:	74 1c                	je     807bac <pbuf_cat+0x91>
  807b90:	c7 44 24 08 2a 39 81 	movl   $0x81392a,0x8(%esp)
  807b97:	00 
  807b98:	c7 44 24 04 4b 02 00 	movl   $0x24b,0x4(%esp)
  807b9f:	00 
  807ba0:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807ba7:	e8 28 8e ff ff       	call   8009d4 <_panic>
  /* add total length of second chain to last pbuf total of first chain */
  p->tot_len += t->tot_len;
  807bac:	66 03 59 08          	add    0x8(%ecx),%bx
  807bb0:	66 89 58 08          	mov    %bx,0x8(%eax)
  /* chain last pbuf of head (p) with first of tail (t) */
  p->next = t;
  807bb4:	89 08                	mov    %ecx,(%eax)
  /* p->next now references t, but the caller will drop its reference to t,
   * so netto there is no change to the reference count of t.
   */
}
  807bb6:	83 c4 14             	add    $0x14,%esp
  807bb9:	5b                   	pop    %ebx
  807bba:	5d                   	pop    %ebp
  807bbb:	c3                   	ret    

00807bbc <pbuf_chain>:
 * The ->ref field of the first pbuf of the tail chain is adjusted.
 *
 */
void
pbuf_chain(struct pbuf *h, struct pbuf *t)
{
  807bbc:	55                   	push   %ebp
  807bbd:	89 e5                	mov    %esp,%ebp
  807bbf:	53                   	push   %ebx
  807bc0:	83 ec 14             	sub    $0x14,%esp
  807bc3:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  pbuf_cat(h, t);
  807bc6:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  807bca:	8b 45 08             	mov    0x8(%ebp),%eax
  807bcd:	89 04 24             	mov    %eax,(%esp)
  807bd0:	e8 46 ff ff ff       	call   807b1b <pbuf_cat>
  /* t is now referenced by h */
  pbuf_ref(t);
  807bd5:	89 1c 24             	mov    %ebx,(%esp)
  807bd8:	e8 2d ff ff ff       	call   807b0a <pbuf_ref>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_FRESH | 2, ("pbuf_chain: %p references %p\n", (void *)h, (void *)t));
}
  807bdd:	83 c4 14             	add    $0x14,%esp
  807be0:	5b                   	pop    %ebx
  807be1:	5d                   	pop    %ebp
  807be2:	c3                   	ret    

00807be3 <pbuf_header>:
 * @return non-zero on failure, zero on success.
 *
 */
u8_t
pbuf_header(struct pbuf *p, s16_t header_size_increment)
{
  807be3:	55                   	push   %ebp
  807be4:	89 e5                	mov    %esp,%ebp
  807be6:	83 ec 18             	sub    $0x18,%esp
  807be9:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  807bec:	89 75 fc             	mov    %esi,-0x4(%ebp)
  807bef:	8b 55 08             	mov    0x8(%ebp),%edx
  807bf2:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  u16_t type;
  void *payload;
  u16_t increment_magnitude;

  LWIP_ASSERT("p != NULL", p != NULL);
  807bf6:	85 d2                	test   %edx,%edx
  807bf8:	75 1c                	jne    807c16 <pbuf_header+0x33>
  807bfa:	c7 44 24 08 f3 39 81 	movl   $0x8139f3,0x8(%esp)
  807c01:	00 
  807c02:	c7 44 24 04 64 01 00 	movl   $0x164,0x4(%esp)
  807c09:	00 
  807c0a:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807c11:	e8 be 8d ff ff       	call   8009d4 <_panic>
  if ((header_size_increment == 0) || (p == NULL))
  807c16:	b8 00 00 00 00       	mov    $0x0,%eax
  807c1b:	66 85 c9             	test   %cx,%cx
  807c1e:	0f 84 a8 00 00 00    	je     807ccc <pbuf_header+0xe9>
  if (header_size_increment < 0){
    increment_magnitude = -header_size_increment;
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  } else {
    increment_magnitude = header_size_increment;
  807c24:	89 ce                	mov    %ecx,%esi

  LWIP_ASSERT("p != NULL", p != NULL);
  if ((header_size_increment == 0) || (p == NULL))
    return 0;
 
  if (header_size_increment < 0){
  807c26:	66 85 c9             	test   %cx,%cx
  807c29:	79 24                	jns    807c4f <pbuf_header+0x6c>
    increment_magnitude = -header_size_increment;
  807c2b:	f7 de                	neg    %esi
    /* Check that we aren't going to move off the end of the pbuf */
    LWIP_ERROR("increment_magnitude <= p->len", (increment_magnitude <= p->len), return 1;);
  807c2d:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807c31:	76 1c                	jbe    807c4f <pbuf_header+0x6c>
  807c33:	c7 44 24 08 3a 39 81 	movl   $0x81393a,0x8(%esp)
  807c3a:	00 
  807c3b:	c7 44 24 04 6b 01 00 	movl   $0x16b,0x4(%esp)
  807c42:	00 
  807c43:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807c4a:	e8 85 8d ff ff       	call   8009d4 <_panic>
    LWIP_ASSERT("p->payload - increment_magnitude >= p + SIZEOF_STRUCT_PBUF",
                (u8_t *)p->payload - increment_magnitude >= (u8_t *)p + SIZEOF_STRUCT_PBUF);
#endif
  }

  type = p->type;
  807c4f:	0f b6 42 0c          	movzbl 0xc(%edx),%eax
  /* remember current payload pointer */
  payload = p->payload;
  807c53:	8b 5a 04             	mov    0x4(%edx),%ebx

  /* pbuf types containing payloads? */
  if (type == PBUF_RAM || type == PBUF_POOL) {
  807c56:	66 85 c0             	test   %ax,%ax
  807c59:	74 06                	je     807c61 <pbuf_header+0x7e>
  807c5b:	66 83 f8 03          	cmp    $0x3,%ax
  807c5f:	75 1d                	jne    807c7e <pbuf_header+0x9b>
    /* set new payload pointer */
    p->payload = (u8_t *)p->payload - header_size_increment;
  807c61:	0f bf c1             	movswl %cx,%eax
  807c64:	89 de                	mov    %ebx,%esi
  807c66:	29 c6                	sub    %eax,%esi
  807c68:	89 f0                	mov    %esi,%eax
  807c6a:	89 72 04             	mov    %esi,0x4(%edx)
    /* boundary check fails? */
    if ((u8_t *)p->payload < (u8_t *)p + SIZEOF_STRUCT_PBUF) {
  807c6d:	8d 72 10             	lea    0x10(%edx),%esi
  807c70:	39 f0                	cmp    %esi,%eax
  807c72:	73 44                	jae    807cb8 <pbuf_header+0xd5>
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_header: failed as %p < %p (not enough space for new header size)\n",
        (void *)p->payload,
        (void *)(p + 1)));\
      /* restore old payload pointer */
      p->payload = payload;
  807c74:	89 5a 04             	mov    %ebx,0x4(%edx)
  807c77:	b8 01 00 00 00       	mov    $0x1,%eax
      /* bail out unsuccesfully */
      return 1;
  807c7c:	eb 4e                	jmp    807ccc <pbuf_header+0xe9>
    }
  /* pbuf types refering to external payloads? */
  } else if (type == PBUF_REF || type == PBUF_ROM) {
  807c7e:	83 e8 01             	sub    $0x1,%eax
  807c81:	66 83 f8 01          	cmp    $0x1,%ax
  807c85:	77 15                	ja     807c9c <pbuf_header+0xb9>
    /* hide a header in the payload? */
    if ((header_size_increment < 0) && (increment_magnitude <= p->len)) {
  807c87:	66 85 c9             	test   %cx,%cx
  807c8a:	79 3b                	jns    807cc7 <pbuf_header+0xe4>
  807c8c:	66 3b 72 0a          	cmp    0xa(%edx),%si
  807c90:	77 35                	ja     807cc7 <pbuf_header+0xe4>
      /* increase payload pointer */
      p->payload = (u8_t *)p->payload - header_size_increment;
  807c92:	0f bf c1             	movswl %cx,%eax
  807c95:	29 c3                	sub    %eax,%ebx
  807c97:	89 5a 04             	mov    %ebx,0x4(%edx)
  807c9a:	eb 1c                	jmp    807cb8 <pbuf_header+0xd5>
      return 1;
    }
  }
  else {
    /* Unknown type */
    LWIP_ASSERT("bad pbuf type", 0);
  807c9c:	c7 44 24 08 58 39 81 	movl   $0x813958,0x8(%esp)
  807ca3:	00 
  807ca4:	c7 44 24 04 9a 01 00 	movl   $0x19a,0x4(%esp)
  807cab:	00 
  807cac:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807cb3:	e8 1c 8d ff ff       	call   8009d4 <_panic>
    return 1;
  }
  /* modify pbuf length fields */
  p->len += header_size_increment;
  807cb8:	66 01 4a 0a          	add    %cx,0xa(%edx)
  p->tot_len += header_size_increment;
  807cbc:	66 01 4a 08          	add    %cx,0x8(%edx)
  807cc0:	b8 00 00 00 00       	mov    $0x0,%eax

  LWIP_DEBUGF(PBUF_DEBUG, ("pbuf_header: old %p new %p (%"S16_F")\n",
    (void *)payload, (void *)p->payload, header_size_increment));

  return 0;
  807cc5:	eb 05                	jmp    807ccc <pbuf_header+0xe9>
  807cc7:	b8 01 00 00 00       	mov    $0x1,%eax
}
  807ccc:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  807ccf:	8b 75 fc             	mov    -0x4(%ebp),%esi
  807cd2:	89 ec                	mov    %ebp,%esp
  807cd4:	5d                   	pop    %ebp
  807cd5:	c3                   	ret    

00807cd6 <pbuf_copy_partial>:
 * @param len length of data to copy (dataptr must be big enough)
 * @param offset offset into the packet buffer from where to begin copying len bytes
 */
u16_t
pbuf_copy_partial(struct pbuf *buf, void *dataptr, u16_t len, u16_t offset)
{
  807cd6:	55                   	push   %ebp
  807cd7:	89 e5                	mov    %esp,%ebp
  807cd9:	57                   	push   %edi
  807cda:	56                   	push   %esi
  807cdb:	53                   	push   %ebx
  807cdc:	83 ec 2c             	sub    $0x2c,%esp
  807cdf:	8b 5d 08             	mov    0x8(%ebp),%ebx
  807ce2:	0f b7 7d 10          	movzwl 0x10(%ebp),%edi
  807ce6:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  struct pbuf *p;
  u16_t left;
  u16_t buf_copy_len;
  u16_t copied_total = 0;

  LWIP_ERROR("netbuf_copy_partial: invalid buf", (buf != NULL), return 0;);
  807cea:	85 db                	test   %ebx,%ebx
  807cec:	75 1c                	jne    807d0a <pbuf_copy_partial+0x34>
  807cee:	c7 44 24 08 e8 37 81 	movl   $0x8137e8,0x8(%esp)
  807cf5:	00 
  807cf6:	c7 44 24 04 ef 02 00 	movl   $0x2ef,0x4(%esp)
  807cfd:	00 
  807cfe:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807d05:	e8 ca 8c ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netbuf_copy_partial: invalid dataptr", (dataptr != NULL), return 0;);
  807d0a:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  807d0e:	75 1c                	jne    807d2c <pbuf_copy_partial+0x56>
  807d10:	c7 44 24 08 0c 38 81 	movl   $0x81380c,0x8(%esp)
  807d17:	00 
  807d18:	c7 44 24 04 f0 02 00 	movl   $0x2f0,0x4(%esp)
  807d1f:	00 
  807d20:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807d27:	e8 a8 8c ff ff       	call   8009d4 <_panic>
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807d2c:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
  807d32:	66 85 ff             	test   %di,%di
  807d35:	74 62                	je     807d99 <pbuf_copy_partial+0xc3>
  807d37:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    if ((offset != 0) && (offset >= p->len)) {
  807d3d:	66 85 c0             	test   %ax,%ax
  807d40:	74 0e                	je     807d50 <pbuf_copy_partial+0x7a>
  807d42:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  807d46:	66 39 c2             	cmp    %ax,%dx
  807d49:	77 05                	ja     807d50 <pbuf_copy_partial+0x7a>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
  807d4b:	66 29 d0             	sub    %dx,%ax
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
    if ((offset != 0) && (offset >= p->len)) {
  807d4e:	eb 3e                	jmp    807d8e <pbuf_copy_partial+0xb8>
      /* don't copy from this buffer -> on to the next */
      offset -= p->len;
    } else {
      /* copy from this buffer. maybe only partially. */
      buf_copy_len = p->len - offset;
  807d50:	0f b7 73 0a          	movzwl 0xa(%ebx),%esi
  807d54:	66 29 c6             	sub    %ax,%si
  807d57:	66 39 fe             	cmp    %di,%si
  807d5a:	76 02                	jbe    807d5e <pbuf_copy_partial+0x88>
  807d5c:	89 fe                	mov    %edi,%esi
      if (buf_copy_len > len)
          buf_copy_len = len;
      /* copy the necessary parts of the buffer */
      MEMCPY(&((char*)dataptr)[left], &((char*)p->payload)[offset], buf_copy_len);
  807d5e:	0f b7 d6             	movzwl %si,%edx
  807d61:	89 54 24 08          	mov    %edx,0x8(%esp)
  807d65:	0f b7 c0             	movzwl %ax,%eax
  807d68:	03 43 04             	add    0x4(%ebx),%eax
  807d6b:	89 44 24 04          	mov    %eax,0x4(%esp)
  807d6f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807d73:	03 45 0c             	add    0xc(%ebp),%eax
  807d76:	89 04 24             	mov    %eax,(%esp)
  807d79:	e8 13 96 ff ff       	call   801391 <memcpy>
      copied_total += buf_copy_len;
  807d7e:	66 01 75 e4          	add    %si,-0x1c(%ebp)
      left += buf_copy_len;
  807d82:	66 01 75 e6          	add    %si,-0x1a(%ebp)
      len -= buf_copy_len;
  807d86:	66 29 f7             	sub    %si,%di
  807d89:	b8 00 00 00 00       	mov    $0x0,%eax
  if((buf == NULL) || (dataptr == NULL)) {
    return 0;
  }

  /* Note some systems use byte copy if dataptr or one of the pbuf payload pointers are unaligned. */
  for(p = buf; len != 0 && p != NULL; p = p->next) {
  807d8e:	8b 1b                	mov    (%ebx),%ebx
  807d90:	66 85 ff             	test   %di,%di
  807d93:	74 04                	je     807d99 <pbuf_copy_partial+0xc3>
  807d95:	85 db                	test   %ebx,%ebx
  807d97:	75 a4                	jne    807d3d <pbuf_copy_partial+0x67>
      len -= buf_copy_len;
      offset = 0;
    }
  }
  return copied_total;
}
  807d99:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807d9d:	83 c4 2c             	add    $0x2c,%esp
  807da0:	5b                   	pop    %ebx
  807da1:	5e                   	pop    %esi
  807da2:	5f                   	pop    %edi
  807da3:	5d                   	pop    %ebp
  807da4:	c3                   	ret    

00807da5 <pbuf_copy>:
 *         ERR_ARG if one of the pbufs is NULL or p_to is not big
 *                 enough to hold p_from
 */
err_t
pbuf_copy(struct pbuf *p_to, struct pbuf *p_from)
{
  807da5:	55                   	push   %ebp
  807da6:	89 e5                	mov    %esp,%ebp
  807da8:	57                   	push   %edi
  807da9:	56                   	push   %esi
  807daa:	53                   	push   %ebx
  807dab:	83 ec 2c             	sub    $0x2c,%esp
  807dae:	8b 75 08             	mov    0x8(%ebp),%esi
  807db1:	8b 5d 0c             	mov    0xc(%ebp),%ebx

  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_copy(%p, %p)\n",
    (void*)p_to, (void*)p_from));

  /* is the target big enough to hold the source? */
  LWIP_ERROR("pbuf_copy: target not big enough to hold source", ((p_to != NULL) &&
  807db4:	85 f6                	test   %esi,%esi
  807db6:	0f 94 c0             	sete   %al
  807db9:	74 0e                	je     807dc9 <pbuf_copy+0x24>
  807dbb:	85 db                	test   %ebx,%ebx
  807dbd:	74 0a                	je     807dc9 <pbuf_copy+0x24>
  807dbf:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  807dc3:	66 3b 53 08          	cmp    0x8(%ebx),%dx
  807dc7:	73 1c                	jae    807de5 <pbuf_copy+0x40>
  807dc9:	c7 44 24 08 34 38 81 	movl   $0x813834,0x8(%esp)
  807dd0:	00 
  807dd1:	c7 44 24 04 b1 02 00 	movl   $0x2b1,0x4(%esp)
  807dd8:	00 
  807dd9:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807de0:	e8 ef 8b ff ff       	call   8009d4 <_panic>
             (p_from != NULL) && (p_to->tot_len >= p_from->tot_len)), return ERR_ARG;);

  /* iterate through pbuf chain */
  do
  {
    LWIP_ASSERT("p_to != NULL", p_to != NULL);
  807de5:	84 c0                	test   %al,%al
  807de7:	74 25                	je     807e0e <pbuf_copy+0x69>
  807de9:	eb 07                	jmp    807df2 <pbuf_copy+0x4d>
  807deb:	85 f6                	test   %esi,%esi
  807ded:	8d 76 00             	lea    0x0(%esi),%esi
  807df0:	75 27                	jne    807e19 <pbuf_copy+0x74>
  807df2:	c7 44 24 08 66 39 81 	movl   $0x813966,0x8(%esp)
  807df9:	00 
  807dfa:	c7 44 24 04 b6 02 00 	movl   $0x2b6,0x4(%esp)
  807e01:	00 
  807e02:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807e09:	e8 c6 8b ff ff       	call   8009d4 <_panic>
  807e0e:	bf 00 00 00 00       	mov    $0x0,%edi
  807e13:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
    /* copy one part of the original chain */
    if ((p_to->len - offset_to) >= (p_from->len - offset_from)) {
  807e19:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807e1d:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  807e21:	0f b7 4b 0a          	movzwl 0xa(%ebx),%ecx
  807e25:	0f b7 d0             	movzwl %ax,%edx
  807e28:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807e2c:	29 c2                	sub    %eax,%edx
  807e2e:	89 55 e0             	mov    %edx,-0x20(%ebp)
  807e31:	0f b7 d1             	movzwl %cx,%edx
  807e34:	0f b7 c7             	movzwl %di,%eax
  807e37:	29 c2                	sub    %eax,%edx
  807e39:	39 55 e0             	cmp    %edx,-0x20(%ebp)
  807e3c:	7c 09                	jl     807e47 <pbuf_copy+0xa2>
      /* complete current p_from fits into current p_to */
      len = p_from->len - offset_from;
  807e3e:	66 29 f9             	sub    %di,%cx
  807e41:	66 89 4d e4          	mov    %cx,-0x1c(%ebp)
  807e45:	eb 0c                	jmp    807e53 <pbuf_copy+0xae>
    } else {
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
  807e47:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807e4b:	66 2b 45 e6          	sub    -0x1a(%ebp),%ax
  807e4f:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
  807e53:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807e57:	89 44 24 08          	mov    %eax,0x8(%esp)
  807e5b:	0f b7 c7             	movzwl %di,%eax
  807e5e:	03 43 04             	add    0x4(%ebx),%eax
  807e61:	89 44 24 04          	mov    %eax,0x4(%esp)
  807e65:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  807e69:	03 46 04             	add    0x4(%esi),%eax
  807e6c:	89 04 24             	mov    %eax,(%esp)
  807e6f:	e8 1d 95 ff ff       	call   801391 <memcpy>
    offset_to += len;
  807e74:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  807e78:	66 01 45 e6          	add    %ax,-0x1a(%ebp)
    offset_from += len;
    LWIP_ASSERT("offset_to <= p_to->len", offset_to <= p_to->len);
  807e7c:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807e80:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  807e84:	76 1c                	jbe    807ea2 <pbuf_copy+0xfd>
  807e86:	c7 44 24 08 73 39 81 	movl   $0x813973,0x8(%esp)
  807e8d:	00 
  807e8e:	c7 44 24 04 c2 02 00 	movl   $0x2c2,0x4(%esp)
  807e95:	00 
  807e96:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807e9d:	e8 32 8b ff ff       	call   8009d4 <_panic>
    if (offset_to == p_to->len) {
  807ea2:	66 39 45 e6          	cmp    %ax,-0x1a(%ebp)
  807ea6:	75 08                	jne    807eb0 <pbuf_copy+0x10b>
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
  807ea8:	8b 36                	mov    (%esi),%esi
  807eaa:	66 c7 45 e6 00 00    	movw   $0x0,-0x1a(%ebp)
      /* current p_from does not fit into current p_to */
      len = p_to->len - offset_to;
    }
    MEMCPY((u8_t*)p_to->payload + offset_to, (u8_t*)p_from->payload + offset_from, len);
    offset_to += len;
    offset_from += len;
  807eb0:	66 03 7d e4          	add    -0x1c(%ebp),%di
    if (offset_to == p_to->len) {
      /* on to next p_to (if any) */
      offset_to = 0;
      p_to = p_to->next;
    }
    LWIP_ASSERT("offset_from <= p_from->len", offset_from <= p_from->len);
  807eb4:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807eb8:	66 39 c7             	cmp    %ax,%di
  807ebb:	76 1c                	jbe    807ed9 <pbuf_copy+0x134>
  807ebd:	c7 44 24 08 8a 39 81 	movl   $0x81398a,0x8(%esp)
  807ec4:	00 
  807ec5:	c7 44 24 04 c8 02 00 	movl   $0x2c8,0x4(%esp)
  807ecc:	00 
  807ecd:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807ed4:	e8 fb 8a ff ff       	call   8009d4 <_panic>
    if (offset_from >= p_from->len) {
  807ed9:	66 39 c7             	cmp    %ax,%di
  807edc:	72 07                	jb     807ee5 <pbuf_copy+0x140>
      /* on to next p_from (if any) */
      offset_from = 0;
      p_from = p_from->next;
  807ede:	8b 1b                	mov    (%ebx),%ebx
  807ee0:	bf 00 00 00 00       	mov    $0x0,%edi
    }

    if((p_from != NULL) && (p_from->len == p_from->tot_len)) {
  807ee5:	85 db                	test   %ebx,%ebx
  807ee7:	74 2b                	je     807f14 <pbuf_copy+0x16f>
  807ee9:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  807eed:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  807ef1:	75 21                	jne    807f14 <pbuf_copy+0x16f>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807ef3:	83 3b 00             	cmpl   $0x0,(%ebx)
  807ef6:	74 1c                	je     807f14 <pbuf_copy+0x16f>
  807ef8:	c7 44 24 08 64 38 81 	movl   $0x813864,0x8(%esp)
  807eff:	00 
  807f00:	c7 44 24 04 d2 02 00 	movl   $0x2d2,0x4(%esp)
  807f07:	00 
  807f08:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807f0f:	e8 c0 8a ff ff       	call   8009d4 <_panic>
                 (p_from->next == NULL), return ERR_VAL;);
    }
    if((p_to != NULL) && (p_to->len == p_to->tot_len)) {
  807f14:	85 f6                	test   %esi,%esi
  807f16:	74 2b                	je     807f43 <pbuf_copy+0x19e>
  807f18:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  807f1c:	66 3b 46 08          	cmp    0x8(%esi),%ax
  807f20:	75 21                	jne    807f43 <pbuf_copy+0x19e>
      /* don't copy more than one packet! */
      LWIP_ERROR("pbuf_copy() does not allow packet queues!\n",
  807f22:	83 3e 00             	cmpl   $0x0,(%esi)
  807f25:	74 1c                	je     807f43 <pbuf_copy+0x19e>
  807f27:	c7 44 24 08 64 38 81 	movl   $0x813864,0x8(%esp)
  807f2e:	00 
  807f2f:	c7 44 24 04 d7 02 00 	movl   $0x2d7,0x4(%esp)
  807f36:	00 
  807f37:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807f3e:	e8 91 8a ff ff       	call   8009d4 <_panic>
                  (p_to->next == NULL), return ERR_VAL;);
    }
  } while (p_from);
  807f43:	85 db                	test   %ebx,%ebx
  807f45:	0f 85 a0 fe ff ff    	jne    807deb <pbuf_copy+0x46>
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 1, ("pbuf_copy: end of chain reached.\n"));
  return ERR_OK;
}
  807f4b:	b8 00 00 00 00       	mov    $0x0,%eax
  807f50:	83 c4 2c             	add    $0x2c,%esp
  807f53:	5b                   	pop    %ebx
  807f54:	5e                   	pop    %esi
  807f55:	5f                   	pop    %edi
  807f56:	5d                   	pop    %ebp
  807f57:	c3                   	ret    

00807f58 <pbuf_free>:
 * 1->1->1 becomes .......
 *
 */
u8_t
pbuf_free(struct pbuf *p)
{
  807f58:	55                   	push   %ebp
  807f59:	89 e5                	mov    %esp,%ebp
  807f5b:	56                   	push   %esi
  807f5c:	53                   	push   %ebx
  807f5d:	83 ec 10             	sub    $0x10,%esp
  807f60:	8b 45 08             	mov    0x8(%ebp),%eax
  u16_t type;
  struct pbuf *q;
  u8_t count;

  if (p == NULL) {
  807f63:	85 c0                	test   %eax,%eax
  807f65:	75 1c                	jne    807f83 <pbuf_free+0x2b>
    LWIP_ASSERT("p != NULL", p != NULL);
  807f67:	c7 44 24 08 f3 39 81 	movl   $0x8139f3,0x8(%esp)
  807f6e:	00 
  807f6f:	c7 44 24 04 d0 01 00 	movl   $0x1d0,0x4(%esp)
  807f76:	00 
  807f77:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807f7e:	e8 51 8a ff ff       	call   8009d4 <_panic>
  }
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_free(%p)\n", (void *)p));

  PERF_START;

  LWIP_ASSERT("pbuf_free: sane type",
  807f83:	80 78 0c 03          	cmpb   $0x3,0xc(%eax)
  807f87:	77 0a                	ja     807f93 <pbuf_free+0x3b>
  807f89:	be 00 00 00 00       	mov    $0x0,%esi
  807f8e:	e9 82 00 00 00       	jmp    808015 <pbuf_free+0xbd>
  807f93:	c7 44 24 08 a5 39 81 	movl   $0x8139a5,0x8(%esp)
  807f9a:	00 
  807f9b:	c7 44 24 04 db 01 00 	movl   $0x1db,0x4(%esp)
  807fa2:	00 
  807fa3:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807faa:	e8 25 8a ff ff       	call   8009d4 <_panic>
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  807faf:	c7 44 24 08 ba 39 81 	movl   $0x8139ba,0x8(%esp)
  807fb6:	00 
  807fb7:	c7 44 24 04 e8 01 00 	movl   $0x1e8,0x4(%esp)
  807fbe:	00 
  807fbf:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  807fc6:	e8 09 8a ff ff       	call   8009d4 <_panic>
    ref = --(p->ref);
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
      /* remember next pbuf in chain for next iteration */
      q = p->next;
  807fcb:	8b 18                	mov    (%eax),%ebx
      LWIP_DEBUGF( PBUF_DEBUG | 2, ("pbuf_free: deallocating %p\n", (void *)p));
      type = p->type;
  807fcd:	0f b6 50 0c          	movzbl 0xc(%eax),%edx
      /* is this a pbuf from the pool? */
      if (type == PBUF_POOL) {
  807fd1:	66 83 fa 03          	cmp    $0x3,%dx
  807fd5:	75 12                	jne    807fe9 <pbuf_free+0x91>
        memp_free(MEMP_PBUF_POOL, p);
  807fd7:	89 44 24 04          	mov    %eax,0x4(%esp)
  807fdb:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  807fe2:	e8 d9 f7 ff ff       	call   8077c0 <memp_free>
  807fe7:	eb 23                	jmp    80800c <pbuf_free+0xb4>
      /* is this a ROM or RAM referencing pbuf? */
      } else if (type == PBUF_ROM || type == PBUF_REF) {
  807fe9:	83 ea 01             	sub    $0x1,%edx
  807fec:	66 83 fa 01          	cmp    $0x1,%dx
  807ff0:	77 12                	ja     808004 <pbuf_free+0xac>
        memp_free(MEMP_PBUF, p);
  807ff2:	89 44 24 04          	mov    %eax,0x4(%esp)
  807ff6:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  807ffd:	e8 be f7 ff ff       	call   8077c0 <memp_free>
  808002:	eb 08                	jmp    80800c <pbuf_free+0xb4>
      /* type == PBUF_RAM */
      } else {
        mem_free(p);
  808004:	89 04 24             	mov    %eax,(%esp)
  808007:	e8 42 f5 ff ff       	call   80754e <mem_free>
      }
      count++;
  80800c:	83 c6 01             	add    $0x1,%esi
    p->type == PBUF_REF || p->type == PBUF_POOL);

  count = 0;
  /* de-allocate all consecutive pbufs from the head of the chain that
   * obtain a zero reference count after decrementing*/
  while (p != NULL) {
  80800f:	85 db                	test   %ebx,%ebx
  808011:	74 17                	je     80802a <pbuf_free+0xd2>
  808013:	89 d8                	mov    %ebx,%eax
    /* Since decrementing ref cannot be guaranteed to be a single machine operation
     * we must protect it. We put the new ref into a local variable to prevent
     * further protection. */
    SYS_ARCH_PROTECT(old_level);
    /* all pbufs in a chain are referenced at least once */
    LWIP_ASSERT("pbuf_free: p->ref > 0", p->ref > 0);
  808015:	0f b7 50 0e          	movzwl 0xe(%eax),%edx
  808019:	66 85 d2             	test   %dx,%dx
  80801c:	74 91                	je     807faf <pbuf_free+0x57>
    /* decrease reference count (number of pointers to pbuf) */
    ref = --(p->ref);
  80801e:	83 ea 01             	sub    $0x1,%edx
  808021:	66 89 50 0e          	mov    %dx,0xe(%eax)
    SYS_ARCH_UNPROTECT(old_level);
    /* this pbuf is no longer referenced to? */
    if (ref == 0) {
  808025:	66 85 d2             	test   %dx,%dx
  808028:	74 a1                	je     807fcb <pbuf_free+0x73>
    }
  }
  PERF_STOP("pbuf_free");
  /* return number of de-allocated pbufs */
  return count;
}
  80802a:	89 f0                	mov    %esi,%eax
  80802c:	83 c4 10             	add    $0x10,%esp
  80802f:	5b                   	pop    %ebx
  808030:	5e                   	pop    %esi
  808031:	5d                   	pop    %ebp
  808032:	c3                   	ret    

00808033 <pbuf_dechain>:
 * @return remainder of the pbuf chain, or NULL if it was de-allocated.
 * @note May not be called on a packet queue.
 */
struct pbuf *
pbuf_dechain(struct pbuf *p)
{
  808033:	55                   	push   %ebp
  808034:	89 e5                	mov    %esp,%ebp
  808036:	83 ec 38             	sub    $0x38,%esp
  808039:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80803c:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80803f:	89 7d fc             	mov    %edi,-0x4(%ebp)
  808042:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t tail_gone = 1;
  /* tail */
  q = p->next;
  808045:	8b 33                	mov    (%ebx),%esi
  /* pbuf has successor in chain? */
  if (q != NULL) {
  808047:	b8 01 00 00 00       	mov    $0x1,%eax
  80804c:	85 f6                	test   %esi,%esi
  80804e:	74 55                	je     8080a5 <pbuf_dechain+0x72>
    /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
    LWIP_ASSERT("p->tot_len == p->len + q->tot_len", q->tot_len == p->tot_len - p->len);
  808050:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  808054:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  808058:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  80805c:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80805f:	0f b7 fa             	movzwl %dx,%edi
  808062:	0f b7 c8             	movzwl %ax,%ecx
  808065:	29 cf                	sub    %ecx,%edi
  808067:	39 7d e4             	cmp    %edi,-0x1c(%ebp)
  80806a:	74 1c                	je     808088 <pbuf_dechain+0x55>
  80806c:	c7 44 24 08 90 38 81 	movl   $0x813890,0x8(%esp)
  808073:	00 
  808074:	c7 44 24 04 80 02 00 	movl   $0x280,0x4(%esp)
  80807b:	00 
  80807c:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  808083:	e8 4c 89 ff ff       	call   8009d4 <_panic>
    /* enforce invariant if assertion is disabled */
    q->tot_len = p->tot_len - p->len;
  808088:	66 29 c2             	sub    %ax,%dx
  80808b:	66 89 56 08          	mov    %dx,0x8(%esi)
    /* decouple pbuf from remainder */
    p->next = NULL;
  80808f:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
    /* total length of pbuf p is its own length only */
    p->tot_len = p->len;
  808095:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  808099:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* q is no longer referenced by p, free it */
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_STATE, ("pbuf_dechain: unreferencing %p\n", (void *)q));
    tail_gone = pbuf_free(q);
  80809d:	89 34 24             	mov    %esi,(%esp)
  8080a0:	e8 b3 fe ff ff       	call   807f58 <pbuf_free>
                  ("pbuf_dechain: deallocated %p (as it is no longer referenced)\n", (void *)q));
    }
    /* return remaining tail or NULL if deallocated */
  }
  /* assert tot_len invariant: (p->tot_len == p->len + (p->next? p->next->tot_len: 0) */
  LWIP_ASSERT("p->tot_len == p->len", p->tot_len == p->len);
  8080a5:	0f b7 53 08          	movzwl 0x8(%ebx),%edx
  8080a9:	66 3b 53 0a          	cmp    0xa(%ebx),%dx
  8080ad:	74 1c                	je     8080cb <pbuf_dechain+0x98>
  8080af:	c7 44 24 08 d0 39 81 	movl   $0x8139d0,0x8(%esp)
  8080b6:	00 
  8080b7:	c7 44 24 04 91 02 00 	movl   $0x291,0x4(%esp)
  8080be:	00 
  8080bf:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  8080c6:	e8 09 89 ff ff       	call   8009d4 <_panic>
  return ((tail_gone > 0) ? NULL : q);
  8080cb:	3c 01                	cmp    $0x1,%al
  8080cd:	19 c0                	sbb    %eax,%eax
  8080cf:	21 c6                	and    %eax,%esi
}
  8080d1:	89 f0                	mov    %esi,%eax
  8080d3:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  8080d6:	8b 75 f8             	mov    -0x8(%ebp),%esi
  8080d9:	8b 7d fc             	mov    -0x4(%ebp),%edi
  8080dc:	89 ec                	mov    %ebp,%esp
  8080de:	5d                   	pop    %ebp
  8080df:	c3                   	ret    

008080e0 <pbuf_realloc>:
 *
 * @note Despite its name, pbuf_realloc cannot grow the size of a pbuf (chain).
 */
void
pbuf_realloc(struct pbuf *p, u16_t new_len)
{
  8080e0:	55                   	push   %ebp
  8080e1:	89 e5                	mov    %esp,%ebp
  8080e3:	56                   	push   %esi
  8080e4:	53                   	push   %ebx
  8080e5:	83 ec 10             	sub    $0x10,%esp
  8080e8:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8080eb:	0f b7 75 0c          	movzwl 0xc(%ebp),%esi
  struct pbuf *q;
  u16_t rem_len; /* remaining length */
  s32_t grow;

  LWIP_ASSERT("pbuf_realloc: p != NULL", p != NULL);
  8080ef:	85 db                	test   %ebx,%ebx
  8080f1:	75 1c                	jne    80810f <pbuf_realloc+0x2f>
  8080f3:	c7 44 24 08 e5 39 81 	movl   $0x8139e5,0x8(%esp)
  8080fa:	00 
  8080fb:	c7 44 24 04 13 01 00 	movl   $0x113,0x4(%esp)
  808102:	00 
  808103:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  80810a:	e8 c5 88 ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("pbuf_realloc: sane p->type", p->type == PBUF_POOL ||
  80810f:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  808113:	3c 03                	cmp    $0x3,%al
  808115:	74 2b                	je     808142 <pbuf_realloc+0x62>
  808117:	3c 01                	cmp    $0x1,%al
  808119:	74 27                	je     808142 <pbuf_realloc+0x62>
  80811b:	84 c0                	test   %al,%al
  80811d:	8d 76 00             	lea    0x0(%esi),%esi
  808120:	74 20                	je     808142 <pbuf_realloc+0x62>
  808122:	3c 02                	cmp    $0x2,%al
  808124:	74 1c                	je     808142 <pbuf_realloc+0x62>
  808126:	c7 44 24 08 fd 39 81 	movl   $0x8139fd,0x8(%esp)
  80812d:	00 
  80812e:	c7 44 24 04 17 01 00 	movl   $0x117,0x4(%esp)
  808135:	00 
  808136:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  80813d:	e8 92 88 ff ff       	call   8009d4 <_panic>
              p->type == PBUF_ROM ||
              p->type == PBUF_RAM ||
              p->type == PBUF_REF);

  /* desired length larger than current length? */
  if (new_len >= p->tot_len) {
  808142:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808146:	66 39 f0             	cmp    %si,%ax
  808149:	0f 86 bd 00 00 00    	jbe    80820c <pbuf_realloc+0x12c>
    return;
  }

  /* the pbuf chain grows by (new_len - p->tot_len) bytes
   * (which may be negative in case of shrinking) */
  grow = new_len - p->tot_len;
  80814f:	0f b7 d6             	movzwl %si,%edx
  808152:	0f b7 c0             	movzwl %ax,%eax
  808155:	29 c2                	sub    %eax,%edx

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  808157:	eb 4d                	jmp    8081a6 <pbuf_realloc+0xc6>
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
    /* decrease total length indicator */
    LWIP_ASSERT("grow < max_u16_t", grow < 0xffff);
  808159:	81 fa fe ff 00 00    	cmp    $0xfffe,%edx
  80815f:	7e 1c                	jle    80817d <pbuf_realloc+0x9d>
  808161:	c7 44 24 08 18 3a 81 	movl   $0x813a18,0x8(%esp)
  808168:	00 
  808169:	c7 44 24 04 2b 01 00 	movl   $0x12b,0x4(%esp)
  808170:	00 
  808171:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  808178:	e8 57 88 ff ff       	call   8009d4 <_panic>
    q->tot_len += (u16_t)grow;
  80817d:	66 01 53 08          	add    %dx,0x8(%ebx)
    /* proceed to next pbuf in chain */
    q = q->next;
  808181:	8b 1b                	mov    (%ebx),%ebx
    LWIP_ASSERT("pbuf_realloc: q != NULL", q != NULL);
  808183:	85 db                	test   %ebx,%ebx
  808185:	75 1c                	jne    8081a3 <pbuf_realloc+0xc3>
  808187:	c7 44 24 08 29 3a 81 	movl   $0x813a29,0x8(%esp)
  80818e:	00 
  80818f:	c7 44 24 04 2f 01 00 	movl   $0x12f,0x4(%esp)
  808196:	00 
  808197:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  80819e:	e8 31 88 ff ff       	call   8009d4 <_panic>
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
    /* decrease remaining length by pbuf length */
    rem_len -= q->len;
  8081a3:	66 29 c6             	sub    %ax,%si

  /* first, step over any pbufs that should remain in the chain */
  rem_len = new_len;
  q = p;
  /* should this pbuf be kept? */
  while (rem_len > q->len) {
  8081a6:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  8081aa:	66 39 c6             	cmp    %ax,%si
  8081ad:	77 aa                	ja     808159 <pbuf_realloc+0x79>
  /* we have now reached the new last pbuf (in q) */
  /* rem_len == desired length for pbuf q */

  /* shrink allocated memory for PBUF_RAM */
  /* (other types merely adjust their length fields */
  if ((q->type == PBUF_RAM) && (rem_len != q->len)) {
  8081af:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  8081b3:	75 3b                	jne    8081f0 <pbuf_realloc+0x110>
  8081b5:	66 39 f0             	cmp    %si,%ax
  8081b8:	74 36                	je     8081f0 <pbuf_realloc+0x110>
    /* reallocate and adjust the length of the pbuf that will be split */
    q = mem_realloc(q, (u8_t *)q->payload - (u8_t *)q + rem_len);
  8081ba:	0f b7 c6             	movzwl %si,%eax
  8081bd:	03 43 04             	add    0x4(%ebx),%eax
  8081c0:	29 d8                	sub    %ebx,%eax
  8081c2:	89 44 24 04          	mov    %eax,0x4(%esp)
  8081c6:	89 1c 24             	mov    %ebx,(%esp)
  8081c9:	e8 1d f2 ff ff       	call   8073eb <mem_realloc>
  8081ce:	89 c3                	mov    %eax,%ebx
    LWIP_ASSERT("mem_realloc give q == NULL", q != NULL);
  8081d0:	85 c0                	test   %eax,%eax
  8081d2:	75 1c                	jne    8081f0 <pbuf_realloc+0x110>
  8081d4:	c7 44 24 08 41 3a 81 	movl   $0x813a41,0x8(%esp)
  8081db:	00 
  8081dc:	c7 44 24 04 39 01 00 	movl   $0x139,0x4(%esp)
  8081e3:	00 
  8081e4:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  8081eb:	e8 e4 87 ff ff       	call   8009d4 <_panic>
  }
  /* adjust length fields for new last pbuf */
  q->len = rem_len;
  8081f0:	66 89 73 0a          	mov    %si,0xa(%ebx)
  q->tot_len = q->len;
  8081f4:	66 89 73 08          	mov    %si,0x8(%ebx)

  /* any remaining pbufs in chain? */
  if (q->next != NULL) {
  8081f8:	8b 03                	mov    (%ebx),%eax
  8081fa:	85 c0                	test   %eax,%eax
  8081fc:	74 08                	je     808206 <pbuf_realloc+0x126>
    /* free remaining pbufs in chain */
    pbuf_free(q->next);
  8081fe:	89 04 24             	mov    %eax,(%esp)
  808201:	e8 52 fd ff ff       	call   807f58 <pbuf_free>
  }
  /* q is last packet in chain */
  q->next = NULL;
  808206:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

}
  80820c:	83 c4 10             	add    $0x10,%esp
  80820f:	5b                   	pop    %ebx
  808210:	5e                   	pop    %esi
  808211:	5d                   	pop    %ebp
  808212:	c3                   	ret    

00808213 <pbuf_alloc>:
 * @return the allocated pbuf. If multiple pbufs where allocated, this
 * is the first pbuf of a pbuf chain.
 */
struct pbuf *
pbuf_alloc(pbuf_layer layer, u16_t length, pbuf_type type)
{
  808213:	55                   	push   %ebp
  808214:	89 e5                	mov    %esp,%ebp
  808216:	57                   	push   %edi
  808217:	56                   	push   %esi
  808218:	53                   	push   %ebx
  808219:	83 ec 2c             	sub    $0x2c,%esp
  80821c:	8b 45 08             	mov    0x8(%ebp),%eax
  80821f:	8b 7d 10             	mov    0x10(%ebp),%edi
  808222:	0f b7 5d 0c          	movzwl 0xc(%ebp),%ebx
  s32_t rem_len; /* remaining length */
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F")\n", length));

  /* determine header offset */
  offset = 0;
  switch (layer) {
  808226:	83 f8 01             	cmp    $0x1,%eax
  808229:	74 27                	je     808252 <pbuf_alloc+0x3f>
  80822b:	ba 14 00 00 00       	mov    $0x14,%edx
  808230:	83 f8 01             	cmp    $0x1,%eax
  808233:	72 22                	jb     808257 <pbuf_alloc+0x44>
  808235:	83 f8 02             	cmp    $0x2,%eax
  808238:	74 10                	je     80824a <pbuf_alloc+0x37>
  80823a:	83 f8 03             	cmp    $0x3,%eax
  80823d:	8d 76 00             	lea    0x0(%esi),%esi
  808240:	75 21                	jne    808263 <pbuf_alloc+0x50>
  808242:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  808248:	eb 35                	jmp    80827f <pbuf_alloc+0x6c>
  80824a:	ba 00 00 00 00       	mov    $0x0,%edx
  80824f:	90                   	nop
  808250:	eb 08                	jmp    80825a <pbuf_alloc+0x47>
  808252:	ba 00 00 00 00       	mov    $0x0,%edx
    /* add room for transport (often TCP) layer header */
    offset += PBUF_TRANSPORT_HLEN;
    /* FALLTHROUGH */
  case PBUF_IP:
    /* add room for IP layer header */
    offset += PBUF_IP_HLEN;
  808257:	83 c2 14             	add    $0x14,%edx
    /* FALLTHROUGH */
  case PBUF_LINK:
    /* add room for link layer header */
    offset += PBUF_LINK_HLEN;
  80825a:	83 c2 0e             	add    $0xe,%edx
  80825d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
    break;
  808261:	eb 22                	jmp    808285 <pbuf_alloc+0x72>
  case PBUF_RAW:
    break;
  default:
    LWIP_ASSERT("pbuf_alloc: bad pbuf layer", 0);
  808263:	c7 44 24 08 5c 3a 81 	movl   $0x813a5c,0x8(%esp)
  80826a:	00 
  80826b:	c7 44 24 04 8a 00 00 	movl   $0x8a,0x4(%esp)
  808272:	00 
  808273:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  80827a:	e8 55 87 ff ff       	call   8009d4 <_panic>
  80827f:	66 c7 45 e4 00 00    	movw   $0x0,-0x1c(%ebp)
    return NULL;
  }

  switch (type) {
  808285:	83 ff 02             	cmp    $0x2,%edi
  808288:	77 0e                	ja     808298 <pbuf_alloc+0x85>
  80828a:	83 ff 01             	cmp    $0x1,%edi
  80828d:	0f 83 c1 01 00 00    	jae    808454 <pbuf_alloc+0x241>
  808293:	e9 7a 01 00 00       	jmp    808412 <pbuf_alloc+0x1ff>
  808298:	83 ff 03             	cmp    $0x3,%edi
  80829b:	90                   	nop
  80829c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8082a0:	0f 85 dc 01 00 00    	jne    808482 <pbuf_alloc+0x26f>
  case PBUF_POOL:
    /* allocate head of pbuf chain into p */
      p = memp_malloc(MEMP_PBUF_POOL);
  8082a6:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  8082ad:	8d 76 00             	lea    0x0(%esi),%esi
  8082b0:	e8 4f f5 ff ff       	call   807804 <memp_malloc>
  8082b5:	89 c6                	mov    %eax,%esi
    LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc: allocated pbuf %p\n", (void *)p));
    if (p == NULL) {
  8082b7:	85 c0                	test   %eax,%eax
  8082b9:	0f 84 e9 01 00 00    	je     8084a8 <pbuf_alloc+0x295>
      return NULL;
    }
    p->type = type;
  8082bf:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
    p->next = NULL;
  8082c3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    /* make the payload pointer point 'offset' bytes into pbuf data memory */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + (SIZEOF_STRUCT_PBUF + offset)));
  8082c9:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  8082cd:	8d 54 06 13          	lea    0x13(%esi,%eax,1),%edx
  8082d1:	83 e2 fc             	and    $0xfffffffc,%edx
  8082d4:	89 56 04             	mov    %edx,0x4(%esi)
    LWIP_ASSERT("pbuf_alloc: pbuf p->payload properly aligned",
            ((mem_ptr_t)p->payload % MEM_ALIGNMENT) == 0);
    /* the total length of the pbuf chain is the requested size */
    p->tot_len = length;
  8082d7:	66 89 5e 08          	mov    %bx,0x8(%esi)
    /* set the length of the first pbuf in the chain */
    p->len = LWIP_MIN(length, PBUF_POOL_BUFSIZE_ALIGNED - LWIP_MEM_ALIGN_SIZE(offset));
  8082db:	0f b7 db             	movzwl %bx,%ebx
  8082de:	83 c0 03             	add    $0x3,%eax
  8082e1:	89 c1                	mov    %eax,%ecx
  8082e3:	83 e1 fc             	and    $0xfffffffc,%ecx
  8082e6:	b8 d0 07 00 00       	mov    $0x7d0,%eax
  8082eb:	29 c8                	sub    %ecx,%eax
  8082ed:	39 d8                	cmp    %ebx,%eax
  8082ef:	7e 02                	jle    8082f3 <pbuf_alloc+0xe0>
  8082f1:	89 d8                	mov    %ebx,%eax
  8082f3:	89 c1                	mov    %eax,%ecx
  8082f5:	66 89 46 0a          	mov    %ax,0xa(%esi)
    LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8082f9:	8d 86 e0 07 00 00    	lea    0x7e0(%esi),%eax
  8082ff:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  808302:	0f b7 c1             	movzwl %cx,%eax
  808305:	01 c2                	add    %eax,%edx
  808307:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80830a:	73 1c                	jae    808328 <pbuf_alloc+0x115>
  80830c:	c7 44 24 08 b4 38 81 	movl   $0x8138b4,0x8(%esp)
  808313:	00 
  808314:	c7 44 24 04 a3 00 00 	movl   $0xa3,0x4(%esp)
  80831b:	00 
  80831c:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  808323:	e8 ac 86 ff ff       	call   8009d4 <_panic>
                ((u8_t*)p->payload + p->len <=
                 (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
    /* set reference count (needed here in case we fail) */
    p->ref = 1;
  808328:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
    /* now allocate the tail of the pbuf chain */

    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
  80832e:	0f b7 c9             	movzwl %cx,%ecx
  808331:	29 cb                	sub    %ecx,%ebx
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  808333:	85 db                	test   %ebx,%ebx
  808335:	0f 8e 63 01 00 00    	jle    80849e <pbuf_alloc+0x28b>
  80833b:	89 f7                	mov    %esi,%edi
      q = memp_malloc(MEMP_PBUF_POOL);
  80833d:	c7 04 24 0d 00 00 00 	movl   $0xd,(%esp)
  808344:	e8 bb f4 ff ff       	call   807804 <memp_malloc>
      if (q == NULL) {
  808349:	85 c0                	test   %eax,%eax
  80834b:	75 12                	jne    80835f <pbuf_alloc+0x14c>
        /* free chain so far allocated */
        pbuf_free(p);
  80834d:	89 34 24             	mov    %esi,(%esp)
  808350:	e8 03 fc ff ff       	call   807f58 <pbuf_free>
  808355:	be 00 00 00 00       	mov    $0x0,%esi
        /* bail out unsuccesfully */
        return NULL;
  80835a:	e9 49 01 00 00       	jmp    8084a8 <pbuf_alloc+0x295>
      }
      q->type = type;
  80835f:	c6 40 0c 03          	movb   $0x3,0xc(%eax)
      q->flags = 0;
  808363:	c6 40 0d 00          	movb   $0x0,0xd(%eax)
      q->next = NULL;
  808367:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
      /* make previous pbuf point to this pbuf */
      r->next = q;
  80836d:	89 07                	mov    %eax,(%edi)
      /* set total length of this pbuf and next in chain */
      LWIP_ASSERT("rem_len < max_u16_t", rem_len < 0xffff);
  80836f:	81 fb fe ff 00 00    	cmp    $0xfffe,%ebx
  808375:	7e 1c                	jle    808393 <pbuf_alloc+0x180>
  808377:	c7 44 24 08 77 3a 81 	movl   $0x813a77,0x8(%esp)
  80837e:	00 
  80837f:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  808386:	00 
  808387:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  80838e:	e8 41 86 ff ff       	call   8009d4 <_panic>
      q->tot_len = (u16_t)rem_len;
  808393:	66 89 58 08          	mov    %bx,0x8(%eax)
      /* this pbuf length is pool size, unless smaller sized tail */
      q->len = LWIP_MIN((u16_t)rem_len, PBUF_POOL_BUFSIZE_ALIGNED);
  808397:	89 da                	mov    %ebx,%edx
  808399:	66 81 fb cf 07       	cmp    $0x7cf,%bx
  80839e:	76 05                	jbe    8083a5 <pbuf_alloc+0x192>
  8083a0:	ba d0 07 00 00       	mov    $0x7d0,%edx
  8083a5:	66 89 50 0a          	mov    %dx,0xa(%eax)
      q->payload = (void *)((u8_t *)q + SIZEOF_STRUCT_PBUF);
  8083a9:	8d 48 10             	lea    0x10(%eax),%ecx
  8083ac:	89 48 04             	mov    %ecx,0x4(%eax)
      LWIP_ASSERT("pbuf_alloc: pbuf q->payload properly aligned",
  8083af:	f6 c1 03             	test   $0x3,%cl
  8083b2:	74 1c                	je     8083d0 <pbuf_alloc+0x1bd>
  8083b4:	c7 44 24 08 e8 38 81 	movl   $0x8138e8,0x8(%esp)
  8083bb:	00 
  8083bc:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  8083c3:	00 
  8083c4:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  8083cb:	e8 04 86 ff ff       	call   8009d4 <_panic>
              ((mem_ptr_t)q->payload % MEM_ALIGNMENT) == 0);
      LWIP_ASSERT("check p->payload + p->len does not overflow pbuf",
  8083d0:	0f b7 4e 0a          	movzwl 0xa(%esi),%ecx
  8083d4:	03 4e 04             	add    0x4(%esi),%ecx
  8083d7:	39 4d e4             	cmp    %ecx,-0x1c(%ebp)
  8083da:	73 1c                	jae    8083f8 <pbuf_alloc+0x1e5>
  8083dc:	c7 44 24 08 b4 38 81 	movl   $0x8138b4,0x8(%esp)
  8083e3:	00 
  8083e4:	c7 44 24 04 c5 00 00 	movl   $0xc5,0x4(%esp)
  8083eb:	00 
  8083ec:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  8083f3:	e8 dc 85 ff ff       	call   8009d4 <_panic>
                  ((u8_t*)p->payload + p->len <=
                   (u8_t*)p + SIZEOF_STRUCT_PBUF + PBUF_POOL_BUFSIZE_ALIGNED));
      q->ref = 1;
  8083f8:	66 c7 40 0e 01 00    	movw   $0x1,0xe(%eax)
      /* calculate remaining length to be allocated */
      rem_len -= q->len;
  8083fe:	0f b7 d2             	movzwl %dx,%edx
  808401:	29 d3                	sub    %edx,%ebx
    /* remember first pbuf for linkage in next iteration */
    r = p;
    /* remaining length to be allocated */
    rem_len = length - p->len;
    /* any remaining pbufs to be allocated? */
    while (rem_len > 0) {
  808403:	85 db                	test   %ebx,%ebx
  808405:	0f 8e 93 00 00 00    	jle    80849e <pbuf_alloc+0x28b>
  80840b:	89 c7                	mov    %eax,%edi
  80840d:	e9 2b ff ff ff       	jmp    80833d <pbuf_alloc+0x12a>
    /*r->next = NULL;*/

    break;
  case PBUF_RAM:
    /* If pbuf is to be allocated in RAM, allocate memory for it. */
    p = (struct pbuf*)mem_malloc(LWIP_MEM_ALIGN_SIZE(SIZEOF_STRUCT_PBUF + offset) + LWIP_MEM_ALIGN_SIZE(length));
  808412:	0f b7 7d e4          	movzwl -0x1c(%ebp),%edi
  808416:	8d 57 13             	lea    0x13(%edi),%edx
  808419:	83 e2 fc             	and    $0xfffffffc,%edx
  80841c:	0f b7 c3             	movzwl %bx,%eax
  80841f:	83 c0 03             	add    $0x3,%eax
  808422:	83 e0 fc             	and    $0xfffffffc,%eax
  808425:	8d 04 02             	lea    (%edx,%eax,1),%eax
  808428:	89 04 24             	mov    %eax,(%esp)
  80842b:	e8 90 ed ff ff       	call   8071c0 <mem_malloc>
  808430:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808432:	85 c0                	test   %eax,%eax
  808434:	74 72                	je     8084a8 <pbuf_alloc+0x295>
      return NULL;
    }
    /* Set up internal structure of the pbuf. */
    p->payload = LWIP_MEM_ALIGN((void *)((u8_t *)p + SIZEOF_STRUCT_PBUF + offset));
  808436:	8d 44 38 13          	lea    0x13(%eax,%edi,1),%eax
  80843a:	83 e0 fc             	and    $0xfffffffc,%eax
  80843d:	89 46 04             	mov    %eax,0x4(%esi)
    p->len = p->tot_len = length;
  808440:	66 89 5e 08          	mov    %bx,0x8(%esi)
  808444:	66 89 5e 0a          	mov    %bx,0xa(%esi)
    p->next = NULL;
  808448:	c7 06 00 00 00 00    	movl   $0x0,(%esi)
    p->type = type;
  80844e:	c6 46 0c 00          	movb   $0x0,0xc(%esi)
  808452:	eb 4a                	jmp    80849e <pbuf_alloc+0x28b>
  /* pbuf references existing (non-volatile static constant) ROM payload? */
  case PBUF_ROM:
  /* pbuf references existing (externally allocated) RAM payload? */
  case PBUF_REF:
    /* only allocate memory for the pbuf structure */
    p = memp_malloc(MEMP_PBUF);
  808454:	c7 04 24 0c 00 00 00 	movl   $0xc,(%esp)
  80845b:	e8 a4 f3 ff ff       	call   807804 <memp_malloc>
  808460:	89 c6                	mov    %eax,%esi
    if (p == NULL) {
  808462:	85 c0                	test   %eax,%eax
  808464:	74 42                	je     8084a8 <pbuf_alloc+0x295>
      LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 2, ("pbuf_alloc: Could not allocate MEMP_PBUF for PBUF_%s.\n",
                  (type == PBUF_ROM) ? "ROM" : "REF"));
      return NULL;
    }
    /* caller must set this field properly, afterwards */
    p->payload = NULL;
  808466:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)
    p->len = p->tot_len = length;
  80846d:	66 89 58 08          	mov    %bx,0x8(%eax)
  808471:	66 89 58 0a          	mov    %bx,0xa(%eax)
    p->next = NULL;
  808475:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    p->type = type;
  80847b:	89 f8                	mov    %edi,%eax
  80847d:	88 46 0c             	mov    %al,0xc(%esi)
    break;
  808480:	eb 1c                	jmp    80849e <pbuf_alloc+0x28b>
  default:
    LWIP_ASSERT("pbuf_alloc: erroneous type", 0);
  808482:	c7 44 24 08 8b 3a 81 	movl   $0x813a8b,0x8(%esp)
  808489:	00 
  80848a:	c7 44 24 04 f1 00 00 	movl   $0xf1,0x4(%esp)
  808491:	00 
  808492:	c7 04 24 15 39 81 00 	movl   $0x813915,(%esp)
  808499:	e8 36 85 ff ff       	call   8009d4 <_panic>
    return NULL;
  }
  /* set reference count */
  p->ref = 1;
  80849e:	66 c7 46 0e 01 00    	movw   $0x1,0xe(%esi)
  /* set flags */
  p->flags = 0;
  8084a4:	c6 46 0d 00          	movb   $0x0,0xd(%esi)
  LWIP_DEBUGF(PBUF_DEBUG | LWIP_DBG_TRACE | 3, ("pbuf_alloc(length=%"U16_F") == %p\n", length, (void *)p));
  return p;
}
  8084a8:	89 f0                	mov    %esi,%eax
  8084aa:	83 c4 2c             	add    $0x2c,%esp
  8084ad:	5b                   	pop    %ebx
  8084ae:	5e                   	pop    %esi
  8084af:	5f                   	pop    %edi
  8084b0:	5d                   	pop    %ebp
  8084b1:	c3                   	ret    
	...

008084c0 <sswt_handler>:
 *
 * @param arg struct sswt_cb* used to signal a semaphore and end waiting.
 */
static void
sswt_handler(void *arg)
{
  8084c0:	55                   	push   %ebp
  8084c1:	89 e5                	mov    %esp,%ebp
  8084c3:	83 ec 18             	sub    $0x18,%esp
  8084c6:	8b 45 08             	mov    0x8(%ebp),%eax
  struct sswt_cb *sswt_cb = (struct sswt_cb *) arg;

  /* Timeout. Set flag to TRUE and signal semaphore */
  sswt_cb->timeflag = 1;
  8084c9:	66 c7 00 01 00       	movw   $0x1,(%eax)
  sys_sem_signal(*(sswt_cb->psem));
  8084ce:	8b 40 04             	mov    0x4(%eax),%eax
  8084d1:	8b 00                	mov    (%eax),%eax
  8084d3:	89 04 24             	mov    %eax,(%esp)
  8084d6:	e8 4c 57 00 00       	call   80dc27 <sys_sem_signal>
}
  8084db:	c9                   	leave  
  8084dc:	c3                   	ret    

008084dd <sys_untimeout>:
 * @param h callback function that would be called by the timeout
 * @param arg callback argument that would be passed to h
*/
void
sys_untimeout(sys_timeout_handler h, void *arg)
{
  8084dd:	55                   	push   %ebp
  8084de:	89 e5                	mov    %esp,%ebp
  8084e0:	57                   	push   %edi
  8084e1:	56                   	push   %esi
  8084e2:	53                   	push   %ebx
  8084e3:	83 ec 1c             	sub    $0x1c,%esp
  8084e6:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8084e9:	8b 75 0c             	mov    0xc(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *prev_t, *t;

  timeouts = sys_arch_timeouts();
  8084ec:	e8 0e 52 00 00       	call   80d6ff <sys_arch_timeouts>

  if (timeouts == NULL) {
  8084f1:	85 c0                	test   %eax,%eax
  8084f3:	75 1c                	jne    808511 <sys_untimeout+0x34>
    LWIP_ASSERT("sys_untimeout: timeouts != NULL", timeouts != NULL);
  8084f5:	c7 44 24 08 a8 3a 81 	movl   $0x813aa8,0x8(%esp)
  8084fc:	00 
  8084fd:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  808504:	00 
  808505:	c7 04 24 c8 3a 81 00 	movl   $0x813ac8,(%esp)
  80850c:	e8 c3 84 ff ff       	call   8009d4 <_panic>
    return;
  }
  if (timeouts->next == NULL) {
  808511:	8b 10                	mov    (%eax),%edx
  808513:	85 d2                	test   %edx,%edx
  808515:	74 4b                	je     808562 <sys_untimeout+0x85>
  808517:	bf 00 00 00 00       	mov    $0x0,%edi
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
    if ((t->h == h) && (t->arg == arg)) {
  80851c:	39 5a 08             	cmp    %ebx,0x8(%edx)
  80851f:	75 33                	jne    808554 <sys_untimeout+0x77>
  808521:	39 72 0c             	cmp    %esi,0xc(%edx)
  808524:	75 2e                	jne    808554 <sys_untimeout+0x77>
      /* We have a match */
      /* Unlink from previous in list */
      if (prev_t == NULL)
  808526:	85 ff                	test   %edi,%edi
  808528:	75 08                	jne    808532 <sys_untimeout+0x55>
        timeouts->next = t->next;
  80852a:	8b 0a                	mov    (%edx),%ecx
  80852c:	89 08                	mov    %ecx,(%eax)
  80852e:	66 90                	xchg   %ax,%ax
  808530:	eb 04                	jmp    808536 <sys_untimeout+0x59>
      else
        prev_t->next = t->next;
  808532:	8b 02                	mov    (%edx),%eax
  808534:	89 07                	mov    %eax,(%edi)
      /* If not the last one, add time of this one back to next */
      if (t->next != NULL)
  808536:	8b 02                	mov    (%edx),%eax
  808538:	85 c0                	test   %eax,%eax
  80853a:	74 06                	je     808542 <sys_untimeout+0x65>
        t->next->time += t->time;
  80853c:	8b 4a 04             	mov    0x4(%edx),%ecx
  80853f:	01 48 04             	add    %ecx,0x4(%eax)
      memp_free(MEMP_SYS_TIMEOUT, t);
  808542:	89 54 24 04          	mov    %edx,0x4(%esp)
  808546:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80854d:	e8 6e f2 ff ff       	call   8077c0 <memp_free>
      return;
  808552:	eb 0e                	jmp    808562 <sys_untimeout+0x85>
  }
  if (timeouts->next == NULL) {
    return;
  }

  for (t = timeouts->next, prev_t = NULL; t != NULL; prev_t = t, t = t->next) {
  808554:	8b 0a                	mov    (%edx),%ecx
  808556:	85 c9                	test   %ecx,%ecx
  808558:	74 08                	je     808562 <sys_untimeout+0x85>
  80855a:	89 d7                	mov    %edx,%edi
  80855c:	89 ca                	mov    %ecx,%edx
  80855e:	66 90                	xchg   %ax,%ax
  808560:	eb ba                	jmp    80851c <sys_untimeout+0x3f>
      memp_free(MEMP_SYS_TIMEOUT, t);
      return;
    }
  }
  return;
}
  808562:	83 c4 1c             	add    $0x1c,%esp
  808565:	5b                   	pop    %ebx
  808566:	5e                   	pop    %esi
  808567:	5f                   	pop    %edi
  808568:	5d                   	pop    %ebp
  808569:	c3                   	ret    

0080856a <sys_timeout>:
 * @param h callback function to call when msecs have elapsed
 * @param arg argument to pass to the callback function
 */
void
sys_timeout(u32_t msecs, sys_timeout_handler h, void *arg)
{
  80856a:	55                   	push   %ebp
  80856b:	89 e5                	mov    %esp,%ebp
  80856d:	56                   	push   %esi
  80856e:	53                   	push   %ebx
  80856f:	83 ec 10             	sub    $0x10,%esp
  808572:	8b 75 08             	mov    0x8(%ebp),%esi
  struct sys_timeouts *timeouts;
  struct sys_timeo *timeout, *t;

  timeout = memp_malloc(MEMP_SYS_TIMEOUT);
  808575:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  80857c:	e8 83 f2 ff ff       	call   807804 <memp_malloc>
  808581:	89 c3                	mov    %eax,%ebx
  if (timeout == NULL) {
  808583:	85 c0                	test   %eax,%eax
  808585:	75 1c                	jne    8085a3 <sys_timeout+0x39>
    LWIP_ASSERT("sys_timeout: timeout != NULL", timeout != NULL);
  808587:	c7 44 24 08 dc 3a 81 	movl   $0x813adc,0x8(%esp)
  80858e:	00 
  80858f:	c7 44 24 04 c3 00 00 	movl   $0xc3,0x4(%esp)
  808596:	00 
  808597:	c7 04 24 c8 3a 81 00 	movl   $0x813ac8,(%esp)
  80859e:	e8 31 84 ff ff       	call   8009d4 <_panic>
    return;
  }
  timeout->next = NULL;
  8085a3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
  timeout->h = h;
  8085a9:	8b 45 0c             	mov    0xc(%ebp),%eax
  8085ac:	89 43 08             	mov    %eax,0x8(%ebx)
  timeout->arg = arg;
  8085af:	8b 45 10             	mov    0x10(%ebp),%eax
  8085b2:	89 43 0c             	mov    %eax,0xc(%ebx)
  timeout->time = msecs;
  8085b5:	89 73 04             	mov    %esi,0x4(%ebx)

  timeouts = sys_arch_timeouts();
  8085b8:	e8 42 51 00 00       	call   80d6ff <sys_arch_timeouts>

  LWIP_DEBUGF(SYS_DEBUG, ("sys_timeout: %p msecs=%"U32_F" h=%p arg=%p\n",
    (void *)timeout, msecs, (void*)&h, (void *)arg));

  if (timeouts == NULL) {
  8085bd:	85 c0                	test   %eax,%eax
  8085bf:	75 1c                	jne    8085dd <sys_timeout+0x73>
    LWIP_ASSERT("sys_timeout: timeouts != NULL", timeouts != NULL);
  8085c1:	c7 44 24 08 f9 3a 81 	movl   $0x813af9,0x8(%esp)
  8085c8:	00 
  8085c9:	c7 44 24 04 d1 00 00 	movl   $0xd1,0x4(%esp)
  8085d0:	00 
  8085d1:	c7 04 24 c8 3a 81 00 	movl   $0x813ac8,(%esp)
  8085d8:	e8 f7 83 ff ff       	call   8009d4 <_panic>
    return;
  }

  if (timeouts->next == NULL) {
  8085dd:	8b 10                	mov    (%eax),%edx
  8085df:	85 d2                	test   %edx,%edx
  8085e1:	75 04                	jne    8085e7 <sys_timeout+0x7d>
    timeouts->next = timeout;
  8085e3:	89 18                	mov    %ebx,(%eax)
    return;
  8085e5:	eb 4c                	jmp    808633 <sys_timeout+0xc9>
  }

  if (timeouts->next->time > msecs) {
  8085e7:	8b 4a 04             	mov    0x4(%edx),%ecx
  8085ea:	39 ce                	cmp    %ecx,%esi
  8085ec:	73 2d                	jae    80861b <sys_timeout+0xb1>
    timeouts->next->time -= msecs;
  8085ee:	29 f1                	sub    %esi,%ecx
  8085f0:	89 4a 04             	mov    %ecx,0x4(%edx)
    timeout->next = timeouts->next;
  8085f3:	8b 10                	mov    (%eax),%edx
  8085f5:	89 13                	mov    %edx,(%ebx)
    timeouts->next = timeout;
  8085f7:	89 18                	mov    %ebx,(%eax)
  8085f9:	eb 38                	jmp    808633 <sys_timeout+0xc9>
  8085fb:	89 c2                	mov    %eax,%edx
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  8085fd:	8b 73 04             	mov    0x4(%ebx),%esi
  808600:	2b 70 04             	sub    0x4(%eax),%esi
  808603:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808606:	8b 00                	mov    (%eax),%eax
  808608:	85 c0                	test   %eax,%eax
  80860a:	74 07                	je     808613 <sys_timeout+0xa9>
  80860c:	3b 70 04             	cmp    0x4(%eax),%esi
  80860f:	73 ea                	jae    8085fb <sys_timeout+0x91>
  808611:	eb 1b                	jmp    80862e <sys_timeout+0xc4>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
        }
        timeout->next = t->next;
  808613:	8b 02                	mov    (%edx),%eax
  808615:	89 03                	mov    %eax,(%ebx)
        t->next = timeout;
  808617:	89 1a                	mov    %ebx,(%edx)
  808619:	eb 18                	jmp    808633 <sys_timeout+0xc9>
    timeouts->next->time -= msecs;
    timeout->next = timeouts->next;
    timeouts->next = timeout;
  } else {
    for(t = timeouts->next; t != NULL; t = t->next) {
      timeout->time -= t->time;
  80861b:	8b 73 04             	mov    0x4(%ebx),%esi
  80861e:	29 ce                	sub    %ecx,%esi
  808620:	89 73 04             	mov    %esi,0x4(%ebx)
      if (t->next == NULL || t->next->time > timeout->time) {
  808623:	8b 02                	mov    (%edx),%eax
  808625:	85 c0                	test   %eax,%eax
  808627:	74 ea                	je     808613 <sys_timeout+0xa9>
  808629:	3b 70 04             	cmp    0x4(%eax),%esi
  80862c:	73 cd                	jae    8085fb <sys_timeout+0x91>
        if (t->next != NULL) {
          t->next->time -= timeout->time;
  80862e:	29 70 04             	sub    %esi,0x4(%eax)
  808631:	eb e0                	jmp    808613 <sys_timeout+0xa9>
        t->next = timeout;
        break;
      }
    }
  }
}
  808633:	83 c4 10             	add    $0x10,%esp
  808636:	5b                   	pop    %ebx
  808637:	5e                   	pop    %esi
  808638:	5d                   	pop    %ebp
  808639:	c3                   	ret    

0080863a <sys_sem_wait>:
 *
 * @param sem semaphore to wait for
 */
void
sys_sem_wait(sys_sem_t sem)
{
  80863a:	55                   	push   %ebp
  80863b:	89 e5                	mov    %esp,%ebp
  80863d:	57                   	push   %edi
  80863e:	56                   	push   %esi
  80863f:	53                   	push   %ebx
  808640:	83 ec 1c             	sub    $0x1c,%esp
  808643:	8b 7d 08             	mov    0x8(%ebp),%edi
  sys_timeout_handler h;
  void *arg;

 again:

  timeouts = sys_arch_timeouts();
  808646:	e8 b4 50 00 00       	call   80d6ff <sys_arch_timeouts>
  80864b:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80864d:	85 c0                	test   %eax,%eax
  80864f:	74 06                	je     808657 <sys_sem_wait+0x1d>
  808651:	8b 00                	mov    (%eax),%eax
  808653:	85 c0                	test   %eax,%eax
  808655:	75 12                	jne    808669 <sys_sem_wait+0x2f>
    sys_arch_sem_wait(sem, 0);
  808657:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80865e:	00 
  80865f:	89 3c 24             	mov    %edi,(%esp)
  808662:	e8 cf 52 00 00       	call   80d936 <sys_arch_sem_wait>

 again:

  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  808667:	eb 58                	jmp    8086c1 <sys_sem_wait+0x87>
    sys_arch_sem_wait(sem, 0);
  } else {
    if (timeouts->next->time > 0) {
  808669:	8b 40 04             	mov    0x4(%eax),%eax
  80866c:	85 c0                	test   %eax,%eax
  80866e:	74 11                	je     808681 <sys_sem_wait+0x47>
      time_needed = sys_arch_sem_wait(sem, timeouts->next->time);
  808670:	89 44 24 04          	mov    %eax,0x4(%esp)
  808674:	89 3c 24             	mov    %edi,(%esp)
  808677:	e8 ba 52 00 00       	call   80d936 <sys_arch_sem_wait>
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  80867c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80867f:	75 29                	jne    8086aa <sys_sem_wait+0x70>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
        could be fetched. We should now call the timeout handler and
        deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  808681:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  808683:	8b 10                	mov    (%eax),%edx
  808685:	89 13                	mov    %edx,(%ebx)
      h = tmptimeout->h;
  808687:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  80868a:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  80868d:	89 44 24 04          	mov    %eax,0x4(%esp)
  808691:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  808698:	e8 23 f1 ff ff       	call   8077c0 <memp_free>
      if (h != NULL) {
  80869d:	85 db                	test   %ebx,%ebx
  80869f:	74 a5                	je     808646 <sys_sem_wait+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("ssw h=%p(%p)\n", (void*)&h, (void *)arg));
        h(arg);
  8086a1:	89 34 24             	mov    %esi,(%esp)
  8086a4:	ff d3                	call   *%ebx
  8086a6:	66 90                	xchg   %ax,%ax
  8086a8:	eb 9c                	jmp    808646 <sys_sem_wait+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8086aa:	8b 13                	mov    (%ebx),%edx
  8086ac:	8b 4a 04             	mov    0x4(%edx),%ecx
  8086af:	39 c8                	cmp    %ecx,%eax
  8086b1:	73 07                	jae    8086ba <sys_sem_wait+0x80>
        timeouts->next->time -= time_needed;
  8086b3:	29 c1                	sub    %eax,%ecx
  8086b5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8086b8:	eb 07                	jmp    8086c1 <sys_sem_wait+0x87>
      } else {
        timeouts->next->time = 0;
  8086ba:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8086c1:	83 c4 1c             	add    $0x1c,%esp
  8086c4:	5b                   	pop    %ebx
  8086c5:	5e                   	pop    %esi
  8086c6:	5f                   	pop    %edi
  8086c7:	5d                   	pop    %ebp
  8086c8:	c3                   	ret    

008086c9 <sys_sem_wait_timeout>:
 * @param timeout timeout in ms (0: wait forever)
 * @return 0 on timeout, 1 otherwise
 */
int
sys_sem_wait_timeout(sys_sem_t sem, u32_t timeout)
{
  8086c9:	55                   	push   %ebp
  8086ca:	89 e5                	mov    %esp,%ebp
  8086cc:	83 ec 28             	sub    $0x28,%esp
  8086cf:	8b 45 0c             	mov    0xc(%ebp),%eax
  struct sswt_cb sswt_cb;

  sswt_cb.psem = &sem;
  8086d2:	8d 55 08             	lea    0x8(%ebp),%edx
  8086d5:	89 55 f4             	mov    %edx,-0xc(%ebp)
  sswt_cb.timeflag = 0;
  8086d8:	66 c7 45 f0 00 00    	movw   $0x0,-0x10(%ebp)

  /* If timeout is zero, then just wait forever */
  if (timeout > 0) {
  8086de:	85 c0                	test   %eax,%eax
  8086e0:	74 17                	je     8086f9 <sys_sem_wait_timeout+0x30>
    /* Create a timer and pass it the address of our flag */
    sys_timeout(timeout, sswt_handler, &sswt_cb);
  8086e2:	8d 55 f0             	lea    -0x10(%ebp),%edx
  8086e5:	89 54 24 08          	mov    %edx,0x8(%esp)
  8086e9:	c7 44 24 04 c0 84 80 	movl   $0x8084c0,0x4(%esp)
  8086f0:	00 
  8086f1:	89 04 24             	mov    %eax,(%esp)
  8086f4:	e8 71 fe ff ff       	call   80856a <sys_timeout>
  }
  sys_sem_wait(sem);
  8086f9:	8b 45 08             	mov    0x8(%ebp),%eax
  8086fc:	89 04 24             	mov    %eax,(%esp)
  8086ff:	e8 36 ff ff ff       	call   80863a <sys_sem_wait>
  /* Was it a timeout? */
  if (sswt_cb.timeflag) {
  808704:	b8 00 00 00 00       	mov    $0x0,%eax
  808709:	66 83 7d f0 00       	cmpw   $0x0,-0x10(%ebp)
  80870e:	75 18                	jne    808728 <sys_sem_wait_timeout+0x5f>
    /* timeout */
    return 0;
  } else {
    /* Not a timeout. Remove timeout entry */
    sys_untimeout(sswt_handler, &sswt_cb);
  808710:	8d 45 f0             	lea    -0x10(%ebp),%eax
  808713:	89 44 24 04          	mov    %eax,0x4(%esp)
  808717:	c7 04 24 c0 84 80 00 	movl   $0x8084c0,(%esp)
  80871e:	e8 ba fd ff ff       	call   8084dd <sys_untimeout>
  808723:	b8 01 00 00 00       	mov    $0x1,%eax
    return 1;
  }
}
  808728:	c9                   	leave  
  808729:	c3                   	ret    

0080872a <sys_msleep>:
 *
 * @param ms number of milliseconds to sleep
 */
void
sys_msleep(u32_t ms)
{
  80872a:	55                   	push   %ebp
  80872b:	89 e5                	mov    %esp,%ebp
  80872d:	53                   	push   %ebx
  80872e:	83 ec 14             	sub    $0x14,%esp
  sys_sem_t delaysem = sys_sem_new(0);
  808731:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  808738:	e8 48 53 00 00       	call   80da85 <sys_sem_new>
  80873d:	89 c3                	mov    %eax,%ebx

  sys_sem_wait_timeout(delaysem, ms);
  80873f:	8b 45 08             	mov    0x8(%ebp),%eax
  808742:	89 44 24 04          	mov    %eax,0x4(%esp)
  808746:	89 1c 24             	mov    %ebx,(%esp)
  808749:	e8 7b ff ff ff       	call   8086c9 <sys_sem_wait_timeout>

  sys_sem_free(delaysem);
  80874e:	89 1c 24             	mov    %ebx,(%esp)
  808751:	e8 8d 4e 00 00       	call   80d5e3 <sys_sem_free>
}
  808756:	83 c4 14             	add    $0x14,%esp
  808759:	5b                   	pop    %ebx
  80875a:	5d                   	pop    %ebp
  80875b:	c3                   	ret    

0080875c <sys_mbox_fetch>:
 * @param mbox the mbox to fetch the message from
 * @param msg the place to store the message
 */
void
sys_mbox_fetch(sys_mbox_t mbox, void **msg)
{
  80875c:	55                   	push   %ebp
  80875d:	89 e5                	mov    %esp,%ebp
  80875f:	57                   	push   %edi
  808760:	56                   	push   %esi
  808761:	53                   	push   %ebx
  808762:	83 ec 1c             	sub    $0x1c,%esp
  808765:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct sys_timeo *tmptimeout;
  sys_timeout_handler h;
  void *arg;

 again:
  timeouts = sys_arch_timeouts();
  808768:	e8 92 4f 00 00       	call   80d6ff <sys_arch_timeouts>
  80876d:	89 c3                	mov    %eax,%ebx

  if (!timeouts || !timeouts->next) {
  80876f:	85 c0                	test   %eax,%eax
  808771:	74 06                	je     808779 <sys_mbox_fetch+0x1d>
  808773:	8b 00                	mov    (%eax),%eax
  808775:	85 c0                	test   %eax,%eax
  808777:	75 19                	jne    808792 <sys_mbox_fetch+0x36>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
  808779:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  808780:	00 
  808781:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808785:	8b 45 08             	mov    0x8(%ebp),%eax
  808788:	89 04 24             	mov    %eax,(%esp)
  80878b:	e8 04 55 00 00       	call   80dc94 <sys_arch_mbox_fetch>
  void *arg;

 again:
  timeouts = sys_arch_timeouts();

  if (!timeouts || !timeouts->next) {
  808790:	eb 5f                	jmp    8087f1 <sys_mbox_fetch+0x95>
    UNLOCK_TCPIP_CORE();
    time_needed = sys_arch_mbox_fetch(mbox, msg, 0);
    LOCK_TCPIP_CORE();
  } else {
    if (timeouts->next->time > 0) {
  808792:	8b 40 04             	mov    0x4(%eax),%eax
  808795:	85 c0                	test   %eax,%eax
  808797:	74 18                	je     8087b1 <sys_mbox_fetch+0x55>
      UNLOCK_TCPIP_CORE();
      time_needed = sys_arch_mbox_fetch(mbox, msg, timeouts->next->time);
  808799:	89 44 24 08          	mov    %eax,0x8(%esp)
  80879d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  8087a1:	8b 45 08             	mov    0x8(%ebp),%eax
  8087a4:	89 04 24             	mov    %eax,(%esp)
  8087a7:	e8 e8 54 00 00       	call   80dc94 <sys_arch_mbox_fetch>
      LOCK_TCPIP_CORE();
    } else {
      time_needed = SYS_ARCH_TIMEOUT;
    }

    if (time_needed == SYS_ARCH_TIMEOUT) {
  8087ac:	83 f8 ff             	cmp    $0xffffffff,%eax
  8087af:	75 29                	jne    8087da <sys_mbox_fetch+0x7e>
      /* If time == SYS_ARCH_TIMEOUT, a timeout occured before a message
         could be fetched. We should now call the timeout handler and
         deallocate the memory allocated for the timeout. */
      tmptimeout = timeouts->next;
  8087b1:	8b 03                	mov    (%ebx),%eax
      timeouts->next = tmptimeout->next;
  8087b3:	8b 10                	mov    (%eax),%edx
  8087b5:	89 13                	mov    %edx,(%ebx)
      h   = tmptimeout->h;
  8087b7:	8b 58 08             	mov    0x8(%eax),%ebx
      arg = tmptimeout->arg;
  8087ba:	8b 70 0c             	mov    0xc(%eax),%esi
      memp_free(MEMP_SYS_TIMEOUT, tmptimeout);
  8087bd:	89 44 24 04          	mov    %eax,0x4(%esp)
  8087c1:	c7 04 24 0b 00 00 00 	movl   $0xb,(%esp)
  8087c8:	e8 f3 ef ff ff       	call   8077c0 <memp_free>
      if (h != NULL) {
  8087cd:	85 db                	test   %ebx,%ebx
  8087cf:	74 97                	je     808768 <sys_mbox_fetch+0xc>
        LWIP_DEBUGF(SYS_DEBUG, ("smf calling h=%p(%p)\n", (void*)&h, arg));
        h(arg);
  8087d1:	89 34 24             	mov    %esi,(%esp)
  8087d4:	ff d3                	call   *%ebx
  8087d6:	66 90                	xchg   %ax,%ax
  8087d8:	eb 8e                	jmp    808768 <sys_mbox_fetch+0xc>
      goto again;
    } else {
      /* If time != SYS_ARCH_TIMEOUT, a message was received before the timeout
         occured. The time variable is set to the number of
         milliseconds we waited for the message. */
      if (time_needed < timeouts->next->time) {
  8087da:	8b 13                	mov    (%ebx),%edx
  8087dc:	8b 4a 04             	mov    0x4(%edx),%ecx
  8087df:	39 c8                	cmp    %ecx,%eax
  8087e1:	73 07                	jae    8087ea <sys_mbox_fetch+0x8e>
        timeouts->next->time -= time_needed;
  8087e3:	29 c1                	sub    %eax,%ecx
  8087e5:	89 4a 04             	mov    %ecx,0x4(%edx)
  8087e8:	eb 07                	jmp    8087f1 <sys_mbox_fetch+0x95>
      } else {
        timeouts->next->time = 0;
  8087ea:	c7 42 04 00 00 00 00 	movl   $0x0,0x4(%edx)
      }
    }
  }
}
  8087f1:	83 c4 1c             	add    $0x1c,%esp
  8087f4:	5b                   	pop    %ebx
  8087f5:	5e                   	pop    %esi
  8087f6:	5f                   	pop    %edi
  8087f7:	5d                   	pop    %ebp
  8087f8:	c3                   	ret    
  8087f9:	00 00                	add    %al,(%eax)
  8087fb:	00 00                	add    %al,(%eax)
  8087fd:	00 00                	add    %al,(%eax)
	...

00808800 <tcp_accept_null>:
/**
 * Default accept callback if no accept callback is specified by the user.
 */
static err_t
tcp_accept_null(void *arg, struct tcp_pcb *pcb, err_t err)
{
  808800:	55                   	push   %ebp
  808801:	89 e5                	mov    %esp,%ebp
  LWIP_UNUSED_ARG(arg);
  LWIP_UNUSED_ARG(pcb);
  LWIP_UNUSED_ARG(err);

  return ERR_ABRT;
}
  808803:	b8 fb ff ff ff       	mov    $0xfffffffb,%eax
  808808:	5d                   	pop    %ebp
  808809:	c3                   	ret    

0080880a <tcp_new_port>:
 *
 * @return a new (free) local TCP port number
 */
static u16_t
tcp_new_port(void)
{
  80880a:	55                   	push   %ebp
  80880b:	89 e5                	mov    %esp,%ebp
  80880d:	57                   	push   %edi
  80880e:	56                   	push   %esi
  80880f:	53                   	push   %ebx
  808810:	83 ec 04             	sub    $0x4,%esp
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808813:	8b 0d 08 f6 b3 00    	mov    0xb3f608,%ecx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808819:	8b 1d 1c f6 b3 00    	mov    0xb3f61c,%ebx
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  80881f:	8b 35 10 f6 b3 00    	mov    0xb3f610,%esi
  808825:	0f b7 15 80 90 81 00 	movzwl 0x819080,%edx
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  80882c:	bf 00 10 00 00       	mov    $0x1000,%edi
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
  808831:	89 75 f0             	mov    %esi,-0x10(%ebp)
#define TCP_LOCAL_PORT_RANGE_END   0x7fff
#endif
  static u16_t port = TCP_LOCAL_PORT_RANGE_START;
  
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
  808834:	66 83 c2 01          	add    $0x1,%dx
  808838:	79 02                	jns    80883c <tcp_new_port+0x32>
  80883a:	89 fa                	mov    %edi,%edx
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80883c:	85 c9                	test   %ecx,%ecx
  80883e:	74 19                	je     808859 <tcp_new_port+0x4f>
    if (pcb->local_port == port) {
  808840:	89 c8                	mov    %ecx,%eax
  808842:	66 3b 51 1c          	cmp    0x1c(%ecx),%dx
  808846:	75 0a                	jne    808852 <tcp_new_port+0x48>
  808848:	eb ea                	jmp    808834 <tcp_new_port+0x2a>
  80884a:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80884e:	66 90                	xchg   %ax,%ax
  808850:	74 e2                	je     808834 <tcp_new_port+0x2a>
 again:
  if (++port > TCP_LOCAL_PORT_RANGE_END) {
    port = TCP_LOCAL_PORT_RANGE_START;
  }
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808852:	8b 40 0c             	mov    0xc(%eax),%eax
  808855:	85 c0                	test   %eax,%eax
  808857:	75 f1                	jne    80884a <tcp_new_port+0x40>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808859:	85 db                	test   %ebx,%ebx
  80885b:	74 1c                	je     808879 <tcp_new_port+0x6f>
    if (pcb->local_port == port) {
  80885d:	89 d8                	mov    %ebx,%eax
  80885f:	66 3b 53 1c          	cmp    0x1c(%ebx),%dx
  808863:	75 0d                	jne    808872 <tcp_new_port+0x68>
  808865:	eb cd                	jmp    808834 <tcp_new_port+0x2a>
  808867:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  80886b:	90                   	nop
  80886c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  808870:	74 c2                	je     808834 <tcp_new_port+0x2a>
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  808872:	8b 40 0c             	mov    0xc(%eax),%eax
  808875:	85 c0                	test   %eax,%eax
  808877:	75 ee                	jne    808867 <tcp_new_port+0x5d>
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  808879:	85 f6                	test   %esi,%esi
  80887b:	75 09                	jne    808886 <tcp_new_port+0x7c>
  80887d:	66 89 15 80 90 81 00 	mov    %dx,0x819080
  808884:	eb 23                	jmp    8088a9 <tcp_new_port+0x9f>
    if (pcb->local_port == port) {
  808886:	8b 45 f0             	mov    -0x10(%ebp),%eax
  808889:	66 3b 56 1c          	cmp    0x1c(%esi),%dx
  80888d:	75 09                	jne    808898 <tcp_new_port+0x8e>
  80888f:	90                   	nop
  808890:	eb a2                	jmp    808834 <tcp_new_port+0x2a>
  808892:	66 3b 50 1c          	cmp    0x1c(%eax),%dx
  808896:	74 9c                	je     808834 <tcp_new_port+0x2a>
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->local_port == port) {
      goto again;
    }
  }
  for(pcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs; pcb != NULL; pcb = pcb->next) {
  808898:	8b 40 0c             	mov    0xc(%eax),%eax
  80889b:	85 c0                	test   %eax,%eax
  80889d:	8d 76 00             	lea    0x0(%esi),%esi
  8088a0:	75 f0                	jne    808892 <tcp_new_port+0x88>
  8088a2:	66 89 15 80 90 81 00 	mov    %dx,0x819080
    if (pcb->local_port == port) {
      goto again;
    }
  }
  return port;
}
  8088a9:	0f b7 05 80 90 81 00 	movzwl 0x819080,%eax
  8088b0:	83 c4 04             	add    $0x4,%esp
  8088b3:	5b                   	pop    %ebx
  8088b4:	5e                   	pop    %esi
  8088b5:	5f                   	pop    %edi
  8088b6:	5d                   	pop    %ebp
  8088b7:	c3                   	ret    

008088b8 <tcp_setprio>:
 * @param pcb the tcp_pcb to manipulate
 * @param prio new priority
 */
void
tcp_setprio(struct tcp_pcb *pcb, u8_t prio)
{
  8088b8:	55                   	push   %ebp
  8088b9:	89 e5                	mov    %esp,%ebp
  pcb->prio = prio;
  8088bb:	8b 55 0c             	mov    0xc(%ebp),%edx
  8088be:	8b 45 08             	mov    0x8(%ebp),%eax
  8088c1:	88 50 14             	mov    %dl,0x14(%eax)
}
  8088c4:	5d                   	pop    %ebp
  8088c5:	c3                   	ret    

008088c6 <tcp_arg>:
 * @param pcb tcp_pcb to set the callback argument
 * @param arg void pointer argument to pass to callback functions
 */ 
void
tcp_arg(struct tcp_pcb *pcb, void *arg)
{  
  8088c6:	55                   	push   %ebp
  8088c7:	89 e5                	mov    %esp,%ebp
  pcb->callback_arg = arg;
  8088c9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8088cc:	8b 45 08             	mov    0x8(%ebp),%eax
  8088cf:	89 50 18             	mov    %edx,0x18(%eax)
}
  8088d2:	5d                   	pop    %ebp
  8088d3:	c3                   	ret    

008088d4 <tcp_recv>:
 * @param recv callback function to call for this pcb when data is received
 */ 
void
tcp_recv(struct tcp_pcb *pcb,
   err_t (* recv)(void *arg, struct tcp_pcb *tpcb, struct pbuf *p, err_t err))
{
  8088d4:	55                   	push   %ebp
  8088d5:	89 e5                	mov    %esp,%ebp
  pcb->recv = recv;
  8088d7:	8b 55 0c             	mov    0xc(%ebp),%edx
  8088da:	8b 45 08             	mov    0x8(%ebp),%eax
  8088dd:	89 90 88 00 00 00    	mov    %edx,0x88(%eax)
}
  8088e3:	5d                   	pop    %ebp
  8088e4:	c3                   	ret    

008088e5 <tcp_sent>:
 * @param sent callback function to call for this pcb when data is successfully sent
 */ 
void
tcp_sent(struct tcp_pcb *pcb,
   err_t (* sent)(void *arg, struct tcp_pcb *tpcb, u16_t len))
{
  8088e5:	55                   	push   %ebp
  8088e6:	89 e5                	mov    %esp,%ebp
  pcb->sent = sent;
  8088e8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8088eb:	8b 45 08             	mov    0x8(%ebp),%eax
  8088ee:	89 90 84 00 00 00    	mov    %edx,0x84(%eax)
}
  8088f4:	5d                   	pop    %ebp
  8088f5:	c3                   	ret    

008088f6 <tcp_err>:
 *        has occured on the connection
 */ 
void
tcp_err(struct tcp_pcb *pcb,
   void (* errf)(void *arg, err_t err))
{
  8088f6:	55                   	push   %ebp
  8088f7:	89 e5                	mov    %esp,%ebp
  pcb->errf = errf;
  8088f9:	8b 55 0c             	mov    0xc(%ebp),%edx
  8088fc:	8b 45 08             	mov    0x8(%ebp),%eax
  8088ff:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
}
  808905:	5d                   	pop    %ebp
  808906:	c3                   	ret    

00808907 <tcp_accept>:
 *        connection has been connected to another host
 */ 
void
tcp_accept(struct tcp_pcb *pcb,
     err_t (* accept)(void *arg, struct tcp_pcb *newpcb, err_t err))
{
  808907:	55                   	push   %ebp
  808908:	89 e5                	mov    %esp,%ebp
  ((struct tcp_pcb_listen *)pcb)->accept = accept;
  80890a:	8b 55 0c             	mov    0xc(%ebp),%edx
  80890d:	8b 45 08             	mov    0x8(%ebp),%eax
  808910:	89 50 20             	mov    %edx,0x20(%eax)
}
  808913:	5d                   	pop    %ebp
  808914:	c3                   	ret    

00808915 <tcp_poll>:
 *
 */ 
void
tcp_poll(struct tcp_pcb *pcb,
   err_t (* poll)(void *arg, struct tcp_pcb *tpcb), u8_t interval)
{
  808915:	55                   	push   %ebp
  808916:	89 e5                	mov    %esp,%ebp
  808918:	8b 45 08             	mov    0x8(%ebp),%eax
#if LWIP_CALLBACK_API
  pcb->poll = poll;
  80891b:	8b 55 0c             	mov    0xc(%ebp),%edx
  80891e:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
#endif /* LWIP_CALLBACK_API */  
  pcb->pollinterval = interval;
  808924:	8b 55 10             	mov    0x10(%ebp),%edx
  808927:	88 50 31             	mov    %dl,0x31(%eax)
}
  80892a:	5d                   	pop    %ebp
  80892b:	c3                   	ret    

0080892c <tcp_next_iss>:
 *
 * @return u32_t pseudo random sequence number
 */
u32_t
tcp_next_iss(void)
{
  80892c:	55                   	push   %ebp
  80892d:	89 e5                	mov    %esp,%ebp
  static u32_t iss = 6510;
  
  iss += tcp_ticks;       /* XXX */
  80892f:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  808934:	03 05 7c 90 81 00    	add    0x81907c,%eax
  80893a:	a3 7c 90 81 00       	mov    %eax,0x81907c
  return iss;
}
  80893f:	5d                   	pop    %ebp
  808940:	c3                   	ret    

00808941 <tcp_eff_send_mss>:
 * by using ip_route to determin the netif used to send to the address and
 * calculating the minimum of TCP_MSS and that netif's mtu (if set).
 */
u16_t
tcp_eff_send_mss(u16_t sendmss, struct ip_addr *addr)
{
  808941:	55                   	push   %ebp
  808942:	89 e5                	mov    %esp,%ebp
  808944:	53                   	push   %ebx
  808945:	83 ec 14             	sub    $0x14,%esp
  808948:	0f b7 5d 08          	movzwl 0x8(%ebp),%ebx
  u16_t mss_s;
  struct netif *outif;

  outif = ip_route(addr);
  80894c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80894f:	89 04 24             	mov    %eax,(%esp)
  808952:	e8 ea 11 00 00       	call   809b41 <ip_route>
  if ((outif != NULL) && (outif->mtu != 0)) {
  808957:	85 c0                	test   %eax,%eax
  808959:	74 13                	je     80896e <tcp_eff_send_mss+0x2d>
  80895b:	0f b7 40 2c          	movzwl 0x2c(%eax),%eax
  80895f:	66 85 c0             	test   %ax,%ax
  808962:	74 0a                	je     80896e <tcp_eff_send_mss+0x2d>
    mss_s = outif->mtu - IP_HLEN - TCP_HLEN;
    /* RFC 1122, chap 4.2.2.6:
     * Eff.snd.MSS = min(SendMSS+20, MMS_S) - TCPhdrsize - IPoptionsize
     * but we only send options with SYN and that is never filled with data! */
    sendmss = LWIP_MIN(sendmss, mss_s);
  808964:	83 e8 28             	sub    $0x28,%eax
  808967:	66 39 c3             	cmp    %ax,%bx
  80896a:	76 02                	jbe    80896e <tcp_eff_send_mss+0x2d>
  80896c:	89 c3                	mov    %eax,%ebx
  }
  return sendmss;
}
  80896e:	89 d8                	mov    %ebx,%eax
  808970:	83 c4 14             	add    $0x14,%esp
  808973:	5b                   	pop    %ebx
  808974:	5d                   	pop    %ebp
  808975:	c3                   	ret    

00808976 <tcp_recved>:
 * @param pcb the tcp_pcb for which data is read
 * @param len the amount of bytes that have been read by the application
 */
void
tcp_recved(struct tcp_pcb *pcb, u16_t len)
{
  808976:	55                   	push   %ebp
  808977:	89 e5                	mov    %esp,%ebp
  808979:	83 ec 18             	sub    $0x18,%esp
  80897c:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80897f:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808982:	8b 45 08             	mov    0x8(%ebp),%eax
  808985:	0f b7 4d 0c          	movzwl 0xc(%ebp),%ecx
  if ((u32_t)pcb->rcv_wnd + len > TCP_WND) {
  808989:	0f b7 50 28          	movzwl 0x28(%eax),%edx
  80898d:	0f b7 f1             	movzwl %cx,%esi
  808990:	0f b7 da             	movzwl %dx,%ebx
  808993:	8d 1c 1e             	lea    (%esi,%ebx,1),%ebx
  808996:	81 fb c0 5d 00 00    	cmp    $0x5dc0,%ebx
  80899c:	76 0e                	jbe    8089ac <tcp_recved+0x36>
    pcb->rcv_wnd = TCP_WND;
  80899e:	66 c7 40 28 c0 5d    	movw   $0x5dc0,0x28(%eax)
    pcb->rcv_ann_wnd = TCP_WND;
  8089a4:	66 c7 40 2a c0 5d    	movw   $0x5dc0,0x2a(%eax)
  8089aa:	eb 11                	jmp    8089bd <tcp_recved+0x47>
  } else {
    pcb->rcv_wnd += len;
  8089ac:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  8089af:	66 89 50 28          	mov    %dx,0x28(%eax)
    if (pcb->rcv_wnd >= pcb->mss) {
  8089b3:	66 3b 50 34          	cmp    0x34(%eax),%dx
  8089b7:	72 04                	jb     8089bd <tcp_recved+0x47>
      pcb->rcv_ann_wnd = pcb->rcv_wnd;
  8089b9:	66 89 50 2a          	mov    %dx,0x2a(%eax)
    }
  }

  if (!(pcb->flags & TF_ACK_DELAY) &&
  8089bd:	0f b6 50 20          	movzbl 0x20(%eax),%edx
  8089c1:	f6 c2 03             	test   $0x3,%dl
  8089c4:	75 20                	jne    8089e6 <tcp_recved+0x70>
     * two ACKs being sent for each received packet in some limited cases
     * (where the application is only receiving data, and is slow to
     * process it) but it is necessary to guarantee that the sender can
     * continue to transmit.
     */
    tcp_ack(pcb);
  8089c6:	f6 c2 01             	test   $0x1,%dl
  8089c9:	74 13                	je     8089de <tcp_recved+0x68>
  8089cb:	83 e2 fe             	and    $0xfffffffe,%edx
  8089ce:	83 ca 02             	or     $0x2,%edx
  8089d1:	88 50 20             	mov    %dl,0x20(%eax)
  8089d4:	89 04 24             	mov    %eax,(%esp)
  8089d7:	e8 ff 29 00 00       	call   80b3db <tcp_output>
  8089dc:	eb 23                	jmp    808a01 <tcp_recved+0x8b>
  8089de:	83 ca 01             	or     $0x1,%edx
  8089e1:	88 50 20             	mov    %dl,0x20(%eax)
  8089e4:	eb 1b                	jmp    808a01 <tcp_recved+0x8b>
  } 
  else if (pcb->flags & TF_ACK_DELAY && pcb->rcv_wnd >= TCP_WND/2) {
  8089e6:	f6 c2 01             	test   $0x1,%dl
  8089e9:	74 16                	je     808a01 <tcp_recved+0x8b>
  8089eb:	66 81 78 28 df 2e    	cmpw   $0x2edf,0x28(%eax)
  8089f1:	76 0e                	jbe    808a01 <tcp_recved+0x8b>
     * nagle-like in its goals, and tries to hit a compromise between
     * sending acks each time the window is updated, and only sending
     * window updates when a timer expires.  The "threshold" used
     * above (currently TCP_WND/2) can be tuned to be more or less
     * aggressive  */
    tcp_ack_now(pcb);
  8089f3:	83 ca 02             	or     $0x2,%edx
  8089f6:	88 50 20             	mov    %dl,0x20(%eax)
  8089f9:	89 04 24             	mov    %eax,(%esp)
  8089fc:	e8 da 29 00 00       	call   80b3db <tcp_output>
  }

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_recved: recveived %"U16_F" bytes, wnd %"U16_F" (%"U16_F").\n",
         len, pcb->rcv_wnd, TCP_WND - pcb->rcv_wnd));
}
  808a01:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808a04:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808a07:	89 ec                	mov    %ebp,%esp
  808a09:	5d                   	pop    %ebp
  808a0a:	c3                   	ret    

00808a0b <tcp_fasttmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_fasttmr(void)
{
  808a0b:	55                   	push   %ebp
  808a0c:	89 e5                	mov    %esp,%ebp
  808a0e:	53                   	push   %ebx
  808a0f:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808a12:	8b 1d 08 f6 b3 00    	mov    0xb3f608,%ebx
  808a18:	85 db                	test   %ebx,%ebx
  808a1a:	74 6c                	je     808a88 <tcp_fasttmr+0x7d>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  808a1c:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808a22:	85 c0                	test   %eax,%eax
  808a24:	74 41                	je     808a67 <tcp_fasttmr+0x5c>
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808a26:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  808a2c:	85 d2                	test   %edx,%edx
  808a2e:	74 1e                	je     808a4e <tcp_fasttmr+0x43>
  808a30:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  808a37:	00 
  808a38:	89 44 24 08          	mov    %eax,0x8(%esp)
  808a3c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808a40:	8b 43 18             	mov    0x18(%ebx),%eax
  808a43:	89 04 24             	mov    %eax,(%esp)
  808a46:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  808a48:	84 c0                	test   %al,%al
  808a4a:	75 1b                	jne    808a67 <tcp_fasttmr+0x5c>
  808a4c:	eb 0f                	jmp    808a5d <tcp_fasttmr+0x52>
    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      err_t err;
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_fasttmr: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  808a4e:	89 04 24             	mov    %eax,(%esp)
  808a51:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  808a58:	e8 fb f4 ff ff       	call   807f58 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  808a5d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808a64:	00 00 00 
      }
    }

    /* send delayed ACKs */  
    if (pcb->flags & TF_ACK_DELAY) {
  808a67:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  808a6b:	a8 01                	test   $0x1,%al
  808a6d:	74 12                	je     808a81 <tcp_fasttmr+0x76>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
  808a6f:	83 c8 02             	or     $0x2,%eax
  808a72:	88 43 20             	mov    %al,0x20(%ebx)
  808a75:	89 1c 24             	mov    %ebx,(%esp)
  808a78:	e8 5e 29 00 00       	call   80b3db <tcp_output>
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  808a7d:	80 63 20 fc          	andb   $0xfc,0x20(%ebx)
void
tcp_fasttmr(void)
{
  struct tcp_pcb *pcb;

  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  808a81:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  808a84:	85 db                	test   %ebx,%ebx
  808a86:	75 94                	jne    808a1c <tcp_fasttmr+0x11>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_fasttmr: delayed ACK\n"));
      tcp_ack_now(pcb);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }
  }
}
  808a88:	83 c4 14             	add    $0x14,%esp
  808a8b:	5b                   	pop    %ebx
  808a8c:	5d                   	pop    %ebp
  808a8d:	c3                   	ret    

00808a8e <tcp_seg_copy>:
 * @param seg the old tcp_seg
 * @return a copy of seg
 */ 
struct tcp_seg *
tcp_seg_copy(struct tcp_seg *seg)
{
  808a8e:	55                   	push   %ebp
  808a8f:	89 e5                	mov    %esp,%ebp
  808a91:	53                   	push   %ebx
  808a92:	83 ec 14             	sub    $0x14,%esp
  struct tcp_seg *cseg;

  cseg = memp_malloc(MEMP_TCP_SEG);
  808a95:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808a9c:	e8 63 ed ff ff       	call   807804 <memp_malloc>
  808aa1:	89 c3                	mov    %eax,%ebx
  if (cseg == NULL) {
  808aa3:	85 c0                	test   %eax,%eax
  808aa5:	74 22                	je     808ac9 <tcp_seg_copy+0x3b>
    return NULL;
  }
  SMEMCPY((u8_t *)cseg, (const u8_t *)seg, sizeof(struct tcp_seg)); 
  808aa7:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  808aae:	00 
  808aaf:	8b 45 08             	mov    0x8(%ebp),%eax
  808ab2:	89 44 24 04          	mov    %eax,0x4(%esp)
  808ab6:	89 1c 24             	mov    %ebx,(%esp)
  808ab9:	e8 d3 88 ff ff       	call   801391 <memcpy>
  pbuf_ref(cseg->p);
  808abe:	8b 43 04             	mov    0x4(%ebx),%eax
  808ac1:	89 04 24             	mov    %eax,(%esp)
  808ac4:	e8 41 f0 ff ff       	call   807b0a <pbuf_ref>
  return cseg;
}
  808ac9:	89 d8                	mov    %ebx,%eax
  808acb:	83 c4 14             	add    $0x14,%esp
  808ace:	5b                   	pop    %ebx
  808acf:	5d                   	pop    %ebp
  808ad0:	c3                   	ret    

00808ad1 <tcp_seg_free>:
 * @param seg single tcp_seg to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_seg_free(struct tcp_seg *seg)
{
  808ad1:	55                   	push   %ebp
  808ad2:	89 e5                	mov    %esp,%ebp
  808ad4:	83 ec 18             	sub    $0x18,%esp
  808ad7:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808ada:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808add:	8b 75 08             	mov    0x8(%ebp),%esi
  u8_t count = 0;
  
  if (seg != NULL) {
  808ae0:	bb 00 00 00 00       	mov    $0x0,%ebx
  808ae5:	85 f6                	test   %esi,%esi
  808ae7:	74 21                	je     808b0a <tcp_seg_free+0x39>
    if (seg->p != NULL) {
  808ae9:	8b 46 04             	mov    0x4(%esi),%eax
  808aec:	85 c0                	test   %eax,%eax
  808aee:	74 0a                	je     808afa <tcp_seg_free+0x29>
      count = pbuf_free(seg->p);
  808af0:	89 04 24             	mov    %eax,(%esp)
  808af3:	e8 60 f4 ff ff       	call   807f58 <pbuf_free>
  808af8:	89 c3                	mov    %eax,%ebx
#if TCP_DEBUG
      seg->p = NULL;
#endif /* TCP_DEBUG */
    }
    memp_free(MEMP_TCP_SEG, seg);
  808afa:	89 74 24 04          	mov    %esi,0x4(%esp)
  808afe:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  808b05:	e8 b6 ec ff ff       	call   8077c0 <memp_free>
  }
  return count;
}
  808b0a:	89 d8                	mov    %ebx,%eax
  808b0c:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808b0f:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808b12:	89 ec                	mov    %ebp,%esp
  808b14:	5d                   	pop    %ebp
  808b15:	c3                   	ret    

00808b16 <tcp_segs_free>:
 * @param seg tcp_seg list of TCP segments to free
 * @return the number of pbufs that were deallocated
 */
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  808b16:	55                   	push   %ebp
  808b17:	89 e5                	mov    %esp,%ebp
  808b19:	56                   	push   %esi
  808b1a:	53                   	push   %ebx
  808b1b:	83 ec 10             	sub    $0x10,%esp
  808b1e:	8b 45 08             	mov    0x8(%ebp),%eax
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808b21:	be 00 00 00 00       	mov    $0x0,%esi
  808b26:	85 c0                	test   %eax,%eax
  808b28:	74 14                	je     808b3e <tcp_segs_free+0x28>
    next = seg->next;
  808b2a:	8b 18                	mov    (%eax),%ebx
    count += tcp_seg_free(seg);
  808b2c:	89 04 24             	mov    %eax,(%esp)
  808b2f:	e8 9d ff ff ff       	call   808ad1 <tcp_seg_free>
  808b34:	01 c6                	add    %eax,%esi
u8_t
tcp_segs_free(struct tcp_seg *seg)
{
  u8_t count = 0;
  struct tcp_seg *next;
  while (seg != NULL) {
  808b36:	85 db                	test   %ebx,%ebx
  808b38:	74 04                	je     808b3e <tcp_segs_free+0x28>
  808b3a:	89 d8                	mov    %ebx,%eax
  808b3c:	eb ec                	jmp    808b2a <tcp_segs_free+0x14>
    next = seg->next;
    count += tcp_seg_free(seg);
    seg = next;
  }
  return count;
}
  808b3e:	89 f0                	mov    %esi,%eax
  808b40:	83 c4 10             	add    $0x10,%esp
  808b43:	5b                   	pop    %ebx
  808b44:	5e                   	pop    %esi
  808b45:	5d                   	pop    %ebp
  808b46:	c3                   	ret    

00808b47 <tcp_pcb_purge>:
 *
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  808b47:	55                   	push   %ebp
  808b48:	89 e5                	mov    %esp,%ebp
  808b4a:	53                   	push   %ebx
  808b4b:	83 ec 14             	sub    $0x14,%esp
  808b4e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (pcb->state != CLOSED &&
     pcb->state != TIME_WAIT &&
  808b51:	8b 43 10             	mov    0x10(%ebx),%eax
 * @param pcb tcp_pcb to purge. The pcb itself is not deallocated!
 */
void
tcp_pcb_purge(struct tcp_pcb *pcb)
{
  if (pcb->state != CLOSED &&
  808b54:	85 c0                	test   %eax,%eax
  808b56:	74 62                	je     808bba <tcp_pcb_purge+0x73>
  808b58:	83 f8 0a             	cmp    $0xa,%eax
  808b5b:	74 5d                	je     808bba <tcp_pcb_purge+0x73>
  808b5d:	83 f8 01             	cmp    $0x1,%eax
  808b60:	74 58                	je     808bba <tcp_pcb_purge+0x73>
     pcb->state != TIME_WAIT &&
     pcb->state != LISTEN) {

    LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge\n"));

    if (pcb->refused_data != NULL) {
  808b62:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  808b68:	85 c0                	test   %eax,%eax
  808b6a:	74 12                	je     808b7e <tcp_pcb_purge+0x37>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->refused_data\n"));
      pbuf_free(pcb->refused_data);
  808b6c:	89 04 24             	mov    %eax,(%esp)
  808b6f:	e8 e4 f3 ff ff       	call   807f58 <pbuf_free>
      pcb->refused_data = NULL;
  808b74:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  808b7b:	00 00 00 
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_pcb_purge: data left on ->ooseq\n"));
    }

    /* Stop the retransmission timer as it will expect data on unacked
       queue if it fires */
    pcb->rtime = -1;
  808b7e:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)

    tcp_segs_free(pcb->ooseq);
  808b84:	8b 43 7c             	mov    0x7c(%ebx),%eax
  808b87:	89 04 24             	mov    %eax,(%esp)
  808b8a:	e8 87 ff ff ff       	call   808b16 <tcp_segs_free>
    pcb->ooseq = NULL;
  808b8f:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
#endif /* TCP_QUEUE_OOSEQ */
    tcp_segs_free(pcb->unsent);
  808b96:	8b 43 74             	mov    0x74(%ebx),%eax
  808b99:	89 04 24             	mov    %eax,(%esp)
  808b9c:	e8 75 ff ff ff       	call   808b16 <tcp_segs_free>
    tcp_segs_free(pcb->unacked);
  808ba1:	8b 43 78             	mov    0x78(%ebx),%eax
  808ba4:	89 04 24             	mov    %eax,(%esp)
  808ba7:	e8 6a ff ff ff       	call   808b16 <tcp_segs_free>
    pcb->unacked = pcb->unsent = NULL;
  808bac:	c7 43 74 00 00 00 00 	movl   $0x0,0x74(%ebx)
  808bb3:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)
  }
}
  808bba:	83 c4 14             	add    $0x14,%esp
  808bbd:	5b                   	pop    %ebx
  808bbe:	5d                   	pop    %ebp
  808bbf:	c3                   	ret    

00808bc0 <tcp_pcb_remove>:
 * @param pcblist PCB list to purge.
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  808bc0:	55                   	push   %ebp
  808bc1:	89 e5                	mov    %esp,%ebp
  808bc3:	53                   	push   %ebx
  808bc4:	83 ec 14             	sub    $0x14,%esp
  808bc7:	8b 45 08             	mov    0x8(%ebp),%eax
  808bca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  TCP_RMV(pcblist, pcb);
  808bcd:	8b 10                	mov    (%eax),%edx
  808bcf:	39 da                	cmp    %ebx,%edx
  808bd1:	75 07                	jne    808bda <tcp_pcb_remove+0x1a>
  808bd3:	8b 52 0c             	mov    0xc(%edx),%edx
  808bd6:	89 10                	mov    %edx,(%eax)
  808bd8:	eb 2a                	jmp    808c04 <tcp_pcb_remove+0x44>
  808bda:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  808be0:	85 d2                	test   %edx,%edx
  808be2:	74 20                	je     808c04 <tcp_pcb_remove+0x44>
  808be4:	8b 42 0c             	mov    0xc(%edx),%eax
  808be7:	85 c0                	test   %eax,%eax
  808be9:	0f 84 c0 00 00 00    	je     808caf <tcp_pcb_remove+0xef>
  808bef:	39 c3                	cmp    %eax,%ebx
  808bf1:	75 08                	jne    808bfb <tcp_pcb_remove+0x3b>
  808bf3:	8b 43 0c             	mov    0xc(%ebx),%eax
  808bf6:	89 42 0c             	mov    %eax,0xc(%edx)
  808bf9:	eb 09                	jmp    808c04 <tcp_pcb_remove+0x44>
  808bfb:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  808c00:	89 c2                	mov    %eax,%edx
  808c02:	eb e0                	jmp    808be4 <tcp_pcb_remove+0x24>
  808c04:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)

  tcp_pcb_purge(pcb);
  808c0b:	89 1c 24             	mov    %ebx,(%esp)
  808c0e:	e8 34 ff ff ff       	call   808b47 <tcp_pcb_purge>
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
     pcb->state != LISTEN &&
  808c13:	8b 43 10             	mov    0x10(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808c16:	83 f8 0a             	cmp    $0xa,%eax
  808c19:	74 1b                	je     808c36 <tcp_pcb_remove+0x76>
  808c1b:	83 f8 01             	cmp    $0x1,%eax
  808c1e:	74 16                	je     808c36 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
  808c20:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  TCP_RMV(pcblist, pcb);

  tcp_pcb_purge(pcb);
  
  /* if there is an outstanding delayed ACKs, send it */
  if (pcb->state != TIME_WAIT &&
  808c24:	a8 01                	test   $0x1,%al
  808c26:	74 0e                	je     808c36 <tcp_pcb_remove+0x76>
     pcb->state != LISTEN &&
     pcb->flags & TF_ACK_DELAY) {
    pcb->flags |= TF_ACK_NOW;
  808c28:	83 c8 02             	or     $0x2,%eax
  808c2b:	88 43 20             	mov    %al,0x20(%ebx)
    tcp_output(pcb);
  808c2e:	89 1c 24             	mov    %ebx,(%esp)
  808c31:	e8 a5 27 00 00       	call   80b3db <tcp_output>
  }

  if (pcb->state != LISTEN) {
  808c36:	83 7b 10 01          	cmpl   $0x1,0x10(%ebx)
  808c3a:	74 66                	je     808ca2 <tcp_pcb_remove+0xe2>
    LWIP_ASSERT("unsent segments leaking", pcb->unsent == NULL);
  808c3c:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  808c40:	74 1c                	je     808c5e <tcp_pcb_remove+0x9e>
  808c42:	c7 44 24 08 17 3b 81 	movl   $0x813b17,0x8(%esp)
  808c49:	00 
  808c4a:	c7 44 24 04 b4 04 00 	movl   $0x4b4,0x4(%esp)
  808c51:	00 
  808c52:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  808c59:	e8 76 7d ff ff       	call   8009d4 <_panic>
    LWIP_ASSERT("unacked segments leaking", pcb->unacked == NULL);
  808c5e:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  808c62:	74 1c                	je     808c80 <tcp_pcb_remove+0xc0>
  808c64:	c7 44 24 08 43 3b 81 	movl   $0x813b43,0x8(%esp)
  808c6b:	00 
  808c6c:	c7 44 24 04 b5 04 00 	movl   $0x4b5,0x4(%esp)
  808c73:	00 
  808c74:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  808c7b:	e8 54 7d ff ff       	call   8009d4 <_panic>
#if TCP_QUEUE_OOSEQ
    LWIP_ASSERT("ooseq segments leaking", pcb->ooseq == NULL);
  808c80:	83 7b 7c 00          	cmpl   $0x0,0x7c(%ebx)
  808c84:	74 1c                	je     808ca2 <tcp_pcb_remove+0xe2>
  808c86:	c7 44 24 08 5c 3b 81 	movl   $0x813b5c,0x8(%esp)
  808c8d:	00 
  808c8e:	c7 44 24 04 b7 04 00 	movl   $0x4b7,0x4(%esp)
  808c95:	00 
  808c96:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  808c9d:	e8 32 7d ff ff       	call   8009d4 <_panic>
#endif /* TCP_QUEUE_OOSEQ */
  }

  pcb->state = CLOSED;
  808ca2:	c7 43 10 00 00 00 00 	movl   $0x0,0x10(%ebx)

  LWIP_ASSERT("tcp_pcb_remove: tcp_pcbs_sane()", tcp_pcbs_sane());
}
  808ca9:	83 c4 14             	add    $0x14,%esp
  808cac:	5b                   	pop    %ebx
  808cad:	5d                   	pop    %ebp
  808cae:	c3                   	ret    
 * @param pcb tcp_pcb to purge. The pcb itself is also deallocated!
 */
void
tcp_pcb_remove(struct tcp_pcb **pcblist, struct tcp_pcb *pcb)
{
  TCP_RMV(pcblist, pcb);
  808caf:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  808cb4:	e9 4b ff ff ff       	jmp    808c04 <tcp_pcb_remove+0x44>

00808cb9 <tcp_listen_with_backlog>:
 *       called like this:
 *             tpcb = tcp_listen(tpcb);
 */
struct tcp_pcb *
tcp_listen_with_backlog(struct tcp_pcb *pcb, u8_t backlog)
{
  808cb9:	55                   	push   %ebp
  808cba:	89 e5                	mov    %esp,%ebp
  808cbc:	83 ec 18             	sub    $0x18,%esp
  808cbf:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  808cc2:	89 75 fc             	mov    %esi,-0x4(%ebp)
  808cc5:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_pcb_listen *lpcb;

  LWIP_UNUSED_ARG(backlog);
  LWIP_ERROR("tcp_listen: pcb already connected", pcb->state == CLOSED, return NULL);
  808cc8:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808ccc:	74 1c                	je     808cea <tcp_listen_with_backlog+0x31>
  808cce:	c7 44 24 08 74 3b 81 	movl   $0x813b74,0x8(%esp)
  808cd5:	00 
  808cd6:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  808cdd:	00 
  808cde:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  808ce5:	e8 ea 7c ff ff       	call   8009d4 <_panic>

  /* already listening? */
  if (pcb->state == LISTEN) {
    return pcb;
  }
  lpcb = memp_malloc(MEMP_TCP_PCB_LISTEN);
  808cea:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  808cf1:	e8 0e eb ff ff       	call   807804 <memp_malloc>
  808cf6:	89 c6                	mov    %eax,%esi
  if (lpcb == NULL) {
  808cf8:	b8 00 00 00 00       	mov    $0x0,%eax
  808cfd:	85 f6                	test   %esi,%esi
  808cff:	0f 84 a8 00 00 00    	je     808dad <tcp_listen_with_backlog+0xf4>
    return NULL;
  }
  lpcb->callback_arg = pcb->callback_arg;
  808d05:	8b 43 18             	mov    0x18(%ebx),%eax
  808d08:	89 46 18             	mov    %eax,0x18(%esi)
  lpcb->local_port = pcb->local_port;
  808d0b:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  808d0f:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  lpcb->state = LISTEN;
  808d13:	c7 46 10 01 00 00 00 	movl   $0x1,0x10(%esi)
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  808d1a:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  808d1e:	83 c8 02             	or     $0x2,%eax
  808d21:	66 89 46 08          	mov    %ax,0x8(%esi)
  lpcb->ttl = pcb->ttl;
  808d25:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  808d29:	88 46 0b             	mov    %al,0xb(%esi)
  lpcb->tos = pcb->tos;
  808d2c:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  808d30:	88 46 0a             	mov    %al,0xa(%esi)
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  808d33:	b8 00 00 00 00       	mov    $0x0,%eax
  808d38:	85 db                	test   %ebx,%ebx
  808d3a:	74 02                	je     808d3e <tcp_listen_with_backlog+0x85>
  808d3c:	8b 03                	mov    (%ebx),%eax
  808d3e:	89 06                	mov    %eax,(%esi)
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808d40:	8b 15 18 f6 b3 00    	mov    0xb3f618,%edx
  808d46:	39 da                	cmp    %ebx,%edx
  808d48:	75 0a                	jne    808d54 <tcp_listen_with_backlog+0x9b>
  808d4a:	8b 42 0c             	mov    0xc(%edx),%eax
  808d4d:	a3 18 f6 b3 00       	mov    %eax,0xb3f618
  808d52:	eb 26                	jmp    808d7a <tcp_listen_with_backlog+0xc1>
  808d54:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  808d5a:	85 d2                	test   %edx,%edx
  808d5c:	74 1c                	je     808d7a <tcp_listen_with_backlog+0xc1>
  808d5e:	8b 42 0c             	mov    0xc(%edx),%eax
  808d61:	85 c0                	test   %eax,%eax
  808d63:	74 52                	je     808db7 <tcp_listen_with_backlog+0xfe>
  808d65:	39 c3                	cmp    %eax,%ebx
  808d67:	75 08                	jne    808d71 <tcp_listen_with_backlog+0xb8>
  808d69:	8b 43 0c             	mov    0xc(%ebx),%eax
  808d6c:	89 42 0c             	mov    %eax,0xc(%edx)
  808d6f:	eb 09                	jmp    808d7a <tcp_listen_with_backlog+0xc1>
  808d71:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  808d76:	89 c2                	mov    %eax,%edx
  808d78:	eb e4                	jmp    808d5e <tcp_listen_with_backlog+0xa5>
  808d7a:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  memp_free(MEMP_TCP_PCB, pcb);
  808d81:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  808d85:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  808d8c:	e8 2f ea ff ff       	call   8077c0 <memp_free>
#if LWIP_CALLBACK_API
  lpcb->accept = tcp_accept_null;
  808d91:	c7 46 20 00 88 80 00 	movl   $0x808800,0x20(%esi)
#endif /* LWIP_CALLBACK_API */
#if TCP_LISTEN_BACKLOG
  lpcb->accepts_pending = 0;
  lpcb->backlog = (backlog ? backlog : 1);
#endif /* TCP_LISTEN_BACKLOG */
  TCP_REG(&tcp_listen_pcbs.listen_pcbs, lpcb);
  808d98:	a1 10 f6 b3 00       	mov    0xb3f610,%eax
  808d9d:	89 46 0c             	mov    %eax,0xc(%esi)
  808da0:	89 35 10 f6 b3 00    	mov    %esi,0xb3f610
  808da6:	e8 52 c2 ff ff       	call   804ffd <tcp_timer_needed>
  return (struct tcp_pcb *)lpcb;
  808dab:	89 f0                	mov    %esi,%eax
}
  808dad:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  808db0:	8b 75 fc             	mov    -0x4(%ebp),%esi
  808db3:	89 ec                	mov    %ebp,%esp
  808db5:	5d                   	pop    %ebp
  808db6:	c3                   	ret    
  lpcb->so_options = pcb->so_options;
  lpcb->so_options |= SOF_ACCEPTCONN;
  lpcb->ttl = pcb->ttl;
  lpcb->tos = pcb->tos;
  ip_addr_set(&lpcb->local_ip, &pcb->local_ip);
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808db7:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  808dbc:	eb bc                	jmp    808d7a <tcp_listen_with_backlog+0xc1>

00808dbe <tcp_bind>:
 * @return ERR_USE if the port is already in use
 *         ERR_OK if bound
 */
err_t
tcp_bind(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  808dbe:	55                   	push   %ebp
  808dbf:	89 e5                	mov    %esp,%ebp
  808dc1:	57                   	push   %edi
  808dc2:	56                   	push   %esi
  808dc3:	53                   	push   %ebx
  808dc4:	83 ec 1c             	sub    $0x1c,%esp
  808dc7:	8b 75 08             	mov    0x8(%ebp),%esi
  808dca:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  808dcd:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct tcp_pcb *cpcb;

  LWIP_ERROR("tcp_connect: can only bind in state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808dd1:	83 7e 10 00          	cmpl   $0x0,0x10(%esi)
  808dd5:	74 1c                	je     808df3 <tcp_bind+0x35>
  808dd7:	c7 44 24 08 98 3b 81 	movl   $0x813b98,0x8(%esp)
  808dde:	00 
  808ddf:	c7 44 24 04 05 01 00 	movl   $0x105,0x4(%esp)
  808de6:	00 
  808de7:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  808dee:	e8 e1 7b ff ff       	call   8009d4 <_panic>

  if (port == 0) {
  808df3:	66 85 c0             	test   %ax,%ax
  808df6:	75 05                	jne    808dfd <tcp_bind+0x3f>
    port = tcp_new_port();
  808df8:	e8 0d fa ff ff       	call   80880a <tcp_new_port>
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808dfd:	8b 15 10 f6 b3 00    	mov    0xb3f610,%edx
  808e03:	85 d2                	test   %edx,%edx
  808e05:	74 39                	je     808e40 <tcp_bind+0x82>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808e07:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808e0b:	75 2c                	jne    808e39 <tcp_bind+0x7b>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e0d:	85 d2                	test   %edx,%edx
  808e0f:	0f 84 e1 00 00 00    	je     808ef6 <tcp_bind+0x138>
  808e15:	8b 0a                	mov    (%edx),%ecx
  808e17:	85 c9                	test   %ecx,%ecx
  808e19:	0f 84 d7 00 00 00    	je     808ef6 <tcp_bind+0x138>
  808e1f:	85 db                	test   %ebx,%ebx
  808e21:	0f 84 cf 00 00 00    	je     808ef6 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808e27:	8b 3b                	mov    (%ebx),%edi
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e29:	85 ff                	test   %edi,%edi
  808e2b:	0f 84 c5 00 00 00    	je     808ef6 <tcp_bind+0x138>
  808e31:	39 f9                	cmp    %edi,%ecx
  808e33:	0f 84 bd 00 00 00    	je     808ef6 <tcp_bind+0x138>
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808e39:	8b 52 0c             	mov    0xc(%edx),%edx
  if (port == 0) {
    port = tcp_new_port();
  }
  /* Check if the address already is in use. */
  /* Check the listen pcbs. */
  for(cpcb = (struct tcp_pcb *)tcp_listen_pcbs.pcbs;
  808e3c:	85 d2                	test   %edx,%edx
  808e3e:	75 c7                	jne    808e07 <tcp_bind+0x49>
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808e40:	8b 15 08 f6 b3 00    	mov    0xb3f608,%edx
  808e46:	85 d2                	test   %edx,%edx
  808e48:	74 35                	je     808e7f <tcp_bind+0xc1>
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
  808e4a:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808e4e:	75 28                	jne    808e78 <tcp_bind+0xba>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e50:	85 d2                	test   %edx,%edx
  808e52:	0f 84 9e 00 00 00    	je     808ef6 <tcp_bind+0x138>
  808e58:	8b 0a                	mov    (%edx),%ecx
  808e5a:	85 c9                	test   %ecx,%ecx
  808e5c:	0f 84 94 00 00 00    	je     808ef6 <tcp_bind+0x138>
  808e62:	85 db                	test   %ebx,%ebx
  808e64:	0f 84 8c 00 00 00    	je     808ef6 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808e6a:	8b 3b                	mov    (%ebx),%edi
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e6c:	85 ff                	test   %edi,%edi
  808e6e:	0f 84 82 00 00 00    	je     808ef6 <tcp_bind+0x138>
  808e74:	39 f9                	cmp    %edi,%ecx
  808e76:	74 7e                	je     808ef6 <tcp_bind+0x138>
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
      cpcb != NULL; cpcb = cpcb->next) {
  808e78:	8b 52 0c             	mov    0xc(%edx),%edx
        return ERR_USE;
      }
    }
  }
  /* Check the connected pcbs. */
  for(cpcb = tcp_active_pcbs;
  808e7b:	85 d2                	test   %edx,%edx
  808e7d:	75 cb                	jne    808e4a <tcp_bind+0x8c>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808e7f:	8b 15 18 f6 b3 00    	mov    0xb3f618,%edx
  808e85:	85 d2                	test   %edx,%edx
  808e87:	74 25                	je     808eae <tcp_bind+0xf0>
    if (cpcb->local_port == port) {
  808e89:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808e8d:	75 18                	jne    808ea7 <tcp_bind+0xe9>
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e8f:	85 d2                	test   %edx,%edx
  808e91:	74 63                	je     808ef6 <tcp_bind+0x138>
  808e93:	8b 0a                	mov    (%edx),%ecx
  808e95:	85 c9                	test   %ecx,%ecx
  808e97:	74 5d                	je     808ef6 <tcp_bind+0x138>
  808e99:	85 db                	test   %ebx,%ebx
  808e9b:	74 59                	je     808ef6 <tcp_bind+0x138>
          ip_addr_isany(ipaddr) ||
  808e9d:	8b 3b                	mov    (%ebx),%edi
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
    if (cpcb->local_port == port) {
      if (ip_addr_isany(&(cpcb->local_ip)) ||
  808e9f:	85 ff                	test   %edi,%edi
  808ea1:	74 53                	je     808ef6 <tcp_bind+0x138>
  808ea3:	39 f9                	cmp    %edi,%ecx
  808ea5:	74 4f                	je     808ef6 <tcp_bind+0x138>
        return ERR_USE;
      }
    }
  }
  /* Check the bound, not yet connected pcbs. */
  for(cpcb = tcp_bound_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808ea7:	8b 52 0c             	mov    0xc(%edx),%edx
  808eaa:	85 d2                	test   %edx,%edx
  808eac:	75 db                	jne    808e89 <tcp_bind+0xcb>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808eae:	8b 15 1c f6 b3 00    	mov    0xb3f61c,%edx
  808eb4:	85 d2                	test   %edx,%edx
  808eb6:	74 13                	je     808ecb <tcp_bind+0x10d>
    if (cpcb->local_port == port) {
  808eb8:	66 39 42 1c          	cmp    %ax,0x1c(%edx)
  808ebc:	75 06                	jne    808ec4 <tcp_bind+0x106>
      if (ip_addr_cmp(&(cpcb->local_ip), ipaddr)) {
  808ebe:	8b 0a                	mov    (%edx),%ecx
  808ec0:	3b 0b                	cmp    (%ebx),%ecx
  808ec2:	74 32                	je     808ef6 <tcp_bind+0x138>
      }
    }
  }
  /* @todo: until SO_REUSEADDR is implemented (see task #6995 on savannah),
   * we have to check the pcbs in TIME-WAIT state, also: */
  for(cpcb = tcp_tw_pcbs; cpcb != NULL; cpcb = cpcb->next) {
  808ec4:	8b 52 0c             	mov    0xc(%edx),%edx
  808ec7:	85 d2                	test   %edx,%edx
  808ec9:	75 ed                	jne    808eb8 <tcp_bind+0xfa>
        return ERR_USE;
      }
    }
  }

  if (!ip_addr_isany(ipaddr)) {
  808ecb:	85 db                	test   %ebx,%ebx
  808ecd:	74 09                	je     808ed8 <tcp_bind+0x11a>
  808ecf:	83 3b 00             	cmpl   $0x0,(%ebx)
  808ed2:	74 04                	je     808ed8 <tcp_bind+0x11a>
    pcb->local_ip = *ipaddr;
  808ed4:	8b 13                	mov    (%ebx),%edx
  808ed6:	89 16                	mov    %edx,(%esi)
  }
  pcb->local_port = port;
  808ed8:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  TCP_REG(&tcp_bound_pcbs, pcb);
  808edc:	a1 18 f6 b3 00       	mov    0xb3f618,%eax
  808ee1:	89 46 0c             	mov    %eax,0xc(%esi)
  808ee4:	89 35 18 f6 b3 00    	mov    %esi,0xb3f618
  808eea:	e8 0e c1 ff ff       	call   804ffd <tcp_timer_needed>
  808eef:	b8 00 00 00 00       	mov    $0x0,%eax
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_bind: bind to port %"U16_F"\n", port));
  return ERR_OK;
  808ef4:	eb 05                	jmp    808efb <tcp_bind+0x13d>
  808ef6:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
}
  808efb:	83 c4 1c             	add    $0x1c,%esp
  808efe:	5b                   	pop    %ebx
  808eff:	5e                   	pop    %esi
  808f00:	5f                   	pop    %edi
  808f01:	5d                   	pop    %ebp
  808f02:	c3                   	ret    

00808f03 <tcp_connect>:
 *         other err_t values if connect request couldn't be sent
 */
err_t
tcp_connect(struct tcp_pcb *pcb, struct ip_addr *ipaddr, u16_t port,
      err_t (* connected)(void *arg, struct tcp_pcb *tpcb, err_t err))
{
  808f03:	55                   	push   %ebp
  808f04:	89 e5                	mov    %esp,%ebp
  808f06:	57                   	push   %edi
  808f07:	56                   	push   %esi
  808f08:	53                   	push   %ebx
  808f09:	83 ec 3c             	sub    $0x3c,%esp
  808f0c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  808f0f:	8b 7d 0c             	mov    0xc(%ebp),%edi
  808f12:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  u32_t optdata;
  err_t ret;
  u32_t iss;

  LWIP_ERROR("tcp_connect: can only connected from state CLOSED", pcb->state == CLOSED, return ERR_ISCONN);
  808f16:	83 7b 10 00          	cmpl   $0x0,0x10(%ebx)
  808f1a:	74 1c                	je     808f38 <tcp_connect+0x35>
  808f1c:	c7 44 24 08 c4 3b 81 	movl   $0x813bc4,0x8(%esp)
  808f23:	00 
  808f24:	c7 44 24 04 ec 01 00 	movl   $0x1ec,0x4(%esp)
  808f2b:	00 
  808f2c:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  808f33:	e8 9c 7a ff ff       	call   8009d4 <_panic>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_connect to port %"U16_F"\n", port));
  if (ipaddr != NULL) {
  808f38:	be f7 ff ff ff       	mov    $0xfffffff7,%esi
  808f3d:	85 ff                	test   %edi,%edi
  808f3f:	0f 84 28 01 00 00    	je     80906d <tcp_connect+0x16a>
    pcb->remote_ip = *ipaddr;
  808f45:	8b 17                	mov    (%edi),%edx
  808f47:	89 53 04             	mov    %edx,0x4(%ebx)
  } else {
    return ERR_VAL;
  }
  pcb->remote_port = port;
  808f4a:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
  if (pcb->local_port == 0) {
  808f4e:	66 83 7b 1c 00       	cmpw   $0x0,0x1c(%ebx)
  808f53:	75 09                	jne    808f5e <tcp_connect+0x5b>
    pcb->local_port = tcp_new_port();
  808f55:	e8 b0 f8 ff ff       	call   80880a <tcp_new_port>
  808f5a:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
  }
  iss = tcp_next_iss();
  808f5e:	e8 c9 f9 ff ff       	call   80892c <tcp_next_iss>
  pcb->rcv_nxt = 0;
  808f63:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
  pcb->snd_nxt = iss;
  808f6a:	89 43 54             	mov    %eax,0x54(%ebx)
  pcb->lastack = iss - 1;
  808f6d:	83 e8 01             	sub    $0x1,%eax
  808f70:	89 43 48             	mov    %eax,0x48(%ebx)
  pcb->snd_lbb = iss - 1;
  808f73:	89 43 68             	mov    %eax,0x68(%ebx)
  pcb->rcv_wnd = TCP_WND;
  808f76:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
  pcb->rcv_ann_wnd = TCP_WND;
  808f7c:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
  pcb->snd_wnd = TCP_WND;
  808f82:	66 c7 43 5c c0 5d    	movw   $0x5dc0,0x5c(%ebx)
  /* As initial send MSS, we use TCP_MSS but limit it to 536.
     The send MSS is updated when an MSS option is received. */
  pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  808f88:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
#if TCP_CALCULATE_EFF_SEND_MSS
  pcb->mss = tcp_eff_send_mss(pcb->mss, ipaddr);
  808f8e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  808f92:	c7 04 24 18 02 00 00 	movl   $0x218,(%esp)
  808f99:	e8 a3 f9 ff ff       	call   808941 <tcp_eff_send_mss>
  808f9e:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */
  pcb->cwnd = 1;
  808fa2:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
  pcb->ssthresh = pcb->mss * 10;
  808fa8:	8d 04 80             	lea    (%eax,%eax,4),%eax
  808fab:	01 c0                	add    %eax,%eax
  808fad:	66 89 43 50          	mov    %ax,0x50(%ebx)
  pcb->state = SYN_SENT;
  808fb1:	c7 43 10 02 00 00 00 	movl   $0x2,0x10(%ebx)
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
  808fb8:	8b 45 14             	mov    0x14(%ebp),%eax
  808fbb:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  808fc1:	8b 15 18 f6 b3 00    	mov    0xb3f618,%edx
  808fc7:	39 da                	cmp    %ebx,%edx
  808fc9:	75 0a                	jne    808fd5 <tcp_connect+0xd2>
  808fcb:	8b 42 0c             	mov    0xc(%edx),%eax
  808fce:	a3 18 f6 b3 00       	mov    %eax,0xb3f618
  808fd3:	eb 2a                	jmp    808fff <tcp_connect+0xfc>
  808fd5:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  808fdb:	85 d2                	test   %edx,%edx
  808fdd:	74 20                	je     808fff <tcp_connect+0xfc>
  808fdf:	8b 42 0c             	mov    0xc(%edx),%eax
  808fe2:	85 c0                	test   %eax,%eax
  808fe4:	0f 84 8d 00 00 00    	je     809077 <tcp_connect+0x174>
  808fea:	39 c3                	cmp    %eax,%ebx
  808fec:	75 08                	jne    808ff6 <tcp_connect+0xf3>
  808fee:	8b 43 0c             	mov    0xc(%ebx),%eax
  808ff1:	89 42 0c             	mov    %eax,0xc(%edx)
  808ff4:	eb 09                	jmp    808fff <tcp_connect+0xfc>
  808ff6:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  808ffb:	89 c2                	mov    %eax,%edx
  808ffd:	eb e0                	jmp    808fdf <tcp_connect+0xdc>
  808fff:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
  TCP_REG(&tcp_active_pcbs, pcb);
  809006:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
  80900b:	89 43 0c             	mov    %eax,0xc(%ebx)
  80900e:	89 1d 08 f6 b3 00    	mov    %ebx,0xb3f608
  809014:	e8 e4 bf ff ff       	call   804ffd <tcp_timer_needed>

  snmp_inc_tcpactiveopens();
  
  /* Build an MSS option */
  optdata = TCP_BUILD_MSS_OPTION();
  809019:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  809020:	e8 50 1d 00 00       	call   80ad75 <htonl>
  809025:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  ret = tcp_enqueue(pcb, NULL, 0, TCP_SYN, 0, (u8_t *)&optdata, 4);
  809028:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  80902f:	00 
  809030:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  809033:	89 44 24 14          	mov    %eax,0x14(%esp)
  809037:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80903e:	00 
  80903f:	c7 44 24 0c 02 00 00 	movl   $0x2,0xc(%esp)
  809046:	00 
  809047:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80904e:	00 
  80904f:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809056:	00 
  809057:	89 1c 24             	mov    %ebx,(%esp)
  80905a:	e8 c9 28 00 00       	call   80b928 <tcp_enqueue>
  80905f:	89 c6                	mov    %eax,%esi
  if (ret == ERR_OK) { 
  809061:	84 c0                	test   %al,%al
  809063:	75 08                	jne    80906d <tcp_connect+0x16a>
    tcp_output(pcb);
  809065:	89 1c 24             	mov    %ebx,(%esp)
  809068:	e8 6e 23 00 00       	call   80b3db <tcp_output>
  }
  return ret;
} 
  80906d:	89 f0                	mov    %esi,%eax
  80906f:	83 c4 3c             	add    $0x3c,%esp
  809072:	5b                   	pop    %ebx
  809073:	5e                   	pop    %esi
  809074:	5f                   	pop    %edi
  809075:	5d                   	pop    %ebp
  809076:	c3                   	ret    
  pcb->ssthresh = pcb->mss * 10;
  pcb->state = SYN_SENT;
#if LWIP_CALLBACK_API  
  pcb->connected = connected;
#endif /* LWIP_CALLBACK_API */
  TCP_RMV(&tcp_bound_pcbs, pcb);
  809077:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  80907c:	eb 81                	jmp    808fff <tcp_connect+0xfc>

0080907e <tcp_abort>:
 *
 * @param pcb the tcp_pcb to abort
 */
void
tcp_abort(struct tcp_pcb *pcb)
{
  80907e:	55                   	push   %ebp
  80907f:	89 e5                	mov    %esp,%ebp
  809081:	57                   	push   %edi
  809082:	56                   	push   %esi
  809083:	53                   	push   %ebx
  809084:	83 ec 4c             	sub    $0x4c,%esp
  809087:	8b 5d 08             	mov    0x8(%ebp),%ebx

  
  /* Figure out on which TCP PCB list we are, and remove us. If we
     are in an active state, call the receive function associated with
     the PCB with a NULL argument, and send an RST to the remote end. */
  if (pcb->state == TIME_WAIT) {
  80908a:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  80908e:	75 25                	jne    8090b5 <tcp_abort+0x37>
    tcp_pcb_remove(&tcp_tw_pcbs, pcb);
  809090:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809094:	c7 04 24 1c f6 b3 00 	movl   $0xb3f61c,(%esp)
  80909b:	e8 20 fb ff ff       	call   808bc0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  8090a0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8090a4:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8090ab:	e8 10 e7 ff ff       	call   8077c0 <memp_free>
  8090b0:	e9 d1 00 00 00       	jmp    809186 <tcp_abort+0x108>
  } else {
    seqno = pcb->snd_nxt;
  8090b5:	8b 43 54             	mov    0x54(%ebx),%eax
  8090b8:	89 45 d0             	mov    %eax,-0x30(%ebp)
    ackno = pcb->rcv_nxt;
  8090bb:	8b 7b 24             	mov    0x24(%ebx),%edi
    ip_addr_set(&local_ip, &(pcb->local_ip));
  8090be:	b8 00 00 00 00       	mov    $0x0,%eax
  8090c3:	85 db                	test   %ebx,%ebx
  8090c5:	74 02                	je     8090c9 <tcp_abort+0x4b>
  8090c7:	8b 03                	mov    (%ebx),%eax
  8090c9:	89 45 e0             	mov    %eax,-0x20(%ebp)
    ip_addr_set(&remote_ip, &(pcb->remote_ip));
  8090cc:	b8 00 00 00 00       	mov    $0x0,%eax
  8090d1:	83 fb fc             	cmp    $0xfffffffc,%ebx
  8090d4:	74 03                	je     8090d9 <tcp_abort+0x5b>
  8090d6:	8b 43 04             	mov    0x4(%ebx),%eax
  8090d9:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    local_port = pcb->local_port;
  8090dc:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  8090e0:	66 89 45 d6          	mov    %ax,-0x2a(%ebp)
    remote_port = pcb->remote_port;
  8090e4:	0f b7 43 1e          	movzwl 0x1e(%ebx),%eax
  8090e8:	66 89 45 d4          	mov    %ax,-0x2c(%ebp)
#if LWIP_CALLBACK_API
    errf = pcb->errf;
  8090ec:	8b b3 98 00 00 00    	mov    0x98(%ebx),%esi
#endif /* LWIP_CALLBACK_API */
    errf_arg = pcb->callback_arg;
  8090f2:	8b 43 18             	mov    0x18(%ebx),%eax
  8090f5:	89 45 cc             	mov    %eax,-0x34(%ebp)
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  8090f8:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8090fc:	c7 04 24 08 f6 b3 00 	movl   $0xb3f608,(%esp)
  809103:	e8 b8 fa ff ff       	call   808bc0 <tcp_pcb_remove>
    if (pcb->unacked != NULL) {
  809108:	8b 43 78             	mov    0x78(%ebx),%eax
  80910b:	85 c0                	test   %eax,%eax
  80910d:	74 08                	je     809117 <tcp_abort+0x99>
      tcp_segs_free(pcb->unacked);
  80910f:	89 04 24             	mov    %eax,(%esp)
  809112:	e8 ff f9 ff ff       	call   808b16 <tcp_segs_free>
    }
    if (pcb->unsent != NULL) {
  809117:	8b 43 74             	mov    0x74(%ebx),%eax
  80911a:	85 c0                	test   %eax,%eax
  80911c:	74 08                	je     809126 <tcp_abort+0xa8>
      tcp_segs_free(pcb->unsent);
  80911e:	89 04 24             	mov    %eax,(%esp)
  809121:	e8 f0 f9 ff ff       	call   808b16 <tcp_segs_free>
    }
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL) {
  809126:	8b 43 7c             	mov    0x7c(%ebx),%eax
  809129:	85 c0                	test   %eax,%eax
  80912b:	74 08                	je     809135 <tcp_abort+0xb7>
      tcp_segs_free(pcb->ooseq);
  80912d:	89 04 24             	mov    %eax,(%esp)
  809130:	e8 e1 f9 ff ff       	call   808b16 <tcp_segs_free>
    }
#endif /* TCP_QUEUE_OOSEQ */
    memp_free(MEMP_TCP_PCB, pcb);
  809135:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809139:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809140:	e8 7b e6 ff ff       	call   8077c0 <memp_free>
    TCP_EVENT_ERR(errf, errf_arg, ERR_ABRT);
  809145:	85 f6                	test   %esi,%esi
  809147:	74 10                	je     809159 <tcp_abort+0xdb>
  809149:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809150:	ff 
  809151:	8b 45 cc             	mov    -0x34(%ebp),%eax
  809154:	89 04 24             	mov    %eax,(%esp)
  809157:	ff d6                	call   *%esi
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_abort: sending RST\n"));
    tcp_rst(seqno, ackno, &local_ip, &remote_ip, local_port, remote_port);
  809159:	0f b7 45 d4          	movzwl -0x2c(%ebp),%eax
  80915d:	89 44 24 14          	mov    %eax,0x14(%esp)
  809161:	0f b7 45 d6          	movzwl -0x2a(%ebp),%eax
  809165:	89 44 24 10          	mov    %eax,0x10(%esp)
  809169:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80916c:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809170:	8d 45 e0             	lea    -0x20(%ebp),%eax
  809173:	89 44 24 08          	mov    %eax,0x8(%esp)
  809177:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80917b:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80917e:	89 04 24             	mov    %eax,(%esp)
  809181:	e8 f6 20 00 00       	call   80b27c <tcp_rst>
  }
}
  809186:	83 c4 4c             	add    $0x4c,%esp
  809189:	5b                   	pop    %ebx
  80918a:	5e                   	pop    %esi
  80918b:	5f                   	pop    %edi
  80918c:	5d                   	pop    %ebp
  80918d:	c3                   	ret    

0080918e <tcp_alloc>:
 * @param prio priority for the new pcb
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_alloc(u8_t prio)
{
  80918e:	55                   	push   %ebp
  80918f:	89 e5                	mov    %esp,%ebp
  809191:	83 ec 38             	sub    $0x38,%esp
  809194:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809197:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80919a:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80919d:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct tcp_pcb *pcb;
  u32_t iss;
  
  pcb = memp_malloc(MEMP_TCP_PCB);
  8091a1:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8091a8:	e8 57 e6 ff ff       	call   807804 <memp_malloc>
  8091ad:	89 c3                	mov    %eax,%ebx
  if (pcb == NULL) {
  8091af:	85 c0                	test   %eax,%eax
  8091b1:	0f 85 c9 00 00 00    	jne    809280 <tcp_alloc+0xf2>
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8091b7:	a1 1c f6 b3 00       	mov    0xb3f61c,%eax
  8091bc:	85 c0                	test   %eax,%eax
  8091be:	74 36                	je     8091f6 <tcp_alloc+0x68>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  8091c0:	8b 1d 0c f6 b3 00    	mov    0xb3f60c,%ebx
  8091c6:	bf 00 00 00 00       	mov    $0x0,%edi
  8091cb:	b9 00 00 00 00       	mov    $0x0,%ecx
  8091d0:	89 da                	mov    %ebx,%edx
  8091d2:	2b 50 2c             	sub    0x2c(%eax),%edx
  8091d5:	39 ca                	cmp    %ecx,%edx
  8091d7:	72 04                	jb     8091dd <tcp_alloc+0x4f>
  8091d9:	89 c7                	mov    %eax,%edi
  8091db:	eb 02                	jmp    8091df <tcp_alloc+0x51>
  8091dd:	89 ca                	mov    %ecx,%edx
  u32_t inactivity;

  inactivity = 0;
  inactive = NULL;
  /* Go through the list of TIME_WAIT pcbs and get the oldest pcb. */
  for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  8091df:	8b 40 0c             	mov    0xc(%eax),%eax
  8091e2:	85 c0                	test   %eax,%eax
  8091e4:	74 04                	je     8091ea <tcp_alloc+0x5c>
  8091e6:	89 d1                	mov    %edx,%ecx
  8091e8:	eb e6                	jmp    8091d0 <tcp_alloc+0x42>
    if ((u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
    }
  }
  if (inactive != NULL) {
  8091ea:	85 ff                	test   %edi,%edi
  8091ec:	74 08                	je     8091f6 <tcp_alloc+0x68>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_timewait: killing oldest TIME-WAIT PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  8091ee:	89 3c 24             	mov    %edi,(%esp)
  8091f1:	e8 88 fe ff ff       	call   80907e <tcp_abort>
  if (pcb == NULL) {
    /* Try killing oldest connection in TIME-WAIT. */
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_alloc: killing off oldest TIME-WAIT connection\n"));
    tcp_kill_timewait();
    /* Try to allocate a tcp_pcb again. */
    pcb = memp_malloc(MEMP_TCP_PCB);
  8091f6:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  8091fd:	e8 02 e6 ff ff       	call   807804 <memp_malloc>
  809202:	89 c3                	mov    %eax,%ebx
    if (pcb == NULL) {
  809204:	85 c0                	test   %eax,%eax
  809206:	75 78                	jne    809280 <tcp_alloc+0xf2>
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  809208:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
  80920d:	85 c0                	test   %eax,%eax
  80920f:	74 59                	je     80926a <tcp_alloc+0xdc>
    if (pcb->prio <= prio &&
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  809211:	8b 15 0c f6 b3 00    	mov    0xb3f60c,%edx
  809217:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80921a:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  809221:	bf 00 00 00 00       	mov    $0x0,%edi
  809226:	b9 7f 00 00 00       	mov    $0x7f,%ecx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80922b:	0f b6 50 14          	movzbl 0x14(%eax),%edx
  80922f:	89 f3                	mov    %esi,%ebx
  809231:	38 d3                	cmp    %dl,%bl
  809233:	72 13                	jb     809248 <tcp_alloc+0xba>
  809235:	38 ca                	cmp    %cl,%dl
  809237:	77 0f                	ja     809248 <tcp_alloc+0xba>
       pcb->prio <= mprio &&
       (u32_t)(tcp_ticks - pcb->tmr) >= inactivity) {
  809239:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80923c:	2b 58 2c             	sub    0x2c(%eax),%ebx
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    if (pcb->prio <= prio &&
  80923f:	39 df                	cmp    %ebx,%edi
  809241:	77 05                	ja     809248 <tcp_alloc+0xba>
  809243:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809246:	eb 04                	jmp    80924c <tcp_alloc+0xbe>
  809248:	89 ca                	mov    %ecx,%edx
  80924a:	89 fb                	mov    %edi,%ebx
  mprio = TCP_PRIO_MAX;
  
  /* We kill the oldest active connection that has lower priority than prio. */
  inactivity = 0;
  inactive = NULL;
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  80924c:	8b 40 0c             	mov    0xc(%eax),%eax
  80924f:	85 c0                	test   %eax,%eax
  809251:	74 06                	je     809259 <tcp_alloc+0xcb>
  809253:	89 df                	mov    %ebx,%edi
  809255:	89 d1                	mov    %edx,%ecx
  809257:	eb d2                	jmp    80922b <tcp_alloc+0x9d>
      inactivity = tcp_ticks - pcb->tmr;
      inactive = pcb;
      mprio = pcb->prio;
    }
  }
  if (inactive != NULL) {
  809259:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80925d:	74 0b                	je     80926a <tcp_alloc+0xdc>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_kill_prio: killing oldest PCB %p (%"S32_F")\n",
           (void *)inactive, inactivity));
    tcp_abort(inactive);
  80925f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  809262:	89 04 24             	mov    %eax,(%esp)
  809265:	e8 14 fe ff ff       	call   80907e <tcp_abort>
    pcb = memp_malloc(MEMP_TCP_PCB);
    if (pcb == NULL) {
      /* Try killing active connections with lower priority than the new one. */
      tcp_kill_prio(prio);
      /* Try to allocate a tcp_pcb again. */
      pcb = memp_malloc(MEMP_TCP_PCB);
  80926a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809271:	e8 8e e5 ff ff       	call   807804 <memp_malloc>
  809276:	89 c3                	mov    %eax,%ebx
    }
  }
  if (pcb != NULL) {
  809278:	85 c0                	test   %eax,%eax
  80927a:	0f 84 9b 00 00 00    	je     80931b <tcp_alloc+0x18d>
    memset(pcb, 0, sizeof(struct tcp_pcb));
  809280:	c7 44 24 08 a8 00 00 	movl   $0xa8,0x8(%esp)
  809287:	00 
  809288:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80928f:	00 
  809290:	89 1c 24             	mov    %ebx,(%esp)
  809293:	e8 1e 80 ff ff       	call   8012b6 <memset>
    pcb->prio = TCP_PRIO_NORMAL;
  809298:	c6 43 14 40          	movb   $0x40,0x14(%ebx)
    pcb->snd_buf = TCP_SND_BUF;
  80929c:	66 c7 43 6e 40 5b    	movw   $0x5b40,0x6e(%ebx)
    pcb->snd_queuelen = 0;
  8092a2:	66 c7 43 70 00 00    	movw   $0x0,0x70(%ebx)
    pcb->rcv_wnd = TCP_WND;
  8092a8:	66 c7 43 28 c0 5d    	movw   $0x5dc0,0x28(%ebx)
    pcb->rcv_ann_wnd = TCP_WND;
  8092ae:	66 c7 43 2a c0 5d    	movw   $0x5dc0,0x2a(%ebx)
    pcb->tos = 0;
  8092b4:	c6 43 0a 00          	movb   $0x0,0xa(%ebx)
    pcb->ttl = TCP_TTL;
  8092b8:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    /* As initial send MSS, we use TCP_MSS but limit it to 536.
       The send MSS is updated when an MSS option is received. */
    pcb->mss = (TCP_MSS > 536) ? 536 : TCP_MSS;
  8092bc:	66 c7 43 34 18 02    	movw   $0x218,0x34(%ebx)
    pcb->rto = 3000 / TCP_SLOW_INTERVAL;
  8092c2:	66 c7 43 44 06 00    	movw   $0x6,0x44(%ebx)
    pcb->sa = 0;
  8092c8:	66 c7 43 40 00 00    	movw   $0x0,0x40(%ebx)
    pcb->sv = 3000 / TCP_SLOW_INTERVAL;
  8092ce:	66 c7 43 42 06 00    	movw   $0x6,0x42(%ebx)
    pcb->rtime = -1;
  8092d4:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
    pcb->cwnd = 1;
  8092da:	66 c7 43 4e 01 00    	movw   $0x1,0x4e(%ebx)
    iss = tcp_next_iss();
  8092e0:	e8 47 f6 ff ff       	call   80892c <tcp_next_iss>
    pcb->snd_wl2 = iss;
  8092e5:	89 43 64             	mov    %eax,0x64(%ebx)
    pcb->snd_nxt = iss;
  8092e8:	89 43 54             	mov    %eax,0x54(%ebx)
    pcb->snd_max = iss;
  8092eb:	89 43 58             	mov    %eax,0x58(%ebx)
    pcb->lastack = iss;
  8092ee:	89 43 48             	mov    %eax,0x48(%ebx)
    pcb->snd_lbb = iss;   
  8092f1:	89 43 68             	mov    %eax,0x68(%ebx)
    pcb->tmr = tcp_ticks;
  8092f4:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  8092f9:	89 43 2c             	mov    %eax,0x2c(%ebx)

    pcb->polltmr = 0;
  8092fc:	c6 43 30 00          	movb   $0x0,0x30(%ebx)

#if LWIP_CALLBACK_API
    pcb->recv = tcp_recv_null;
  809300:	c7 83 88 00 00 00 0f 	movl   $0x80990f,0x88(%ebx)
  809307:	99 80 00 
#endif /* LWIP_CALLBACK_API */  
    
    /* Init KEEPALIVE timer */
    pcb->keep_idle  = TCP_KEEPIDLE_DEFAULT;
  80930a:	c7 83 9c 00 00 00 00 	movl   $0x6ddd00,0x9c(%ebx)
  809311:	dd 6d 00 
#if LWIP_TCP_KEEPALIVE
    pcb->keep_intvl = TCP_KEEPINTVL_DEFAULT;
    pcb->keep_cnt   = TCP_KEEPCNT_DEFAULT;
#endif /* LWIP_TCP_KEEPALIVE */

    pcb->keep_cnt_sent = 0;
  809314:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)
  }
  return pcb;
}
  80931b:	89 d8                	mov    %ebx,%eax
  80931d:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809320:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809323:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809326:	89 ec                	mov    %ebp,%esp
  809328:	5d                   	pop    %ebp
  809329:	c3                   	ret    

0080932a <tcp_new>:
 *
 * @return a new tcp_pcb that initially is in state CLOSED
 */
struct tcp_pcb *
tcp_new(void)
{
  80932a:	55                   	push   %ebp
  80932b:	89 e5                	mov    %esp,%ebp
  80932d:	83 ec 18             	sub    $0x18,%esp
  return tcp_alloc(TCP_PRIO_NORMAL);
  809330:	c7 04 24 40 00 00 00 	movl   $0x40,(%esp)
  809337:	e8 52 fe ff ff       	call   80918e <tcp_alloc>
}
  80933c:	c9                   	leave  
  80933d:	c3                   	ret    

0080933e <tcp_slowtmr>:
 *
 * Automatically called from tcp_tmr().
 */
void
tcp_slowtmr(void)
{
  80933e:	55                   	push   %ebp
  80933f:	89 e5                	mov    %esp,%ebp
  809341:	57                   	push   %edi
  809342:	56                   	push   %esi
  809343:	53                   	push   %ebx
  809344:	83 ec 2c             	sub    $0x2c,%esp
  u8_t pcb_remove;      /* flag if a PCB should be removed */
  err_t err;

  err = ERR_OK;

  ++tcp_ticks;
  809347:	83 05 0c f6 b3 00 01 	addl   $0x1,0xb3f60c

  /* Steps through all of the active PCBs. */
  prev = NULL;
  pcb = tcp_active_pcbs;
  80934e:	8b 1d 08 f6 b3 00    	mov    0xb3f608,%ebx
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  809354:	85 db                	test   %ebx,%ebx
  809356:	0f 84 5f 03 00 00    	je     8096bb <tcp_slowtmr+0x37d>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  80935c:	8b 43 10             	mov    0x10(%ebx),%eax
  80935f:	85 c0                	test   %eax,%eax
  809361:	74 1c                	je     80937f <tcp_slowtmr+0x41>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  809363:	83 f8 01             	cmp    $0x1,%eax
  809366:	74 38                	je     8093a0 <tcp_slowtmr+0x62>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  809368:	83 f8 0a             	cmp    $0xa,%eax
  80936b:	74 54                	je     8093c1 <tcp_slowtmr+0x83>
  80936d:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  809371:	bf 00 00 00 00       	mov    $0x0,%edi
  809376:	eb 67                	jmp    8093df <tcp_slowtmr+0xa1>
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: processing active pcb\n"));
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != CLOSED\n", pcb->state != CLOSED);
  809378:	8b 46 10             	mov    0x10(%esi),%eax
  80937b:	85 c0                	test   %eax,%eax
  80937d:	75 1c                	jne    80939b <tcp_slowtmr+0x5d>
  80937f:	c7 44 24 08 f8 3b 81 	movl   $0x813bf8,0x8(%esp)
  809386:	00 
  809387:	c7 44 24 04 36 02 00 	movl   $0x236,0x4(%esp)
  80938e:	00 
  80938f:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  809396:	e8 39 76 ff ff       	call   8009d4 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != LISTEN\n", pcb->state != LISTEN);
  80939b:	83 f8 01             	cmp    $0x1,%eax
  80939e:	75 1c                	jne    8093bc <tcp_slowtmr+0x7e>
  8093a0:	c7 44 24 08 24 3c 81 	movl   $0x813c24,0x8(%esp)
  8093a7:	00 
  8093a8:	c7 44 24 04 37 02 00 	movl   $0x237,0x4(%esp)
  8093af:	00 
  8093b0:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  8093b7:	e8 18 76 ff ff       	call   8009d4 <_panic>
    LWIP_ASSERT("tcp_slowtmr: active pcb->state != TIME-WAIT\n", pcb->state != TIME_WAIT);
  8093bc:	83 f8 0a             	cmp    $0xa,%eax
  8093bf:	75 1c                	jne    8093dd <tcp_slowtmr+0x9f>
  8093c1:	c7 44 24 08 50 3c 81 	movl   $0x813c50,0x8(%esp)
  8093c8:	00 
  8093c9:	c7 44 24 04 38 02 00 	movl   $0x238,0x4(%esp)
  8093d0:	00 
  8093d1:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  8093d8:	e8 f7 75 ff ff       	call   8009d4 <_panic>
  8093dd:	89 f3                	mov    %esi,%ebx

    pcb_remove = 0;

    if (pcb->state == SYN_SENT && pcb->nrtx == TCP_SYNMAXRTX) {
  8093df:	83 f8 02             	cmp    $0x2,%eax
  8093e2:	75 0a                	jne    8093ee <tcp_slowtmr+0xb0>
  8093e4:	80 7b 46 06          	cmpb   $0x6,0x46(%ebx)
  8093e8:	0f 84 f1 00 00 00    	je     8094df <tcp_slowtmr+0x1a1>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max SYN retries reached\n"));
    }
    else if (pcb->nrtx == TCP_MAXRTX) {
  8093ee:	80 7b 46 0c          	cmpb   $0xc,0x46(%ebx)
  8093f2:	0f 84 e7 00 00 00    	je     8094df <tcp_slowtmr+0x1a1>
      ++pcb_remove;
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: max DATA retries reached\n"));
    } else {
      if (pcb->persist_backoff > 0) {
  8093f8:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  8093ff:	90                   	nop
  809400:	74 55                	je     809457 <tcp_slowtmr+0x119>
        /* If snd_wnd is zero, use persist timer to send 1 byte probes
         * instead of using the standard retransmission mechanism. */
        pcb->persist_cnt++;
  809402:	8b 83 a0 00 00 00    	mov    0xa0(%ebx),%eax
  809408:	83 c0 01             	add    $0x1,%eax
  80940b:	89 83 a0 00 00 00    	mov    %eax,0xa0(%ebx)
        if (pcb->persist_cnt >= tcp_persist_backoff[pcb->persist_backoff-1]) {
  809411:	0f b6 93 a4 00 00 00 	movzbl 0xa4(%ebx),%edx
  809418:	0f b6 92 84 3d 81 00 	movzbl 0x813d84(%edx),%edx
  80941f:	39 d0                	cmp    %edx,%eax
  809421:	0f 82 bf 00 00 00    	jb     8094e6 <tcp_slowtmr+0x1a8>
          pcb->persist_cnt = 0;
  809427:	c7 83 a0 00 00 00 00 	movl   $0x0,0xa0(%ebx)
  80942e:	00 00 00 
          if (pcb->persist_backoff < sizeof(tcp_persist_backoff)) {
  809431:	0f b6 83 a4 00 00 00 	movzbl 0xa4(%ebx),%eax
  809438:	3c 06                	cmp    $0x6,%al
  80943a:	77 09                	ja     809445 <tcp_slowtmr+0x107>
            pcb->persist_backoff++;
  80943c:	83 c0 01             	add    $0x1,%eax
  80943f:	88 83 a4 00 00 00    	mov    %al,0xa4(%ebx)
          }
          tcp_zero_window_probe(pcb);
  809445:	89 1c 24             	mov    %ebx,(%esp)
  809448:	e8 63 1b 00 00       	call   80afb0 <tcp_zero_window_probe>
  80944d:	be 00 00 00 00       	mov    $0x0,%esi
  809452:	e9 94 00 00 00       	jmp    8094eb <tcp_slowtmr+0x1ad>
        }
      } else {
        /* Increase the retransmission timer if it is running */
        if(pcb->rtime >= 0)
  809457:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  80945b:	66 85 c0             	test   %ax,%ax
  80945e:	78 07                	js     809467 <tcp_slowtmr+0x129>
          ++pcb->rtime;
  809460:	83 c0 01             	add    $0x1,%eax
  809463:	66 89 43 32          	mov    %ax,0x32(%ebx)

        if (pcb->unacked != NULL && pcb->rtime >= pcb->rto) {
  809467:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  80946b:	74 79                	je     8094e6 <tcp_slowtmr+0x1a8>
  80946d:	0f b7 43 32          	movzwl 0x32(%ebx),%eax
  809471:	66 3b 43 44          	cmp    0x44(%ebx),%ax
  809475:	7c 6f                	jl     8094e6 <tcp_slowtmr+0x1a8>
                                      " pcb->rto %"S16_F"\n",
                                      pcb->rtime, pcb->rto));

          /* Double retransmission time-out unless we are trying to
           * connect to somebody (i.e., we are in SYN_SENT). */
          if (pcb->state != SYN_SENT) {
  809477:	83 7b 10 02          	cmpl   $0x2,0x10(%ebx)
  80947b:	74 20                	je     80949d <tcp_slowtmr+0x15f>
            pcb->rto = ((pcb->sa >> 3) + pcb->sv) << tcp_backoff[pcb->nrtx];
  80947d:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  809481:	66 c1 f8 03          	sar    $0x3,%ax
  809485:	98                   	cwtl   
  809486:	0f bf 53 42          	movswl 0x42(%ebx),%edx
  80948a:	01 d0                	add    %edx,%eax
  80948c:	0f b6 53 46          	movzbl 0x46(%ebx),%edx
  809490:	0f b6 8a 78 3d 81 00 	movzbl 0x813d78(%edx),%ecx
  809497:	d3 e0                	shl    %cl,%eax
  809499:	66 89 43 44          	mov    %ax,0x44(%ebx)
          }

          /* Reset the retransmission timer. */
          pcb->rtime = 0;
  80949d:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

          /* Reduce congestion window and ssthresh. */
          eff_wnd = LWIP_MIN(pcb->cwnd, pcb->snd_wnd);
          pcb->ssthresh = eff_wnd >> 1;
  8094a3:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  8094a7:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  8094ab:	66 39 d0             	cmp    %dx,%ax
  8094ae:	76 02                	jbe    8094b2 <tcp_slowtmr+0x174>
  8094b0:	89 d0                	mov    %edx,%eax
  8094b2:	66 d1 e8             	shr    %ax
  8094b5:	66 89 43 50          	mov    %ax,0x50(%ebx)
          if (pcb->ssthresh < pcb->mss) {
  8094b9:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  8094bd:	66 39 d0             	cmp    %dx,%ax
  8094c0:	73 06                	jae    8094c8 <tcp_slowtmr+0x18a>
            pcb->ssthresh = pcb->mss * 2;
  8094c2:	01 d2                	add    %edx,%edx
  8094c4:	66 89 53 50          	mov    %dx,0x50(%ebx)
          }
          pcb->cwnd = pcb->mss;
  8094c8:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  8094cc:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
                                       " ssthresh %"U16_F"\n",
                                       pcb->cwnd, pcb->ssthresh));
 
          /* The following needs to be called AFTER cwnd is set to one
             mss - STJ */
          tcp_rexmit_rto(pcb);
  8094d0:	89 1c 24             	mov    %ebx,(%esp)
  8094d3:	e8 fb 23 00 00       	call   80b8d3 <tcp_rexmit_rto>
  8094d8:	be 00 00 00 00       	mov    $0x0,%esi
  8094dd:	eb 0c                	jmp    8094eb <tcp_slowtmr+0x1ad>
  8094df:	be 01 00 00 00       	mov    $0x1,%esi
  8094e4:	eb 05                	jmp    8094eb <tcp_slowtmr+0x1ad>
  8094e6:	be 00 00 00 00       	mov    $0x0,%esi
        }
      }
    }
    /* Check if this PCB has stayed too long in FIN-WAIT-2 */
    if (pcb->state == FIN_WAIT_2) {
  8094eb:	8b 43 10             	mov    0x10(%ebx),%eax
  8094ee:	83 f8 06             	cmp    $0x6,%eax
  8094f1:	75 13                	jne    809506 <tcp_slowtmr+0x1c8>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8094f3:	8b 15 0c f6 b3 00    	mov    0xb3f60c,%edx
  8094f9:	2b 53 2c             	sub    0x2c(%ebx),%edx
          TCP_FIN_WAIT_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8094fc:	83 fa 29             	cmp    $0x29,%edx
  8094ff:	89 f2                	mov    %esi,%edx
  809501:	80 da ff             	sbb    $0xff,%dl
  809504:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in FIN-WAIT-2\n"));
      }
    }

    /* Check if KEEPALIVE should be sent */
    if((pcb->so_options & SOF_KEEPALIVE) && 
  809506:	f6 43 08 08          	testb  $0x8,0x8(%ebx)
  80950a:	74 6a                	je     809576 <tcp_slowtmr+0x238>
  80950c:	83 f8 04             	cmp    $0x4,%eax
  80950f:	74 05                	je     809516 <tcp_slowtmr+0x1d8>
  809511:	83 f8 07             	cmp    $0x7,%eax
  809514:	75 60                	jne    809576 <tcp_slowtmr+0x238>
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  809516:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  80951b:	2b 43 2c             	sub    0x2c(%ebx),%eax
  80951e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
         (pcb->keep_idle + TCP_MAXIDLE) / TCP_SLOW_INTERVAL)
  809521:	8b 8b 9c 00 00 00    	mov    0x9c(%ebx),%ecx
#if LWIP_TCP_KEEPALIVE
      if((u32_t)(tcp_ticks - pcb->tmr) > 
         (pcb->keep_idle + (pcb->keep_cnt*pcb->keep_intvl))
         / TCP_SLOW_INTERVAL)
#else      
      if((u32_t)(tcp_ticks - pcb->tmr) > 
  809527:	8d 81 b8 4c 0a 00    	lea    0xa4cb8(%ecx),%eax
  80952d:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  809532:	f7 e2                	mul    %edx
  809534:	c1 ea 05             	shr    $0x5,%edx
  809537:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  80953a:	76 0a                	jbe    809546 <tcp_slowtmr+0x208>
      {
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: KEEPALIVE timeout. Aborting connection to %"U16_F".%"U16_F".%"U16_F".%"U16_F".\n",
                                ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                                ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));
        
        tcp_abort(pcb);
  80953c:	89 1c 24             	mov    %ebx,(%esp)
  80953f:	e8 3a fb ff ff       	call   80907e <tcp_abort>
  809544:	eb 30                	jmp    809576 <tcp_slowtmr+0x238>
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * pcb->keep_intvl)
              / TCP_SLOW_INTERVAL)
#else
      else if((u32_t)(tcp_ticks - pcb->tmr) > 
              (pcb->keep_idle + pcb->keep_cnt_sent * TCP_KEEPINTVL_DEFAULT) 
  809546:	0f b6 93 a5 00 00 00 	movzbl 0xa5(%ebx),%edx
  80954d:	69 d2 f8 24 01 00    	imul   $0x124f8,%edx,%edx
  809553:	8d 0c 0a             	lea    (%edx,%ecx,1),%ecx
  809556:	ba d3 4d 62 10       	mov    $0x10624dd3,%edx
  80955b:	89 c8                	mov    %ecx,%eax
  80955d:	f7 e2                	mul    %edx
  80955f:	c1 ea 05             	shr    $0x5,%edx
  809562:	39 55 e4             	cmp    %edx,-0x1c(%ebp)
  809565:	76 0f                	jbe    809576 <tcp_slowtmr+0x238>
              / TCP_SLOW_INTERVAL)
#endif /* LWIP_TCP_KEEPALIVE */
      {
        tcp_keepalive(pcb);
  809567:	89 1c 24             	mov    %ebx,(%esp)
  80956a:	e8 b8 1b 00 00       	call   80b127 <tcp_keepalive>
        pcb->keep_cnt_sent++;
  80956f:	80 83 a5 00 00 00 01 	addb   $0x1,0xa5(%ebx)

    /* If this PCB has queued out of sequence data, but has been
       inactive for too long, will drop the data (it will eventually
       be retransmitted). */
#if TCP_QUEUE_OOSEQ    
    if (pcb->ooseq != NULL &&
  809576:	8b 53 7c             	mov    0x7c(%ebx),%edx
  809579:	85 d2                	test   %edx,%edx
  80957b:	74 25                	je     8095a2 <tcp_slowtmr+0x264>
        (u32_t)tcp_ticks - pcb->tmr >= pcb->rto * TCP_OOSEQ_TIMEOUT) {
  80957d:	8b 0d 0c f6 b3 00    	mov    0xb3f60c,%ecx
  809583:	2b 4b 2c             	sub    0x2c(%ebx),%ecx
  809586:	0f bf 43 44          	movswl 0x44(%ebx),%eax
  80958a:	8d 04 40             	lea    (%eax,%eax,2),%eax
  80958d:	01 c0                	add    %eax,%eax
  80958f:	39 c1                	cmp    %eax,%ecx
  809591:	72 0f                	jb     8095a2 <tcp_slowtmr+0x264>
      tcp_segs_free(pcb->ooseq);
  809593:	89 14 24             	mov    %edx,(%esp)
  809596:	e8 7b f5 ff ff       	call   808b16 <tcp_segs_free>
      pcb->ooseq = NULL;
  80959b:	c7 43 7c 00 00 00 00 	movl   $0x0,0x7c(%ebx)
      LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_slowtmr: dropping OOSEQ queued data\n"));
    }
#endif /* TCP_QUEUE_OOSEQ */

    /* Check if this PCB has stayed too long in SYN-RCVD */
    if (pcb->state == SYN_RCVD) {
  8095a2:	8b 43 10             	mov    0x10(%ebx),%eax
  8095a5:	83 f8 03             	cmp    $0x3,%eax
  8095a8:	75 13                	jne    8095bd <tcp_slowtmr+0x27f>
      if ((u32_t)(tcp_ticks - pcb->tmr) >
  8095aa:	8b 15 0c f6 b3 00    	mov    0xb3f60c,%edx
  8095b0:	2b 53 2c             	sub    0x2c(%ebx),%edx
  8095b3:	83 fa 28             	cmp    $0x28,%edx
  8095b6:	76 05                	jbe    8095bd <tcp_slowtmr+0x27f>
          TCP_SYN_RCVD_TIMEOUT / TCP_SLOW_INTERVAL) {
        ++pcb_remove;
  8095b8:	83 c6 01             	add    $0x1,%esi
  8095bb:	eb 19                	jmp    8095d6 <tcp_slowtmr+0x298>
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in SYN-RCVD\n"));
      }
    }

    /* Check if this PCB has stayed too long in LAST-ACK */
    if (pcb->state == LAST_ACK) {
  8095bd:	83 f8 09             	cmp    $0x9,%eax
  8095c0:	75 14                	jne    8095d6 <tcp_slowtmr+0x298>
      if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8095c2:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  8095c7:	2b 43 2c             	sub    0x2c(%ebx),%eax
        ++pcb_remove;
  8095ca:	3d f1 00 00 00       	cmp    $0xf1,%eax
  8095cf:	89 f2                	mov    %esi,%edx
  8095d1:	80 da ff             	sbb    $0xff,%dl
  8095d4:	89 d6                	mov    %edx,%esi
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: removing pcb stuck in LAST-ACK\n"));
      }
    }

    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
  8095d6:	89 f0                	mov    %esi,%eax
  8095d8:	84 c0                	test   %al,%al
  8095da:	0f 84 94 00 00 00    	je     809674 <tcp_slowtmr+0x336>
      tcp_pcb_purge(pcb);      
  8095e0:	89 1c 24             	mov    %ebx,(%esp)
  8095e3:	e8 5f f5 ff ff       	call   808b47 <tcp_pcb_purge>
      /* Remove PCB from tcp_active_pcbs list. */
      if (prev != NULL) {
  8095e8:	85 ff                	test   %edi,%edi
  8095ea:	74 2c                	je     809618 <tcp_slowtmr+0x2da>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_active_pcbs", pcb != tcp_active_pcbs);
  8095ec:	3b 1d 08 f6 b3 00    	cmp    0xb3f608,%ebx
  8095f2:	75 1c                	jne    809610 <tcp_slowtmr+0x2d2>
  8095f4:	c7 44 24 08 80 3c 81 	movl   $0x813c80,0x8(%esp)
  8095fb:	00 
  8095fc:	c7 44 24 04 c1 02 00 	movl   $0x2c1,0x4(%esp)
  809603:	00 
  809604:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  80960b:	e8 c4 73 ff ff       	call   8009d4 <_panic>
        prev->next = pcb->next;
  809610:	8b 43 0c             	mov    0xc(%ebx),%eax
  809613:	89 47 0c             	mov    %eax,0xc(%edi)
  809616:	eb 2d                	jmp    809645 <tcp_slowtmr+0x307>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_active_pcbs", tcp_active_pcbs == pcb);
  809618:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
  80961d:	39 d8                	cmp    %ebx,%eax
  80961f:	74 1c                	je     80963d <tcp_slowtmr+0x2ff>
  809621:	c7 44 24 08 ac 3c 81 	movl   $0x813cac,0x8(%esp)
  809628:	00 
  809629:	c7 44 24 04 c5 02 00 	movl   $0x2c5,0x4(%esp)
  809630:	00 
  809631:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  809638:	e8 97 73 ff ff       	call   8009d4 <_panic>
        tcp_active_pcbs = pcb->next;
  80963d:	8b 40 0c             	mov    0xc(%eax),%eax
  809640:	a3 08 f6 b3 00       	mov    %eax,0xb3f608
      }

      TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_ABRT);
  809645:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80964b:	85 c0                	test   %eax,%eax
  80964d:	74 10                	je     80965f <tcp_slowtmr+0x321>
  80964f:	c7 44 24 04 fb ff ff 	movl   $0xfffffffb,0x4(%esp)
  809656:	ff 
  809657:	8b 53 18             	mov    0x18(%ebx),%edx
  80965a:	89 14 24             	mov    %edx,(%esp)
  80965d:	ff d0                	call   *%eax

      pcb2 = pcb->next;
  80965f:	8b 73 0c             	mov    0xc(%ebx),%esi
      memp_free(MEMP_TCP_PCB, pcb);
  809662:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809666:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80966d:	e8 4e e1 ff ff       	call   8077c0 <memp_free>
  809672:	eb 3f                	jmp    8096b3 <tcp_slowtmr+0x375>
      pcb = pcb2;
    } else {

      /* We check if we should poll the connection. */
      ++pcb->polltmr;
  809674:	0f b6 43 30          	movzbl 0x30(%ebx),%eax
  809678:	83 c0 01             	add    $0x1,%eax
  80967b:	88 43 30             	mov    %al,0x30(%ebx)
      if (pcb->polltmr >= pcb->pollinterval) {
  80967e:	3a 43 31             	cmp    0x31(%ebx),%al
  809681:	72 2b                	jb     8096ae <tcp_slowtmr+0x370>
        pcb->polltmr = 0;
  809683:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: polling application\n"));
        TCP_EVENT_POLL(pcb, err);
  809687:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80968d:	85 c0                	test   %eax,%eax
  80968f:	74 0f                	je     8096a0 <tcp_slowtmr+0x362>
  809691:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809695:	8b 53 18             	mov    0x18(%ebx),%edx
  809698:	89 14 24             	mov    %edx,(%esp)
  80969b:	ff d0                	call   *%eax
  80969d:	88 45 e3             	mov    %al,-0x1d(%ebp)
        if (err == ERR_OK) {
  8096a0:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  8096a4:	75 08                	jne    8096ae <tcp_slowtmr+0x370>
          tcp_output(pcb);
  8096a6:	89 1c 24             	mov    %ebx,(%esp)
  8096a9:	e8 2d 1d 00 00       	call   80b3db <tcp_output>
        }
      }
      
      prev = pcb;
      pcb = pcb->next;
  8096ae:	8b 73 0c             	mov    0xc(%ebx),%esi
  8096b1:	89 df                	mov    %ebx,%edi
  prev = NULL;
  pcb = tcp_active_pcbs;
  if (pcb == NULL) {
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_slowtmr: no active pcbs\n"));
  }
  while (pcb != NULL) {
  8096b3:	85 f6                	test   %esi,%esi
  8096b5:	0f 85 bd fc ff ff    	jne    809378 <tcp_slowtmr+0x3a>
  }

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  8096bb:	8b 1d 1c f6 b3 00    	mov    0xb3f61c,%ebx
  while (pcb != NULL) {
  8096c1:	85 db                	test   %ebx,%ebx
  8096c3:	0f 84 c7 00 00 00    	je     809790 <tcp_slowtmr+0x452>
    LWIP_ASSERT("tcp_slowtmr: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  8096c9:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  8096cd:	75 0d                	jne    8096dc <tcp_slowtmr+0x39e>
  8096cf:	be 00 00 00 00       	mov    $0x0,%esi
  8096d4:	eb 24                	jmp    8096fa <tcp_slowtmr+0x3bc>
  8096d6:	83 7f 10 0a          	cmpl   $0xa,0x10(%edi)
  8096da:	74 1c                	je     8096f8 <tcp_slowtmr+0x3ba>
  8096dc:	c7 44 24 08 d8 3c 81 	movl   $0x813cd8,0x8(%esp)
  8096e3:	00 
  8096e4:	c7 44 24 04 e5 02 00 	movl   $0x2e5,0x4(%esp)
  8096eb:	00 
  8096ec:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  8096f3:	e8 dc 72 ff ff       	call   8009d4 <_panic>
  8096f8:	89 fb                	mov    %edi,%ebx
    pcb_remove = 0;

    /* Check if this PCB has stayed long enough in TIME-WAIT */
    if ((u32_t)(tcp_ticks - pcb->tmr) > 2 * TCP_MSL / TCP_SLOW_INTERVAL) {
  8096fa:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  8096ff:	2b 43 2c             	sub    0x2c(%ebx),%eax
  809702:	3d f0 00 00 00       	cmp    $0xf0,%eax
  809707:	76 7a                	jbe    809783 <tcp_slowtmr+0x445>
    


    /* If the PCB should be removed, do it. */
    if (pcb_remove) {
      tcp_pcb_purge(pcb);      
  809709:	89 1c 24             	mov    %ebx,(%esp)
  80970c:	e8 36 f4 ff ff       	call   808b47 <tcp_pcb_purge>
      /* Remove PCB from tcp_tw_pcbs list. */
      if (prev != NULL) {
  809711:	85 f6                	test   %esi,%esi
  809713:	74 2c                	je     809741 <tcp_slowtmr+0x403>
        LWIP_ASSERT("tcp_slowtmr: middle tcp != tcp_tw_pcbs", pcb != tcp_tw_pcbs);
  809715:	3b 1d 1c f6 b3 00    	cmp    0xb3f61c,%ebx
  80971b:	75 1c                	jne    809739 <tcp_slowtmr+0x3fb>
  80971d:	c7 44 24 08 08 3d 81 	movl   $0x813d08,0x8(%esp)
  809724:	00 
  809725:	c7 44 24 04 f4 02 00 	movl   $0x2f4,0x4(%esp)
  80972c:	00 
  80972d:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  809734:	e8 9b 72 ff ff       	call   8009d4 <_panic>
        prev->next = pcb->next;
  809739:	8b 43 0c             	mov    0xc(%ebx),%eax
  80973c:	89 46 0c             	mov    %eax,0xc(%esi)
  80973f:	eb 2d                	jmp    80976e <tcp_slowtmr+0x430>
      } else {
        /* This PCB was the first. */
        LWIP_ASSERT("tcp_slowtmr: first pcb == tcp_tw_pcbs", tcp_tw_pcbs == pcb);
  809741:	a1 1c f6 b3 00       	mov    0xb3f61c,%eax
  809746:	39 d8                	cmp    %ebx,%eax
  809748:	74 1c                	je     809766 <tcp_slowtmr+0x428>
  80974a:	c7 44 24 08 30 3d 81 	movl   $0x813d30,0x8(%esp)
  809751:	00 
  809752:	c7 44 24 04 f8 02 00 	movl   $0x2f8,0x4(%esp)
  809759:	00 
  80975a:	c7 04 24 2f 3b 81 00 	movl   $0x813b2f,(%esp)
  809761:	e8 6e 72 ff ff       	call   8009d4 <_panic>
        tcp_tw_pcbs = pcb->next;
  809766:	8b 40 0c             	mov    0xc(%eax),%eax
  809769:	a3 1c f6 b3 00       	mov    %eax,0xb3f61c
      }
      pcb2 = pcb->next;
  80976e:	8b 7b 0c             	mov    0xc(%ebx),%edi
      memp_free(MEMP_TCP_PCB, pcb);
  809771:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809775:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80977c:	e8 3f e0 ff ff       	call   8077c0 <memp_free>
  809781:	eb 05                	jmp    809788 <tcp_slowtmr+0x44a>
      pcb = pcb2;
    } else {
      prev = pcb;
      pcb = pcb->next;
  809783:	8b 7b 0c             	mov    0xc(%ebx),%edi
  809786:	89 de                	mov    %ebx,%esi

  
  /* Steps through all of the TIME-WAIT PCBs. */
  prev = NULL;    
  pcb = tcp_tw_pcbs;
  while (pcb != NULL) {
  809788:	85 ff                	test   %edi,%edi
  80978a:	0f 85 46 ff ff ff    	jne    8096d6 <tcp_slowtmr+0x398>
    } else {
      prev = pcb;
      pcb = pcb->next;
    }
  }
}
  809790:	83 c4 2c             	add    $0x2c,%esp
  809793:	5b                   	pop    %ebx
  809794:	5e                   	pop    %esi
  809795:	5f                   	pop    %edi
  809796:	5d                   	pop    %ebp
  809797:	c3                   	ret    

00809798 <tcp_tmr>:
 * Called periodically to dispatch TCP timers.
 *
 */
void
tcp_tmr(void)
{
  809798:	55                   	push   %ebp
  809799:	89 e5                	mov    %esp,%ebp
  80979b:	83 ec 08             	sub    $0x8,%esp
  /* Call tcp_fasttmr() every 250 ms */
  tcp_fasttmr();
  80979e:	e8 68 f2 ff ff       	call   808a0b <tcp_fasttmr>

  if (++tcp_timer & 1) {
  8097a3:	0f b6 05 a8 87 b3 00 	movzbl 0xb387a8,%eax
  8097aa:	83 c0 01             	add    $0x1,%eax
  8097ad:	a2 a8 87 b3 00       	mov    %al,0xb387a8
  8097b2:	a8 01                	test   $0x1,%al
  8097b4:	74 05                	je     8097bb <tcp_tmr+0x23>
    /* Call tcp_tmr() every 500 ms, i.e., every other timer
       tcp_tmr() is called. */
    tcp_slowtmr();
  8097b6:	e8 83 fb ff ff       	call   80933e <tcp_slowtmr>
  }
}
  8097bb:	c9                   	leave  
  8097bc:	c3                   	ret    

008097bd <tcp_close>:
 * @return ERR_OK if connection has been closed
 *         another err_t if closing failed and pcb is not freed
 */
err_t
tcp_close(struct tcp_pcb *pcb)
{
  8097bd:	55                   	push   %ebp
  8097be:	89 e5                	mov    %esp,%ebp
  8097c0:	53                   	push   %ebx
  8097c1:	83 ec 14             	sub    $0x14,%esp
  8097c4:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if TCP_DEBUG
  LWIP_DEBUGF(TCP_DEBUG, ("tcp_close: closing in "));
  tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */

  switch (pcb->state) {
  8097c7:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  8097cb:	77 0a                	ja     8097d7 <tcp_close+0x1a>
  8097cd:	8b 43 10             	mov    0x10(%ebx),%eax
  8097d0:	ff 24 85 58 3d 81 00 	jmp    *0x813d58(,%eax,4)
  8097d7:	bb 00 00 00 00       	mov    $0x0,%ebx
  8097dc:	e9 05 01 00 00       	jmp    8098e6 <tcp_close+0x129>
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  8097e1:	8b 15 18 f6 b3 00    	mov    0xb3f618,%edx
  8097e7:	39 da                	cmp    %ebx,%edx
  8097e9:	75 0a                	jne    8097f5 <tcp_close+0x38>
  8097eb:	8b 42 0c             	mov    0xc(%edx),%eax
  8097ee:	a3 18 f6 b3 00       	mov    %eax,0xb3f618
  8097f3:	eb 2a                	jmp    80981f <tcp_close+0x62>
  8097f5:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  8097fb:	85 d2                	test   %edx,%edx
  8097fd:	74 20                	je     80981f <tcp_close+0x62>
  8097ff:	8b 42 0c             	mov    0xc(%edx),%eax
  809802:	85 c0                	test   %eax,%eax
  809804:	0f 84 fb 00 00 00    	je     809905 <tcp_close+0x148>
  80980a:	39 c3                	cmp    %eax,%ebx
  80980c:	75 08                	jne    809816 <tcp_close+0x59>
  80980e:	8b 43 0c             	mov    0xc(%ebx),%eax
  809811:	89 42 0c             	mov    %eax,0xc(%edx)
  809814:	eb 09                	jmp    80981f <tcp_close+0x62>
  809816:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  80981b:	89 c2                	mov    %eax,%edx
  80981d:	eb e0                	jmp    8097ff <tcp_close+0x42>
  80981f:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
    memp_free(MEMP_TCP_PCB, pcb);
  809826:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80982a:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809831:	e8 8a df ff ff       	call   8077c0 <memp_free>
  809836:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  80983b:	e9 bf 00 00 00       	jmp    8098ff <tcp_close+0x142>
  case LISTEN:
    err = ERR_OK;
    tcp_pcb_remove((struct tcp_pcb **)&tcp_listen_pcbs.pcbs, pcb);
  809840:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809844:	c7 04 24 10 f6 b3 00 	movl   $0xb3f610,(%esp)
  80984b:	e8 70 f3 ff ff       	call   808bc0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB_LISTEN, pcb);
  809850:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809854:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80985b:	e8 60 df ff ff       	call   8077c0 <memp_free>
  809860:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    break;
  809865:	e9 95 00 00 00       	jmp    8098ff <tcp_close+0x142>
  case SYN_SENT:
    err = ERR_OK;
    tcp_pcb_remove(&tcp_active_pcbs, pcb);
  80986a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80986e:	c7 04 24 08 f6 b3 00 	movl   $0xb3f608,(%esp)
  809875:	e8 46 f3 ff ff       	call   808bc0 <tcp_pcb_remove>
    memp_free(MEMP_TCP_PCB, pcb);
  80987a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80987e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809885:	e8 36 df ff ff       	call   8077c0 <memp_free>
  80988a:	b8 00 00 00 00       	mov    $0x0,%eax
    pcb = NULL;
    snmp_inc_tcpattemptfails();
    break;
  80988f:	eb 6e                	jmp    8098ff <tcp_close+0x142>
  case SYN_RCVD:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  809891:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  809898:	00 
  809899:	89 1c 24             	mov    %ebx,(%esp)
  80989c:	e8 f7 27 00 00       	call   80c098 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8098a1:	84 c0                	test   %al,%al
  8098a3:	75 5a                	jne    8098ff <tcp_close+0x142>
      snmp_inc_tcpattemptfails();
      pcb->state = FIN_WAIT_1;
  8098a5:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8098ac:	eb 38                	jmp    8098e6 <tcp_close+0x129>
    }
    break;
  case ESTABLISHED:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8098ae:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8098b5:	00 
  8098b6:	89 1c 24             	mov    %ebx,(%esp)
  8098b9:	e8 da 27 00 00       	call   80c098 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8098be:	84 c0                	test   %al,%al
  8098c0:	75 3d                	jne    8098ff <tcp_close+0x142>
      snmp_inc_tcpestabresets();
      pcb->state = FIN_WAIT_1;
  8098c2:	c7 43 10 05 00 00 00 	movl   $0x5,0x10(%ebx)
  8098c9:	eb 1b                	jmp    8098e6 <tcp_close+0x129>
    }
    break;
  case CLOSE_WAIT:
    err = tcp_send_ctrl(pcb, TCP_FIN);
  8098cb:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  8098d2:	00 
  8098d3:	89 1c 24             	mov    %ebx,(%esp)
  8098d6:	e8 bd 27 00 00       	call   80c098 <tcp_send_ctrl>
    if (err == ERR_OK) {
  8098db:	84 c0                	test   %al,%al
  8098dd:	75 20                	jne    8098ff <tcp_close+0x142>
      snmp_inc_tcpestabresets();
      pcb->state = LAST_ACK;
  8098df:	c7 43 10 09 00 00 00 	movl   $0x9,0x10(%ebx)
    err = ERR_OK;
    pcb = NULL;
    break;
  }

  if (pcb != NULL && err == ERR_OK) {
  8098e6:	85 db                	test   %ebx,%ebx
  8098e8:	75 08                	jne    8098f2 <tcp_close+0x135>
  8098ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8098ef:	90                   	nop
  8098f0:	eb 0d                	jmp    8098ff <tcp_close+0x142>
       Since we don't really have to ensure all data has been sent when tcp_close
       returns (unsent data is sent from tcp timer functions, also), we don't care
       for the return value of tcp_output for now. */
    /* @todo: When implementing SO_LINGER, this must be changed somehow:
       If SOF_LINGER is set, the data should be sent when tcp_close returns. */
    tcp_output(pcb);
  8098f2:	89 1c 24             	mov    %ebx,(%esp)
  8098f5:	e8 e1 1a 00 00       	call   80b3db <tcp_output>
  8098fa:	b8 00 00 00 00       	mov    $0x0,%eax
  }
  return err;
}
  8098ff:	83 c4 14             	add    $0x14,%esp
  809902:	5b                   	pop    %ebx
  809903:	5d                   	pop    %ebp
  809904:	c3                   	ret    
     * Calling tcp_close() with a pcb that has already been closed, (i.e. twice)
     * or for a pcb that has been used and then entered the CLOSED state 
     * is erroneous, but this should never happen as the pcb has in those cases
     * been freed, and so any remaining handles are bogus. */
    err = ERR_OK;
    TCP_RMV(&tcp_bound_pcbs, pcb);
  809905:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  80990a:	e9 10 ff ff ff       	jmp    80981f <tcp_close+0x62>

0080990f <tcp_recv_null>:
 * Default receive callback that is called if the user didn't register
 * a recv callback for the pcb.
 */
static err_t
tcp_recv_null(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80990f:	55                   	push   %ebp
  809910:	89 e5                	mov    %esp,%ebp
  809912:	83 ec 18             	sub    $0x18,%esp
  809915:	8b 45 10             	mov    0x10(%ebp),%eax
  809918:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  arg = arg;
  if (p != NULL) {
  80991c:	85 c0                	test   %eax,%eax
  80991e:	74 0f                	je     80992f <tcp_recv_null+0x20>
    pbuf_free(p);
  809920:	89 04 24             	mov    %eax,(%esp)
  809923:	e8 30 e6 ff ff       	call   807f58 <pbuf_free>
  809928:	b8 00 00 00 00       	mov    $0x0,%eax
  80992d:	eb 14                	jmp    809943 <tcp_recv_null+0x34>
  } else if (err == ERR_OK) {
  80992f:	b8 00 00 00 00       	mov    $0x0,%eax
  809934:	84 d2                	test   %dl,%dl
  809936:	75 0b                	jne    809943 <tcp_recv_null+0x34>
    return tcp_close(pcb);
  809938:	8b 45 0c             	mov    0xc(%ebp),%eax
  80993b:	89 04 24             	mov    %eax,(%esp)
  80993e:	e8 7a fe ff ff       	call   8097bd <tcp_close>
  }
  return ERR_OK;
}
  809943:	c9                   	leave  
  809944:	c3                   	ret    
  809945:	00 00                	add    %al,(%eax)
	...

00809948 <ip_addr_isbroadcast>:
 * @param addr address to be checked
 * @param netif the network interface against which the address is checked
 * @return returns non-zero if the address is a broadcast address
 */
u8_t ip_addr_isbroadcast(struct ip_addr *addr, struct netif *netif)
{
  809948:	55                   	push   %ebp
  809949:	89 e5                	mov    %esp,%ebp
  80994b:	53                   	push   %ebx
  80994c:	8b 4d 0c             	mov    0xc(%ebp),%ecx
  u32_t addr2test;

  addr2test = addr->addr;
  80994f:	8b 45 08             	mov    0x8(%ebp),%eax
  809952:	8b 10                	mov    (%eax),%edx
  /* all ones (broadcast) or all zeroes (old skool broadcast) */
  if ((~addr2test == IP_ADDR_ANY_VALUE) ||
  809954:	8d 5a ff             	lea    -0x1(%edx),%ebx
  809957:	b8 01 00 00 00       	mov    $0x1,%eax
  80995c:	83 fb fd             	cmp    $0xfffffffd,%ebx
  80995f:	77 26                	ja     809987 <ip_addr_isbroadcast+0x3f>
      (addr2test == IP_ADDR_ANY_VALUE))
    return 1;
  /* no broadcast support on this network interface? */
  else if ((netif->flags & NETIF_FLAG_BROADCAST) == 0)
  809961:	f6 41 2e 02          	testb  $0x2,0x2e(%ecx)
  809965:	74 1b                	je     809982 <ip_addr_isbroadcast+0x3a>
    /* the given address cannot be a broadcast address
     * nor can we check against any broadcast addresses */
    return 0;
  /* address matches network interface address exactly? => no broadcast */
  else if (addr2test == netif->ip_addr.addr)
  809967:	8b 41 04             	mov    0x4(%ecx),%eax
  80996a:	39 d0                	cmp    %edx,%eax
  80996c:	74 14                	je     809982 <ip_addr_isbroadcast+0x3a>
    return 0;
  /*  on the same (sub) network... */
  else if (ip_addr_netcmp(addr, &(netif->ip_addr), &(netif->netmask))
  80996e:	8b 49 08             	mov    0x8(%ecx),%ecx
  809971:	31 d0                	xor    %edx,%eax
  809973:	85 c8                	test   %ecx,%eax
  809975:	75 0b                	jne    809982 <ip_addr_isbroadcast+0x3a>
         /* ...and host identifier bits are all ones? =>... */
          && ((addr2test & ~netif->netmask.addr) ==
  809977:	f7 d1                	not    %ecx
  809979:	21 ca                	and    %ecx,%edx
  80997b:	39 d1                	cmp    %edx,%ecx
  80997d:	0f 94 c0             	sete   %al
  809980:	eb 05                	jmp    809987 <ip_addr_isbroadcast+0x3f>
  809982:	b8 00 00 00 00       	mov    $0x0,%eax
           (IP_ADDR_BROADCAST_VALUE & ~netif->netmask.addr)))
    /* => network broadcast address */
    return 1;
  else
    return 0;
}
  809987:	5b                   	pop    %ebx
  809988:	5d                   	pop    %ebp
  809989:	c3                   	ret    
  80998a:	00 00                	add    %al,(%eax)
  80998c:	00 00                	add    %al,(%eax)
	...

00809990 <ip_output_if>:
 */
err_t
ip_output_if(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
             u8_t ttl, u8_t tos,
             u8_t proto, struct netif *netif)
{
  809990:	55                   	push   %ebp
  809991:	89 e5                	mov    %esp,%ebp
  809993:	83 ec 48             	sub    $0x48,%esp
  809996:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809999:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80999c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80999f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  8099a2:	8b 7d 10             	mov    0x10(%ebp),%edi
  8099a5:	8b 75 20             	mov    0x20(%ebp),%esi
  8099a8:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  8099ac:	88 45 d8             	mov    %al,-0x28(%ebp)
  8099af:	0f b6 55 18          	movzbl 0x18(%ebp),%edx
  8099b3:	88 55 d7             	mov    %dl,-0x29(%ebp)
  8099b6:	0f b6 45 1c          	movzbl 0x1c(%ebp),%eax
  8099ba:	88 45 d6             	mov    %al,-0x2a(%ebp)
  static u16_t ip_id = 0;

  snmp_inc_ipoutrequests();

  /* Should the IP header be generated or is it already included in p? */
  if (dest != IP_HDRINCL) {
  8099bd:	85 ff                	test   %edi,%edi
  8099bf:	0f 84 3a 01 00 00    	je     809aff <ip_output_if+0x16f>
    /* generate IP header */
    if (pbuf_header(p, IP_HLEN)) {
  8099c5:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8099cc:	00 
  8099cd:	89 1c 24             	mov    %ebx,(%esp)
  8099d0:	e8 0e e2 ff ff       	call   807be3 <pbuf_header>
  8099d5:	89 c2                	mov    %eax,%edx
  8099d7:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  8099dc:	84 d2                	test   %dl,%dl
  8099de:	0f 85 50 01 00 00    	jne    809b34 <ip_output_if+0x1a4>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  8099e4:	8b 43 04             	mov    0x4(%ebx),%eax
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
  8099e7:	66 83 7b 0a 13       	cmpw   $0x13,0xa(%ebx)
  8099ec:	77 1c                	ja     809a0a <ip_output_if+0x7a>
  8099ee:	c7 44 24 08 94 3d 81 	movl   $0x813d94,0x8(%esp)
  8099f5:	00 
  8099f6:	c7 44 24 04 ee 01 00 	movl   $0x1ee,0x4(%esp)
  8099fd:	00 
  8099fe:	c7 04 24 c1 3d 81 00 	movl   $0x813dc1,(%esp)
  809a05:	e8 ca 6f ff ff       	call   8009d4 <_panic>
      IP_STATS_INC(ip.err);
      snmp_inc_ipoutdiscards();
      return ERR_BUF;
    }

    iphdr = p->payload;
  809a0a:	89 45 d0             	mov    %eax,-0x30(%ebp)
    LWIP_ASSERT("check that first pbuf can hold struct ip_hdr",
               (p->len >= sizeof(struct ip_hdr)));

    IPH_TTL_SET(iphdr, ttl);
  809a0d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  809a11:	89 04 24             	mov    %eax,(%esp)
  809a14:	e8 48 13 00 00       	call   80ad61 <ntohs>
  809a19:	0f b6 d0             	movzbl %al,%edx
  809a1c:	0f b6 45 d8          	movzbl -0x28(%ebp),%eax
  809a20:	c1 e0 08             	shl    $0x8,%eax
  809a23:	09 d0                	or     %edx,%eax
  809a25:	0f b7 c0             	movzwl %ax,%eax
  809a28:	89 04 24             	mov    %eax,(%esp)
  809a2b:	e8 24 13 00 00       	call   80ad54 <htons>
  809a30:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a33:	66 89 42 08          	mov    %ax,0x8(%edx)
    IPH_PROTO_SET(iphdr, proto);
  809a37:	0f b7 c0             	movzwl %ax,%eax
  809a3a:	89 04 24             	mov    %eax,(%esp)
  809a3d:	e8 1f 13 00 00       	call   80ad61 <ntohs>
  809a42:	89 c2                	mov    %eax,%edx
  809a44:	81 e2 00 ff 00 00    	and    $0xff00,%edx
  809a4a:	0f b6 45 d6          	movzbl -0x2a(%ebp),%eax
  809a4e:	09 d0                	or     %edx,%eax
  809a50:	0f b7 c0             	movzwl %ax,%eax
  809a53:	89 04 24             	mov    %eax,(%esp)
  809a56:	e8 f9 12 00 00       	call   80ad54 <htons>
  809a5b:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a5e:	66 89 42 08          	mov    %ax,0x8(%edx)

    ip_addr_set(&(iphdr->dest), dest);
  809a62:	8b 07                	mov    (%edi),%eax
  809a64:	89 42 10             	mov    %eax,0x10(%edx)

    IPH_VHLTOS_SET(iphdr, 4, IP_HLEN / 4, tos);
  809a67:	0f b6 45 d7          	movzbl -0x29(%ebp),%eax
  809a6b:	80 cc 45             	or     $0x45,%ah
  809a6e:	89 04 24             	mov    %eax,(%esp)
  809a71:	e8 de 12 00 00       	call   80ad54 <htons>
  809a76:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a79:	66 89 02             	mov    %ax,(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
  809a7c:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809a80:	89 04 24             	mov    %eax,(%esp)
  809a83:	e8 cc 12 00 00       	call   80ad54 <htons>
  809a88:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809a8b:	66 89 42 02          	mov    %ax,0x2(%edx)
    IPH_OFFSET_SET(iphdr, 0);
  809a8f:	66 c7 42 06 00 00    	movw   $0x0,0x6(%edx)
    IPH_ID_SET(iphdr, htons(ip_id));
  809a95:	0f b7 05 ac 87 b3 00 	movzwl 0xb387ac,%eax
  809a9c:	89 04 24             	mov    %eax,(%esp)
  809a9f:	e8 b0 12 00 00       	call   80ad54 <htons>
  809aa4:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809aa7:	66 89 42 04          	mov    %ax,0x4(%edx)
    ++ip_id;
  809aab:	66 83 05 ac 87 b3 00 	addw   $0x1,0xb387ac
  809ab2:	01 

    if (ip_addr_isany(src)) {
  809ab3:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  809ab7:	74 09                	je     809ac2 <ip_output_if+0x132>
  809ab9:	8b 55 0c             	mov    0xc(%ebp),%edx
  809abc:	8b 02                	mov    (%edx),%eax
  809abe:	85 c0                	test   %eax,%eax
  809ac0:	75 15                	jne    809ad7 <ip_output_if+0x147>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
  809ac2:	b8 00 00 00 00       	mov    $0x0,%eax
  809ac7:	83 fe fc             	cmp    $0xfffffffc,%esi
  809aca:	74 03                	je     809acf <ip_output_if+0x13f>
  809acc:	8b 46 04             	mov    0x4(%esi),%eax
  809acf:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809ad2:	89 42 0c             	mov    %eax,0xc(%edx)
    IPH_LEN_SET(iphdr, htons(p->tot_len));
    IPH_OFFSET_SET(iphdr, 0);
    IPH_ID_SET(iphdr, htons(ip_id));
    ++ip_id;

    if (ip_addr_isany(src)) {
  809ad5:	eb 06                	jmp    809add <ip_output_if+0x14d>
      ip_addr_set(&(iphdr->src), &(netif->ip_addr));
    } else {
      ip_addr_set(&(iphdr->src), src);
  809ad7:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809ada:	89 42 0c             	mov    %eax,0xc(%edx)
    }

    IPH_CHKSUM_SET(iphdr, 0);
  809add:	8b 45 d0             	mov    -0x30(%ebp),%eax
  809ae0:	66 c7 40 0a 00 00    	movw   $0x0,0xa(%eax)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  809ae6:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  809aed:	00 
  809aee:	89 04 24             	mov    %eax,(%esp)
  809af1:	e8 44 0f 00 00       	call   80aa3a <inet_chksum>
  809af6:	8b 55 d0             	mov    -0x30(%ebp),%edx
  809af9:	66 89 42 0a          	mov    %ax,0xa(%edx)
  809afd:	eb 06                	jmp    809b05 <ip_output_if+0x175>
#endif
  } else {
    /* IP header already included in p */
    iphdr = p->payload;
    dest = &(iphdr->dest);
  809aff:	8b 7b 04             	mov    0x4(%ebx),%edi
  809b02:	83 c7 10             	add    $0x10,%edi
  }

#if IP_FRAG
  /* don't fragment if interface has mtu set to 0 [loopif] */
  if (netif->mtu && (p->tot_len > netif->mtu))
  809b05:	0f b7 46 2c          	movzwl 0x2c(%esi),%eax
  809b09:	66 85 c0             	test   %ax,%ax
  809b0c:	74 18                	je     809b26 <ip_output_if+0x196>
  809b0e:	66 3b 43 08          	cmp    0x8(%ebx),%ax
  809b12:	73 12                	jae    809b26 <ip_output_if+0x196>
    return ip_frag(p,netif,dest);
  809b14:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809b18:	89 74 24 04          	mov    %esi,0x4(%esp)
  809b1c:	89 1c 24             	mov    %ebx,(%esp)
  809b1f:	e8 ac 03 00 00       	call   809ed0 <ip_frag>
  809b24:	eb 0e                	jmp    809b34 <ip_output_if+0x1a4>
  } else
#endif /* (LWIP_NETIF_LOOPBACK || LWIP_HAVE_LOOPIF) */
  {
    LWIP_DEBUGF(IP_DEBUG, ("netif->output()"));

    return netif->output(netif, p, dest);
  809b26:	89 7c 24 08          	mov    %edi,0x8(%esp)
  809b2a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  809b2e:	89 34 24             	mov    %esi,(%esp)
  809b31:	ff 56 14             	call   *0x14(%esi)
  }
}
  809b34:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809b37:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809b3a:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809b3d:	89 ec                	mov    %ebp,%esp
  809b3f:	5d                   	pop    %ebp
  809b40:	c3                   	ret    

00809b41 <ip_route>:
 * @param dest the destination IP address for which to find the route
 * @return the netif on which to send to reach dest
 */
struct netif *
ip_route(struct ip_addr *dest)
{
  809b41:	55                   	push   %ebp
  809b42:	89 e5                	mov    %esp,%ebp
  809b44:	56                   	push   %esi
  809b45:	53                   	push   %ebx
  809b46:	83 ec 10             	sub    $0x10,%esp
  809b49:	8b 75 08             	mov    0x8(%ebp),%esi
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  809b4c:	8b 1d 00 f6 b3 00    	mov    0xb3f600,%ebx
  809b52:	85 db                	test   %ebx,%ebx
  809b54:	74 1c                	je     809b72 <ip_route+0x31>
    /* network mask matches? */
    if (netif_is_up(netif)) {
  809b56:	89 1c 24             	mov    %ebx,(%esp)
  809b59:	e8 01 de ff ff       	call   80795f <netif_is_up>
  809b5e:	84 c0                	test   %al,%al
  809b60:	74 0a                	je     809b6c <ip_route+0x2b>
      if (ip_addr_netcmp(dest, &(netif->ip_addr), &(netif->netmask))) {
  809b62:	8b 43 04             	mov    0x4(%ebx),%eax
  809b65:	33 06                	xor    (%esi),%eax
  809b67:	85 43 08             	test   %eax,0x8(%ebx)
  809b6a:	74 28                	je     809b94 <ip_route+0x53>
ip_route(struct ip_addr *dest)
{
  struct netif *netif;

  /* iterate through netifs */
  for(netif = netif_list; netif != NULL; netif = netif->next) {
  809b6c:	8b 1b                	mov    (%ebx),%ebx
  809b6e:	85 db                	test   %ebx,%ebx
  809b70:	75 e4                	jne    809b56 <ip_route+0x15>
        /* return netif on which to forward IP packet */
        return netif;
      }
    }
  }
  if ((netif_default == NULL) || (!netif_is_up(netif_default))) {
  809b72:	a1 04 f6 b3 00       	mov    0xb3f604,%eax
  809b77:	85 c0                	test   %eax,%eax
  809b79:	74 14                	je     809b8f <ip_route+0x4e>
  809b7b:	89 04 24             	mov    %eax,(%esp)
  809b7e:	e8 dc dd ff ff       	call   80795f <netif_is_up>
  809b83:	84 c0                	test   %al,%al
  809b85:	74 08                	je     809b8f <ip_route+0x4e>
    IP_STATS_INC(ip.rterr);
    snmp_inc_ipoutnoroutes();
    return NULL;
  }
  /* no matching netif found, use default netif */
  return netif_default;
  809b87:	8b 1d 04 f6 b3 00    	mov    0xb3f604,%ebx
  809b8d:	eb 05                	jmp    809b94 <ip_route+0x53>
  809b8f:	bb 00 00 00 00       	mov    $0x0,%ebx
}
  809b94:	89 d8                	mov    %ebx,%eax
  809b96:	83 c4 10             	add    $0x10,%esp
  809b99:	5b                   	pop    %ebx
  809b9a:	5e                   	pop    %esi
  809b9b:	5d                   	pop    %ebp
  809b9c:	c3                   	ret    

00809b9d <ip_output>:
 *         see ip_output_if() for more return values
 */
err_t
ip_output(struct pbuf *p, struct ip_addr *src, struct ip_addr *dest,
          u8_t ttl, u8_t tos, u8_t proto)
{
  809b9d:	55                   	push   %ebp
  809b9e:	89 e5                	mov    %esp,%ebp
  809ba0:	83 ec 48             	sub    $0x48,%esp
  809ba3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809ba6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809ba9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809bac:	8b 5d 10             	mov    0x10(%ebp),%ebx
  809baf:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  809bb3:	88 45 e7             	mov    %al,-0x19(%ebp)
  809bb6:	0f b6 7d 18          	movzbl 0x18(%ebp),%edi
  809bba:	0f b6 75 1c          	movzbl 0x1c(%ebp),%esi
  struct netif *netif;

  if ((netif = ip_route(dest)) == NULL) {
  809bbe:	89 1c 24             	mov    %ebx,(%esp)
  809bc1:	e8 7b ff ff ff       	call   809b41 <ip_route>
  809bc6:	89 c2                	mov    %eax,%edx
  809bc8:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  809bcd:	85 d2                	test   %edx,%edx
  809bcf:	74 36                	je     809c07 <ip_output+0x6a>
    return ERR_RTE;
  }

  return ip_output_if(p, src, dest, ttl, tos, proto, netif);
  809bd1:	89 54 24 18          	mov    %edx,0x18(%esp)
  809bd5:	81 e6 ff 00 00 00    	and    $0xff,%esi
  809bdb:	89 74 24 14          	mov    %esi,0x14(%esp)
  809bdf:	81 e7 ff 00 00 00    	and    $0xff,%edi
  809be5:	89 7c 24 10          	mov    %edi,0x10(%esp)
  809be9:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  809bed:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809bf1:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  809bf5:	8b 45 0c             	mov    0xc(%ebp),%eax
  809bf8:	89 44 24 04          	mov    %eax,0x4(%esp)
  809bfc:	8b 45 08             	mov    0x8(%ebp),%eax
  809bff:	89 04 24             	mov    %eax,(%esp)
  809c02:	e8 89 fd ff ff       	call   809990 <ip_output_if>
}
  809c07:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809c0a:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809c0d:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809c10:	89 ec                	mov    %ebp,%esp
  809c12:	5d                   	pop    %ebp
  809c13:	c3                   	ret    

00809c14 <ip_input>:
 * @return ERR_OK if the packet was processed (could return ERR_* if it wasn't
 *         processed, but currently always returns ERR_OK)
 */
err_t
ip_input(struct pbuf *p, struct netif *inp)
{
  809c14:	55                   	push   %ebp
  809c15:	89 e5                	mov    %esp,%ebp
  809c17:	83 ec 48             	sub    $0x48,%esp
  809c1a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  809c1d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  809c20:	89 7d fc             	mov    %edi,-0x4(%ebp)
  809c23:	8b 75 08             	mov    0x8(%ebp),%esi

  IP_STATS_INC(ip.recv);
  snmp_inc_ipinreceives();

  /* identify the IP header */
  iphdr = p->payload;
  809c26:	8b 5e 04             	mov    0x4(%esi),%ebx
  if (IPH_V(iphdr) != 4) {
  809c29:	0f b7 03             	movzwl (%ebx),%eax
  809c2c:	89 04 24             	mov    %eax,(%esp)
  809c2f:	e8 2d 11 00 00       	call   80ad61 <ntohs>
  809c34:	66 c1 e8 0c          	shr    $0xc,%ax
  809c38:	66 83 f8 04          	cmp    $0x4,%ax
  809c3c:	74 0d                	je     809c4b <ip_input+0x37>
    LWIP_DEBUGF(IP_DEBUG | 1, ("IP packet dropped due to bad version number %"U16_F"\n", IPH_V(iphdr)));
    ip_debug_print(p);
    pbuf_free(p);
  809c3e:	89 34 24             	mov    %esi,(%esp)
  809c41:	e8 12 e3 ff ff       	call   807f58 <pbuf_free>
    IP_STATS_INC(ip.err);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809c46:	e9 72 02 00 00       	jmp    809ebd <ip_input+0x2a9>
  }

  /* obtain IP header length in number of 32-bit words */
  iphdr_hlen = IPH_HL(iphdr);
  809c4b:	0f b7 03             	movzwl (%ebx),%eax
  809c4e:	89 04 24             	mov    %eax,(%esp)
  809c51:	e8 0b 11 00 00       	call   80ad61 <ntohs>
  809c56:	66 c1 e8 06          	shr    $0x6,%ax
  /* calculate IP header length in bytes */
  iphdr_hlen *= 4;
  809c5a:	83 e0 3c             	and    $0x3c,%eax
  809c5d:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  /* obtain ip length in bytes */
  iphdr_len = ntohs(IPH_LEN(iphdr));
  809c61:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  809c65:	89 04 24             	mov    %eax,(%esp)
  809c68:	e8 f4 10 00 00       	call   80ad61 <ntohs>
  809c6d:	89 c7                	mov    %eax,%edi

  /* header length exceeds first pbuf length, or ip length exceeds total pbuf length? */
  if ((iphdr_hlen > p->len) || (iphdr_len > p->tot_len)) {
  809c6f:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809c73:	66 3b 46 0a          	cmp    0xa(%esi),%ax
  809c77:	77 06                	ja     809c7f <ip_input+0x6b>
  809c79:	66 3b 7e 08          	cmp    0x8(%esi),%di
  809c7d:	76 0d                	jbe    809c8c <ip_input+0x78>
    if (iphdr_len > p->tot_len)
    LWIP_DEBUGF(IP_DEBUG | 2, ("IP (len %"U16_F") is longer than pbuf (len %"U16_F"), "
                               "IP packet dropped.\n",
                               iphdr_len, p->tot_len));
    /* free (drop) packet pbufs */
    pbuf_free(p);
  809c7f:	89 34 24             	mov    %esi,(%esp)
  809c82:	e8 d1 e2 ff ff       	call   807f58 <pbuf_free>
    IP_STATS_INC(ip.lenerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipindiscards();
    return ERR_OK;
  809c87:	e9 31 02 00 00       	jmp    809ebd <ip_input+0x2a9>
  }

  /* verify checksum */
#if CHECKSUM_CHECK_IP
  if (inet_chksum(iphdr, iphdr_hlen) != 0) {
  809c8c:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809c90:	89 44 24 04          	mov    %eax,0x4(%esp)
  809c94:	89 1c 24             	mov    %ebx,(%esp)
  809c97:	e8 9e 0d 00 00       	call   80aa3a <inet_chksum>
  809c9c:	66 85 c0             	test   %ax,%ax
  809c9f:	74 0d                	je     809cae <ip_input+0x9a>

    LWIP_DEBUGF(IP_DEBUG | 2, ("Checksum (0x%"X16_F") failed, IP packet dropped.\n", inet_chksum(iphdr, iphdr_hlen)));
    ip_debug_print(p);
    pbuf_free(p);
  809ca1:	89 34 24             	mov    %esi,(%esp)
  809ca4:	e8 af e2 ff ff       	call   807f58 <pbuf_free>
    IP_STATS_INC(ip.chkerr);
    IP_STATS_INC(ip.drop);
    snmp_inc_ipinhdrerrors();
    return ERR_OK;
  809ca9:	e9 0f 02 00 00       	jmp    809ebd <ip_input+0x2a9>
  }
#endif

  /* Trim pbuf. This should have been done at the netif layer,
   * but we'll do it anyway just to be sure that its done. */
  pbuf_realloc(p, iphdr_len);
  809cae:	0f b7 ff             	movzwl %di,%edi
  809cb1:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809cb5:	89 34 24             	mov    %esi,(%esp)
  809cb8:	e8 23 e4 ff ff       	call   8080e0 <pbuf_realloc>
      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809cbd:	8d 43 10             	lea    0x10(%ebx),%eax
  809cc0:	89 45 dc             	mov    %eax,-0x24(%ebp)
  809cc3:	8b 7d 0c             	mov    0xc(%ebp),%edi
  809cc6:	c7 45 d8 01 00 00 00 	movl   $0x1,-0x28(%ebp)
        netif = netif->next;
      }
      if (netif == inp) {
        netif = netif->next;
      }
    } while(netif != NULL);
  809ccd:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809cd0:	89 de                	mov    %ebx,%esi
  809cd2:	bb 01 00 00 00       	mov    $0x1,%ebx
          iphdr->dest.addr & netif->netmask.addr,
          netif->ip_addr.addr & netif->netmask.addr,
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
  809cd7:	89 3c 24             	mov    %edi,(%esp)
  809cda:	e8 80 dc ff ff       	call   80795f <netif_is_up>
  809cdf:	84 c0                	test   %al,%al
  809ce1:	74 27                	je     809d0a <ip_input+0xf6>
  809ce3:	83 ff fc             	cmp    $0xfffffffc,%edi
  809ce6:	74 22                	je     809d0a <ip_input+0xf6>
  809ce8:	8b 47 04             	mov    0x4(%edi),%eax
  809ceb:	85 c0                	test   %eax,%eax
  809ced:	8d 76 00             	lea    0x0(%esi),%esi
  809cf0:	74 18                	je     809d0a <ip_input+0xf6>
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809cf2:	3b 46 10             	cmp    0x10(%esi),%eax
  809cf5:	74 36                	je     809d2d <ip_input+0x119>
            /* or broadcast on this interface network address? */
            ip_addr_isbroadcast(&(iphdr->dest), netif)) {
  809cf7:	89 7c 24 04          	mov    %edi,0x4(%esp)
  809cfb:	8b 45 dc             	mov    -0x24(%ebp),%eax
  809cfe:	89 04 24             	mov    %eax,(%esp)
  809d01:	e8 42 fc ff ff       	call   809948 <ip_addr_isbroadcast>
          iphdr->dest.addr & ~(netif->netmask.addr)));

      /* interface is up and configured? */
      if ((netif_is_up(netif)) && (!ip_addr_isany(&(netif->ip_addr)))) {
        /* unicast to this interface address? */
        if (ip_addr_cmp(&(iphdr->dest), &(netif->ip_addr)) ||
  809d06:	84 c0                	test   %al,%al
  809d08:	75 23                	jne    809d2d <ip_input+0x119>
              netif->name[0], netif->name[1]));
          /* break out of for loop */
          break;
        }
      }
      if (first) {
  809d0a:	85 db                	test   %ebx,%ebx
  809d0c:	74 08                	je     809d16 <ip_input+0x102>
        first = 0;
        netif = netif_list;
  809d0e:	8b 3d 00 f6 b3 00    	mov    0xb3f600,%edi
  809d14:	eb 02                	jmp    809d18 <ip_input+0x104>
      } else {
        netif = netif->next;
  809d16:	8b 3f                	mov    (%edi),%edi
      }
      if (netif == inp) {
  809d18:	3b 7d 0c             	cmp    0xc(%ebp),%edi
  809d1b:	75 05                	jne    809d22 <ip_input+0x10e>
        netif = netif->next;
  809d1d:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d20:	8b 38                	mov    (%eax),%edi
      }
    } while(netif != NULL);
  809d22:	85 ff                	test   %edi,%edi
  809d24:	74 12                	je     809d38 <ip_input+0x124>
  809d26:	bb 00 00 00 00       	mov    $0x0,%ebx
  809d2b:	eb aa                	jmp    809cd7 <ip_input+0xc3>
  809d2d:	89 f3                	mov    %esi,%ebx
  809d2f:	8b 75 d4             	mov    -0x2c(%ebp),%esi
#if LWIP_DHCP
  /* Pass DHCP messages regardless of destination address. DHCP traffic is addressed
   * using link layer addressing (such as Ethernet MAC) so we must not filter on IP.
   * According to RFC 1542 section 3.1.1, referred by RFC 2131).
   */
  if (netif == NULL) {
  809d32:	85 ff                	test   %edi,%edi
  809d34:	75 2e                	jne    809d64 <ip_input+0x150>
  809d36:	eb 05                	jmp    809d3d <ip_input+0x129>
  809d38:	89 f3                	mov    %esi,%ebx
  809d3a:	8b 75 d4             	mov    -0x2c(%ebp),%esi
    /* remote port is DHCP server? */
    if (IPH_PROTO(iphdr) == IP_PROTO_UDP) {
  809d3d:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809d41:	89 04 24             	mov    %eax,(%esp)
  809d44:	e8 18 10 00 00       	call   80ad61 <ntohs>
  809d49:	3c 11                	cmp    $0x11,%al
  809d4b:	75 17                	jne    809d64 <ip_input+0x150>
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: UDP packet to DHCP client port %"U16_F"\n",
        ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest)));
      if (ntohs(((struct udp_hdr *)((u8_t *)iphdr + iphdr_hlen))->dest) == DHCP_CLIENT_PORT) {
  809d4d:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809d51:	0f b7 44 03 02       	movzwl 0x2(%ebx,%eax,1),%eax
  809d56:	89 04 24             	mov    %eax,(%esp)
  809d59:	e8 03 10 00 00       	call   80ad61 <ntohs>
  809d5e:	66 83 f8 44          	cmp    $0x44,%ax
  809d62:	74 4e                	je     809db2 <ip_input+0x19e>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809d64:	8b 45 0c             	mov    0xc(%ebp),%eax
  809d67:	89 44 24 04          	mov    %eax,0x4(%esp)
  809d6b:	8d 43 0c             	lea    0xc(%ebx),%eax
  809d6e:	89 04 24             	mov    %eax,(%esp)
  809d71:	e8 d2 fb ff ff       	call   809948 <ip_addr_isbroadcast>
  809d76:	84 c0                	test   %al,%al
  809d78:	75 2b                	jne    809da5 <ip_input+0x191>
         (ip_addr_ismulticast(&(iphdr->src)))) {
  809d7a:	8b 43 0c             	mov    0xc(%ebx),%eax
  809d7d:	89 45 dc             	mov    %eax,-0x24(%ebp)
  809d80:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809d87:	e8 0e 12 00 00       	call   80af9a <ntohl>
  809d8c:	89 45 e0             	mov    %eax,-0x20(%ebp)
  809d8f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809d96:	e8 ff 11 00 00       	call   80af9a <ntohl>

  /* broadcast or multicast packet source address? Compliant with RFC 1122: 3.2.1.3 */
#if LWIP_DHCP
  if (check_ip_src)
#endif /* LWIP_DHCP */
  {  if ((ip_addr_isbroadcast(&(iphdr->src), inp)) ||
  809d9b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  809d9e:	23 55 dc             	and    -0x24(%ebp),%edx
  809da1:	39 c2                	cmp    %eax,%edx
  809da3:	75 10                	jne    809db5 <ip_input+0x1a1>
         (ip_addr_ismulticast(&(iphdr->src)))) {
      /* packet source is not valid */
      LWIP_DEBUGF(IP_DEBUG | LWIP_DBG_TRACE | 1, ("ip_input: packet source is not valid.\n"));
      /* free (drop) packet pbufs */
      pbuf_free(p);
  809da5:	89 34 24             	mov    %esi,(%esp)
  809da8:	e8 ab e1 ff ff       	call   807f58 <pbuf_free>
      IP_STATS_INC(ip.drop);
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
      return ERR_OK;
  809dad:	e9 0b 01 00 00       	jmp    809ebd <ip_input+0x2a9>
  809db2:	8b 7d 0c             	mov    0xc(%ebp),%edi
    }
  }

  /* packet not for us? */
  if (netif == NULL) {
  809db5:	85 ff                	test   %edi,%edi
  809db7:	75 11                	jne    809dca <ip_input+0x1b6>
#endif /* IP_FORWARD */
    {
      snmp_inc_ipinaddrerrors();
      snmp_inc_ipindiscards();
    }
    pbuf_free(p);
  809db9:	89 34 24             	mov    %esi,(%esp)
  809dbc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  809dc0:	e8 93 e1 ff ff       	call   807f58 <pbuf_free>
    return ERR_OK;
  809dc5:	e9 f3 00 00 00       	jmp    809ebd <ip_input+0x2a9>
  }
  /* packet consists of multiple fragments? */
  if ((IPH_OFFSET(iphdr) & htons(IP_OFFMASK | IP_MF)) != 0) {
  809dca:	0f b7 7b 06          	movzwl 0x6(%ebx),%edi
  809dce:	c7 04 24 ff 3f 00 00 	movl   $0x3fff,(%esp)
  809dd5:	e8 7a 0f 00 00       	call   80ad54 <htons>
  809dda:	66 85 f8             	test   %di,%ax
  809ddd:	74 15                	je     809df4 <ip_input+0x1e0>
#if IP_REASSEMBLY /* packet fragment reassembly code present? */
    LWIP_DEBUGF(IP_DEBUG, ("IP packet is a fragment (id=0x%04"X16_F" tot_len=%"U16_F" len=%"U16_F" MF=%"U16_F" offset=%"U16_F"), calling ip_reass()\n",
      ntohs(IPH_ID(iphdr)), p->tot_len, ntohs(IPH_LEN(iphdr)), !!(IPH_OFFSET(iphdr) & htons(IP_MF)), (ntohs(IPH_OFFSET(iphdr)) & IP_OFFMASK)*8));
    /* reassemble the packet*/
    p = ip_reass(p);
  809ddf:	89 34 24             	mov    %esi,(%esp)
  809de2:	e8 4a 05 00 00       	call   80a331 <ip_reass>
  809de7:	89 c6                	mov    %eax,%esi
    /* packet not fully reassembled yet? */
    if (p == NULL) {
  809de9:	85 c0                	test   %eax,%eax
  809deb:	0f 84 cc 00 00 00    	je     809ebd <ip_input+0x2a9>
      return ERR_OK;
    }
    iphdr = p->payload;
  809df1:	8b 58 04             	mov    0x4(%eax),%ebx
  ip_debug_print(p);
  LWIP_DEBUGF(IP_DEBUG, ("ip_input: p->len %"U16_F" p->tot_len %"U16_F"\n", p->len, p->tot_len));

#if LWIP_RAW
  /* raw input did not eat the packet? */
  if (raw_input(p, inp) == 0)
  809df4:	8b 45 0c             	mov    0xc(%ebp),%eax
  809df7:	89 44 24 04          	mov    %eax,0x4(%esp)
  809dfb:	89 34 24             	mov    %esi,(%esp)
  809dfe:	e8 20 7e 00 00       	call   811c23 <raw_input>
  809e03:	84 c0                	test   %al,%al
  809e05:	0f 85 b2 00 00 00    	jne    809ebd <ip_input+0x2a9>
#endif /* LWIP_RAW */
  {

    switch (IPH_PROTO(iphdr)) {
  809e0b:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  809e0f:	89 04 24             	mov    %eax,(%esp)
  809e12:	e8 4a 0f 00 00       	call   80ad61 <ntohs>
  809e17:	0f b6 c0             	movzbl %al,%eax
  809e1a:	83 f8 06             	cmp    $0x6,%eax
  809e1d:	74 24                	je     809e43 <ip_input+0x22f>
  809e1f:	83 f8 11             	cmp    $0x11,%eax
  809e22:	74 0e                	je     809e32 <ip_input+0x21e>
  809e24:	83 f8 01             	cmp    $0x1,%eax
  809e27:	75 3c                	jne    809e65 <ip_input+0x251>
  809e29:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  809e30:	eb 22                	jmp    809e54 <ip_input+0x240>
    case IP_PROTO_UDP:
#if LWIP_UDPLITE
    case IP_PROTO_UDPLITE:
#endif /* LWIP_UDPLITE */
      snmp_inc_ipindelivers();
      udp_input(p, inp);
  809e32:	8b 45 0c             	mov    0xc(%ebp),%eax
  809e35:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e39:	89 34 24             	mov    %esi,(%esp)
  809e3c:	e8 c6 26 00 00       	call   80c507 <udp_input>
      break;
  809e41:	eb 7a                	jmp    809ebd <ip_input+0x2a9>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case IP_PROTO_TCP:
      snmp_inc_ipindelivers();
      tcp_input(p, inp);
  809e43:	8b 45 0c             	mov    0xc(%ebp),%eax
  809e46:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e4a:	89 34 24             	mov    %esi,(%esp)
  809e4d:	e8 95 6d 00 00       	call   810be7 <tcp_input>
      break;
  809e52:	eb 69                	jmp    809ebd <ip_input+0x2a9>
#endif /* LWIP_TCP */
#if LWIP_ICMP
    case IP_PROTO_ICMP:
      snmp_inc_ipindelivers();
      icmp_input(p, inp);
  809e54:	8b 45 0c             	mov    0xc(%ebp),%eax
  809e57:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e5b:	89 34 24             	mov    %esi,(%esp)
  809e5e:	e8 91 80 00 00       	call   811ef4 <icmp_input>
      break;
  809e63:	eb 58                	jmp    809ebd <ip_input+0x2a9>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809e65:	8b 45 0c             	mov    0xc(%ebp),%eax
  809e68:	89 44 24 04          	mov    %eax,0x4(%esp)
  809e6c:	8d 43 10             	lea    0x10(%ebx),%eax
  809e6f:	89 04 24             	mov    %eax,(%esp)
  809e72:	e8 d1 fa ff ff       	call   809948 <ip_addr_isbroadcast>
  809e77:	84 c0                	test   %al,%al
  809e79:	75 3a                	jne    809eb5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
  809e7b:	8b 43 10             	mov    0x10(%ebx),%eax
  809e7e:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  809e81:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  809e88:	e8 0d 11 00 00       	call   80af9a <ntohl>
  809e8d:	89 c7                	mov    %eax,%edi
  809e8f:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  809e96:	e8 ff 10 00 00       	call   80af9a <ntohl>
      break;
#endif /* LWIP_IGMP */
    default:
#if LWIP_ICMP
      /* send ICMP destination protocol unreachable unless is was a broadcast */
      if (!ip_addr_isbroadcast(&(iphdr->dest), inp) &&
  809e9b:	23 7d e4             	and    -0x1c(%ebp),%edi
  809e9e:	39 c7                	cmp    %eax,%edi
  809ea0:	74 13                	je     809eb5 <ip_input+0x2a1>
          !ip_addr_ismulticast(&(iphdr->dest))) {
        p->payload = iphdr;
  809ea2:	89 5e 04             	mov    %ebx,0x4(%esi)
        icmp_dest_unreach(p, ICMP_DUR_PROTO);
  809ea5:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  809eac:	00 
  809ead:	89 34 24             	mov    %esi,(%esp)
  809eb0:	e8 2d 7f 00 00       	call   811de2 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      pbuf_free(p);
  809eb5:	89 34 24             	mov    %esi,(%esp)
  809eb8:	e8 9b e0 ff ff       	call   807f58 <pbuf_free>
      snmp_inc_ipinunknownprotos();
    }
  }

  return ERR_OK;
}
  809ebd:	b8 00 00 00 00       	mov    $0x0,%eax
  809ec2:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  809ec5:	8b 75 f8             	mov    -0x8(%ebp),%esi
  809ec8:	8b 7d fc             	mov    -0x4(%ebp),%edi
  809ecb:	89 ec                	mov    %ebp,%esp
  809ecd:	5d                   	pop    %ebp
  809ece:	c3                   	ret    
	...

00809ed0 <ip_frag>:
 *
 * @return ERR_OK if sent successfully, err_t otherwise
 */
err_t 
ip_frag(struct pbuf *p, struct netif *netif, struct ip_addr *dest)
{
  809ed0:	55                   	push   %ebp
  809ed1:	89 e5                	mov    %esp,%ebp
  809ed3:	57                   	push   %edi
  809ed4:	56                   	push   %esi
  809ed5:	53                   	push   %ebx
  809ed6:	83 ec 5c             	sub    $0x5c,%esp
  struct ip_hdr *original_iphdr;
#endif
  struct ip_hdr *iphdr;
  u16_t nfb;
  u16_t left, cop;
  u16_t mtu = netif->mtu;
  809ed9:	8b 45 0c             	mov    0xc(%ebp),%eax
  809edc:	0f b7 70 2c          	movzwl 0x2c(%eax),%esi
#if IP_FRAG_USES_STATIC_BUF
  /* When using a static buffer, we use a PBUF_REF, which we will
   * use to reference the packet (without link header).
   * Layer and length is irrelevant.
   */
  rambuf = pbuf_alloc(PBUF_LINK, 0, PBUF_REF);
  809ee0:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  809ee7:	00 
  809ee8:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  809eef:	00 
  809ef0:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  809ef7:	e8 17 e3 ff ff       	call   808213 <pbuf_alloc>
  809efc:	89 45 d8             	mov    %eax,-0x28(%ebp)
  if (rambuf == NULL) {
  809eff:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  809f04:	83 7d d8 00          	cmpl   $0x0,-0x28(%ebp)
  809f08:	0f 84 ca 01 00 00    	je     80a0d8 <ip_frag+0x208>
    LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc(PBUF_LINK, 0, PBUF_REF) failed\n"));
    return ERR_MEM;
  }
  rambuf->tot_len = rambuf->len = mtu;
  809f0e:	8b 55 d8             	mov    -0x28(%ebp),%edx
  809f11:	66 89 72 0a          	mov    %si,0xa(%edx)
  809f15:	66 89 72 08          	mov    %si,0x8(%edx)
  rambuf->payload = LWIP_MEM_ALIGN((void *)buf);
  809f19:	bb e3 87 b3 00       	mov    $0xb387e3,%ebx
  809f1e:	83 e3 fc             	and    $0xfffffffc,%ebx
  809f21:	89 5a 04             	mov    %ebx,0x4(%edx)

  /* Copy the IP header in it */
  iphdr = rambuf->payload;
  SMEMCPY(iphdr, p->payload, IP_HLEN);
  809f24:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  809f2b:	00 
  809f2c:	8b 55 08             	mov    0x8(%ebp),%edx
  809f2f:	8b 42 04             	mov    0x4(%edx),%eax
  809f32:	89 44 24 04          	mov    %eax,0x4(%esp)
  809f36:	89 1c 24             	mov    %ebx,(%esp)
  809f39:	e8 53 74 ff ff       	call   801391 <memcpy>
  original_iphdr = p->payload;
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  809f3e:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  809f42:	89 04 24             	mov    %eax,(%esp)
  809f45:	e8 17 0e 00 00       	call   80ad61 <ntohs>
  ofo = tmp & IP_OFFMASK;
  omf = tmp & IP_MF;
  809f4a:	89 c2                	mov    %eax,%edx
  809f4c:	66 81 e2 00 20       	and    $0x2000,%dx
  809f51:	66 89 55 d2          	mov    %dx,-0x2e(%ebp)

  left = p->tot_len - IP_HLEN;
  809f55:	8b 55 08             	mov    0x8(%ebp),%edx
  809f58:	0f b7 4a 08          	movzwl 0x8(%edx),%ecx

  nfb = (mtu - IP_HLEN) / 8;
  809f5c:	0f b7 f6             	movzwl %si,%esi
  809f5f:	83 ee 14             	sub    $0x14,%esi
  809f62:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  809f65:	89 f2                	mov    %esi,%edx
  809f67:	c1 fa 1f             	sar    $0x1f,%edx
  809f6a:	c1 ea 1d             	shr    $0x1d,%edx
  809f6d:	01 f2                	add    %esi,%edx
  809f6f:	c1 ea 03             	shr    $0x3,%edx
  809f72:	66 89 55 b8          	mov    %dx,-0x48(%ebp)

  while (left) {
  809f76:	66 83 e9 14          	sub    $0x14,%cx
  809f7a:	66 89 4d e6          	mov    %cx,-0x1a(%ebp)
  809f7e:	0f 84 44 01 00 00    	je     80a0c8 <ip_frag+0x1f8>
  iphdr = original_iphdr;
#endif /* IP_FRAG_USES_STATIC_BUF */

  /* Save original offset */
  tmp = ntohs(IPH_OFFSET(iphdr));
  ofo = tmp & IP_OFFMASK;
  809f84:	66 25 ff 1f          	and    $0x1fff,%ax
  809f88:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;

    /* Fill this fragment */
    cop = last ? left : nfb * 8;
  809f8c:	66 c7 45 e2 14 00    	movw   $0x14,-0x1e(%ebp)
    last = (left <= mtu - IP_HLEN);

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
    if (!last)
      tmp = tmp | IP_MF;
  809f92:	c1 e2 03             	shl    $0x3,%edx
  809f95:	66 89 55 b2          	mov    %dx,-0x4e(%ebp)

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809f99:	8d 43 14             	lea    0x14(%ebx),%eax
  809f9c:	89 45 b4             	mov    %eax,-0x4c(%ebp)
  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
    last = (left <= mtu - IP_HLEN);
  809f9f:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  809fa3:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  809fa6:	0f 9d c0             	setge  %al
  809fa9:	0f b6 f0             	movzbl %al,%esi

    /* Set new offset and MF flag */
    tmp = omf | (IP_OFFMASK & (ofo));
  809fac:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  809fb0:	66 25 ff 1f          	and    $0x1fff,%ax
  809fb4:	66 0b 45 d2          	or     -0x2e(%ebp),%ax
  809fb8:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
    if (!last)
  809fbc:	0f b7 7d e6          	movzwl -0x1a(%ebp),%edi
  809fc0:	66 85 f6             	test   %si,%si
  809fc3:	75 0a                	jne    809fcf <ip_frag+0xff>
      tmp = tmp | IP_MF;
  809fc5:	66 81 4d e4 00 20    	orw    $0x2000,-0x1c(%ebp)
  809fcb:	0f b7 7d b2          	movzwl -0x4e(%ebp),%edi

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  809fcf:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  809fd3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  809fd7:	0f b7 c7             	movzwl %di,%eax
  809fda:	89 44 24 08          	mov    %eax,0x8(%esp)
  809fde:	8b 55 b4             	mov    -0x4c(%ebp),%edx
  809fe1:	89 54 24 04          	mov    %edx,0x4(%esp)
  809fe5:	8b 45 08             	mov    0x8(%ebp),%eax
  809fe8:	89 04 24             	mov    %eax,(%esp)
  809feb:	e8 e6 dc ff ff       	call   807cd6 <pbuf_copy_partial>
  809ff0:	66 89 45 de          	mov    %ax,-0x22(%ebp)
    }
    poff = newpbuflen;
#endif /* IP_FRAG_USES_STATIC_BUF */

    /* Correct header */
    IPH_OFFSET_SET(iphdr, htons(tmp));
  809ff4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  809ff8:	89 04 24             	mov    %eax,(%esp)
  809ffb:	e8 54 0d 00 00       	call   80ad54 <htons>
  80a000:	66 89 43 06          	mov    %ax,0x6(%ebx)
    IPH_LEN_SET(iphdr, htons(cop + IP_HLEN));
  80a004:	8d 47 14             	lea    0x14(%edi),%eax
  80a007:	0f b7 c0             	movzwl %ax,%eax
  80a00a:	89 04 24             	mov    %eax,(%esp)
  80a00d:	e8 42 0d 00 00       	call   80ad54 <htons>
  80a012:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_CHKSUM_SET(iphdr, 0);
  80a016:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  80a01c:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a023:	00 
  80a024:	89 1c 24             	mov    %ebx,(%esp)
  80a027:	e8 0e 0a 00 00       	call   80aa3a <inet_chksum>
  80a02c:	66 89 43 0a          	mov    %ax,0xa(%ebx)

#if IP_FRAG_USES_STATIC_BUF
    if (last)
  80a030:	66 85 f6             	test   %si,%si
  80a033:	74 19                	je     80a04e <ip_frag+0x17e>
      pbuf_realloc(rambuf, left + IP_HLEN);
  80a035:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80a039:	83 c0 14             	add    $0x14,%eax
  80a03c:	0f b7 c0             	movzwl %ax,%eax
  80a03f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a043:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80a046:	89 14 24             	mov    %edx,(%esp)
  80a049:	e8 92 e0 ff ff       	call   8080e0 <pbuf_realloc>
    /* This part is ugly: we alloc a RAM based pbuf for 
     * the link level header for each chunk and then 
     * free it.A PBUF_ROM style pbuf for which pbuf_header
     * worked would make things simpler.
     */
    header = pbuf_alloc(PBUF_LINK, 0, PBUF_RAM);
  80a04e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80a055:	00 
  80a056:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a05d:	00 
  80a05e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80a065:	e8 a9 e1 ff ff       	call   808213 <pbuf_alloc>
  80a06a:	89 c6                	mov    %eax,%esi
    if (header != NULL) {
  80a06c:	85 c0                	test   %eax,%eax
  80a06e:	74 46                	je     80a0b6 <ip_frag+0x1e6>
      pbuf_chain(header, rambuf);
  80a070:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a073:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a077:	89 34 24             	mov    %esi,(%esp)
  80a07a:	e8 3d db ff ff       	call   807bbc <pbuf_chain>
      netif->output(netif, header, dest);
  80a07f:	8b 55 10             	mov    0x10(%ebp),%edx
  80a082:	89 54 24 08          	mov    %edx,0x8(%esp)
  80a086:	89 74 24 04          	mov    %esi,0x4(%esp)
  80a08a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80a08d:	89 04 24             	mov    %eax,(%esp)
  80a090:	ff 50 14             	call   *0x14(%eax)
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
  80a093:	89 34 24             	mov    %esi,(%esp)
  80a096:	e8 bd de ff ff       	call   807f58 <pbuf_free>

  left = p->tot_len - IP_HLEN;

  nfb = (mtu - IP_HLEN) / 8;

  while (left) {
  80a09b:	66 29 7d e6          	sub    %di,-0x1a(%ebp)
  80a09f:	74 27                	je     80a0c8 <ip_frag+0x1f8>

    /* Fill this fragment */
    cop = last ? left : nfb * 8;

#if IP_FRAG_USES_STATIC_BUF
    poff += pbuf_copy_partial(p, (u8_t*)iphdr + IP_HLEN, cop, poff);
  80a0a1:	0f b7 45 de          	movzwl -0x22(%ebp),%eax
  80a0a5:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
     */
    
    pbuf_free(rambuf);
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  80a0a9:	0f b7 55 b8          	movzwl -0x48(%ebp),%edx
  80a0ad:	66 01 55 e0          	add    %dx,-0x20(%ebp)
  80a0b1:	e9 e9 fe ff ff       	jmp    809f9f <ip_frag+0xcf>
      IPFRAG_STATS_INC(ip_frag.xmit);
      snmp_inc_ipfragcreates();
      pbuf_free(header);
    } else {
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_frag: pbuf_alloc() for header failed\n"));
      pbuf_free(rambuf);
  80a0b6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80a0b9:	89 04 24             	mov    %eax,(%esp)
  80a0bc:	e8 97 de ff ff       	call   807f58 <pbuf_free>
  80a0c1:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
      return ERR_MEM;
  80a0c6:	eb 10                	jmp    80a0d8 <ip_frag+0x208>
#endif /* IP_FRAG_USES_STATIC_BUF */
    left -= cop;
    ofo += nfb;
  }
#if IP_FRAG_USES_STATIC_BUF
  pbuf_free(rambuf);
  80a0c8:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80a0cb:	89 14 24             	mov    %edx,(%esp)
  80a0ce:	e8 85 de ff ff       	call   807f58 <pbuf_free>
  80a0d3:	b8 00 00 00 00       	mov    $0x0,%eax
#endif /* IP_FRAG_USES_STATIC_BUF */
  snmp_inc_ipfragoks();
  return ERR_OK;
}
  80a0d8:	83 c4 5c             	add    $0x5c,%esp
  80a0db:	5b                   	pop    %ebx
  80a0dc:	5e                   	pop    %esi
  80a0dd:	5f                   	pop    %edi
  80a0de:	5d                   	pop    %ebp
  80a0df:	c3                   	ret    

0080a0e0 <ip_reass_dequeue_datagram>:
 * Dequeues a datagram from the datagram queue. Doesn't deallocate the pbufs.
 * @param ipr points to the queue entry to dequeue
 */
static void
ip_reass_dequeue_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80a0e0:	55                   	push   %ebp
  80a0e1:	89 e5                	mov    %esp,%ebp
  80a0e3:	83 ec 18             	sub    $0x18,%esp
  
  /* dequeue the reass struct  */
  if (reassdatagrams == ipr) {
  80a0e6:	8b 0d c0 87 b3 00    	mov    0xb387c0,%ecx
  80a0ec:	39 c1                	cmp    %eax,%ecx
  80a0ee:	75 0a                	jne    80a0fa <ip_reass_dequeue_datagram+0x1a>
    /* it was the first in the list */
    reassdatagrams = ipr->next;
  80a0f0:	8b 11                	mov    (%ecx),%edx
  80a0f2:	89 15 c0 87 b3 00    	mov    %edx,0xb387c0
  80a0f8:	eb 24                	jmp    80a11e <ip_reass_dequeue_datagram+0x3e>
  } else {
    /* it wasn't the first, so it must have a valid 'prev' */
    LWIP_ASSERT("sanity check linked list", prev != NULL);
  80a0fa:	85 d2                	test   %edx,%edx
  80a0fc:	75 1c                	jne    80a11a <ip_reass_dequeue_datagram+0x3a>
  80a0fe:	c7 44 24 08 d9 3d 81 	movl   $0x813dd9,0x8(%esp)
  80a105:	00 
  80a106:	c7 44 24 04 29 01 00 	movl   $0x129,0x4(%esp)
  80a10d:	00 
  80a10e:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a115:	e8 ba 68 ff ff       	call   8009d4 <_panic>
    prev->next = ipr->next;
  80a11a:	8b 08                	mov    (%eax),%ecx
  80a11c:	89 0a                	mov    %ecx,(%edx)
  }

  /* now we can free the ip_reass struct */
  memp_free(MEMP_REASSDATA, ipr);
  80a11e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a122:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a129:	e8 92 d6 ff ff       	call   8077c0 <memp_free>
}
  80a12e:	c9                   	leave  
  80a12f:	c3                   	ret    

0080a130 <ip_reass_free_complete_datagram>:
 * @param prev the previous datagram in the linked list
 * @return the number of pbufs freed
 */
static int
ip_reass_free_complete_datagram(struct ip_reassdata *ipr, struct ip_reassdata *prev)
{
  80a130:	55                   	push   %ebp
  80a131:	89 e5                	mov    %esp,%ebp
  80a133:	57                   	push   %edi
  80a134:	56                   	push   %esi
  80a135:	53                   	push   %ebx
  80a136:	83 ec 2c             	sub    $0x2c,%esp
  80a139:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a13c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  int pbufs_freed = 0;
  struct pbuf *p;
  struct ip_reass_helper *iprh;

  LWIP_ASSERT("prev != ipr", prev != ipr);
  80a13f:	39 c2                	cmp    %eax,%edx
  80a141:	75 1c                	jne    80a15f <ip_reass_free_complete_datagram+0x2f>
  80a143:	c7 44 24 08 0f 3e 81 	movl   $0x813e0f,0x8(%esp)
  80a14a:	00 
  80a14b:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80a152:	00 
  80a153:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a15a:	e8 75 68 ff ff       	call   8009d4 <_panic>
  if (prev != NULL) {
  80a15f:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80a163:	74 26                	je     80a18b <ip_reass_free_complete_datagram+0x5b>
    LWIP_ASSERT("prev->next == ipr", prev->next == ipr);
  80a165:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a168:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a16b:	39 10                	cmp    %edx,(%eax)
  80a16d:	74 1c                	je     80a18b <ip_reass_free_complete_datagram+0x5b>
  80a16f:	c7 44 24 08 1b 3e 81 	movl   $0x813e1b,0x8(%esp)
  80a176:	00 
  80a177:	c7 44 24 04 9b 00 00 	movl   $0x9b,0x4(%esp)
  80a17e:	00 
  80a17f:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a186:	e8 49 68 ff ff       	call   8009d4 <_panic>
  }

  snmp_inc_ipreasmfails();
#if LWIP_ICMP
  iprh = (struct ip_reass_helper *)ipr->p->payload;
  80a18b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a18e:	8b 58 04             	mov    0x4(%eax),%ebx
  80a191:	8b 43 04             	mov    0x4(%ebx),%eax
  if (iprh->start == 0) {
  80a194:	bf 00 00 00 00       	mov    $0x0,%edi
  80a199:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a19e:	75 47                	jne    80a1e7 <ip_reass_free_complete_datagram+0xb7>
    /* The first fragment was received, send ICMP time exceeded. */
    /* First, de-queue the first pbuf from r->p. */
    p = ipr->p;
    ipr->p = iprh->next_pbuf;
  80a1a0:	8b 00                	mov    (%eax),%eax
  80a1a2:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80a1a5:	89 42 04             	mov    %eax,0x4(%edx)
    /* Then, copy the original header into it. */
    SMEMCPY(p->payload, &ipr->iphdr, IP_HLEN);
  80a1a8:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a1af:	00 
  80a1b0:	89 d0                	mov    %edx,%eax
  80a1b2:	83 c0 08             	add    $0x8,%eax
  80a1b5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a1b9:	8b 43 04             	mov    0x4(%ebx),%eax
  80a1bc:	89 04 24             	mov    %eax,(%esp)
  80a1bf:	e8 cd 71 ff ff       	call   801391 <memcpy>
    icmp_time_exceeded(p, ICMP_TE_FRAG);
  80a1c4:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80a1cb:	00 
  80a1cc:	89 1c 24             	mov    %ebx,(%esp)
  80a1cf:	e8 fc 7a 00 00       	call   811cd0 <icmp_time_exceeded>
    pbufs_freed += pbuf_clen(p);
  80a1d4:	89 1c 24             	mov    %ebx,(%esp)
  80a1d7:	e8 14 d9 ff ff       	call   807af0 <pbuf_clen>
  80a1dc:	0f b6 f8             	movzbl %al,%edi
    pbuf_free(p);
  80a1df:	89 1c 24             	mov    %ebx,(%esp)
  80a1e2:	e8 71 dd ff ff       	call   807f58 <pbuf_free>
  }
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  80a1e7:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a1ea:	8b 58 04             	mov    0x4(%eax),%ebx
  while (p != NULL) {
  80a1ed:	85 db                	test   %ebx,%ebx
  80a1ef:	74 22                	je     80a213 <ip_reass_free_complete_datagram+0xe3>
    struct pbuf *pcur;
    iprh = (struct ip_reass_helper *)p->payload;
  80a1f1:	8b 43 04             	mov    0x4(%ebx),%eax
    pcur = p;
    /* get the next pointer before freeing */
    p = iprh->next_pbuf;
  80a1f4:	8b 30                	mov    (%eax),%esi
    pbufs_freed += pbuf_clen(pcur);
  80a1f6:	89 1c 24             	mov    %ebx,(%esp)
  80a1f9:	e8 f2 d8 ff ff       	call   807af0 <pbuf_clen>
  80a1fe:	0f b6 c0             	movzbl %al,%eax
  80a201:	01 c7                	add    %eax,%edi
    pbuf_free(pcur);    
  80a203:	89 1c 24             	mov    %ebx,(%esp)
  80a206:	e8 4d dd ff ff       	call   807f58 <pbuf_free>
#endif /* LWIP_ICMP */

  /* First, free all received pbufs.  The individual pbufs need to be released 
     separately as they have not yet been chained */
  p = ipr->p;
  while (p != NULL) {
  80a20b:	85 f6                	test   %esi,%esi
  80a20d:	74 04                	je     80a213 <ip_reass_free_complete_datagram+0xe3>
  80a20f:	89 f3                	mov    %esi,%ebx
  80a211:	eb de                	jmp    80a1f1 <ip_reass_free_complete_datagram+0xc1>
    p = iprh->next_pbuf;
    pbufs_freed += pbuf_clen(pcur);
    pbuf_free(pcur);    
  }
  /* Then, unchain the struct ip_reassdata from the list and free it. */
  ip_reass_dequeue_datagram(ipr, prev);
  80a213:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a216:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a219:	e8 c2 fe ff ff       	call   80a0e0 <ip_reass_dequeue_datagram>
  LWIP_ASSERT("ip_reass_pbufcount >= clen", ip_reass_pbufcount >= pbufs_freed);
  80a21e:	0f b7 05 c4 87 b3 00 	movzwl 0xb387c4,%eax
  80a225:	0f b7 d0             	movzwl %ax,%edx
  80a228:	39 fa                	cmp    %edi,%edx
  80a22a:	7d 1c                	jge    80a248 <ip_reass_free_complete_datagram+0x118>
  80a22c:	c7 44 24 08 2d 3e 81 	movl   $0x813e2d,0x8(%esp)
  80a233:	00 
  80a234:	c7 44 24 04 bc 00 00 	movl   $0xbc,0x4(%esp)
  80a23b:	00 
  80a23c:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a243:	e8 8c 67 ff ff       	call   8009d4 <_panic>
  ip_reass_pbufcount -= pbufs_freed;
  80a248:	66 29 f8             	sub    %di,%ax
  80a24b:	66 a3 c4 87 b3 00    	mov    %ax,0xb387c4

  return pbufs_freed;
}
  80a251:	89 f8                	mov    %edi,%eax
  80a253:	83 c4 2c             	add    $0x2c,%esp
  80a256:	5b                   	pop    %ebx
  80a257:	5e                   	pop    %esi
  80a258:	5f                   	pop    %edi
  80a259:	5d                   	pop    %ebp
  80a25a:	c3                   	ret    

0080a25b <ip_reass_remove_oldest_datagram>:
 *        (used for freeing other datagrams if not enough space)
 * @return the number of pbufs freed
 */
static int
ip_reass_remove_oldest_datagram(struct ip_hdr *fraghdr, int pbufs_needed)
{
  80a25b:	55                   	push   %ebp
  80a25c:	89 e5                	mov    %esp,%ebp
  80a25e:	57                   	push   %edi
  80a25f:	56                   	push   %esi
  80a260:	53                   	push   %ebx
  80a261:	83 ec 2c             	sub    $0x2c,%esp
  80a264:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80a267:	89 55 dc             	mov    %edx,-0x24(%ebp)
  80a26a:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
   * but don't free the datagram that 'fraghdr' belongs to! */
  do {
    oldest = NULL;
    prev = NULL;
    other_datagrams = 0;
    r = reassdatagrams;
  80a271:	8b 0d c0 87 b3 00    	mov    0xb387c0,%ecx
    while (r != NULL) {
  80a277:	85 c9                	test   %ecx,%ecx
  80a279:	74 6f                	je     80a2ea <ip_reass_remove_oldest_datagram+0x8f>
      if (!IP_ADDRESSES_AND_ID_MATCH(&r->iphdr, fraghdr)) {
  80a27b:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a27e:	8b 78 0c             	mov    0xc(%eax),%edi
  80a281:	ba 00 00 00 00       	mov    $0x0,%edx
  80a286:	b8 00 00 00 00       	mov    $0x0,%eax
  80a28b:	bb 00 00 00 00       	mov    $0x0,%ebx
  80a290:	89 55 d4             	mov    %edx,-0x2c(%ebp)
  80a293:	39 79 14             	cmp    %edi,0x14(%ecx)
  80a296:	75 15                	jne    80a2ad <ip_reass_remove_oldest_datagram+0x52>
  80a298:	8b 51 18             	mov    0x18(%ecx),%edx
  80a29b:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  80a29e:	3b 56 10             	cmp    0x10(%esi),%edx
  80a2a1:	75 0a                	jne    80a2ad <ip_reass_remove_oldest_datagram+0x52>
  80a2a3:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80a2a7:	66 3b 56 04          	cmp    0x4(%esi),%dx
  80a2ab:	74 14                	je     80a2c1 <ip_reass_remove_oldest_datagram+0x66>
        /* Not the same datagram as fraghdr */
        other_datagrams++;
  80a2ad:	83 c3 01             	add    $0x1,%ebx
        if (oldest == NULL) {
  80a2b0:	85 c0                	test   %eax,%eax
  80a2b2:	74 0b                	je     80a2bf <ip_reass_remove_oldest_datagram+0x64>
          oldest = r;
        } else if (r->timer <= oldest->timer) {
  80a2b4:	0f b6 71 1f          	movzbl 0x1f(%ecx),%esi
  80a2b8:	89 f2                	mov    %esi,%edx
  80a2ba:	3a 50 1f             	cmp    0x1f(%eax),%dl
  80a2bd:	77 02                	ja     80a2c1 <ip_reass_remove_oldest_datagram+0x66>
  80a2bf:	89 c8                	mov    %ecx,%eax
          /* older than the previous oldest */
          oldest = r;
        }
      }
      if (r->next != NULL) {
  80a2c1:	8b 31                	mov    (%ecx),%esi
  80a2c3:	85 f6                	test   %esi,%esi
  80a2c5:	74 07                	je     80a2ce <ip_reass_remove_oldest_datagram+0x73>
  80a2c7:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80a2ca:	89 f1                	mov    %esi,%ecx
  80a2cc:	eb c5                	jmp    80a293 <ip_reass_remove_oldest_datagram+0x38>
  80a2ce:	8b 55 d4             	mov    -0x2c(%ebp),%edx
        prev = r;
      }
      r = r->next;
    }
    if (oldest != NULL) {
  80a2d1:	85 c0                	test   %eax,%eax
  80a2d3:	74 08                	je     80a2dd <ip_reass_remove_oldest_datagram+0x82>
      pbufs_freed_current = ip_reass_free_complete_datagram(oldest, prev);
  80a2d5:	e8 56 fe ff ff       	call   80a130 <ip_reass_free_complete_datagram>
      pbufs_freed += pbufs_freed_current;
  80a2da:	01 45 e0             	add    %eax,-0x20(%ebp)
    }
  } while ((pbufs_freed < pbufs_needed) && (other_datagrams > 1));
  80a2dd:	8b 75 dc             	mov    -0x24(%ebp),%esi
  80a2e0:	39 75 e0             	cmp    %esi,-0x20(%ebp)
  80a2e3:	7d 05                	jge    80a2ea <ip_reass_remove_oldest_datagram+0x8f>
  80a2e5:	83 fb 01             	cmp    $0x1,%ebx
  80a2e8:	7f 87                	jg     80a271 <ip_reass_remove_oldest_datagram+0x16>
  return pbufs_freed;
}
  80a2ea:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a2ed:	83 c4 2c             	add    $0x2c,%esp
  80a2f0:	5b                   	pop    %ebx
  80a2f1:	5e                   	pop    %esi
  80a2f2:	5f                   	pop    %edi
  80a2f3:	5d                   	pop    %ebp
  80a2f4:	c3                   	ret    

0080a2f5 <ip_reass_tmr>:
 *
 * Should be called every 1000 msec (defined by IP_TMR_INTERVAL).
 */
void
ip_reass_tmr(void)
{
  80a2f5:	55                   	push   %ebp
  80a2f6:	89 e5                	mov    %esp,%ebp
  80a2f8:	56                   	push   %esi
  80a2f9:	53                   	push   %ebx
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  80a2fa:	a1 c0 87 b3 00       	mov    0xb387c0,%eax
  while (r != NULL) {
  80a2ff:	85 c0                	test   %eax,%eax
  80a301:	74 2a                	je     80a32d <ip_reass_tmr+0x38>
  80a303:	be 00 00 00 00       	mov    $0x0,%esi
    /* Decrement the timer. Once it reaches 0,
     * clean up the incomplete fragment assembly */
    if (r->timer > 0) {
  80a308:	0f b6 50 1f          	movzbl 0x1f(%eax),%edx
  80a30c:	84 d2                	test   %dl,%dl
  80a30e:	74 0c                	je     80a31c <ip_reass_tmr+0x27>
      r->timer--;
  80a310:	83 ea 01             	sub    $0x1,%edx
  80a313:	88 50 1f             	mov    %dl,0x1f(%eax)
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer dec %"U16_F"\n",(u16_t)r->timer));
      prev = r;
      r = r->next;
  80a316:	8b 18                	mov    (%eax),%ebx
  80a318:	89 c6                	mov    %eax,%esi
  80a31a:	eb 09                	jmp    80a325 <ip_reass_tmr+0x30>
      /* reassembly timed out */
      struct ip_reassdata *tmp;
      LWIP_DEBUGF(IP_REASS_DEBUG, ("ip_reass_tmr: timer timed out\n"));
      tmp = r;
      /* get the next pointer before freeing */
      r = r->next;
  80a31c:	8b 18                	mov    (%eax),%ebx
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
  80a31e:	89 f2                	mov    %esi,%edx
  80a320:	e8 0b fe ff ff       	call   80a130 <ip_reass_free_complete_datagram>
ip_reass_tmr(void)
{
  struct ip_reassdata *r, *prev = NULL;

  r = reassdatagrams;
  while (r != NULL) {
  80a325:	85 db                	test   %ebx,%ebx
  80a327:	74 04                	je     80a32d <ip_reass_tmr+0x38>
  80a329:	89 d8                	mov    %ebx,%eax
  80a32b:	eb db                	jmp    80a308 <ip_reass_tmr+0x13>
      r = r->next;
      /* free the helper struct and all enqueued pbufs */
      ip_reass_free_complete_datagram(tmp, prev);
     }
   }
}
  80a32d:	5b                   	pop    %ebx
  80a32e:	5e                   	pop    %esi
  80a32f:	5d                   	pop    %ebp
  80a330:	c3                   	ret    

0080a331 <ip_reass>:
 * @param p points to a pbuf chain of the fragment
 * @return NULL if reassembly is incomplete, ? otherwise
 */
struct pbuf *
ip_reass(struct pbuf *p)
{
  80a331:	55                   	push   %ebp
  80a332:	89 e5                	mov    %esp,%ebp
  80a334:	57                   	push   %edi
  80a335:	56                   	push   %esi
  80a336:	53                   	push   %ebx
  80a337:	83 ec 3c             	sub    $0x3c,%esp
  struct ip_reassdata *ipr_prev = NULL;

  IPFRAG_STATS_INC(ip_frag.recv);
  snmp_inc_ipreasmreqds();

  fraghdr = (struct ip_hdr*)p->payload;
  80a33a:	8b 45 08             	mov    0x8(%ebp),%eax
  80a33d:	8b 58 04             	mov    0x4(%eax),%ebx

  if ((IPH_HL(fraghdr) * 4) != IP_HLEN) {
  80a340:	0f b7 03             	movzwl (%ebx),%eax
  80a343:	89 04 24             	mov    %eax,(%esp)
  80a346:	e8 16 0a 00 00       	call   80ad61 <ntohs>
  80a34b:	c1 e8 06             	shr    $0x6,%eax
  80a34e:	83 e0 3c             	and    $0x3c,%eax
  80a351:	83 f8 14             	cmp    $0x14,%eax
  80a354:	0f 85 f3 04 00 00    	jne    80a84d <ip_reass+0x51c>
    LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: IP options currently not supported!\n"));
    IPFRAG_STATS_INC(ip_frag.err);
    goto nullreturn;
  }

  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a35a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a35e:	89 04 24             	mov    %eax,(%esp)
  80a361:	e8 fb 09 00 00       	call   80ad61 <ntohs>
  80a366:	66 89 45 d0          	mov    %ax,-0x30(%ebp)
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a36a:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a36e:	89 04 24             	mov    %eax,(%esp)
  80a371:	e8 eb 09 00 00       	call   80ad61 <ntohs>
  80a376:	66 89 45 da          	mov    %ax,-0x26(%ebp)
  80a37a:	0f b7 03             	movzwl (%ebx),%eax
  80a37d:	89 04 24             	mov    %eax,(%esp)
  80a380:	e8 dc 09 00 00       	call   80ad61 <ntohs>
  80a385:	66 89 45 dc          	mov    %ax,-0x24(%ebp)

  /* Check if we are allowed to enqueue more datagrams. */
  clen = pbuf_clen(p);
  80a389:	8b 55 08             	mov    0x8(%ebp),%edx
  80a38c:	89 14 24             	mov    %edx,(%esp)
  80a38f:	e8 5c d7 ff ff       	call   807af0 <pbuf_clen>
  80a394:	89 c7                	mov    %eax,%edi
  if ((ip_reass_pbufcount + clen) > IP_REASS_MAX_PBUFS) {
  80a396:	0f b6 c8             	movzbl %al,%ecx
  80a399:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a39c:	0f b7 05 c4 87 b3 00 	movzwl 0xb387c4,%eax
  80a3a3:	01 c8                	add    %ecx,%eax
  80a3a5:	83 f8 0a             	cmp    $0xa,%eax
  80a3a8:	7e 24                	jle    80a3ce <ip_reass+0x9d>
#if IP_REASS_FREE_OLDEST
    if (!ip_reass_remove_oldest_datagram(fraghdr, clen) ||
  80a3aa:	89 ca                	mov    %ecx,%edx
  80a3ac:	89 d8                	mov    %ebx,%eax
  80a3ae:	e8 a8 fe ff ff       	call   80a25b <ip_reass_remove_oldest_datagram>
  80a3b3:	85 c0                	test   %eax,%eax
  80a3b5:	0f 84 92 04 00 00    	je     80a84d <ip_reass+0x51c>
  80a3bb:	0f b7 05 c4 87 b3 00 	movzwl 0xb387c4,%eax
  80a3c2:	03 45 e0             	add    -0x20(%ebp),%eax
  80a3c5:	83 f8 0a             	cmp    $0xa,%eax
  80a3c8:	0f 8f 7f 04 00 00    	jg     80a84d <ip_reass+0x51c>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80a3ce:	8b 35 c0 87 b3 00    	mov    0xb387c0,%esi
  80a3d4:	85 f6                	test   %esi,%esi
  80a3d6:	0f 84 97 04 00 00    	je     80a873 <ip_reass+0x542>
    /* Check if the incoming fragment matches the one currently present
       in the reassembly buffer. If so, we proceed with copying the
       fragment into the buffer. */
    if (IP_ADDRESSES_AND_ID_MATCH(&ipr->iphdr, fraghdr)) {
  80a3dc:	8b 53 0c             	mov    0xc(%ebx),%edx
  80a3df:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a3e6:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a3eb:	39 56 14             	cmp    %edx,0x14(%esi)
  80a3ee:	75 12                	jne    80a402 <ip_reass+0xd1>
  80a3f0:	8b 46 18             	mov    0x18(%esi),%eax
  80a3f3:	3b 43 10             	cmp    0x10(%ebx),%eax
  80a3f6:	75 0a                	jne    80a402 <ip_reass+0xd1>
  80a3f8:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  80a3fc:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  80a400:	74 11                	je     80a413 <ip_reass+0xe2>
    }
  }

  /* Look for the datagram the fragment belongs to in the current datagram queue,
   * remembering the previous in the queue for later dequeueing. */
  for (ipr = reassdatagrams; ipr != NULL; ipr = ipr->next) {
  80a402:	8b 06                	mov    (%esi),%eax
  80a404:	85 c0                	test   %eax,%eax
  80a406:	75 05                	jne    80a40d <ip_reass+0xdc>
  80a408:	89 75 d4             	mov    %esi,-0x2c(%ebp)
  80a40b:	eb 10                	jmp    80a41d <ip_reass+0xec>
  80a40d:	89 f1                	mov    %esi,%ecx
  80a40f:	89 c6                	mov    %eax,%esi
  80a411:	eb d8                	jmp    80a3eb <ip_reass+0xba>
  80a413:	89 4d d4             	mov    %ecx,-0x2c(%ebp)
  80a416:	89 75 cc             	mov    %esi,-0x34(%ebp)
      break;
    }
    ipr_prev = ipr;
  }

  if (ipr == NULL) {
  80a419:	85 f6                	test   %esi,%esi
  80a41b:	75 7d                	jne    80a49a <ip_reass+0x169>
static struct ip_reassdata*
ip_reass_enqueue_new_datagram(struct ip_hdr *fraghdr, int clen)
{
  struct ip_reassdata* ipr;
  /* No matching previous fragment found, allocate a new reassdata struct */
  ipr = memp_malloc(MEMP_REASSDATA);
  80a41d:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a424:	e8 db d3 ff ff       	call   807804 <memp_malloc>
  80a429:	89 c6                	mov    %eax,%esi
  if (ipr == NULL) {
  80a42b:	85 c0                	test   %eax,%eax
  80a42d:	75 29                	jne    80a458 <ip_reass+0x127>
#if IP_REASS_FREE_OLDEST
    if (ip_reass_remove_oldest_datagram(fraghdr, clen) >= clen) {
  80a42f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a432:	89 d8                	mov    %ebx,%eax
  80a434:	e8 22 fe ff ff       	call   80a25b <ip_reass_remove_oldest_datagram>
  80a439:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80a43c:	0f 8f 0b 04 00 00    	jg     80a84d <ip_reass+0x51c>
      ipr = memp_malloc(MEMP_REASSDATA);
  80a442:	c7 04 24 05 00 00 00 	movl   $0x5,(%esp)
  80a449:	e8 b6 d3 ff ff       	call   807804 <memp_malloc>
  80a44e:	89 c6                	mov    %eax,%esi
    }
    if (ipr == NULL)
  80a450:	85 c0                	test   %eax,%eax
  80a452:	0f 84 f5 03 00 00    	je     80a84d <ip_reass+0x51c>
      IPFRAG_STATS_INC(ip_frag.memerr);
      LWIP_DEBUGF(IP_REASS_DEBUG,("Failed to alloc reassdata struct\n"));
      return NULL;
    }
  }
  memset(ipr, 0, sizeof(struct ip_reassdata));
  80a458:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80a45f:	00 
  80a460:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80a467:	00 
  80a468:	89 34 24             	mov    %esi,(%esp)
  80a46b:	e8 46 6e ff ff       	call   8012b6 <memset>
  ipr->timer = IP_REASS_MAXAGE;
  80a470:	c6 46 1f 03          	movb   $0x3,0x1f(%esi)

  /* enqueue the new structure to the front of the list */
  ipr->next = reassdatagrams;
  80a474:	a1 c0 87 b3 00       	mov    0xb387c0,%eax
  80a479:	89 06                	mov    %eax,(%esi)
  reassdatagrams = ipr;
  80a47b:	89 35 c0 87 b3 00    	mov    %esi,0xb387c0
  /* copy the ip header for later tests and input */
  /* @todo: no ip options supported? */
  SMEMCPY(&(ipr->iphdr), fraghdr, IP_HLEN);
  80a481:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a488:	00 
  80a489:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a48d:	8d 46 08             	lea    0x8(%esi),%eax
  80a490:	89 04 24             	mov    %eax,(%esp)
  80a493:	e8 f9 6e ff ff       	call   801391 <memcpy>
  80a498:	eb 41                	jmp    80a4db <ip_reass+0x1aa>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80a49a:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a49e:	89 04 24             	mov    %eax,(%esp)
  80a4a1:	e8 bb 08 00 00       	call   80ad61 <ntohs>
  80a4a6:	66 a9 ff 1f          	test   $0x1fff,%ax
  80a4aa:	75 2f                	jne    80a4db <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
  80a4ac:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80a4af:	0f b7 42 0e          	movzwl 0xe(%edx),%eax
  80a4b3:	89 04 24             	mov    %eax,(%esp)
  80a4b6:	e8 a6 08 00 00       	call   80ad61 <ntohs>
    /* Bail if unable to enqueue */
    if(ipr == NULL) {
      goto nullreturn;
    }
  } else {
    if (((ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) == 0) && 
  80a4bb:	66 a9 ff 1f          	test   $0x1fff,%ax
  80a4bf:	74 1a                	je     80a4db <ip_reass+0x1aa>
      ((ntohs(IPH_OFFSET(&ipr->iphdr)) & IP_OFFMASK) != 0)) {
      /* ipr->iphdr is not the header from the first fragment, but fraghdr is
       * -> copy fraghdr into ipr->iphdr since we want to have the header
       * of the first fragment (for ICMP time exceeded and later, for copying
       * all options, if supported)*/
      SMEMCPY(&ipr->iphdr, fraghdr, IP_HLEN);
  80a4c1:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a4c8:	00 
  80a4c9:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80a4cd:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80a4d0:	83 c0 08             	add    $0x8,%eax
  80a4d3:	89 04 24             	mov    %eax,(%esp)
  80a4d6:	e8 b6 6e ff ff       	call   801391 <memcpy>
    }
  }
  /* Track the current number of pbufs current 'in-flight', in order to limit 
  the number of fragments that may be enqueued at any one time */
  ip_reass_pbufcount += clen;
  80a4db:	66 81 e7 ff 00       	and    $0xff,%di
  80a4e0:	66 01 3d c4 87 b3 00 	add    %di,0xb387c4

  /* At this point, we have either created a new entry or pointing 
   * to an existing one */

  /* check for 'no more fragments', and update queue entry*/
  if ((ntohs(IPH_OFFSET(fraghdr)) & IP_MF) == 0) {
  80a4e7:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a4eb:	89 04 24             	mov    %eax,(%esp)
  80a4ee:	e8 6e 08 00 00       	call   80ad61 <ntohs>
  80a4f3:	f6 c4 20             	test   $0x20,%ah
  80a4f6:	75 21                	jne    80a519 <ip_reass+0x1e8>
    ipr->flags |= IP_REASS_FLAG_LASTFRAG;
  80a4f8:	80 4e 1e 01          	orb    $0x1,0x1e(%esi)
    ipr->datagram_len = offset + len;
  80a4fc:	0f b7 4d d0          	movzwl -0x30(%ebp),%ecx
  80a500:	0f b7 5d da          	movzwl -0x26(%ebp),%ebx
  80a504:	8d 04 cb             	lea    (%ebx,%ecx,8),%eax
  80a507:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  80a50b:	66 c1 ea 06          	shr    $0x6,%dx
  80a50f:	83 e2 3c             	and    $0x3c,%edx
  80a512:	66 29 d0             	sub    %dx,%ax
  80a515:	66 89 46 1c          	mov    %ax,0x1c(%esi)
  u16_t offset,len;
  struct ip_hdr *fraghdr;
  int valid = 1;

  /* Extract length and fragment offset from current fragment */
  fraghdr = (struct ip_hdr*)new_p->payload; 
  80a519:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a51c:	8b 5f 04             	mov    0x4(%edi),%ebx
  len = ntohs(IPH_LEN(fraghdr)) - IPH_HL(fraghdr) * 4;
  80a51f:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  80a523:	89 04 24             	mov    %eax,(%esp)
  80a526:	e8 36 08 00 00       	call   80ad61 <ntohs>
  80a52b:	89 c7                	mov    %eax,%edi
  80a52d:	0f b7 03             	movzwl (%ebx),%eax
  80a530:	89 04 24             	mov    %eax,(%esp)
  80a533:	e8 29 08 00 00       	call   80ad61 <ntohs>
  80a538:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  offset = (ntohs(IPH_OFFSET(fraghdr)) & IP_OFFMASK) * 8;
  80a53c:	0f b7 43 06          	movzwl 0x6(%ebx),%eax
  80a540:	89 04 24             	mov    %eax,(%esp)
  80a543:	e8 19 08 00 00       	call   80ad61 <ntohs>
  80a548:	c1 e0 03             	shl    $0x3,%eax
  /* overwrite the fragment's ip header from the pbuf with our helper struct,
   * and setup the embedded helper structure. */
  /* make sure the struct ip_reass_helper fits into the IP header */
  LWIP_ASSERT("sizeof(struct ip_reass_helper) <= IP_HLEN",
              sizeof(struct ip_reass_helper) <= IP_HLEN);
  iprh = (struct ip_reass_helper*)new_p->payload;
  80a54b:	8b 55 08             	mov    0x8(%ebp),%edx
  80a54e:	8b 52 04             	mov    0x4(%edx),%edx
  80a551:	89 55 e0             	mov    %edx,-0x20(%ebp)
  iprh->next_pbuf = NULL;
  80a554:	c7 02 00 00 00 00    	movl   $0x0,(%edx)
  iprh->start = offset;
  80a55a:	66 89 42 04          	mov    %ax,0x4(%edx)
  iprh->end = offset + len;
  80a55e:	8d 0c 38             	lea    (%eax,%edi,1),%ecx
  80a561:	0f b7 55 dc          	movzwl -0x24(%ebp),%edx
  80a565:	66 c1 ea 06          	shr    $0x6,%dx
  80a569:	83 e2 3c             	and    $0x3c,%edx
  80a56c:	66 29 d1             	sub    %dx,%cx
  80a56f:	66 89 4d da          	mov    %cx,-0x26(%ebp)
  80a573:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a576:	66 89 4b 06          	mov    %cx,0x6(%ebx)

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a57a:	8b 7e 04             	mov    0x4(%esi),%edi
  80a57d:	85 ff                	test   %edi,%edi
  80a57f:	0f 84 10 03 00 00    	je     80a895 <ip_reass+0x564>
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a585:	8b 57 04             	mov    0x4(%edi),%edx
    if (iprh->start < iprh_tmp->start) {
  80a588:	0f b7 4a 04          	movzwl 0x4(%edx),%ecx
  80a58c:	66 39 c8             	cmp    %cx,%ax
  80a58f:	0f 82 ea 02 00 00    	jb     80a87f <ip_reass+0x54e>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a595:	66 39 c8             	cmp    %cx,%ax
  80a598:	0f 84 23 02 00 00    	je     80a7c1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a59e:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a5a5:	66 39 42 06          	cmp    %ax,0x6(%edx)
  80a5a9:	0f 86 8e 00 00 00    	jbe    80a63d <ip_reass+0x30c>
  80a5af:	90                   	nop
  80a5b0:	e9 0c 02 00 00       	jmp    80a7c1 <ip_reass+0x490>
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
  80a5b5:	8b 4f 04             	mov    0x4(%edi),%ecx
    if (iprh->start < iprh_tmp->start) {
  80a5b8:	0f b7 59 04          	movzwl 0x4(%ecx),%ebx
  80a5bc:	66 39 d8             	cmp    %bx,%ax
  80a5bf:	73 49                	jae    80a60a <ip_reass+0x2d9>
  80a5c1:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80a5c4:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a5c7:	8b 75 d0             	mov    -0x30(%ebp),%esi
  80a5ca:	89 d3                	mov    %edx,%ebx
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a5cc:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80a5cf:	89 39                	mov    %edi,(%ecx)
      if (iprh_prev != NULL) {
  80a5d1:	85 d2                	test   %edx,%edx
  80a5d3:	74 25                	je     80a5fa <ip_reass+0x2c9>
        /* not the fragment with the lowest offset */
#if IP_REASS_CHECK_OVERLAP
        if ((iprh->start < iprh_prev->end) || (iprh->end > iprh_tmp->start)) {
  80a5d5:	66 3b 42 06          	cmp    0x6(%edx),%ax
  80a5d9:	0f 82 e2 01 00 00    	jb     80a7c1 <ip_reass+0x490>
  80a5df:	0f b7 45 da          	movzwl -0x26(%ebp),%eax
  80a5e3:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a5e6:	66 3b 47 04          	cmp    0x4(%edi),%ax
  80a5ea:	0f 87 d1 01 00 00    	ja     80a7c1 <ip_reass+0x490>
          /* fragment overlaps with previous or following, throw away */
          goto freepbuf;
        }
#endif /* IP_REASS_CHECK_OVERLAP */
        iprh_prev->next_pbuf = new_p;
  80a5f0:	8b 55 08             	mov    0x8(%ebp),%edx
  80a5f3:	89 13                	mov    %edx,(%ebx)
  80a5f5:	e9 cc 00 00 00       	jmp    80a6c6 <ip_reass+0x395>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
  80a5fa:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a5fd:	89 4e 04             	mov    %ecx,0x4(%esi)
    q = iprh_tmp->next_pbuf;
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
  80a600:	85 ff                	test   %edi,%edi
  80a602:	0f 85 be 00 00 00    	jne    80a6c6 <ip_reass+0x395>
  80a608:	eb 49                	jmp    80a653 <ip_reass+0x322>
      } else {
        /* fragment with the lowest offset */
        ipr->p = new_p;
      }
      break;
    } else if(iprh->start == iprh_tmp->start) {
  80a60a:	66 39 d8             	cmp    %bx,%ax
  80a60d:	8d 76 00             	lea    0x0(%esi),%esi
  80a610:	0f 84 ab 01 00 00    	je     80a7c1 <ip_reass+0x490>
      /* received the same datagram twice: no need to keep the datagram */
      goto freepbuf;
#if IP_REASS_CHECK_OVERLAP
    } else if(iprh->start < iprh_tmp->end) {
  80a616:	66 3b 41 06          	cmp    0x6(%ecx),%ax
  80a61a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80a620:	0f 82 9b 01 00 00    	jb     80a7c1 <ip_reass+0x490>
      /* overlap: no need to keep the new datagram */
      goto freepbuf;
#endif /* IP_REASS_CHECK_OVERLAP */
    } else {
      /* Check if the fragments received so far have no wholes. */
      if (iprh_prev != NULL) {
  80a626:	85 d2                	test   %edx,%edx
  80a628:	74 0f                	je     80a639 <ip_reass+0x308>
        if (iprh_prev->end != iprh_tmp->start) {
  80a62a:	66 3b 5a 06          	cmp    0x6(%edx),%bx
  80a62e:	0f 95 c2             	setne  %dl
  80a631:	0f b6 d2             	movzbl %dl,%edx
  80a634:	83 ea 01             	sub    $0x1,%edx
  80a637:	21 d6                	and    %edx,%esi
  80a639:	89 ca                	mov    %ecx,%edx
  80a63b:	eb 06                	jmp    80a643 <ip_reass+0x312>
  80a63d:	89 75 d0             	mov    %esi,-0x30(%ebp)
  80a640:	8b 75 dc             	mov    -0x24(%ebp),%esi
           * and the previous fragment */
          valid = 0;
        }
      }
    }
    q = iprh_tmp->next_pbuf;
  80a643:	8b 3a                	mov    (%edx),%edi
  iprh->start = offset;
  iprh->end = offset + len;

  /* Iterate through until we either get to the end of the list (append),
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
  80a645:	85 ff                	test   %edi,%edi
  80a647:	0f 85 68 ff ff ff    	jne    80a5b5 <ip_reass+0x284>
  80a64d:	89 75 dc             	mov    %esi,-0x24(%ebp)
  80a650:	8b 75 d0             	mov    -0x30(%ebp),%esi
    iprh_prev = iprh_tmp;
  }

  /* If q is NULL, then we made it to the end of the list. Determine what to do now */
  if (q == NULL) {
    if (iprh_prev != NULL) {
  80a653:	85 d2                	test   %edx,%edx
  80a655:	74 47                	je     80a69e <ip_reass+0x36d>
      /* this is (for now), the fragment with the highest offset:
       * chain it to the last fragment */
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("check fragments don't overlap", iprh_prev->end <= iprh->start);
  80a657:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a65b:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a65e:	66 3b 43 04          	cmp    0x4(%ebx),%ax
  80a662:	76 1c                	jbe    80a680 <ip_reass+0x34f>
  80a664:	c7 44 24 08 48 3e 81 	movl   $0x813e48,0x8(%esp)
  80a66b:	00 
  80a66c:	c7 44 24 04 83 01 00 	movl   $0x183,0x4(%esp)
  80a673:	00 
  80a674:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a67b:	e8 54 63 ff ff       	call   8009d4 <_panic>
#endif /* IP_REASS_CHECK_OVERLAP */
      iprh_prev->next_pbuf = new_p;
  80a680:	8b 7d 08             	mov    0x8(%ebp),%edi
  80a683:	89 3a                	mov    %edi,(%edx)
      if (iprh_prev->end != iprh->start) {
  80a685:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a689:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a68c:	66 3b 42 04          	cmp    0x4(%edx),%ax
  80a690:	0f 95 c0             	setne  %al
  80a693:	0f b6 c0             	movzbl %al,%eax
  80a696:	83 e8 01             	sub    $0x1,%eax
  80a699:	21 45 dc             	and    %eax,-0x24(%ebp)
  80a69c:	eb 28                	jmp    80a6c6 <ip_reass+0x395>
        valid = 0;
      }
    } else {
#if IP_REASS_CHECK_OVERLAP
      LWIP_ASSERT("no previous fragment, this must be the first fragment!",
  80a69e:	83 7e 04 00          	cmpl   $0x0,0x4(%esi)
  80a6a2:	74 1c                	je     80a6c0 <ip_reass+0x38f>
  80a6a4:	c7 44 24 08 74 3e 81 	movl   $0x813e74,0x8(%esp)
  80a6ab:	00 
  80a6ac:	c7 44 24 04 8c 01 00 	movl   $0x18c,0x4(%esp)
  80a6b3:	00 
  80a6b4:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a6bb:	e8 14 63 ff ff       	call   8009d4 <_panic>
        ipr->p == NULL);
#endif /* IP_REASS_CHECK_OVERLAP */
      /* this is the first fragment we ever received for this ip datagram */
      ipr->p = new_p;
  80a6c0:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a6c3:	89 4e 04             	mov    %ecx,0x4(%esi)
    }
  }

  /* At this point, the validation part begins: */
  /* If we already received the last fragment */
  if ((ipr->flags & IP_REASS_FLAG_LASTFRAG) != 0) {
  80a6c6:	f6 46 1e 01          	testb  $0x1,0x1e(%esi)
  80a6ca:	0f 84 91 01 00 00    	je     80a861 <ip_reass+0x530>
    /* and had no wholes so far */
    if (valid) {
  80a6d0:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80a6d4:	0f 84 87 01 00 00    	je     80a861 <ip_reass+0x530>
      /* then check if the rest of the fragments is here */
      /* Check if the queue starts with the first datagram */
      if (((struct ip_reass_helper*)ipr->p->payload)->start != 0) {
  80a6da:	8b 56 04             	mov    0x4(%esi),%edx
  80a6dd:	8b 42 04             	mov    0x4(%edx),%eax
  80a6e0:	66 83 78 04 00       	cmpw   $0x0,0x4(%eax)
  80a6e5:	0f 85 76 01 00 00    	jne    80a861 <ip_reass+0x530>
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
  80a6eb:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80a6ee:	8b 0b                	mov    (%ebx),%ecx
        while (q != NULL) {
  80a6f0:	85 c9                	test   %ecx,%ecx
  80a6f2:	0f 84 ae 01 00 00    	je     80a8a6 <ip_reass+0x575>
          iprh = (struct ip_reass_helper*)q->payload;
  80a6f8:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a6fb:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a6ff:	89 4d e0             	mov    %ecx,-0x20(%ebp)
  80a702:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a706:	74 1a                	je     80a722 <ip_reass+0x3f1>
  80a708:	e9 54 01 00 00       	jmp    80a861 <ip_reass+0x530>
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
          iprh = (struct ip_reass_helper*)q->payload;
  80a70d:	8b 49 04             	mov    0x4(%ecx),%ecx
          if (iprh_prev->end != iprh->start) {
  80a710:	0f b7 5b 06          	movzwl 0x6(%ebx),%ebx
  80a714:	66 3b 59 04          	cmp    0x4(%ecx),%bx
  80a718:	0f 85 43 01 00 00    	jne    80a861 <ip_reass+0x530>
  80a71e:	89 cb                	mov    %ecx,%ebx
  80a720:	eb 03                	jmp    80a725 <ip_reass+0x3f4>
  80a722:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            valid = 0;
            break;
          }
          iprh_prev = iprh;
          q = iprh->next_pbuf;
  80a725:	8b 0b                	mov    (%ebx),%ecx
        valid = 0;
      } else {
        /* and check that there are no wholes after this datagram */
        iprh_prev = iprh;
        q = iprh->next_pbuf;
        while (q != NULL) {
  80a727:	85 c9                	test   %ecx,%ecx
  80a729:	75 e2                	jne    80a70d <ip_reass+0x3dc>
  80a72b:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  80a72e:	e9 73 01 00 00       	jmp    80a8a6 <ip_reass+0x575>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a733:	c7 44 24 08 66 3e 81 	movl   $0x813e66,0x8(%esp)
  80a73a:	00 
  80a73b:	c7 44 24 04 ac 01 00 	movl   $0x1ac,0x4(%esp)
  80a742:	00 
  80a743:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a74a:	e8 85 62 ff ff       	call   8009d4 <_panic>
          LWIP_ASSERT("sanity check",
  80a74f:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  80a752:	75 1c                	jne    80a770 <ip_reass+0x43f>
  80a754:	c7 44 24 08 66 3e 81 	movl   $0x813e66,0x8(%esp)
  80a75b:	00 
  80a75c:	c7 44 24 04 ae 01 00 	movl   $0x1ae,0x4(%esp)
  80a763:	00 
  80a764:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a76b:	e8 64 62 ff ff       	call   8009d4 <_panic>
            ((struct ip_reass_helper*)ipr->p->payload) != iprh);
          LWIP_ASSERT("validate_datagram:next_pbuf!=NULL",
  80a770:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a773:	83 38 00             	cmpl   $0x0,(%eax)
  80a776:	74 1c                	je     80a794 <ip_reass+0x463>
  80a778:	c7 44 24 08 ac 3e 81 	movl   $0x813eac,0x8(%esp)
  80a77f:	00 
  80a780:	c7 44 24 04 b0 01 00 	movl   $0x1b0,0x4(%esp)
  80a787:	00 
  80a788:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a78f:	e8 40 62 ff ff       	call   8009d4 <_panic>
            iprh->next_pbuf == NULL);
          LWIP_ASSERT("validate_datagram:datagram end!=datagram len",
  80a794:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a797:	0f b7 42 06          	movzwl 0x6(%edx),%eax
  80a79b:	66 3b 46 1c          	cmp    0x1c(%esi),%ax
  80a79f:	0f 84 10 01 00 00    	je     80a8b5 <ip_reass+0x584>
  80a7a5:	c7 44 24 08 d0 3e 81 	movl   $0x813ed0,0x8(%esp)
  80a7ac:	00 
  80a7ad:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80a7b4:	00 
  80a7b5:	c7 04 24 f2 3d 81 00 	movl   $0x813df2,(%esp)
  80a7bc:	e8 13 62 ff ff       	call   8009d4 <_panic>
  }
  /* If we come here, not all fragments were received, yet! */
  return 0; /* not yet valid! */
#if IP_REASS_CHECK_OVERLAP
freepbuf:
  ip_reass_pbufcount -= pbuf_clen(new_p);
  80a7c1:	0f b7 1d c4 87 b3 00 	movzwl 0xb387c4,%ebx
  80a7c8:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80a7cb:	89 0c 24             	mov    %ecx,(%esp)
  80a7ce:	e8 1d d3 ff ff       	call   807af0 <pbuf_clen>
  80a7d3:	0f b6 c0             	movzbl %al,%eax
  80a7d6:	66 29 c3             	sub    %ax,%bx
  80a7d9:	66 89 1d c4 87 b3 00 	mov    %bx,0xb387c4
  pbuf_free(new_p);
  80a7e0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80a7e3:	89 1c 24             	mov    %ebx,(%esp)
  80a7e6:	e8 6d d7 ff ff       	call   807f58 <pbuf_free>
  80a7eb:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80a7f2:	eb 74                	jmp    80a868 <ip_reass+0x537>
  80a7f4:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80a7f7:	8b 75 e4             	mov    -0x1c(%ebp),%esi

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
      iprh = (struct ip_reass_helper*)r->payload;
  80a7fa:	8b 5f 04             	mov    0x4(%edi),%ebx

      /* hide the ip header for every succeding fragment */
      pbuf_header(r, -IP_HLEN);
  80a7fd:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80a804:	ff 
  80a805:	89 3c 24             	mov    %edi,(%esp)
  80a808:	e8 d6 d3 ff ff       	call   807be3 <pbuf_header>
      pbuf_cat(p, r);
  80a80d:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80a811:	89 34 24             	mov    %esi,(%esp)
  80a814:	e8 02 d3 ff ff       	call   807b1b <pbuf_cat>
      r = iprh->next_pbuf;
  80a819:	8b 3b                	mov    (%ebx),%edi
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));

    p = ipr->p;

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a81b:	85 ff                	test   %edi,%edi
  80a81d:	75 db                	jne    80a7fa <ip_reass+0x4c9>
  80a81f:	8b 75 e0             	mov    -0x20(%ebp),%esi
      pbuf_header(r, -IP_HLEN);
      pbuf_cat(p, r);
      r = iprh->next_pbuf;
    }
    /* release the sources allocate for the fragment queue entry */
    ip_reass_dequeue_datagram(ipr, ipr_prev);
  80a822:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80a825:	89 f0                	mov    %esi,%eax
  80a827:	e8 b4 f8 ff ff       	call   80a0e0 <ip_reass_dequeue_datagram>

    /* and adjust the number of pbufs currently queued for reassembly. */
    ip_reass_pbufcount -= pbuf_clen(p);
  80a82c:	0f b7 1d c4 87 b3 00 	movzwl 0xb387c4,%ebx
  80a833:	8b 7d e4             	mov    -0x1c(%ebp),%edi
  80a836:	89 3c 24             	mov    %edi,(%esp)
  80a839:	e8 b2 d2 ff ff       	call   807af0 <pbuf_clen>
  80a83e:	0f b6 c0             	movzbl %al,%eax
  80a841:	66 29 c3             	sub    %ax,%bx
  80a844:	66 89 1d c4 87 b3 00 	mov    %bx,0xb387c4

    /* Return the pbuf chain */
    return p;
  80a84b:	eb 1b                	jmp    80a868 <ip_reass+0x537>
  return NULL;

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  80a84d:	8b 45 08             	mov    0x8(%ebp),%eax
  80a850:	89 04 24             	mov    %eax,(%esp)
  80a853:	e8 00 d7 ff ff       	call   807f58 <pbuf_free>
  80a858:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  return NULL;
  80a85f:	eb 07                	jmp    80a868 <ip_reass+0x537>
  80a861:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
}
  80a868:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80a86b:	83 c4 3c             	add    $0x3c,%esp
  80a86e:	5b                   	pop    %ebx
  80a86f:	5e                   	pop    %esi
  80a870:	5f                   	pop    %edi
  80a871:	5d                   	pop    %ebp
  80a872:	c3                   	ret    

nullreturn:
  LWIP_DEBUGF(IP_REASS_DEBUG,("ip_reass: nullreturn\n"));
  IPFRAG_STATS_INC(ip_frag.drop);
  pbuf_free(p);
  return NULL;
  80a873:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80a87a:	e9 9e fb ff ff       	jmp    80a41d <ip_reass+0xec>
   * or we find on with a larger offset (insert). */
  for (q = ipr->p; q != NULL;) {
    iprh_tmp = (struct ip_reass_helper*)q->payload;
    if (iprh->start < iprh_tmp->start) {
      /* the new pbuf should be inserted before this */
      iprh->next_pbuf = q;
  80a87f:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80a882:	89 3a                	mov    %edi,(%edx)
  80a884:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a88b:	ba 00 00 00 00       	mov    $0x0,%edx
  80a890:	e9 65 fd ff ff       	jmp    80a5fa <ip_reass+0x2c9>
  80a895:	c7 45 dc 01 00 00 00 	movl   $0x1,-0x24(%ebp)
  80a89c:	ba 00 00 00 00       	mov    $0x0,%edx
  80a8a1:	e9 ad fd ff ff       	jmp    80a653 <ip_reass+0x322>
          q = iprh->next_pbuf;
        }
        /* if still valid, all fragments are received
         * (because to the MF==0 already arrived */
        if (valid) {
          LWIP_ASSERT("sanity check", ipr->p != NULL);
  80a8a6:	85 d2                	test   %edx,%edx
  80a8a8:	0f 85 a1 fe ff ff    	jne    80a74f <ip_reass+0x41e>
  80a8ae:	66 90                	xchg   %ax,%ax
  80a8b0:	e9 7e fe ff ff       	jmp    80a733 <ip_reass+0x402>
  /* find the right place to insert this pbuf */
  /* @todo: trim pbufs if fragments are overlapping */
  if (ip_reass_chain_frag_into_datagram_and_validate(ipr, p)) {
    /* the totally last fragment (flag more fragments = 0) was received at least
     * once AND all fragments are received */
    ipr->datagram_len += IP_HLEN;
  80a8b5:	83 c0 14             	add    $0x14,%eax
  80a8b8:	66 89 46 1c          	mov    %ax,0x1c(%esi)

    /* save the second pbuf before copying the header over the pointer */
    r = ((struct ip_reass_helper*)ipr->p->payload)->next_pbuf;
  80a8bc:	8b 46 04             	mov    0x4(%esi),%eax
  80a8bf:	8b 58 04             	mov    0x4(%eax),%ebx
  80a8c2:	8b 3b                	mov    (%ebx),%edi

    /* copy the original ip header back to the first pbuf */
    fraghdr = (struct ip_hdr*)(ipr->p->payload);
    SMEMCPY(fraghdr, &ipr->iphdr, IP_HLEN);
  80a8c4:	c7 44 24 08 14 00 00 	movl   $0x14,0x8(%esp)
  80a8cb:	00 
  80a8cc:	8d 46 08             	lea    0x8(%esi),%eax
  80a8cf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80a8d3:	89 1c 24             	mov    %ebx,(%esp)
  80a8d6:	e8 b6 6a ff ff       	call   801391 <memcpy>
    IPH_LEN_SET(fraghdr, htons(ipr->datagram_len));
  80a8db:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80a8df:	89 04 24             	mov    %eax,(%esp)
  80a8e2:	e8 6d 04 00 00       	call   80ad54 <htons>
  80a8e7:	66 89 43 02          	mov    %ax,0x2(%ebx)
    IPH_OFFSET_SET(fraghdr, 0);
  80a8eb:	66 c7 43 06 00 00    	movw   $0x0,0x6(%ebx)
    IPH_CHKSUM_SET(fraghdr, 0);
  80a8f1:	66 c7 43 0a 00 00    	movw   $0x0,0xa(%ebx)
    /* @todo: do we need to set calculate the correct checksum? */
    IPH_CHKSUM_SET(fraghdr, inet_chksum(fraghdr, IP_HLEN));
  80a8f7:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80a8fe:	00 
  80a8ff:	89 1c 24             	mov    %ebx,(%esp)
  80a902:	e8 33 01 00 00       	call   80aa3a <inet_chksum>
  80a907:	66 89 43 0a          	mov    %ax,0xa(%ebx)

    p = ipr->p;
  80a90b:	8b 4e 04             	mov    0x4(%esi),%ecx
  80a90e:	89 4d e4             	mov    %ecx,-0x1c(%ebp)

    /* chain together the pbufs contained within the reass_data list. */
    while(r != NULL) {
  80a911:	85 ff                	test   %edi,%edi
  80a913:	0f 85 db fe ff ff    	jne    80a7f4 <ip_reass+0x4c3>
  80a919:	e9 04 ff ff ff       	jmp    80a822 <ip_reass+0x4f1>
	...

0080a920 <lwip_standard_chksum>:
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
{
  80a920:	55                   	push   %ebp
  80a921:	89 e5                	mov    %esp,%ebp
  80a923:	57                   	push   %edi
  80a924:	56                   	push   %esi
  80a925:	53                   	push   %ebx
  80a926:	83 ec 2c             	sub    $0x2c,%esp
  u16_t src;
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  80a929:	89 c7                	mov    %eax,%edi
  while (len > 1) {
  80a92b:	b9 00 00 00 00       	mov    $0x0,%ecx
  80a930:	66 83 fa 01          	cmp    $0x1,%dx
  80a934:	76 3a                	jbe    80a970 <lwip_standard_chksum+0x50>
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a936:	83 ea 02             	sub    $0x2,%edx
  80a939:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
  80a93d:	66 d1 ea             	shr    %dx
  80a940:	0f b7 d2             	movzwl %dx,%edx
  80a943:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80a946:	8d 74 50 02          	lea    0x2(%eax,%edx,2),%esi
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
    /* declare first octet as most significant
       thus assume network order, ignoring host order */
    src = (*octetptr) << 8;
  80a94a:	0f b6 18             	movzbl (%eax),%ebx
  80a94d:	c1 e3 08             	shl    $0x8,%ebx
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
  80a950:	0f b6 50 01          	movzbl 0x1(%eax),%edx
  80a954:	09 da                	or     %ebx,%edx
 *
 * @note accumulator size limits summable length to 64k
 * @note host endianess is irrelevant (p3 RFC1071)
 */
static u16_t
lwip_standard_chksum(void *dataptr, u16_t len)
  80a956:	83 c0 02             	add    $0x2,%eax
    src = (*octetptr) << 8;
    octetptr++;
    /* declare second octet as least significant */
    src |= (*octetptr);
    octetptr++;
    acc += src;
  80a959:	0f b7 d2             	movzwl %dx,%edx
  80a95c:	01 d1                	add    %edx,%ecx
  u8_t *octetptr;

  acc = 0;
  /* dataptr may be at odd or even addresses */
  octetptr = (u8_t*)dataptr;
  while (len > 1) {
  80a95e:	39 c6                	cmp    %eax,%esi
  80a960:	75 e8                	jne    80a94a <lwip_standard_chksum+0x2a>
  80a962:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80a965:	8d 7c 47 02          	lea    0x2(%edi,%eax,2),%edi
  80a969:	0f b7 55 e6          	movzwl -0x1a(%ebp),%edx
  80a96d:	83 e2 01             	and    $0x1,%edx
    src |= (*octetptr);
    octetptr++;
    acc += src;
    len -= 2;
  }
  if (len > 0) {
  80a970:	66 85 d2             	test   %dx,%dx
  80a973:	74 0b                	je     80a980 <lwip_standard_chksum+0x60>
    /* accumulate remaining octet */
    src = (*octetptr) << 8;
    acc += src;
  80a975:	0f b6 07             	movzbl (%edi),%eax
  80a978:	c1 e0 08             	shl    $0x8,%eax
  80a97b:	0f b7 c0             	movzwl %ax,%eax
  80a97e:	01 c1                	add    %eax,%ecx
  }
  /* add deferred carry bits */
  acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a980:	89 c8                	mov    %ecx,%eax
  80a982:	c1 e8 10             	shr    $0x10,%eax
  80a985:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a98b:	01 c1                	add    %eax,%ecx
  if ((acc & 0xffff0000) != 0) {
  80a98d:	f7 c1 00 00 ff ff    	test   $0xffff0000,%ecx
  80a993:	74 0d                	je     80a9a2 <lwip_standard_chksum+0x82>
    acc = (acc >> 16) + (acc & 0x0000ffffUL);
  80a995:	89 c8                	mov    %ecx,%eax
  80a997:	c1 e8 10             	shr    $0x10,%eax
  80a99a:	81 e1 ff ff 00 00    	and    $0xffff,%ecx
  80a9a0:	01 c1                	add    %eax,%ecx
  }
  /* This maybe a little confusing: reorder sum using htons()
     instead of ntohs() since it has a little less call overhead.
     The caller must invert bits for Internet sum ! */
  return htons((u16_t)acc);
  80a9a2:	0f b7 c9             	movzwl %cx,%ecx
  80a9a5:	89 0c 24             	mov    %ecx,(%esp)
  80a9a8:	e8 a7 03 00 00       	call   80ad54 <htons>
}
  80a9ad:	83 c4 2c             	add    $0x2c,%esp
  80a9b0:	5b                   	pop    %ebx
  80a9b1:	5e                   	pop    %esi
  80a9b2:	5f                   	pop    %edi
  80a9b3:	5d                   	pop    %ebp
  80a9b4:	c3                   	ret    

0080a9b5 <inet_chksum_pbuf>:
 * @param p pbuf chain over that the checksum should be calculated
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */
u16_t
inet_chksum_pbuf(struct pbuf *p)
{
  80a9b5:	55                   	push   %ebp
  80a9b6:	89 e5                	mov    %esp,%ebp
  80a9b8:	57                   	push   %edi
  80a9b9:	56                   	push   %esi
  80a9ba:	53                   	push   %ebx
  80a9bb:	83 ec 0c             	sub    $0xc,%esp
  80a9be:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80a9c1:	be 00 00 00 00       	mov    $0x0,%esi
  80a9c6:	85 db                	test   %ebx,%ebx
  80a9c8:	74 64                	je     80aa2e <inet_chksum_pbuf+0x79>
  80a9ca:	bf 00 00 00 00       	mov    $0x0,%edi
    acc += LWIP_CHKSUM(q->payload, q->len);
  80a9cf:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80a9d3:	8b 43 04             	mov    0x4(%ebx),%eax
  80a9d6:	e8 45 ff ff ff       	call   80a920 <lwip_standard_chksum>
  80a9db:	0f b7 c0             	movzwl %ax,%eax
  80a9de:	8d 34 30             	lea    (%eax,%esi,1),%esi
    acc = FOLD_U32T(acc);
  80a9e1:	89 f0                	mov    %esi,%eax
  80a9e3:	c1 e8 10             	shr    $0x10,%eax
  80a9e6:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80a9ec:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80a9ee:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80a9f2:	74 1c                	je     80aa10 <inet_chksum_pbuf+0x5b>
      swapped = 1 - swapped;
  80a9f4:	b8 01 00 00 00       	mov    $0x1,%eax
  80a9f9:	89 fa                	mov    %edi,%edx
  80a9fb:	28 d0                	sub    %dl,%al
  80a9fd:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80a9ff:	89 f0                	mov    %esi,%eax
  80aa01:	c1 e0 08             	shl    $0x8,%eax
  80aa04:	25 ff ff 00 00       	and    $0xffff,%eax
  80aa09:	89 f2                	mov    %esi,%edx
  80aa0b:	0f b6 f6             	movzbl %dh,%esi
  80aa0e:	09 c6                	or     %eax,%esi
  struct pbuf *q;
  u8_t swapped;

  acc = 0;
  swapped = 0;
  for(q = p; q != NULL; q = q->next) {
  80aa10:	8b 1b                	mov    (%ebx),%ebx
  80aa12:	85 db                	test   %ebx,%ebx
  80aa14:	75 b9                	jne    80a9cf <inet_chksum_pbuf+0x1a>
  80aa16:	89 f0                	mov    %esi,%eax
      swapped = 1 - swapped;
      acc = SWAP_BYTES_IN_WORD(acc);
    }
  }

  if (swapped) {
  80aa18:	89 fa                	mov    %edi,%edx
  80aa1a:	84 d2                	test   %dl,%dl
  80aa1c:	74 10                	je     80aa2e <inet_chksum_pbuf+0x79>
    acc = SWAP_BYTES_IN_WORD(acc);
  80aa1e:	89 f2                	mov    %esi,%edx
  80aa20:	c1 e2 08             	shl    $0x8,%edx
  80aa23:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80aa29:	0f b6 f4             	movzbl %ah,%esi
  80aa2c:	09 d6                	or     %edx,%esi
  80aa2e:	89 f0                	mov    %esi,%eax
  80aa30:	f7 d0                	not    %eax
  }
  return (u16_t)~(acc & 0xffffUL);
}
  80aa32:	83 c4 0c             	add    $0xc,%esp
  80aa35:	5b                   	pop    %ebx
  80aa36:	5e                   	pop    %esi
  80aa37:	5f                   	pop    %edi
  80aa38:	5d                   	pop    %ebp
  80aa39:	c3                   	ret    

0080aa3a <inet_chksum>:
 * @return checksum (as u16_t) to be saved directly in the protocol header
 */

u16_t
inet_chksum(void *dataptr, u16_t len)
{
  80aa3a:	55                   	push   %ebp
  80aa3b:	89 e5                	mov    %esp,%ebp
  80aa3d:	83 ec 08             	sub    $0x8,%esp
  return ~LWIP_CHKSUM(dataptr, len);
  80aa40:	0f b7 55 0c          	movzwl 0xc(%ebp),%edx
  80aa44:	8b 45 08             	mov    0x8(%ebp),%eax
  80aa47:	e8 d4 fe ff ff       	call   80a920 <lwip_standard_chksum>
  80aa4c:	f7 d0                	not    %eax
}
  80aa4e:	c9                   	leave  
  80aa4f:	c3                   	ret    

0080aa50 <inet_chksum_pseudo>:
 */
u16_t
inet_chksum_pseudo(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len)
{
  80aa50:	55                   	push   %ebp
  80aa51:	89 e5                	mov    %esp,%ebp
  80aa53:	57                   	push   %edi
  80aa54:	56                   	push   %esi
  80aa55:	53                   	push   %ebx
  80aa56:	83 ec 2c             	sub    $0x2c,%esp
  80aa59:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80aa5c:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80aa60:	88 45 e7             	mov    %al,-0x19(%ebp)
  80aa63:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80aa67:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80aa6b:	be 00 00 00 00       	mov    $0x0,%esi
  80aa70:	85 db                	test   %ebx,%ebx
  80aa72:	74 64                	je     80aad8 <inet_chksum_pseudo+0x88>
  80aa74:	bf 00 00 00 00       	mov    $0x0,%edi
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    acc += LWIP_CHKSUM(q->payload, q->len);
  80aa79:	0f b7 53 0a          	movzwl 0xa(%ebx),%edx
  80aa7d:	8b 43 04             	mov    0x4(%ebx),%eax
  80aa80:	e8 9b fe ff ff       	call   80a920 <lwip_standard_chksum>
  80aa85:	0f b7 c0             	movzwl %ax,%eax
  80aa88:	8d 34 30             	lea    (%eax,%esi,1),%esi
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* just executing this next line is probably faster that the if statement needed
       to check whether we really need to execute it, and does no harm */
    acc = FOLD_U32T(acc);
  80aa8b:	89 f0                	mov    %esi,%eax
  80aa8d:	c1 e8 10             	shr    $0x10,%eax
  80aa90:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80aa96:	01 c6                	add    %eax,%esi
    if (q->len % 2 != 0) {
  80aa98:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80aa9c:	74 1c                	je     80aaba <inet_chksum_pseudo+0x6a>
      swapped = 1 - swapped;
  80aa9e:	b8 01 00 00 00       	mov    $0x1,%eax
  80aaa3:	89 fa                	mov    %edi,%edx
  80aaa5:	28 d0                	sub    %dl,%al
  80aaa7:	89 c7                	mov    %eax,%edi
      acc = SWAP_BYTES_IN_WORD(acc);
  80aaa9:	89 f0                	mov    %esi,%eax
  80aaab:	c1 e0 08             	shl    $0x8,%eax
  80aaae:	25 ff ff 00 00       	and    $0xffff,%eax
  80aab3:	89 f2                	mov    %esi,%edx
  80aab5:	0f b6 f6             	movzbl %dh,%esi
  80aab8:	09 c6                	or     %eax,%esi
  u8_t swapped;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; q != NULL; q = q->next) {
  80aaba:	8b 1b                	mov    (%ebx),%ebx
  80aabc:	85 db                	test   %ebx,%ebx
  80aabe:	75 b9                	jne    80aa79 <inet_chksum_pseudo+0x29>
  80aac0:	89 f0                	mov    %esi,%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80aac2:	89 fa                	mov    %edi,%edx
  80aac4:	84 d2                	test   %dl,%dl
  80aac6:	74 10                	je     80aad8 <inet_chksum_pseudo+0x88>
    acc = SWAP_BYTES_IN_WORD(acc);
  80aac8:	89 f2                	mov    %esi,%edx
  80aaca:	c1 e2 08             	shl    $0x8,%edx
  80aacd:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80aad3:	0f b6 f4             	movzbl %ah,%esi
  80aad6:	09 d6                	or     %edx,%esi
  }
  acc += (src->addr & 0xffffUL);
  80aad8:	8b 45 0c             	mov    0xc(%ebp),%eax
  80aadb:	8b 10                	mov    (%eax),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80aadd:	8b 45 10             	mov    0x10(%ebp),%eax
  80aae0:	8b 00                	mov    (%eax),%eax
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80aae2:	89 d1                	mov    %edx,%ecx
  80aae4:	c1 e9 10             	shr    $0x10,%ecx
  80aae7:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80aaed:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  acc += ((src->addr >> 16) & 0xffffUL);
  80aaf0:	0f b7 c8             	movzwl %ax,%ecx
  80aaf3:	01 ca                	add    %ecx,%edx
  acc += (dest->addr & 0xffffUL);
  80aaf5:	c1 e8 10             	shr    $0x10,%eax
  80aaf8:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((dest->addr >> 16) & 0xffffUL);
  80aafb:	8d 34 30             	lea    (%eax,%esi,1),%esi
  acc += (u32_t)htons((u16_t)proto);
  80aafe:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  80ab02:	89 04 24             	mov    %eax,(%esp)
  80ab05:	e8 4a 02 00 00       	call   80ad54 <htons>
  80ab0a:	0f b7 c0             	movzwl %ax,%eax
  80ab0d:	01 c6                	add    %eax,%esi
  acc += (u32_t)htons(proto_len);
  80ab0f:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80ab13:	89 04 24             	mov    %eax,(%esp)
  80ab16:	e8 39 02 00 00       	call   80ad54 <htons>
  80ab1b:	0f b7 c0             	movzwl %ax,%eax
  80ab1e:	01 c6                	add    %eax,%esi

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80ab20:	89 f0                	mov    %esi,%eax
  80ab22:	c1 e8 10             	shr    $0x10,%eax
  80ab25:	81 e6 ff ff 00 00    	and    $0xffff,%esi
  80ab2b:	01 c6                	add    %eax,%esi
  acc = FOLD_U32T(acc);
  80ab2d:	89 f0                	mov    %esi,%eax
  80ab2f:	c1 e8 10             	shr    $0x10,%eax
  80ab32:	8d 04 06             	lea    (%esi,%eax,1),%eax
  80ab35:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80ab37:	83 c4 2c             	add    $0x2c,%esp
  80ab3a:	5b                   	pop    %ebx
  80ab3b:	5e                   	pop    %esi
  80ab3c:	5f                   	pop    %edi
  80ab3d:	5d                   	pop    %ebp
  80ab3e:	c3                   	ret    

0080ab3f <inet_chksum_pseudo_partial>:
 */
u16_t
inet_chksum_pseudo_partial(struct pbuf *p,
       struct ip_addr *src, struct ip_addr *dest,
       u8_t proto, u16_t proto_len, u16_t chksum_len)
{
  80ab3f:	55                   	push   %ebp
  80ab40:	89 e5                	mov    %esp,%ebp
  80ab42:	57                   	push   %edi
  80ab43:	56                   	push   %esi
  80ab44:	53                   	push   %ebx
  80ab45:	83 ec 2c             	sub    $0x2c,%esp
  80ab48:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80ab4b:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  80ab4f:	88 45 e2             	mov    %al,-0x1e(%ebp)
  80ab52:	0f b7 4d 18          	movzwl 0x18(%ebp),%ecx
  80ab56:	66 89 4d e0          	mov    %cx,-0x20(%ebp)
  80ab5a:	0f b7 75 1c          	movzwl 0x1c(%ebp),%esi
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80ab5e:	85 db                	test   %ebx,%ebx
  80ab60:	74 05                	je     80ab67 <inet_chksum_pseudo_partial+0x28>
  80ab62:	66 85 f6             	test   %si,%si
  80ab65:	75 0c                	jne    80ab73 <inet_chksum_pseudo_partial+0x34>
  80ab67:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  80ab6e:	e9 ad 00 00 00       	jmp    80ac20 <inet_chksum_pseudo_partial+0xe1>
  80ab73:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
  80ab77:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
    LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): checksumming pbuf %p (has next %p) \n",
      (void *)q, (void *)q->next));
    chklen = q->len;
  80ab7e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80ab82:	89 f7                	mov    %esi,%edi
  80ab84:	66 39 c6             	cmp    %ax,%si
  80ab87:	76 02                	jbe    80ab8b <inet_chksum_pseudo_partial+0x4c>
  80ab89:	89 c7                	mov    %eax,%edi
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80ab8b:	0f b7 d7             	movzwl %di,%edx
  80ab8e:	8b 43 04             	mov    0x4(%ebx),%eax
  80ab91:	e8 8a fd ff ff       	call   80a920 <lwip_standard_chksum>
    chksum_len -= chklen;
  80ab96:	66 29 fe             	sub    %di,%si
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
  80ab99:	66 81 fe fe 7f       	cmp    $0x7ffe,%si
  80ab9e:	76 1c                	jbe    80abbc <inet_chksum_pseudo_partial+0x7d>
  80aba0:	c7 44 24 08 fd 3e 81 	movl   $0x813efd,0x8(%esp)
  80aba7:	00 
  80aba8:	c7 44 24 04 60 01 00 	movl   $0x160,0x4(%esp)
  80abaf:	00 
  80abb0:	c7 04 24 08 3f 81 00 	movl   $0x813f08,(%esp)
  80abb7:	e8 18 5e ff ff       	call   8009d4 <_panic>
      (void *)q, (void *)q->next));
    chklen = q->len;
    if (chklen > chksum_len) {
      chklen = chksum_len;
    }
    acc += LWIP_CHKSUM(q->payload, chklen);
  80abbc:	0f b7 c0             	movzwl %ax,%eax
  80abbf:	03 45 e4             	add    -0x1c(%ebp),%eax
    chksum_len -= chklen;
    LWIP_ASSERT("delete me", chksum_len < 0x7fff);
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): unwrapped lwip_chksum()=%"X32_F" \n", acc));*/
    /* fold the upper bit down */
    acc = FOLD_U32T(acc);
  80abc2:	89 c2                	mov    %eax,%edx
  80abc4:	c1 ea 10             	shr    $0x10,%edx
  80abc7:	25 ff ff 00 00       	and    $0xffff,%eax
  80abcc:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80abcf:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    if (q->len % 2 != 0) {
  80abd2:	f6 43 0a 01          	testb  $0x1,0xa(%ebx)
  80abd6:	74 1d                	je     80abf5 <inet_chksum_pseudo_partial+0xb6>
      swapped = 1 - swapped;
  80abd8:	b8 01 00 00 00       	mov    $0x1,%eax
  80abdd:	2a 45 e3             	sub    -0x1d(%ebp),%al
  80abe0:	88 45 e3             	mov    %al,-0x1d(%ebp)
      acc = SWAP_BYTES_IN_WORD(acc);
  80abe3:	89 d0                	mov    %edx,%eax
  80abe5:	c1 e0 08             	shl    $0x8,%eax
  80abe8:	25 ff ff 00 00       	and    $0xffff,%eax
  80abed:	0f b6 d6             	movzbl %dh,%edx
  80abf0:	09 c2                	or     %eax,%edx
  80abf2:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  u16_t chklen;

  acc = 0;
  swapped = 0;
  /* iterate through all pbuf in chain */
  for(q = p; (q != NULL) && (chksum_len > 0); q = q->next) {
  80abf5:	8b 1b                	mov    (%ebx),%ebx
  80abf7:	85 db                	test   %ebx,%ebx
  80abf9:	74 09                	je     80ac04 <inet_chksum_pseudo_partial+0xc5>
  80abfb:	66 85 f6             	test   %si,%si
  80abfe:	0f 85 7a ff ff ff    	jne    80ab7e <inet_chksum_pseudo_partial+0x3f>
  80ac04:	8b 45 e4             	mov    -0x1c(%ebp),%eax
      acc = SWAP_BYTES_IN_WORD(acc);
    }
    /*LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): wrapped lwip_chksum()=%"X32_F" \n", acc));*/
  }

  if (swapped) {
  80ac07:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80ac0b:	74 13                	je     80ac20 <inet_chksum_pseudo_partial+0xe1>
    acc = SWAP_BYTES_IN_WORD(acc);
  80ac0d:	89 c2                	mov    %eax,%edx
  80ac0f:	c1 e2 08             	shl    $0x8,%edx
  80ac12:	81 e2 ff ff 00 00    	and    $0xffff,%edx
  80ac18:	0f b6 c4             	movzbl %ah,%eax
  80ac1b:	09 d0                	or     %edx,%eax
  80ac1d:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  acc += (src->addr & 0xffffUL);
  80ac20:	8b 45 0c             	mov    0xc(%ebp),%eax
  80ac23:	8b 00                	mov    (%eax),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  acc += (dest->addr & 0xffffUL);
  80ac25:	8b 55 10             	mov    0x10(%ebp),%edx
  80ac28:	8b 1a                	mov    (%edx),%ebx
  }

  if (swapped) {
    acc = SWAP_BYTES_IN_WORD(acc);
  }
  acc += (src->addr & 0xffffUL);
  80ac2a:	89 c2                	mov    %eax,%edx
  80ac2c:	c1 ea 10             	shr    $0x10,%edx
  80ac2f:	25 ff ff 00 00       	and    $0xffff,%eax
  80ac34:	8d 04 02             	lea    (%edx,%eax,1),%eax
  acc += ((src->addr >> 16) & 0xffffUL);
  80ac37:	0f b7 d3             	movzwl %bx,%edx
  80ac3a:	01 d0                	add    %edx,%eax
  acc += (dest->addr & 0xffffUL);
  80ac3c:	c1 eb 10             	shr    $0x10,%ebx
  80ac3f:	8d 1c 18             	lea    (%eax,%ebx,1),%ebx
  acc += ((dest->addr >> 16) & 0xffffUL);
  80ac42:	03 5d e4             	add    -0x1c(%ebp),%ebx
  acc += (u32_t)htons((u16_t)proto);
  80ac45:	0f b6 45 e2          	movzbl -0x1e(%ebp),%eax
  80ac49:	89 04 24             	mov    %eax,(%esp)
  80ac4c:	e8 03 01 00 00       	call   80ad54 <htons>
  80ac51:	0f b7 c0             	movzwl %ax,%eax
  80ac54:	01 c3                	add    %eax,%ebx
  acc += (u32_t)htons(proto_len);
  80ac56:	0f b7 45 e0          	movzwl -0x20(%ebp),%eax
  80ac5a:	89 04 24             	mov    %eax,(%esp)
  80ac5d:	e8 f2 00 00 00       	call   80ad54 <htons>
  80ac62:	0f b7 c0             	movzwl %ax,%eax
  80ac65:	01 c3                	add    %eax,%ebx

  /* Fold 32-bit sum to 16 bits
     calling this twice is propably faster than if statements... */
  acc = FOLD_U32T(acc);
  80ac67:	89 d8                	mov    %ebx,%eax
  80ac69:	c1 e8 10             	shr    $0x10,%eax
  80ac6c:	81 e3 ff ff 00 00    	and    $0xffff,%ebx
  80ac72:	8d 04 03             	lea    (%ebx,%eax,1),%eax
  acc = FOLD_U32T(acc);
  80ac75:	89 c2                	mov    %eax,%edx
  80ac77:	c1 ea 10             	shr    $0x10,%edx
  80ac7a:	01 d0                	add    %edx,%eax
  80ac7c:	f7 d0                	not    %eax
  LWIP_DEBUGF(INET_DEBUG, ("inet_chksum_pseudo(): pbuf chain lwip_chksum()=%"X32_F"\n", acc));
  return (u16_t)~(acc & 0xffffUL);
}
  80ac7e:	83 c4 2c             	add    $0x2c,%esp
  80ac81:	5b                   	pop    %ebx
  80ac82:	5e                   	pop    %esi
  80ac83:	5f                   	pop    %edi
  80ac84:	5d                   	pop    %ebp
  80ac85:	c3                   	ret    
	...

0080ac90 <inet_ntoa>:
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
{
  80ac90:	55                   	push   %ebp
  80ac91:	89 e5                	mov    %esp,%ebp
  80ac93:	57                   	push   %edi
  80ac94:	56                   	push   %esi
  80ac95:	53                   	push   %ebx
  80ac96:	83 ec 1c             	sub    $0x1c,%esp
  static char str[16];
  u32_t s_addr = addr.s_addr;
  80ac99:	8b 45 08             	mov    0x8(%ebp),%eax
  80ac9c:	89 45 f0             	mov    %eax,-0x10(%ebp)
  u8_t rem;
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  80ac9f:	8d 45 f0             	lea    -0x10(%ebp),%eax
  80aca2:	89 45 e0             	mov    %eax,-0x20(%ebp)
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80aca5:	8d 45 f3             	lea    -0xd(%ebp),%eax
  80aca8:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80acab:	b9 bc 8d b3 00       	mov    $0xb38dbc,%ecx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80acb0:	ba cd ff ff ff       	mov    $0xffffffcd,%edx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80acb5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80acb8:	0f b6 18             	movzbl (%eax),%ebx
  80acbb:	be 00 00 00 00       	mov    $0x0,%esi
  80acc0:	89 f0                	mov    %esi,%eax
  80acc2:	89 ce                	mov    %ecx,%esi
  80acc4:	89 c1                	mov    %eax,%ecx
  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
    i = 0;
    do {
      rem = *ap % (u8_t)10;
  80acc6:	89 d8                	mov    %ebx,%eax
  80acc8:	f6 e2                	mul    %dl
  80acca:	66 c1 e8 08          	shr    $0x8,%ax
  80acce:	c0 e8 03             	shr    $0x3,%al
  80acd1:	89 c7                	mov    %eax,%edi
  80acd3:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80acd6:	01 c0                	add    %eax,%eax
  80acd8:	28 c3                	sub    %al,%bl
  80acda:	89 d8                	mov    %ebx,%eax
      *ap /= (u8_t)10;
  80acdc:	89 fb                	mov    %edi,%ebx
      inv[i++] = '0' + rem;
  80acde:	0f b6 f9             	movzbl %cl,%edi
  80ace1:	83 c0 30             	add    $0x30,%eax
  80ace4:	88 44 3d ed          	mov    %al,-0x13(%ebp,%edi,1)
  80ace8:	83 c1 01             	add    $0x1,%ecx
    } while(*ap);
  80aceb:	84 db                	test   %bl,%bl
  80aced:	75 d7                	jne    80acc6 <inet_ntoa+0x36>
  80acef:	89 c8                	mov    %ecx,%eax
  80acf1:	89 f1                	mov    %esi,%ecx
  80acf3:	89 c6                	mov    %eax,%esi
  80acf5:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80acf8:	88 18                	mov    %bl,(%eax)
    while(i--)
  80acfa:	89 f0                	mov    %esi,%eax
  80acfc:	84 c0                	test   %al,%al
  80acfe:	74 2c                	je     80ad2c <inet_ntoa+0x9c>
  80ad00:	8d 5e ff             	lea    -0x1(%esi),%ebx
 * @param addr ip address in network order to convert
 * @return pointer to a global static (!) buffer that holds the ASCII
 *         represenation of addr
 */
char *
inet_ntoa(struct in_addr addr)
  80ad03:	0f b6 c3             	movzbl %bl,%eax
  80ad06:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80ad09:	8d 7c 01 01          	lea    0x1(%ecx,%eax,1),%edi
  80ad0d:	89 c8                	mov    %ecx,%eax
  80ad0f:	89 ce                	mov    %ecx,%esi
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
  80ad11:	0f b6 cb             	movzbl %bl,%ecx
  80ad14:	0f b6 4c 0d ed       	movzbl -0x13(%ebp,%ecx,1),%ecx
  80ad19:	88 08                	mov    %cl,(%eax)
  80ad1b:	83 c0 01             	add    $0x1,%eax
    do {
      rem = *ap % (u8_t)10;
      *ap /= (u8_t)10;
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
  80ad1e:	83 eb 01             	sub    $0x1,%ebx
  80ad21:	39 f8                	cmp    %edi,%eax
  80ad23:	75 ec                	jne    80ad11 <inet_ntoa+0x81>
  80ad25:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ad28:	8d 4c 06 01          	lea    0x1(%esi,%eax,1),%ecx
      *rp++ = inv[i];
    *rp++ = '.';
  80ad2c:	c6 01 2e             	movb   $0x2e,(%ecx)
  80ad2f:	83 c1 01             	add    $0x1,%ecx
  u8_t n;
  u8_t i;

  rp = str;
  ap = (u8_t *)&s_addr;
  for(n = 0; n < 4; n++) {
  80ad32:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80ad35:	39 45 e0             	cmp    %eax,-0x20(%ebp)
  80ad38:	74 09                	je     80ad43 <inet_ntoa+0xb3>
      inv[i++] = '0' + rem;
    } while(*ap);
    while(i--)
      *rp++ = inv[i];
    *rp++ = '.';
    ap++;
  80ad3a:	83 45 e0 01          	addl   $0x1,-0x20(%ebp)
  80ad3e:	e9 72 ff ff ff       	jmp    80acb5 <inet_ntoa+0x25>
  }
  *--rp = 0;
  80ad43:	c6 41 ff 00          	movb   $0x0,-0x1(%ecx)
  return str;
}
  80ad47:	b8 bc 8d b3 00       	mov    $0xb38dbc,%eax
  80ad4c:	83 c4 1c             	add    $0x1c,%esp
  80ad4f:	5b                   	pop    %ebx
  80ad50:	5e                   	pop    %esi
  80ad51:	5f                   	pop    %edi
  80ad52:	5d                   	pop    %ebp
  80ad53:	c3                   	ret    

0080ad54 <htons>:
 * @param n u16_t in host byte order
 * @return n in network byte order
 */
u16_t
htons(u16_t n)
{
  80ad54:	55                   	push   %ebp
  80ad55:	89 e5                	mov    %esp,%ebp
  80ad57:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80ad5b:	66 c1 c0 08          	rol    $0x8,%ax
  return ((n & 0xff) << 8) | ((n & 0xff00) >> 8);
}
  80ad5f:	5d                   	pop    %ebp
  80ad60:	c3                   	ret    

0080ad61 <ntohs>:
 * @param n u16_t in network byte order
 * @return n in host byte order
 */
u16_t
ntohs(u16_t n)
{
  80ad61:	55                   	push   %ebp
  80ad62:	89 e5                	mov    %esp,%ebp
  80ad64:	83 ec 04             	sub    $0x4,%esp
  return htons(n);
  80ad67:	0f b7 45 08          	movzwl 0x8(%ebp),%eax
  80ad6b:	89 04 24             	mov    %eax,(%esp)
  80ad6e:	e8 e1 ff ff ff       	call   80ad54 <htons>
}
  80ad73:	c9                   	leave  
  80ad74:	c3                   	ret    

0080ad75 <htonl>:
 * @param n u32_t in host byte order
 * @return n in network byte order
 */
u32_t
htonl(u32_t n)
{
  80ad75:	55                   	push   %ebp
  80ad76:	89 e5                	mov    %esp,%ebp
  80ad78:	8b 55 08             	mov    0x8(%ebp),%edx
  80ad7b:	89 d1                	mov    %edx,%ecx
  80ad7d:	c1 e9 18             	shr    $0x18,%ecx
  80ad80:	89 d0                	mov    %edx,%eax
  80ad82:	c1 e0 18             	shl    $0x18,%eax
  80ad85:	09 c8                	or     %ecx,%eax
  80ad87:	89 d1                	mov    %edx,%ecx
  80ad89:	81 e1 00 ff 00 00    	and    $0xff00,%ecx
  80ad8f:	c1 e1 08             	shl    $0x8,%ecx
  80ad92:	09 c8                	or     %ecx,%eax
  80ad94:	81 e2 00 00 ff 00    	and    $0xff0000,%edx
  80ad9a:	c1 ea 08             	shr    $0x8,%edx
  80ad9d:	09 d0                	or     %edx,%eax
  return ((n & 0xff) << 24) |
    ((n & 0xff00) << 8) |
    ((n & 0xff0000UL) >> 8) |
    ((n & 0xff000000UL) >> 24);
}
  80ad9f:	5d                   	pop    %ebp
  80ada0:	c3                   	ret    

0080ada1 <inet_aton>:
 * @param addr pointer to which to save the ip address in network order
 * @return 1 if cp could be converted to addr, 0 on failure
 */
int
inet_aton(const char *cp, struct in_addr *addr)
{
  80ada1:	55                   	push   %ebp
  80ada2:	89 e5                	mov    %esp,%ebp
  80ada4:	57                   	push   %edi
  80ada5:	56                   	push   %esi
  80ada6:	53                   	push   %ebx
  80ada7:	83 ec 28             	sub    $0x28,%esp
  80adaa:	8b 45 08             	mov    0x8(%ebp),%eax
  u32_t val;
  int base, n, c;
  u32_t parts[4];
  u32_t *pp = parts;

  c = *cp;
  80adad:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80adb0:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80adb3:	80 f9 09             	cmp    $0x9,%cl
  80adb6:	0f 87 af 01 00 00    	ja     80af6b <inet_aton+0x1ca>
  80adbc:	8d 4d e4             	lea    -0x1c(%ebp),%ecx
  80adbf:	89 4d d8             	mov    %ecx,-0x28(%ebp)
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80adc2:	8d 5d f0             	lea    -0x10(%ebp),%ebx
  80adc5:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
     */
    if (!isdigit(c))
      return (0);
    val = 0;
    base = 10;
    if (c == '0') {
  80adc8:	c7 45 e0 0a 00 00 00 	movl   $0xa,-0x20(%ebp)
  80adcf:	83 fa 30             	cmp    $0x30,%edx
  80add2:	75 24                	jne    80adf8 <inet_aton+0x57>
      c = *++cp;
  80add4:	83 c0 01             	add    $0x1,%eax
  80add7:	0f be 10             	movsbl (%eax),%edx
      if (c == 'x' || c == 'X') {
  80adda:	83 fa 78             	cmp    $0x78,%edx
  80addd:	74 0c                	je     80adeb <inet_aton+0x4a>
  80addf:	c7 45 e0 08 00 00 00 	movl   $0x8,-0x20(%ebp)
  80ade6:	83 fa 58             	cmp    $0x58,%edx
  80ade9:	75 0d                	jne    80adf8 <inet_aton+0x57>
        base = 16;
        c = *++cp;
  80adeb:	83 c0 01             	add    $0x1,%eax
  80adee:	0f be 10             	movsbl (%eax),%edx
  80adf1:	c7 45 e0 10 00 00 00 	movl   $0x10,-0x20(%ebp)
  80adf8:	83 c0 01             	add    $0x1,%eax
  80adfb:	be 00 00 00 00       	mov    $0x0,%esi
  80ae00:	eb 03                	jmp    80ae05 <inet_aton+0x64>
  80ae02:	83 c0 01             	add    $0x1,%eax
  80ae05:	8d 78 ff             	lea    -0x1(%eax),%edi
      } else
        base = 8;
    }
    for (;;) {
      if (isdigit(c)) {
  80ae08:	89 d1                	mov    %edx,%ecx
  80ae0a:	8d 59 d0             	lea    -0x30(%ecx),%ebx
  80ae0d:	80 fb 09             	cmp    $0x9,%bl
  80ae10:	77 0d                	ja     80ae1f <inet_aton+0x7e>
        val = (val * base) + (int)(c - '0');
  80ae12:	0f af 75 e0          	imul   -0x20(%ebp),%esi
  80ae16:	8d 74 32 d0          	lea    -0x30(%edx,%esi,1),%esi
        c = *++cp;
  80ae1a:	0f be 10             	movsbl (%eax),%edx
  80ae1d:	eb e3                	jmp    80ae02 <inet_aton+0x61>
      } else if (base == 16 && isxdigit(c)) {
  80ae1f:	83 7d e0 10          	cmpl   $0x10,-0x20(%ebp)
  80ae23:	75 2b                	jne    80ae50 <inet_aton+0xaf>
  80ae25:	8d 59 9f             	lea    -0x61(%ecx),%ebx
  80ae28:	88 5d d3             	mov    %bl,-0x2d(%ebp)
  80ae2b:	80 fb 05             	cmp    $0x5,%bl
  80ae2e:	76 08                	jbe    80ae38 <inet_aton+0x97>
  80ae30:	8d 59 bf             	lea    -0x41(%ecx),%ebx
  80ae33:	80 fb 05             	cmp    $0x5,%bl
  80ae36:	77 18                	ja     80ae50 <inet_aton+0xaf>
        val = (val << 4) | (int)(c + 10 - (islower(c) ? 'a' : 'A'));
  80ae38:	80 7d d3 1a          	cmpb   $0x1a,-0x2d(%ebp)
  80ae3c:	19 c9                	sbb    %ecx,%ecx
  80ae3e:	83 e1 20             	and    $0x20,%ecx
  80ae41:	c1 e6 04             	shl    $0x4,%esi
  80ae44:	29 ca                	sub    %ecx,%edx
  80ae46:	8d 52 c9             	lea    -0x37(%edx),%edx
  80ae49:	09 d6                	or     %edx,%esi
        c = *++cp;
  80ae4b:	0f be 10             	movsbl (%eax),%edx
  80ae4e:	eb b2                	jmp    80ae02 <inet_aton+0x61>
      } else
        break;
    }
    if (c == '.') {
  80ae50:	83 fa 2e             	cmp    $0x2e,%edx
  80ae53:	75 2c                	jne    80ae81 <inet_aton+0xe0>
       * Internet format:
       *  a.b.c.d
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
  80ae55:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80ae58:	39 55 d8             	cmp    %edx,-0x28(%ebp)
  80ae5b:	0f 83 0a 01 00 00    	jae    80af6b <inet_aton+0x1ca>
        return (0);
      *pp++ = val;
  80ae61:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80ae64:	89 31                	mov    %esi,(%ecx)
      c = *++cp;
  80ae66:	8d 47 01             	lea    0x1(%edi),%eax
  80ae69:	0f be 10             	movsbl (%eax),%edx
    /*
     * Collect number up to ``.''.
     * Values are specified as for C:
     * 0x=hex, 0=octal, 1-9=decimal.
     */
    if (!isdigit(c))
  80ae6c:	8d 4a d0             	lea    -0x30(%edx),%ecx
  80ae6f:	80 f9 09             	cmp    $0x9,%cl
  80ae72:	0f 87 f3 00 00 00    	ja     80af6b <inet_aton+0x1ca>
       *  a.b.c   (with c treated as 16 bits)
       *  a.b (with b treated as 24 bits)
       */
      if (pp >= parts + 3)
        return (0);
      *pp++ = val;
  80ae78:	83 45 d8 04          	addl   $0x4,-0x28(%ebp)
  80ae7c:	e9 47 ff ff ff       	jmp    80adc8 <inet_aton+0x27>
  80ae81:	89 f3                	mov    %esi,%ebx
  80ae83:	89 f0                	mov    %esi,%eax
      break;
  }
  /*
   * Check for trailing characters.
   */
  if (c != '\0' && (!isprint(c) || !isspace(c)))
  80ae85:	85 d2                	test   %edx,%edx
  80ae87:	74 37                	je     80aec0 <inet_aton+0x11f>
  80ae89:	80 f9 1f             	cmp    $0x1f,%cl
  80ae8c:	0f 86 d9 00 00 00    	jbe    80af6b <inet_aton+0x1ca>
  80ae92:	84 d2                	test   %dl,%dl
  80ae94:	0f 88 d1 00 00 00    	js     80af6b <inet_aton+0x1ca>
  80ae9a:	83 fa 20             	cmp    $0x20,%edx
  80ae9d:	8d 76 00             	lea    0x0(%esi),%esi
  80aea0:	74 1e                	je     80aec0 <inet_aton+0x11f>
  80aea2:	83 fa 0c             	cmp    $0xc,%edx
  80aea5:	74 19                	je     80aec0 <inet_aton+0x11f>
  80aea7:	83 fa 0a             	cmp    $0xa,%edx
  80aeaa:	74 14                	je     80aec0 <inet_aton+0x11f>
  80aeac:	83 fa 0d             	cmp    $0xd,%edx
  80aeaf:	90                   	nop
  80aeb0:	74 0e                	je     80aec0 <inet_aton+0x11f>
  80aeb2:	83 fa 09             	cmp    $0x9,%edx
  80aeb5:	74 09                	je     80aec0 <inet_aton+0x11f>
  80aeb7:	83 fa 0b             	cmp    $0xb,%edx
  80aeba:	0f 85 ab 00 00 00    	jne    80af6b <inet_aton+0x1ca>
  /*
   * Concoct the address according to
   * the number of parts specified.
   */
  n = pp - parts + 1;
  switch (n) {
  80aec0:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80aec3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80aec6:	29 d1                	sub    %edx,%ecx
  80aec8:	89 ca                	mov    %ecx,%edx
  80aeca:	c1 fa 02             	sar    $0x2,%edx
  80aecd:	83 c2 01             	add    $0x1,%edx
  80aed0:	83 fa 02             	cmp    $0x2,%edx
  80aed3:	74 2d                	je     80af02 <inet_aton+0x161>
  80aed5:	83 fa 02             	cmp    $0x2,%edx
  80aed8:	7f 10                	jg     80aeea <inet_aton+0x149>
  80aeda:	85 d2                	test   %edx,%edx
  80aedc:	0f 84 89 00 00 00    	je     80af6b <inet_aton+0x1ca>
  80aee2:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80aee8:	eb 62                	jmp    80af4c <inet_aton+0x1ab>
  80aeea:	83 fa 03             	cmp    $0x3,%edx
  80aeed:	8d 76 00             	lea    0x0(%esi),%esi
  80aef0:	74 22                	je     80af14 <inet_aton+0x173>
  80aef2:	83 fa 04             	cmp    $0x4,%edx
  80aef5:	8d 76 00             	lea    0x0(%esi),%esi
  80aef8:	75 52                	jne    80af4c <inet_aton+0x1ab>
  80aefa:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80af00:	eb 2b                	jmp    80af2d <inet_aton+0x18c>

  case 1:             /* a -- 32 bits */
    break;

  case 2:             /* a.b -- 8.24 bits */
    if (val > 0xffffffUL)
  80af02:	3d ff ff ff 00       	cmp    $0xffffff,%eax
  80af07:	90                   	nop
  80af08:	77 61                	ja     80af6b <inet_aton+0x1ca>
      return (0);
    val |= parts[0] << 24;
  80af0a:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  80af0d:	c1 e3 18             	shl    $0x18,%ebx
  80af10:	09 c3                	or     %eax,%ebx
    break;
  80af12:	eb 38                	jmp    80af4c <inet_aton+0x1ab>

  case 3:             /* a.b.c -- 8.8.16 bits */
    if (val > 0xffff)
  80af14:	3d ff ff 00 00       	cmp    $0xffff,%eax
  80af19:	77 50                	ja     80af6b <inet_aton+0x1ca>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16);
  80af1b:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80af1e:	c1 e3 10             	shl    $0x10,%ebx
  80af21:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80af24:	c1 e2 18             	shl    $0x18,%edx
  80af27:	09 d3                	or     %edx,%ebx
  80af29:	09 c3                	or     %eax,%ebx
    break;
  80af2b:	eb 1f                	jmp    80af4c <inet_aton+0x1ab>

  case 4:             /* a.b.c.d -- 8.8.8.8 bits */
    if (val > 0xff)
  80af2d:	3d ff 00 00 00       	cmp    $0xff,%eax
  80af32:	77 37                	ja     80af6b <inet_aton+0x1ca>
      return (0);
    val |= (parts[0] << 24) | (parts[1] << 16) | (parts[2] << 8);
  80af34:	8b 5d e8             	mov    -0x18(%ebp),%ebx
  80af37:	c1 e3 10             	shl    $0x10,%ebx
  80af3a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80af3d:	c1 e2 18             	shl    $0x18,%edx
  80af40:	09 d3                	or     %edx,%ebx
  80af42:	8b 55 ec             	mov    -0x14(%ebp),%edx
  80af45:	c1 e2 08             	shl    $0x8,%edx
  80af48:	09 d3                	or     %edx,%ebx
  80af4a:	09 c3                	or     %eax,%ebx
    break;
  }
  if (addr)
  80af4c:	b8 01 00 00 00       	mov    $0x1,%eax
  80af51:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80af55:	74 19                	je     80af70 <inet_aton+0x1cf>
    addr->s_addr = htonl(val);
  80af57:	89 1c 24             	mov    %ebx,(%esp)
  80af5a:	e8 16 fe ff ff       	call   80ad75 <htonl>
  80af5f:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  80af62:	89 03                	mov    %eax,(%ebx)
  80af64:	b8 01 00 00 00       	mov    $0x1,%eax
  80af69:	eb 05                	jmp    80af70 <inet_aton+0x1cf>
  80af6b:	b8 00 00 00 00       	mov    $0x0,%eax
  return (1);
}
  80af70:	83 c4 28             	add    $0x28,%esp
  80af73:	5b                   	pop    %ebx
  80af74:	5e                   	pop    %esi
  80af75:	5f                   	pop    %edi
  80af76:	5d                   	pop    %ebp
  80af77:	c3                   	ret    

0080af78 <inet_addr>:
 * @param cp IP address in ascii represenation (e.g. "127.0.0.1")
 * @return ip address in network order
 */
u32_t
inet_addr(const char *cp)
{
  80af78:	55                   	push   %ebp
  80af79:	89 e5                	mov    %esp,%ebp
  80af7b:	83 ec 18             	sub    $0x18,%esp
  struct in_addr val;

  if (inet_aton(cp, &val)) {
  80af7e:	8d 45 fc             	lea    -0x4(%ebp),%eax
  80af81:	89 44 24 04          	mov    %eax,0x4(%esp)
  80af85:	8b 45 08             	mov    0x8(%ebp),%eax
  80af88:	89 04 24             	mov    %eax,(%esp)
  80af8b:	e8 11 fe ff ff       	call   80ada1 <inet_aton>
  80af90:	83 f8 01             	cmp    $0x1,%eax
  80af93:	19 c0                	sbb    %eax,%eax
  80af95:	0b 45 fc             	or     -0x4(%ebp),%eax
    return (val.s_addr);
  }
  return (INADDR_NONE);
}
  80af98:	c9                   	leave  
  80af99:	c3                   	ret    

0080af9a <ntohl>:
 * @param n u32_t in network byte order
 * @return n in host byte order
 */
u32_t
ntohl(u32_t n)
{
  80af9a:	55                   	push   %ebp
  80af9b:	89 e5                	mov    %esp,%ebp
  80af9d:	83 ec 04             	sub    $0x4,%esp
  return htonl(n);
  80afa0:	8b 45 08             	mov    0x8(%ebp),%eax
  80afa3:	89 04 24             	mov    %eax,(%esp)
  80afa6:	e8 ca fd ff ff       	call   80ad75 <htonl>
}
  80afab:	c9                   	leave  
  80afac:	c3                   	ret    
  80afad:	00 00                	add    %al,(%eax)
	...

0080afb0 <tcp_zero_window_probe>:
 *
 * @param pcb the tcp_pcb for which to send a zero-window probe packet
 */
void
tcp_zero_window_probe(struct tcp_pcb *pcb)
{
  80afb0:	55                   	push   %ebp
  80afb1:	89 e5                	mov    %esp,%ebp
  80afb3:	57                   	push   %edi
  80afb4:	56                   	push   %esi
  80afb5:	53                   	push   %ebx
  80afb6:	83 ec 3c             	sub    $0x3c,%esp
  80afb9:	8b 75 08             	mov    0x8(%ebp),%esi
  LWIP_DEBUGF(TCP_DEBUG, 
              ("tcp_zero_window_probe: tcp_ticks %"U32_F
               "   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
               tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));

  seg = pcb->unacked;
  80afbc:	8b 46 78             	mov    0x78(%esi),%eax
  80afbf:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  if(seg == NULL)
  80afc2:	85 c0                	test   %eax,%eax
  80afc4:	75 0e                	jne    80afd4 <tcp_zero_window_probe+0x24>
    seg = pcb->unsent;
  80afc6:	8b 56 74             	mov    0x74(%esi),%edx
  80afc9:	89 55 e4             	mov    %edx,-0x1c(%ebp)

  if(seg == NULL)
  80afcc:	85 d2                	test   %edx,%edx
  80afce:	0f 84 4b 01 00 00    	je     80b11f <tcp_zero_window_probe+0x16f>
    return;

  p = pbuf_alloc(PBUF_IP, TCP_HLEN + 1, PBUF_RAM);
  80afd4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80afdb:	00 
  80afdc:	c7 44 24 04 15 00 00 	movl   $0x15,0x4(%esp)
  80afe3:	00 
  80afe4:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80afeb:	e8 23 d2 ff ff       	call   808213 <pbuf_alloc>
  80aff0:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80aff2:	85 c0                	test   %eax,%eax
  80aff4:	0f 84 25 01 00 00    	je     80b11f <tcp_zero_window_probe+0x16f>
    LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: no memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80affa:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80afff:	77 1c                	ja     80b01d <tcp_zero_window_probe+0x6d>
  80b001:	c7 44 24 08 2c 3f 81 	movl   $0x813f2c,0x8(%esp)
  80b008:	00 
  80b009:	c7 44 24 04 8d 03 00 	movl   $0x38d,0x4(%esp)
  80b010:	00 
  80b011:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80b018:	e8 b7 59 ff ff       	call   8009d4 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b01d:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80b020:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b024:	89 04 24             	mov    %eax,(%esp)
  80b027:	e8 28 fd ff ff       	call   80ad54 <htons>
  80b02c:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80b02f:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b033:	89 04 24             	mov    %eax,(%esp)
  80b036:	e8 19 fd ff ff       	call   80ad54 <htons>
  80b03b:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = seg->tcphdr->seqno;
  80b03f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b042:	8b 41 10             	mov    0x10(%ecx),%eax
  80b045:	8b 40 04             	mov    0x4(%eax),%eax
  80b048:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b04b:	8b 46 24             	mov    0x24(%esi),%eax
  80b04e:	89 04 24             	mov    %eax,(%esp)
  80b051:	e8 1f fd ff ff       	call   80ad75 <htonl>
  80b056:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80b059:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b05d:	89 04 24             	mov    %eax,(%esp)
  80b060:	e8 fc fc ff ff       	call   80ad61 <ntohs>
  80b065:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b06a:	89 04 24             	mov    %eax,(%esp)
  80b06d:	e8 e2 fc ff ff       	call   80ad54 <htons>
  80b072:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b076:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b07a:	89 04 24             	mov    %eax,(%esp)
  80b07d:	e8 d2 fc ff ff       	call   80ad54 <htons>
  80b082:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b086:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b08c:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b090:	89 04 24             	mov    %eax,(%esp)
  80b093:	e8 c9 fc ff ff       	call   80ad61 <ntohs>
  80b098:	83 e0 3f             	and    $0x3f,%eax
  80b09b:	80 cc 50             	or     $0x50,%ah
  80b09e:	89 04 24             	mov    %eax,(%esp)
  80b0a1:	e8 ae fc ff ff       	call   80ad54 <htons>
  80b0a6:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  /* Copy in one byte from the head of the unacked queue */
  *((char *)p->payload + sizeof(struct tcp_hdr)) = *(char *)seg->dataptr;
  80b0aa:	8b 47 04             	mov    0x4(%edi),%eax
  80b0ad:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b0b0:	8b 51 08             	mov    0x8(%ecx),%edx
  80b0b3:	0f b6 12             	movzbl (%edx),%edx
  80b0b6:	88 50 14             	mov    %dl,0x14(%eax)

  tcphdr->chksum = 0;
  80b0b9:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b0bf:	8d 46 04             	lea    0x4(%esi),%eax
  80b0c2:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b0c5:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b0c9:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b0cd:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b0d4:	00 
  80b0d5:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b0d8:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b0dc:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b0e0:	89 3c 24             	mov    %edi,(%esp)
  80b0e3:	e8 68 f9 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80b0e8:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b0ec:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b0f3:	00 
  80b0f4:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b0fb:	00 
  80b0fc:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b100:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b104:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80b107:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80b10b:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b10f:	89 3c 24             	mov    %edi,(%esp)
  80b112:	e8 86 ea ff ff       	call   809b9d <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b117:	89 3c 24             	mov    %edi,(%esp)
  80b11a:	e8 39 ce ff ff       	call   807f58 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_zero_window_probe: seqno %"U32_F
                          " ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b11f:	83 c4 3c             	add    $0x3c,%esp
  80b122:	5b                   	pop    %ebx
  80b123:	5e                   	pop    %esi
  80b124:	5f                   	pop    %edi
  80b125:	5d                   	pop    %ebp
  80b126:	c3                   	ret    

0080b127 <tcp_keepalive>:
 *
 * @param pcb the tcp_pcb for which to send a keepalive packet
 */
void
tcp_keepalive(struct tcp_pcb *pcb)
{
  80b127:	55                   	push   %ebp
  80b128:	89 e5                	mov    %esp,%ebp
  80b12a:	57                   	push   %edi
  80b12b:	56                   	push   %esi
  80b12c:	53                   	push   %ebx
  80b12d:	83 ec 3c             	sub    $0x3c,%esp
  80b130:	8b 75 08             	mov    0x8(%ebp),%esi
                          ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip)));

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: tcp_ticks %"U32_F"   pcb->tmr %"U32_F" pcb->keep_cnt_sent %"U16_F"\n", 
                          tcp_ticks, pcb->tmr, pcb->keep_cnt_sent));
   
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b133:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b13a:	00 
  80b13b:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b142:	00 
  80b143:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b14a:	e8 c4 d0 ff ff       	call   808213 <pbuf_alloc>
  80b14f:	89 c7                	mov    %eax,%edi
   
  if(p == NULL) {
  80b151:	85 c0                	test   %eax,%eax
  80b153:	0f 84 1b 01 00 00    	je     80b274 <tcp_keepalive+0x14d>
    LWIP_DEBUGF(TCP_DEBUG, 
                ("tcp_keepalive: could not allocate memory for pbuf\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b159:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b15e:	77 1c                	ja     80b17c <tcp_keepalive+0x55>
  80b160:	c7 44 24 08 2c 3f 81 	movl   $0x813f2c,0x8(%esp)
  80b167:	00 
  80b168:	c7 44 24 04 3a 03 00 	movl   $0x33a,0x4(%esp)
  80b16f:	00 
  80b170:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80b177:	e8 58 58 ff ff       	call   8009d4 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b17c:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(pcb->local_port);
  80b17f:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b183:	89 04 24             	mov    %eax,(%esp)
  80b186:	e8 c9 fb ff ff       	call   80ad54 <htons>
  80b18b:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(pcb->remote_port);
  80b18e:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b192:	89 04 24             	mov    %eax,(%esp)
  80b195:	e8 ba fb ff ff       	call   80ad54 <htons>
  80b19a:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(pcb->snd_nxt - 1);
  80b19e:	8b 46 54             	mov    0x54(%esi),%eax
  80b1a1:	83 e8 01             	sub    $0x1,%eax
  80b1a4:	89 04 24             	mov    %eax,(%esp)
  80b1a7:	e8 c9 fb ff ff       	call   80ad75 <htonl>
  80b1ac:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b1af:	8b 46 24             	mov    0x24(%esi),%eax
  80b1b2:	89 04 24             	mov    %eax,(%esp)
  80b1b5:	e8 bb fb ff ff       	call   80ad75 <htonl>
  80b1ba:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, 0);
  80b1bd:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b1c1:	89 04 24             	mov    %eax,(%esp)
  80b1c4:	e8 98 fb ff ff       	call   80ad61 <ntohs>
  80b1c9:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b1ce:	89 04 24             	mov    %eax,(%esp)
  80b1d1:	e8 7e fb ff ff       	call   80ad54 <htons>
  80b1d6:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b1da:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b1de:	89 04 24             	mov    %eax,(%esp)
  80b1e1:	e8 6e fb ff ff       	call   80ad54 <htons>
  80b1e6:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b1ea:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b1f0:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b1f4:	89 04 24             	mov    %eax,(%esp)
  80b1f7:	e8 65 fb ff ff       	call   80ad61 <ntohs>
  80b1fc:	83 e0 3f             	and    $0x3f,%eax
  80b1ff:	80 cc 50             	or     $0x50,%ah
  80b202:	89 04 24             	mov    %eax,(%esp)
  80b205:	e8 4a fb ff ff       	call   80ad54 <htons>
  80b20a:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b20e:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, &pcb->local_ip, &pcb->remote_ip,
  80b214:	8d 46 04             	lea    0x4(%esi),%eax
  80b217:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80b21a:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b21e:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b222:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b229:	00 
  80b22a:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b22d:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b231:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b235:	89 3c 24             	mov    %edi,(%esp)
  80b238:	e8 13 f8 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80b23d:	66 89 43 10          	mov    %ax,0x10(%ebx)
                   0, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(p, &pcb->local_ip, &pcb->remote_ip, pcb->ttl, 0, IP_PROTO_TCP);
  80b241:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b248:	00 
  80b249:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b250:	00 
  80b251:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b255:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b259:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b25c:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b260:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b264:	89 3c 24             	mov    %edi,(%esp)
  80b267:	e8 31 e9 ff ff       	call   809b9d <ip_output>
#endif /* LWIP_NETIF_HWADDRHINT*/

  pbuf_free(p);
  80b26c:	89 3c 24             	mov    %edi,(%esp)
  80b26f:	e8 e4 cc ff ff       	call   807f58 <pbuf_free>

  LWIP_DEBUGF(TCP_DEBUG, ("tcp_keepalive: seqno %"U32_F" ackno %"U32_F".\n",
                          pcb->snd_nxt - 1, pcb->rcv_nxt));
}
  80b274:	83 c4 3c             	add    $0x3c,%esp
  80b277:	5b                   	pop    %ebx
  80b278:	5e                   	pop    %esi
  80b279:	5f                   	pop    %edi
  80b27a:	5d                   	pop    %ebp
  80b27b:	c3                   	ret    

0080b27c <tcp_rst>:
 */
void
tcp_rst(u32_t seqno, u32_t ackno,
  struct ip_addr *local_ip, struct ip_addr *remote_ip,
  u16_t local_port, u16_t remote_port)
{
  80b27c:	55                   	push   %ebp
  80b27d:	89 e5                	mov    %esp,%ebp
  80b27f:	57                   	push   %edi
  80b280:	56                   	push   %esi
  80b281:	53                   	push   %ebx
  80b282:	83 ec 3c             	sub    $0x3c,%esp
  80b285:	8b 7d 14             	mov    0x14(%ebp),%edi
  80b288:	0f b7 45 18          	movzwl 0x18(%ebp),%eax
  80b28c:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  80b290:	0f b7 45 1c          	movzwl 0x1c(%ebp),%eax
  80b294:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct pbuf *p;
  struct tcp_hdr *tcphdr;
  p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b298:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b29f:	00 
  80b2a0:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b2a7:	00 
  80b2a8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b2af:	e8 5f cf ff ff       	call   808213 <pbuf_alloc>
  80b2b4:	89 c6                	mov    %eax,%esi
  if (p == NULL) {
  80b2b6:	85 c0                	test   %eax,%eax
  80b2b8:	0f 84 15 01 00 00    	je     80b3d3 <tcp_rst+0x157>
      LWIP_DEBUGF(TCP_DEBUG, ("tcp_rst: could not allocate memory for pbuf\n"));
      return;
  }
  LWIP_ASSERT("check that first pbuf can hold struct tcp_hdr",
  80b2be:	66 83 78 0a 13       	cmpw   $0x13,0xa(%eax)
  80b2c3:	77 1c                	ja     80b2e1 <tcp_rst+0x65>
  80b2c5:	c7 44 24 08 2c 3f 81 	movl   $0x813f2c,0x8(%esp)
  80b2cc:	00 
  80b2cd:	c7 44 24 04 be 02 00 	movl   $0x2be,0x4(%esp)
  80b2d4:	00 
  80b2d5:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80b2dc:	e8 f3 56 ff ff       	call   8009d4 <_panic>
              (p->len >= sizeof(struct tcp_hdr)));

  tcphdr = p->payload;
  80b2e1:	8b 58 04             	mov    0x4(%eax),%ebx
  tcphdr->src = htons(local_port);
  80b2e4:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80b2e8:	89 04 24             	mov    %eax,(%esp)
  80b2eb:	e8 64 fa ff ff       	call   80ad54 <htons>
  80b2f0:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = htons(remote_port);
  80b2f3:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80b2f7:	89 04 24             	mov    %eax,(%esp)
  80b2fa:	e8 55 fa ff ff       	call   80ad54 <htons>
  80b2ff:	66 89 43 02          	mov    %ax,0x2(%ebx)
  tcphdr->seqno = htonl(seqno);
  80b303:	8b 45 08             	mov    0x8(%ebp),%eax
  80b306:	89 04 24             	mov    %eax,(%esp)
  80b309:	e8 67 fa ff ff       	call   80ad75 <htonl>
  80b30e:	89 43 04             	mov    %eax,0x4(%ebx)
  tcphdr->ackno = htonl(ackno);
  80b311:	8b 45 0c             	mov    0xc(%ebp),%eax
  80b314:	89 04 24             	mov    %eax,(%esp)
  80b317:	e8 59 fa ff ff       	call   80ad75 <htonl>
  80b31c:	89 43 08             	mov    %eax,0x8(%ebx)
  TCPH_FLAGS_SET(tcphdr, TCP_RST | TCP_ACK);
  80b31f:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b323:	89 04 24             	mov    %eax,(%esp)
  80b326:	e8 36 fa ff ff       	call   80ad61 <ntohs>
  80b32b:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b330:	83 c8 14             	or     $0x14,%eax
  80b333:	89 04 24             	mov    %eax,(%esp)
  80b336:	e8 19 fa ff ff       	call   80ad54 <htons>
  80b33b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  tcphdr->wnd = htons(TCP_WND);
  80b33f:	c7 04 24 c0 5d 00 00 	movl   $0x5dc0,(%esp)
  80b346:	e8 09 fa ff ff       	call   80ad54 <htons>
  80b34b:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  tcphdr->urgp = 0;
  80b34f:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
  TCPH_HDRLEN_SET(tcphdr, 5);
  80b355:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b359:	89 04 24             	mov    %eax,(%esp)
  80b35c:	e8 00 fa ff ff       	call   80ad61 <ntohs>
  80b361:	83 e0 3f             	and    $0x3f,%eax
  80b364:	80 cc 50             	or     $0x50,%ah
  80b367:	89 04 24             	mov    %eax,(%esp)
  80b36a:	e8 e5 f9 ff ff       	call   80ad54 <htons>
  80b36f:	66 89 43 0c          	mov    %ax,0xc(%ebx)

  tcphdr->chksum = 0;
  80b373:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
  tcphdr->chksum = inet_chksum_pseudo(p, local_ip, remote_ip,
  80b379:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80b37d:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b381:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b388:	00 
  80b389:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b38d:	8b 45 10             	mov    0x10(%ebp),%eax
  80b390:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b394:	89 34 24             	mov    %esi,(%esp)
  80b397:	e8 b4 f6 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80b39c:	66 89 43 10          	mov    %ax,0x10(%ebx)
              IP_PROTO_TCP, p->tot_len);
#endif
  TCP_STATS_INC(tcp.xmit);
  snmp_inc_tcpoutrsts();
   /* Send output with hardcoded TTL since we have no access to the pcb */
  ip_output(p, local_ip, remote_ip, TCP_TTL, 0, IP_PROTO_TCP);
  80b3a0:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b3a7:	00 
  80b3a8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  80b3af:	00 
  80b3b0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  80b3b7:	00 
  80b3b8:	89 7c 24 08          	mov    %edi,0x8(%esp)
  80b3bc:	8b 45 10             	mov    0x10(%ebp),%eax
  80b3bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80b3c3:	89 34 24             	mov    %esi,(%esp)
  80b3c6:	e8 d2 e7 ff ff       	call   809b9d <ip_output>
  pbuf_free(p);
  80b3cb:	89 34 24             	mov    %esi,(%esp)
  80b3ce:	e8 85 cb ff ff       	call   807f58 <pbuf_free>
  LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_rst: seqno %"U32_F" ackno %"U32_F".\n", seqno, ackno));
}
  80b3d3:	83 c4 3c             	add    $0x3c,%esp
  80b3d6:	5b                   	pop    %ebx
  80b3d7:	5e                   	pop    %esi
  80b3d8:	5f                   	pop    %edi
  80b3d9:	5d                   	pop    %ebp
  80b3da:	c3                   	ret    

0080b3db <tcp_output>:
 * @return ERR_OK if data has been sent or nothing to send
 *         another err_t on error
 */
err_t
tcp_output(struct tcp_pcb *pcb)
{
  80b3db:	55                   	push   %ebp
  80b3dc:	89 e5                	mov    %esp,%ebp
  80b3de:	57                   	push   %edi
  80b3df:	56                   	push   %esi
  80b3e0:	53                   	push   %ebx
  80b3e1:	83 ec 4c             	sub    $0x4c,%esp
  80b3e4:	8b 75 08             	mov    0x8(%ebp),%esi

  /* First, check if we are invoked by the TCP input processing
     code. If so, we do not output anything. Instead, we rely on the
     input processing code to call us when input processing is done
     with. */
  if (tcp_input_pcb == pcb) {
  80b3e7:	b8 00 00 00 00       	mov    $0x0,%eax
  80b3ec:	39 35 24 f6 b3 00    	cmp    %esi,0xb3f624
  80b3f2:	0f 84 7e 04 00 00    	je     80b876 <tcp_output+0x49b>
    return ERR_OK;
  }

  wnd = LWIP_MIN(pcb->snd_wnd, pcb->cwnd);
  80b3f8:	0f b7 56 4e          	movzwl 0x4e(%esi),%edx
  80b3fc:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b400:	66 39 d0             	cmp    %dx,%ax
  80b403:	76 02                	jbe    80b407 <tcp_output+0x2c>
  80b405:	89 d0                	mov    %edx,%eax
  80b407:	0f b7 c0             	movzwl %ax,%eax
  80b40a:	89 45 d4             	mov    %eax,-0x2c(%ebp)

  seg = pcb->unsent;
  80b40d:	8b 5e 74             	mov    0x74(%esi),%ebx

  /* useg should point to last segment on unacked queue */
  useg = pcb->unacked;
  80b410:	8b 7e 78             	mov    0x78(%esi),%edi
  if (useg != NULL) {
  80b413:	85 ff                	test   %edi,%edi
  80b415:	74 0a                	je     80b421 <tcp_output+0x46>
    for (; useg->next != NULL; useg = useg->next);
  80b417:	8b 07                	mov    (%edi),%eax
  80b419:	85 c0                	test   %eax,%eax
  80b41b:	74 04                	je     80b421 <tcp_output+0x46>
  80b41d:	89 c7                	mov    %eax,%edi
  80b41f:	eb f6                	jmp    80b417 <tcp_output+0x3c>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80b421:	f6 46 20 02          	testb  $0x2,0x20(%esi)
  80b425:	75 0e                	jne    80b435 <tcp_output+0x5a>
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b427:	85 db                	test   %ebx,%ebx
  80b429:	75 2c                	jne    80b457 <tcp_output+0x7c>
  80b42b:	90                   	nop
  80b42c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80b430:	e9 38 04 00 00       	jmp    80b86d <tcp_output+0x492>
   * because the ->unsent queue is empty or because the window does
   * not allow it), construct an empty ACK segment and send it.
   *
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
  80b435:	85 db                	test   %ebx,%ebx
  80b437:	90                   	nop
  80b438:	74 2e                	je     80b468 <tcp_output+0x8d>
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
  80b43a:	8b 43 10             	mov    0x10(%ebx),%eax
  80b43d:	8b 40 04             	mov    0x4(%eax),%eax
  80b440:	89 04 24             	mov    %eax,(%esp)
  80b443:	e8 52 fb ff ff       	call   80af9a <ntohl>
  80b448:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b44c:	2b 56 48             	sub    0x48(%esi),%edx
  80b44f:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b452:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b455:	72 11                	jb     80b468 <tcp_output+0x8d>
  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b457:	89 75 e4             	mov    %esi,-0x1c(%ebp)
    netif = ip_route(&(pcb->remote_ip));
  80b45a:	8d 46 04             	lea    0x4(%esi),%eax
  80b45d:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80b460:	89 7d d8             	mov    %edi,-0x28(%ebp)
  80b463:	e9 a7 03 00 00       	jmp    80b80f <tcp_output+0x434>
   * If data is to be sent, we will just piggyback the ACK (see below).
   */
  if (pcb->flags & TF_ACK_NOW &&
     (seg == NULL ||
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > wnd)) {
    p = pbuf_alloc(PBUF_IP, TCP_HLEN, PBUF_RAM);
  80b468:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80b46f:	00 
  80b470:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80b477:	00 
  80b478:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80b47f:	e8 8f cd ff ff       	call   808213 <pbuf_alloc>
  80b484:	89 c7                	mov    %eax,%edi
    if (p == NULL) {
  80b486:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80b48b:	85 ff                	test   %edi,%edi
  80b48d:	0f 84 e3 03 00 00    	je     80b876 <tcp_output+0x49b>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: (ACK) could not allocate pbuf\n"));
      return ERR_BUF;
    }
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output: sending ACK for %"U32_F"\n", pcb->rcv_nxt));
    /* remove ACK flags from the PCB, as we send an empty ACK now */
    pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b493:	80 66 20 fc          	andb   $0xfc,0x20(%esi)

    tcphdr = p->payload;
  80b497:	8b 5f 04             	mov    0x4(%edi),%ebx
    tcphdr->src = htons(pcb->local_port);
  80b49a:	0f b7 46 1c          	movzwl 0x1c(%esi),%eax
  80b49e:	89 04 24             	mov    %eax,(%esp)
  80b4a1:	e8 ae f8 ff ff       	call   80ad54 <htons>
  80b4a6:	66 89 03             	mov    %ax,(%ebx)
    tcphdr->dest = htons(pcb->remote_port);
  80b4a9:	0f b7 46 1e          	movzwl 0x1e(%esi),%eax
  80b4ad:	89 04 24             	mov    %eax,(%esp)
  80b4b0:	e8 9f f8 ff ff       	call   80ad54 <htons>
  80b4b5:	66 89 43 02          	mov    %ax,0x2(%ebx)
    tcphdr->seqno = htonl(pcb->snd_nxt);
  80b4b9:	8b 46 54             	mov    0x54(%esi),%eax
  80b4bc:	89 04 24             	mov    %eax,(%esp)
  80b4bf:	e8 b1 f8 ff ff       	call   80ad75 <htonl>
  80b4c4:	89 43 04             	mov    %eax,0x4(%ebx)
    tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b4c7:	8b 46 24             	mov    0x24(%esi),%eax
  80b4ca:	89 04 24             	mov    %eax,(%esp)
  80b4cd:	e8 a3 f8 ff ff       	call   80ad75 <htonl>
  80b4d2:	89 43 08             	mov    %eax,0x8(%ebx)
    TCPH_FLAGS_SET(tcphdr, TCP_ACK);
  80b4d5:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b4d9:	89 04 24             	mov    %eax,(%esp)
  80b4dc:	e8 80 f8 ff ff       	call   80ad61 <ntohs>
  80b4e1:	25 c0 ff 00 00       	and    $0xffc0,%eax
  80b4e6:	83 c8 10             	or     $0x10,%eax
  80b4e9:	89 04 24             	mov    %eax,(%esp)
  80b4ec:	e8 63 f8 ff ff       	call   80ad54 <htons>
  80b4f1:	66 89 43 0c          	mov    %ax,0xc(%ebx)
    tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b4f5:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b4f9:	89 04 24             	mov    %eax,(%esp)
  80b4fc:	e8 53 f8 ff ff       	call   80ad54 <htons>
  80b501:	66 89 43 0e          	mov    %ax,0xe(%ebx)
    tcphdr->urgp = 0;
  80b505:	66 c7 43 12 00 00    	movw   $0x0,0x12(%ebx)
    TCPH_HDRLEN_SET(tcphdr, 5);
  80b50b:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80b50f:	89 04 24             	mov    %eax,(%esp)
  80b512:	e8 4a f8 ff ff       	call   80ad61 <ntohs>
  80b517:	83 e0 3f             	and    $0x3f,%eax
  80b51a:	80 cc 50             	or     $0x50,%ah
  80b51d:	89 04 24             	mov    %eax,(%esp)
  80b520:	e8 2f f8 ff ff       	call   80ad54 <htons>
  80b525:	66 89 43 0c          	mov    %ax,0xc(%ebx)

    tcphdr->chksum = 0;
  80b529:	66 c7 43 10 00 00    	movw   $0x0,0x10(%ebx)
#if CHECKSUM_GEN_TCP
    tcphdr->chksum = inet_chksum_pseudo(p, &(pcb->local_ip), &(pcb->remote_ip),
  80b52f:	8d 56 04             	lea    0x4(%esi),%edx
  80b532:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  80b535:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80b539:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b53d:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b544:	00 
  80b545:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b549:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b54d:	89 3c 24             	mov    %edi,(%esp)
  80b550:	e8 fb f4 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80b555:	66 89 43 10          	mov    %ax,0x10(%ebx)
                     pcb->tos, IP_PROTO_TCP, netif);
        netif->addr_hint = NULL;
      }
    }
#else /* LWIP_NETIF_HWADDRHINT*/
    ip_output(p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b559:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b560:	00 
  80b561:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b565:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b569:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b56d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b571:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80b574:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b578:	89 74 24 04          	mov    %esi,0x4(%esp)
  80b57c:	89 3c 24             	mov    %edi,(%esp)
  80b57f:	e8 19 e6 ff ff       	call   809b9d <ip_output>
        IP_PROTO_TCP);
#endif /* LWIP_NETIF_HWADDRHINT*/
    pbuf_free(p);
  80b584:	89 3c 24             	mov    %edi,(%esp)
  80b587:	e8 cc c9 ff ff       	call   807f58 <pbuf_free>
  80b58c:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
  80b591:	e9 e0 02 00 00       	jmp    80b876 <tcp_output+0x49b>
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
    LWIP_ASSERT("RST not expected here!", 
  80b596:	8b 43 10             	mov    0x10(%ebx),%eax
  80b599:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b59d:	89 04 24             	mov    %eax,(%esp)
  80b5a0:	e8 bc f7 ff ff       	call   80ad61 <ntohs>
  80b5a5:	a8 04                	test   $0x4,%al
  80b5a7:	74 1c                	je     80b5c5 <tcp_output+0x1ea>
  80b5a9:	c7 44 24 08 e8 40 81 	movl   $0x8140e8,0x8(%esp)
  80b5b0:	00 
  80b5b1:	c7 44 24 04 05 02 00 	movl   $0x205,0x4(%esp)
  80b5b8:	00 
  80b5b9:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80b5c0:	e8 0f 54 ff ff       	call   8009d4 <_panic>
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b5c5:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b5c9:	74 1c                	je     80b5e7 <tcp_output+0x20c>
  80b5cb:	0f b6 46 20          	movzbl 0x20(%esi),%eax
  80b5cf:	a8 40                	test   $0x40,%al
  80b5d1:	75 14                	jne    80b5e7 <tcp_output+0x20c>
  80b5d3:	8b 56 74             	mov    0x74(%esi),%edx
  80b5d6:	85 d2                	test   %edx,%edx
  80b5d8:	0f 84 a0 02 00 00    	je     80b87e <tcp_output+0x4a3>
  80b5de:	83 3a 00             	cmpl   $0x0,(%edx)
  80b5e1:	0f 84 97 02 00 00    	je     80b87e <tcp_output+0x4a3>
                            pcb->lastack,
                            ntohl(seg->tcphdr->seqno), pcb->lastack, i));
    ++i;
#endif /* TCP_CWND_DEBUG */

    pcb->unsent = seg->next;
  80b5e7:	8b 03                	mov    (%ebx),%eax
  80b5e9:	89 46 74             	mov    %eax,0x74(%esi)

    if (pcb->state != SYN_SENT) {
  80b5ec:	83 7e 10 02          	cmpl   $0x2,0x10(%esi)
  80b5f0:	74 25                	je     80b617 <tcp_output+0x23c>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
  80b5f2:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b5f5:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80b5f9:	89 04 24             	mov    %eax,(%esp)
  80b5fc:	e8 60 f7 ff ff       	call   80ad61 <ntohs>
  80b601:	83 c8 10             	or     $0x10,%eax
  80b604:	0f b7 c0             	movzwl %ax,%eax
  80b607:	89 04 24             	mov    %eax,(%esp)
  80b60a:	e8 45 f7 ff ff       	call   80ad54 <htons>
  80b60f:	66 89 47 0c          	mov    %ax,0xc(%edi)
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
  80b613:	80 66 20 fc          	andb   $0xfc,0x20(%esi)
  /** @bug Exclude retransmitted segments from this count. */
  snmp_inc_tcpoutsegs();

  /* The TCP header has already been constructed, but the ackno and
   wnd fields remain. */
  seg->tcphdr->ackno = htonl(pcb->rcv_nxt);
  80b617:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b61a:	8b 46 24             	mov    0x24(%esi),%eax
  80b61d:	89 04 24             	mov    %eax,(%esp)
  80b620:	e8 50 f7 ff ff       	call   80ad75 <htonl>
  80b625:	89 47 08             	mov    %eax,0x8(%edi)

  /* advertise our receive window size in this TCP segment */
  seg->tcphdr->wnd = htons(pcb->rcv_ann_wnd);
  80b628:	8b 7b 10             	mov    0x10(%ebx),%edi
  80b62b:	0f b7 46 2a          	movzwl 0x2a(%esi),%eax
  80b62f:	89 04 24             	mov    %eax,(%esp)
  80b632:	e8 1d f7 ff ff       	call   80ad54 <htons>
  80b637:	66 89 47 0e          	mov    %ax,0xe(%edi)

  /* If we don't have a local IP address, we get one by
     calling ip_route(). */
  if (ip_addr_isany(&(pcb->local_ip))) {
  80b63b:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  80b63f:	74 05                	je     80b646 <tcp_output+0x26b>
  80b641:	83 3e 00             	cmpl   $0x0,(%esi)
  80b644:	75 22                	jne    80b668 <tcp_output+0x28d>
    netif = ip_route(&(pcb->remote_ip));
  80b646:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b649:	89 14 24             	mov    %edx,(%esp)
  80b64c:	e8 f0 e4 ff ff       	call   809b41 <ip_route>
    if (netif == NULL) {
  80b651:	85 c0                	test   %eax,%eax
  80b653:	0f 84 c3 00 00 00    	je     80b71c <tcp_output+0x341>
      return;
    }
    ip_addr_set(&(pcb->local_ip), &(netif->ip_addr));
  80b659:	ba 00 00 00 00       	mov    $0x0,%edx
  80b65e:	83 f8 fc             	cmp    $0xfffffffc,%eax
  80b661:	74 03                	je     80b666 <tcp_output+0x28b>
  80b663:	8b 50 04             	mov    0x4(%eax),%edx
  80b666:	89 16                	mov    %edx,(%esi)
  }

  /* Set retransmission timer running if it is not currently enabled */
  if(pcb->rtime == -1)
  80b668:	66 83 7e 32 ff       	cmpw   $0xffffffff,0x32(%esi)
  80b66d:	75 06                	jne    80b675 <tcp_output+0x29a>
    pcb->rtime = 0;
  80b66f:	66 c7 46 32 00 00    	movw   $0x0,0x32(%esi)

  if (pcb->rttest == 0) {
  80b675:	83 7e 38 00          	cmpl   $0x0,0x38(%esi)
  80b679:	75 19                	jne    80b694 <tcp_output+0x2b9>
    pcb->rttest = tcp_ticks;
  80b67b:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  80b680:	89 46 38             	mov    %eax,0x38(%esi)
    pcb->rtseq = ntohl(seg->tcphdr->seqno);
  80b683:	8b 43 10             	mov    0x10(%ebx),%eax
  80b686:	8b 40 04             	mov    0x4(%eax),%eax
  80b689:	89 04 24             	mov    %eax,(%esp)
  80b68c:	e8 09 f9 ff ff       	call   80af9a <ntohl>
  80b691:	89 46 3c             	mov    %eax,0x3c(%esi)
  }
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_output_segment: %"U32_F":%"U32_F"\n",
          htonl(seg->tcphdr->seqno), htonl(seg->tcphdr->seqno) +
          seg->len));

  len = (u16_t)((u8_t *)seg->tcphdr - (u8_t *)seg->p->payload);
  80b694:	8b 43 04             	mov    0x4(%ebx),%eax
  80b697:	8b 53 10             	mov    0x10(%ebx),%edx
  80b69a:	66 2b 50 04          	sub    0x4(%eax),%dx

  seg->p->len -= len;
  80b69e:	66 29 50 0a          	sub    %dx,0xa(%eax)
  seg->p->tot_len -= len;
  80b6a2:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6a5:	66 29 50 08          	sub    %dx,0x8(%eax)

  seg->p->payload = seg->tcphdr;
  80b6a9:	8b 43 04             	mov    0x4(%ebx),%eax
  80b6ac:	8b 53 10             	mov    0x10(%ebx),%edx
  80b6af:	89 50 04             	mov    %edx,0x4(%eax)

  seg->tcphdr->chksum = 0;
  80b6b2:	8b 43 10             	mov    0x10(%ebx),%eax
  80b6b5:	66 c7 40 10 00 00    	movw   $0x0,0x10(%eax)
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b6bb:	8b 7b 10             	mov    0x10(%ebx),%edi
             &(pcb->local_ip),
             &(pcb->remote_ip),
             IP_PROTO_TCP, seg->p->tot_len);
  80b6be:	8b 43 04             	mov    0x4(%ebx),%eax

  seg->p->payload = seg->tcphdr;

  seg->tcphdr->chksum = 0;
#if CHECKSUM_GEN_TCP
  seg->tcphdr->chksum = inet_chksum_pseudo(seg->p,
  80b6c1:	0f b7 50 08          	movzwl 0x8(%eax),%edx
  80b6c5:	89 54 24 10          	mov    %edx,0x10(%esp)
  80b6c9:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  80b6d0:	00 
  80b6d1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80b6d4:	89 54 24 08          	mov    %edx,0x8(%esp)
  80b6d8:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b6db:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b6df:	89 04 24             	mov    %eax,(%esp)
  80b6e2:	e8 69 f3 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80b6e7:	66 89 47 10          	mov    %ax,0x10(%edi)
                   pcb->tos, IP_PROTO_TCP, netif);
      netif->addr_hint = NULL;
    }
  }
#else /* LWIP_NETIF_HWADDRHINT*/
  ip_output(seg->p, &(pcb->local_ip), &(pcb->remote_ip), pcb->ttl, pcb->tos,
  80b6eb:	c7 44 24 14 06 00 00 	movl   $0x6,0x14(%esp)
  80b6f2:	00 
  80b6f3:	0f b6 46 0a          	movzbl 0xa(%esi),%eax
  80b6f7:	89 44 24 10          	mov    %eax,0x10(%esp)
  80b6fb:	0f b6 46 0b          	movzbl 0xb(%esi),%eax
  80b6ff:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80b703:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80b706:	89 44 24 08          	mov    %eax,0x8(%esp)
  80b70a:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80b70d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80b711:	8b 43 04             	mov    0x4(%ebx),%eax
  80b714:	89 04 24             	mov    %eax,(%esp)
  80b717:	e8 81 e4 ff ff       	call   809b9d <ip_output>
      TCPH_SET_FLAG(seg->tcphdr, TCP_ACK);
      pcb->flags &= ~(TF_ACK_DELAY | TF_ACK_NOW);
    }

    tcp_output_segment(seg, pcb);
    pcb->snd_nxt = ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg);
  80b71c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b71f:	8b 40 04             	mov    0x4(%eax),%eax
  80b722:	89 04 24             	mov    %eax,(%esp)
  80b725:	e8 70 f8 ff ff       	call   80af9a <ntohl>
  80b72a:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80b72d:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b731:	8b 43 10             	mov    0x10(%ebx),%eax
  80b734:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b738:	89 04 24             	mov    %eax,(%esp)
  80b73b:	e8 21 f6 ff ff       	call   80ad61 <ntohs>
  80b740:	a8 01                	test   $0x1,%al
  80b742:	75 1b                	jne    80b75f <tcp_output+0x384>
  80b744:	8b 43 10             	mov    0x10(%ebx),%eax
  80b747:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b74b:	89 04 24             	mov    %eax,(%esp)
  80b74e:	e8 0e f6 ff ff       	call   80ad61 <ntohs>
  80b753:	89 c2                	mov    %eax,%edx
  80b755:	b8 00 00 00 00       	mov    $0x0,%eax
  80b75a:	f6 c2 02             	test   $0x2,%dl
  80b75d:	74 05                	je     80b764 <tcp_output+0x389>
  80b75f:	b8 01 00 00 00       	mov    $0x1,%eax
  80b764:	0f b7 ff             	movzwl %di,%edi
  80b767:	8d 3c 38             	lea    (%eax,%edi,1),%edi
  80b76a:	03 7d dc             	add    -0x24(%ebp),%edi
  80b76d:	89 7e 54             	mov    %edi,0x54(%esi)
    if (TCP_SEQ_LT(pcb->snd_max, pcb->snd_nxt)) {
  80b770:	39 7e 58             	cmp    %edi,0x58(%esi)
  80b773:	79 03                	jns    80b778 <tcp_output+0x39d>
      pcb->snd_max = pcb->snd_nxt;
  80b775:	89 7e 58             	mov    %edi,0x58(%esi)
    }
    /* put segment on unacknowledged list if length > 0 */
    if (TCP_TCPLEN(seg) > 0) {
  80b778:	0f b7 7b 0c          	movzwl 0xc(%ebx),%edi
  80b77c:	8b 43 10             	mov    0x10(%ebx),%eax
  80b77f:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b783:	89 04 24             	mov    %eax,(%esp)
  80b786:	e8 d6 f5 ff ff       	call   80ad61 <ntohs>
  80b78b:	a8 01                	test   $0x1,%al
  80b78d:	75 18                	jne    80b7a7 <tcp_output+0x3cc>
  80b78f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b792:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80b796:	89 04 24             	mov    %eax,(%esp)
  80b799:	e8 c3 f5 ff ff       	call   80ad61 <ntohs>
  80b79e:	ba 00 00 00 00       	mov    $0x0,%edx
  80b7a3:	a8 02                	test   $0x2,%al
  80b7a5:	74 05                	je     80b7ac <tcp_output+0x3d1>
  80b7a7:	ba 01 00 00 00       	mov    $0x1,%edx
  80b7ac:	0f b7 ff             	movzwl %di,%edi
  80b7af:	01 fa                	add    %edi,%edx
  80b7b1:	74 4d                	je     80b800 <tcp_output+0x425>
      seg->next = NULL;
  80b7b3:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)
      /* unacked list is empty? */
      if (pcb->unacked == NULL) {
  80b7b9:	83 7e 78 00          	cmpl   $0x0,0x78(%esi)
  80b7bd:	75 08                	jne    80b7c7 <tcp_output+0x3ec>
        pcb->unacked = seg;
  80b7bf:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b7c2:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b7c5:	eb 41                	jmp    80b808 <tcp_output+0x42d>
      /* unacked list is not empty? */
      } else {
        /* In the case of fast retransmit, the packet should not go to the tail
         * of the unacked queue, but rather at the head. We need to check for
         * this case. -STJ Jul 27, 2004 */
        if (TCP_SEQ_LT(ntohl(seg->tcphdr->seqno), ntohl(useg->tcphdr->seqno))){
  80b7c7:	8b 43 10             	mov    0x10(%ebx),%eax
  80b7ca:	8b 40 04             	mov    0x4(%eax),%eax
  80b7cd:	89 04 24             	mov    %eax,(%esp)
  80b7d0:	e8 c5 f7 ff ff       	call   80af9a <ntohl>
  80b7d5:	89 c7                	mov    %eax,%edi
  80b7d7:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80b7da:	8b 42 10             	mov    0x10(%edx),%eax
  80b7dd:	8b 40 04             	mov    0x4(%eax),%eax
  80b7e0:	89 04 24             	mov    %eax,(%esp)
  80b7e3:	e8 b2 f7 ff ff       	call   80af9a <ntohl>
  80b7e8:	39 c7                	cmp    %eax,%edi
  80b7ea:	79 0a                	jns    80b7f6 <tcp_output+0x41b>
          /* add segment to head of unacked list */
          seg->next = pcb->unacked;
  80b7ec:	8b 46 78             	mov    0x78(%esi),%eax
  80b7ef:	89 03                	mov    %eax,(%ebx)
          pcb->unacked = seg;
  80b7f1:	89 5e 78             	mov    %ebx,0x78(%esi)
  80b7f4:	eb 12                	jmp    80b808 <tcp_output+0x42d>
        } else {
          /* add segment to tail of unacked list */
          useg->next = seg;
  80b7f6:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80b7f9:	89 18                	mov    %ebx,(%eax)
  80b7fb:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  80b7fe:	eb 08                	jmp    80b808 <tcp_output+0x42d>
          useg = useg->next;
        }
      }
    /* do not queue empty segments on the unacked list */
    } else {
      tcp_seg_free(seg);
  80b800:	89 1c 24             	mov    %ebx,(%esp)
  80b803:	e8 c9 d2 ff ff       	call   808ad1 <tcp_seg_free>
    }
    seg = pcb->unsent;
  80b808:	8b 5e 74             	mov    0x74(%esi),%ebx
                 ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len,
                 ntohl(seg->tcphdr->seqno), pcb->lastack));
  }
#endif /* TCP_CWND_DEBUG */
  /* data available and window allows it to be sent? */
  while (seg != NULL &&
  80b80b:	85 db                	test   %ebx,%ebx
  80b80d:	74 5e                	je     80b86d <tcp_output+0x492>
         ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len <= wnd) {
  80b80f:	8b 43 10             	mov    0x10(%ebx),%eax
  80b812:	8b 40 04             	mov    0x4(%eax),%eax
  80b815:	89 04 24             	mov    %eax,(%esp)
  80b818:	e8 7d f7 ff ff       	call   80af9a <ntohl>
  80b81d:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b821:	2b 56 48             	sub    0x48(%esi),%edx
  80b824:	8d 04 02             	lea    (%edx,%eax,1),%eax
  80b827:	39 45 d4             	cmp    %eax,-0x2c(%ebp)
  80b82a:	0f 83 66 fd ff ff    	jae    80b596 <tcp_output+0x1bb>
      tcp_seg_free(seg);
    }
    seg = pcb->unsent;
  }

  if (seg != NULL && pcb->persist_backoff == 0 && 
  80b830:	85 db                	test   %ebx,%ebx
  80b832:	74 39                	je     80b86d <tcp_output+0x492>
  80b834:	80 be a4 00 00 00 00 	cmpb   $0x0,0xa4(%esi)
  80b83b:	75 30                	jne    80b86d <tcp_output+0x492>
      ntohl(seg->tcphdr->seqno) - pcb->lastack + seg->len > pcb->snd_wnd) {
  80b83d:	8b 43 10             	mov    0x10(%ebx),%eax
  80b840:	8b 40 04             	mov    0x4(%eax),%eax
  80b843:	89 04 24             	mov    %eax,(%esp)
  80b846:	e8 4f f7 ff ff       	call   80af9a <ntohl>
  80b84b:	0f b7 53 0c          	movzwl 0xc(%ebx),%edx
  80b84f:	2b 56 48             	sub    0x48(%esi),%edx
  80b852:	01 c2                	add    %eax,%edx
  80b854:	0f b7 46 5c          	movzwl 0x5c(%esi),%eax
  80b858:	39 c2                	cmp    %eax,%edx
  80b85a:	76 11                	jbe    80b86d <tcp_output+0x492>
    /* prepare for persist timer */
    pcb->persist_cnt = 0;
  80b85c:	c7 86 a0 00 00 00 00 	movl   $0x0,0xa0(%esi)
  80b863:	00 00 00 
    pcb->persist_backoff = 1;
  80b866:	c6 86 a4 00 00 00 01 	movb   $0x1,0xa4(%esi)
  }

  pcb->flags &= ~TF_NAGLEMEMERR;
  80b86d:	80 66 20 7f          	andb   $0x7f,0x20(%esi)
  80b871:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80b876:	83 c4 4c             	add    $0x4c,%esp
  80b879:	5b                   	pop    %ebx
  80b87a:	5e                   	pop    %esi
  80b87b:	5f                   	pop    %edi
  80b87c:	5d                   	pop    %ebp
  80b87d:	c3                   	ret    
     * - if tcp_enqueue had a memory error before (prevent delayed ACK timeout) or
     * - if FIN was already enqueued for this PCB (SYN is always alone in a segment -
     *   either seg->next != NULL or pcb->unacked == NULL;
     *   RST is no sent using tcp_enqueue/tcp_output.
     */
    if((tcp_do_output_nagle(pcb) == 0) &&
  80b87e:	a8 a0                	test   $0xa0,%al
  80b880:	0f 85 61 fd ff ff    	jne    80b5e7 <tcp_output+0x20c>
  80b886:	eb a8                	jmp    80b830 <tcp_output+0x455>

0080b888 <tcp_rexmit>:
 *
 * @param pcb the tcp_pcb for which to retransmit the first unacked segment
 */
void
tcp_rexmit(struct tcp_pcb *pcb)
{
  80b888:	55                   	push   %ebp
  80b889:	89 e5                	mov    %esp,%ebp
  80b88b:	53                   	push   %ebx
  80b88c:	83 ec 14             	sub    $0x14,%esp
  80b88f:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b892:	8b 43 78             	mov    0x78(%ebx),%eax
  80b895:	85 c0                	test   %eax,%eax
  80b897:	74 34                	je     80b8cd <tcp_rexmit+0x45>
    return;
  }

  /* Move the first unacked segment to the unsent queue */
  seg = pcb->unacked->next;
  80b899:	8b 10                	mov    (%eax),%edx
  pcb->unacked->next = pcb->unsent;
  80b89b:	8b 4b 74             	mov    0x74(%ebx),%ecx
  80b89e:	89 08                	mov    %ecx,(%eax)
  pcb->unsent = pcb->unacked;
  80b8a0:	8b 43 78             	mov    0x78(%ebx),%eax
  80b8a3:	89 43 74             	mov    %eax,0x74(%ebx)
  pcb->unacked = seg;
  80b8a6:	89 53 78             	mov    %edx,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b8a9:	8b 40 10             	mov    0x10(%eax),%eax
  80b8ac:	8b 40 04             	mov    0x4(%eax),%eax
  80b8af:	89 04 24             	mov    %eax,(%esp)
  80b8b2:	e8 e3 f6 ff ff       	call   80af9a <ntohl>
  80b8b7:	89 43 54             	mov    %eax,0x54(%ebx)

  ++pcb->nrtx;
  80b8ba:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any rtt measurements after retransmitting. */
  pcb->rttest = 0;
  80b8be:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission. */
  snmp_inc_tcpretranssegs();
  tcp_output(pcb);
  80b8c5:	89 1c 24             	mov    %ebx,(%esp)
  80b8c8:	e8 0e fb ff ff       	call   80b3db <tcp_output>
}
  80b8cd:	83 c4 14             	add    $0x14,%esp
  80b8d0:	5b                   	pop    %ebx
  80b8d1:	5d                   	pop    %ebp
  80b8d2:	c3                   	ret    

0080b8d3 <tcp_rexmit_rto>:
 *
 * @param pcb the tcp_pcb for which to re-enqueue all unacked segments
 */
void
tcp_rexmit_rto(struct tcp_pcb *pcb)
{
  80b8d3:	55                   	push   %ebp
  80b8d4:	89 e5                	mov    %esp,%ebp
  80b8d6:	53                   	push   %ebx
  80b8d7:	83 ec 14             	sub    $0x14,%esp
  80b8da:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct tcp_seg *seg;

  if (pcb->unacked == NULL) {
  80b8dd:	8b 43 78             	mov    0x78(%ebx),%eax
  80b8e0:	85 c0                	test   %eax,%eax
  80b8e2:	74 3e                	je     80b922 <tcp_rexmit_rto+0x4f>
    return;
  }

  /* Move all unacked segments to the head of the unsent queue */
  for (seg = pcb->unacked; seg->next != NULL; seg = seg->next);
  80b8e4:	89 c2                	mov    %eax,%edx
  80b8e6:	8b 00                	mov    (%eax),%eax
  80b8e8:	85 c0                	test   %eax,%eax
  80b8ea:	75 f8                	jne    80b8e4 <tcp_rexmit_rto+0x11>
  /* concatenate unsent queue after unacked queue */
  seg->next = pcb->unsent;
  80b8ec:	8b 43 74             	mov    0x74(%ebx),%eax
  80b8ef:	89 02                	mov    %eax,(%edx)
  /* unsent queue is the concatenated queue (of unacked, unsent) */
  pcb->unsent = pcb->unacked;
  80b8f1:	8b 43 78             	mov    0x78(%ebx),%eax
  80b8f4:	89 43 74             	mov    %eax,0x74(%ebx)
  /* unacked queue is now empty */
  pcb->unacked = NULL;
  80b8f7:	c7 43 78 00 00 00 00 	movl   $0x0,0x78(%ebx)

  pcb->snd_nxt = ntohl(pcb->unsent->tcphdr->seqno);
  80b8fe:	8b 40 10             	mov    0x10(%eax),%eax
  80b901:	8b 40 04             	mov    0x4(%eax),%eax
  80b904:	89 04 24             	mov    %eax,(%esp)
  80b907:	e8 8e f6 ff ff       	call   80af9a <ntohl>
  80b90c:	89 43 54             	mov    %eax,0x54(%ebx)
  /* increment number of retransmissions */
  ++pcb->nrtx;
  80b90f:	80 43 46 01          	addb   $0x1,0x46(%ebx)

  /* Don't take any RTT measurements after retransmitting. */
  pcb->rttest = 0;
  80b913:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)

  /* Do the actual retransmission */
  tcp_output(pcb);
  80b91a:	89 1c 24             	mov    %ebx,(%esp)
  80b91d:	e8 b9 fa ff ff       	call   80b3db <tcp_output>
}
  80b922:	83 c4 14             	add    $0x14,%esp
  80b925:	5b                   	pop    %ebx
  80b926:	5d                   	pop    %ebp
  80b927:	c3                   	ret    

0080b928 <tcp_enqueue>:
 */
err_t
tcp_enqueue(struct tcp_pcb *pcb, void *arg, u16_t len,
  u8_t flags, u8_t apiflags,
  u8_t *optdata, u8_t optlen)
{
  80b928:	55                   	push   %ebp
  80b929:	89 e5                	mov    %esp,%ebp
  80b92b:	57                   	push   %edi
  80b92c:	56                   	push   %esi
  80b92d:	53                   	push   %ebx
  80b92e:	83 ec 5c             	sub    $0x5c,%esp
  80b931:	8b 7d 08             	mov    0x8(%ebp),%edi
  80b934:	8b 55 0c             	mov    0xc(%ebp),%edx
  80b937:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  80b93b:	66 89 45 c2          	mov    %ax,-0x3e(%ebp)
  80b93f:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  80b943:	88 4d bb             	mov    %cl,-0x45(%ebp)
  80b946:	0f b6 45 18          	movzbl 0x18(%ebp),%eax
  80b94a:	88 45 a8             	mov    %al,-0x58(%ebp)
  80b94d:	0f b6 45 20          	movzbl 0x20(%ebp),%eax
  void *ptr;
  u16_t queuelen;

  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_enqueue(pcb=%p, arg=%p, len=%"U16_F", flags=%"X16_F", apiflags=%"U16_F")\n",
    (void *)pcb, arg, len, (u16_t)flags, (u16_t)apiflags));
  LWIP_ERROR("tcp_enqueue: len == 0 || optlen == 0 (programmer violates API)",
  80b951:	66 83 7d c2 00       	cmpw   $0x0,-0x3e(%ebp)
  80b956:	74 20                	je     80b978 <tcp_enqueue+0x50>
  80b958:	84 c0                	test   %al,%al
  80b95a:	74 1c                	je     80b978 <tcp_enqueue+0x50>
  80b95c:	c7 44 24 08 5c 3f 81 	movl   $0x813f5c,0x8(%esp)
  80b963:	00 
  80b964:	c7 44 24 04 90 00 00 	movl   $0x90,0x4(%esp)
  80b96b:	00 
  80b96c:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80b973:	e8 5c 50 ff ff       	call   8009d4 <_panic>
      ((len == 0) || (optlen == 0)), return ERR_ARG;);
  LWIP_ERROR("tcp_enqueue: arg == NULL || optdata == NULL (programmer violates API)",
  80b978:	85 d2                	test   %edx,%edx
  80b97a:	0f 95 45 c1          	setne  -0x3f(%ebp)
  80b97e:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80b982:	0f 95 45 cb          	setne  -0x35(%ebp)
  80b986:	80 7d c1 00          	cmpb   $0x0,-0x3f(%ebp)
  80b98a:	74 22                	je     80b9ae <tcp_enqueue+0x86>
  80b98c:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80b990:	74 1c                	je     80b9ae <tcp_enqueue+0x86>
  80b992:	c7 44 24 08 9c 3f 81 	movl   $0x813f9c,0x8(%esp)
  80b999:	00 
  80b99a:	c7 44 24 04 92 00 00 	movl   $0x92,0x4(%esp)
  80b9a1:	00 
  80b9a2:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80b9a9:	e8 26 50 ff ff       	call   8009d4 <_panic>
      ((arg == NULL) || (optdata == NULL)), return ERR_ARG;);
  /* fail on too much data */
  if (len > pcb->snd_buf) {
  80b9ae:	0f b7 4d c2          	movzwl -0x3e(%ebp),%ecx
  80b9b2:	66 3b 4f 6e          	cmp    0x6e(%edi),%cx
  80b9b6:	76 0e                	jbe    80b9c6 <tcp_enqueue+0x9e>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too much data (len=%"U16_F" > snd_buf=%"U16_F")\n", len, pcb->snd_buf));
    pcb->flags |= TF_NAGLEMEMERR;
  80b9b8:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b9bc:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b9c1:	e9 34 06 00 00       	jmp    80bffa <tcp_enqueue+0x6d2>
  left = len;
  ptr = arg;

  /* seqno will be the sequence number of the first segment enqueued
   * by the call to this function. */
  seqno = pcb->snd_lbb;
  80b9c6:	8b 4f 68             	mov    0x68(%edi),%ecx
  80b9c9:	89 4d d8             	mov    %ecx,-0x28(%ebp)

  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: queuelen: %"U16_F"\n", (u16_t)pcb->snd_queuelen));

  /* If total number of pbufs on the unsent/unacked queues exceeds the
   * configured maximum, return an error */
  queuelen = pcb->snd_queuelen;
  80b9cc:	0f b7 4f 70          	movzwl 0x70(%edi),%ecx
  80b9d0:	66 89 4d e2          	mov    %cx,-0x1e(%ebp)
  /* check for configured max queuelen and possible overflow */
  if ((queuelen >= TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80b9d4:	66 83 f9 1f          	cmp    $0x1f,%cx
  80b9d8:	76 0e                	jbe    80b9e8 <tcp_enqueue+0xc0>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 3, ("tcp_enqueue: too long queue %"U16_F" (max %"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
  80b9da:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  80b9de:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  80b9e3:	e9 12 06 00 00       	jmp    80bffa <tcp_enqueue+0x6d2>
  }
  if (queuelen != 0) {
  80b9e8:	66 83 7d e2 00       	cmpw   $0x0,-0x1e(%ebp)
  80b9ed:	74 74                	je     80ba63 <tcp_enqueue+0x13b>
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80b9ef:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80b9f3:	74 4c                	je     80ba41 <tcp_enqueue+0x119>
    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80b9f5:	89 c1                	mov    %eax,%ecx
  80b9f7:	c0 e9 02             	shr    $0x2,%cl
  80b9fa:	c1 e1 0c             	shl    $0xc,%ecx
  80b9fd:	66 81 c1 00 50       	add    $0x5000,%cx
  80ba02:	66 89 4d c6          	mov    %cx,-0x3a(%ebp)
  80ba06:	89 55 d0             	mov    %edx,-0x30(%ebp)
  80ba09:	0f b7 55 c2          	movzwl -0x3e(%ebp),%edx
  80ba0d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  80ba11:	c7 45 d4 00 00 00 00 	movl   $0x0,-0x2c(%ebp)
  80ba18:	be 00 00 00 00       	mov    $0x0,%esi
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
      seg->dataptr = seg->p->payload;
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80ba1d:	0f b6 4d a8          	movzbl -0x58(%ebp),%ecx
  80ba21:	83 e1 01             	and    $0x1,%ecx
  80ba24:	89 4d bc             	mov    %ecx,-0x44(%ebp)
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80ba27:	0f b6 d0             	movzbl %al,%edx
  80ba2a:	89 55 cc             	mov    %edx,-0x34(%ebp)
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80ba2d:	0f b6 c0             	movzbl %al,%eax
  80ba30:	66 89 45 c4          	mov    %ax,-0x3c(%ebp)
    seg->tcphdr = seg->p->payload;
    seg->tcphdr->src = htons(pcb->local_port);
    seg->tcphdr->dest = htons(pcb->remote_port);
    seg->tcphdr->seqno = htonl(seqno);
    seg->tcphdr->urgp = 0;
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80ba34:	0f b6 4d bb          	movzbl -0x45(%ebp),%ecx
  80ba38:	66 89 4d c8          	mov    %cx,-0x38(%ebp)
  80ba3c:	89 7d dc             	mov    %edi,-0x24(%ebp)
  80ba3f:	eb 55                	jmp    80ba96 <tcp_enqueue+0x16e>
    TCP_STATS_INC(tcp.memerr);
    pcb->flags |= TF_NAGLEMEMERR;
    return ERR_MEM;
  }
  if (queuelen != 0) {
    LWIP_ASSERT("tcp_enqueue: pbufs on queue => at least one queue non-empty",
  80ba41:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80ba45:	75 ae                	jne    80b9f5 <tcp_enqueue+0xcd>
  80ba47:	c7 44 24 08 e4 3f 81 	movl   $0x813fe4,0x8(%esp)
  80ba4e:	00 
  80ba4f:	c7 44 24 04 ae 00 00 	movl   $0xae,0x4(%esp)
  80ba56:	00 
  80ba57:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80ba5e:	e8 71 4f ff ff       	call   8009d4 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  } else {
    LWIP_ASSERT("tcp_enqueue: no pbufs on queue => both queues empty",
  80ba63:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80ba67:	75 06                	jne    80ba6f <tcp_enqueue+0x147>
  80ba69:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80ba6d:	74 86                	je     80b9f5 <tcp_enqueue+0xcd>
  80ba6f:	c7 44 24 08 20 40 81 	movl   $0x814020,0x8(%esp)
  80ba76:	00 
  80ba77:	c7 44 24 04 b1 00 00 	movl   $0xb1,0x4(%esp)
  80ba7e:	00 
  80ba7f:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80ba86:	e8 49 4f ff ff       	call   8009d4 <_panic>
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
    seqno += seglen;
  80ba8b:	0f b7 f6             	movzwl %si,%esi
  80ba8e:	01 75 d8             	add    %esi,-0x28(%ebp)
    ptr = (void *)((u8_t *)ptr + seglen);
  80ba91:	01 75 d0             	add    %esi,-0x30(%ebp)
  80ba94:	89 de                	mov    %ebx,%esi
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80ba96:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80ba99:	0f b7 78 34          	movzwl 0x34(%eax),%edi

    /* Allocate memory for tcp_seg, and fill in fields. */
    seg = memp_malloc(MEMP_TCP_SEG);
  80ba9d:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80baa4:	e8 5b bd ff ff       	call   807804 <memp_malloc>
  80baa9:	89 c3                	mov    %eax,%ebx
    if (seg == NULL) {
  80baab:	85 c0                	test   %eax,%eax
  80baad:	0f 84 d8 04 00 00    	je     80bf8b <tcp_enqueue+0x663>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for tcp_seg\n"));
      goto memerr;
    }
    seg->next = NULL;
  80bab3:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
    seg->p = NULL;
  80bab9:	c7 40 04 00 00 00 00 	movl   $0x0,0x4(%eax)

    /* first segment of to-be-queued data? */
    if (queue == NULL) {
  80bac0:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bac4:	75 05                	jne    80bacb <tcp_enqueue+0x1a3>
  80bac6:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80bac9:	eb 22                	jmp    80baed <tcp_enqueue+0x1c5>
      queue = seg;
    }
    /* subsequent segments of to-be-queued data */
    else {
      /* Attach the segment to the end of the queued segments */
      LWIP_ASSERT("useg != NULL", useg != NULL);
  80bacb:	85 f6                	test   %esi,%esi
  80bacd:	75 1c                	jne    80baeb <tcp_enqueue+0x1c3>
  80bacf:	c7 44 24 08 ff 40 81 	movl   $0x8140ff,0x8(%esp)
  80bad6:	00 
  80bad7:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80bade:	00 
  80badf:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80bae6:	e8 e9 4e ff ff       	call   8009d4 <_panic>
      useg->next = seg;
  80baeb:	89 06                	mov    %eax,(%esi)
  seglen = 0;
  while (queue == NULL || left > 0) {

    /* The segment length should be the MSS if the data to be enqueued
     * is larger than the MSS. */
    seglen = left > pcb->mss? pcb->mss: left;
  80baed:	0f b7 75 e4          	movzwl -0x1c(%ebp),%esi
  80baf1:	66 39 fe             	cmp    %di,%si
  80baf4:	76 02                	jbe    80baf8 <tcp_enqueue+0x1d0>
  80baf6:	89 fe                	mov    %edi,%esi
     * and data copied into pbuf, otherwise data comes from
     * ROM or other static memory, and need not be copied. If
     * optdata is != NULL, we have options instead of data. */
     
    /* options? */
    if (optdata != NULL) {
  80baf8:	80 7d cb 00          	cmpb   $0x0,-0x35(%ebp)
  80bafc:	74 69                	je     80bb67 <tcp_enqueue+0x23f>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, optlen, PBUF_RAM)) == NULL) {
  80bafe:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bb05:	00 
  80bb06:	8b 55 cc             	mov    -0x34(%ebp),%edx
  80bb09:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bb0d:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bb14:	e8 fa c6 ff ff       	call   808213 <pbuf_alloc>
  80bb19:	89 43 04             	mov    %eax,0x4(%ebx)
  80bb1c:	85 c0                	test   %eax,%eax
  80bb1e:	0f 84 6c 04 00 00    	je     80bf90 <tcp_enqueue+0x668>
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold optlen",
  80bb24:	0f b7 4d c4          	movzwl -0x3c(%ebp),%ecx
  80bb28:	66 39 48 0a          	cmp    %cx,0xa(%eax)
  80bb2c:	73 1c                	jae    80bb4a <tcp_enqueue+0x222>
  80bb2e:	c7 44 24 08 54 40 81 	movl   $0x814054,0x8(%esp)
  80bb35:	00 
  80bb36:	c7 44 24 04 df 00 00 	movl   $0xdf,0x4(%esp)
  80bb3d:	00 
  80bb3e:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80bb45:	e8 8a 4e ff ff       	call   8009d4 <_panic>
                  (seg->p->len >= optlen));
      queuelen += pbuf_clen(seg->p);
  80bb4a:	89 04 24             	mov    %eax,(%esp)
  80bb4d:	e8 9e bf ff ff       	call   807af0 <pbuf_clen>
  80bb52:	0f b6 c0             	movzbl %al,%eax
  80bb55:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      seg->dataptr = seg->p->payload;
  80bb59:	8b 43 04             	mov    0x4(%ebx),%eax
  80bb5c:	8b 40 04             	mov    0x4(%eax),%eax
  80bb5f:	89 43 08             	mov    %eax,0x8(%ebx)
  80bb62:	e9 1e 01 00 00       	jmp    80bc85 <tcp_enqueue+0x35d>
    }
    /* copy from volatile memory? */
    else if (apiflags & TCP_WRITE_FLAG_COPY) {
  80bb67:	83 7d bc 00          	cmpl   $0x0,-0x44(%ebp)
  80bb6b:	0f 84 8b 00 00 00    	je     80bbfc <tcp_enqueue+0x2d4>
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_RAM)) == NULL) {
  80bb71:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bb78:	00 
  80bb79:	0f b7 c6             	movzwl %si,%eax
  80bb7c:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bb80:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bb87:	e8 87 c6 ff ff       	call   808213 <pbuf_alloc>
  80bb8c:	89 43 04             	mov    %eax,0x4(%ebx)
  80bb8f:	85 c0                	test   %eax,%eax
  80bb91:	0f 84 fe 03 00 00    	je     80bf95 <tcp_enqueue+0x66d>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
  80bb97:	66 3b 70 0a          	cmp    0xa(%eax),%si
  80bb9b:	76 1c                	jbe    80bbb9 <tcp_enqueue+0x291>
  80bb9d:	c7 44 24 08 7c 40 81 	movl   $0x81407c,0x8(%esp)
  80bba4:	00 
  80bba5:	c7 44 24 04 ea 00 00 	movl   $0xea,0x4(%esp)
  80bbac:	00 
  80bbad:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80bbb4:	e8 1b 4e ff ff       	call   8009d4 <_panic>
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80bbb9:	89 04 24             	mov    %eax,(%esp)
  80bbbc:	e8 2f bf ff ff       	call   807af0 <pbuf_clen>
  80bbc1:	89 c7                	mov    %eax,%edi
      if (arg != NULL) {
  80bbc3:	80 7d c1 00          	cmpb   $0x0,-0x3f(%ebp)
  80bbc7:	74 1c                	je     80bbe5 <tcp_enqueue+0x2bd>
        MEMCPY(seg->p->payload, ptr, seglen);
  80bbc9:	0f b7 c6             	movzwl %si,%eax
  80bbcc:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bbd0:	8b 45 d0             	mov    -0x30(%ebp),%eax
  80bbd3:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bbd7:	8b 43 04             	mov    0x4(%ebx),%eax
  80bbda:	8b 40 04             	mov    0x4(%eax),%eax
  80bbdd:	89 04 24             	mov    %eax,(%esp)
  80bbe0:	e8 ac 57 ff ff       	call   801391 <memcpy>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue : could not allocate memory for pbuf copy size %"U16_F"\n", seglen));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold the complete seglen",
                  (seg->p->len >= seglen));
      queuelen += pbuf_clen(seg->p);
  80bbe5:	89 fa                	mov    %edi,%edx
  80bbe7:	0f b6 c2             	movzbl %dl,%eax
  80bbea:	66 01 45 e2          	add    %ax,-0x1e(%ebp)
      if (arg != NULL) {
        MEMCPY(seg->p->payload, ptr, seglen);
      }
      seg->dataptr = seg->p->payload;
  80bbee:	8b 43 04             	mov    0x4(%ebx),%eax
  80bbf1:	8b 40 04             	mov    0x4(%eax),%eax
  80bbf4:	89 43 08             	mov    %eax,0x8(%ebx)
  80bbf7:	e9 89 00 00 00       	jmp    80bc85 <tcp_enqueue+0x35d>
      /* First, allocate a pbuf for holding the data.
       * since the referenced data is available at least until it is sent out on the
       * link (as it has to be ACKed by the remote party) we can safely use PBUF_ROM
       * instead of PBUF_REF here.
       */
      if ((p = pbuf_alloc(PBUF_TRANSPORT, seglen, PBUF_ROM)) == NULL) {
  80bbfc:	c7 44 24 08 01 00 00 	movl   $0x1,0x8(%esp)
  80bc03:	00 
  80bc04:	0f b7 c6             	movzwl %si,%eax
  80bc07:	89 44 24 04          	mov    %eax,0x4(%esp)
  80bc0b:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bc12:	e8 fc c5 ff ff       	call   808213 <pbuf_alloc>
  80bc17:	89 c7                	mov    %eax,%edi
  80bc19:	85 c0                	test   %eax,%eax
  80bc1b:	0f 84 79 03 00 00    	je     80bf9a <tcp_enqueue+0x672>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for zero-copy pbuf\n"));
        goto memerr;
      }
      ++queuelen;
      /* reference the non-volatile payload data */
      p->payload = ptr;
  80bc21:	8b 4d d0             	mov    -0x30(%ebp),%ecx
  80bc24:	89 48 04             	mov    %ecx,0x4(%eax)
      seg->dataptr = ptr;
  80bc27:	89 4b 08             	mov    %ecx,0x8(%ebx)

      /* Second, allocate a pbuf for the headers. */
      if ((seg->p = pbuf_alloc(PBUF_TRANSPORT, 0, PBUF_RAM)) == NULL) {
  80bc2a:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80bc31:	00 
  80bc32:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80bc39:	00 
  80bc3a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80bc41:	e8 cd c5 ff ff       	call   808213 <pbuf_alloc>
  80bc46:	89 43 04             	mov    %eax,0x4(%ebx)
  80bc49:	85 c0                	test   %eax,%eax
  80bc4b:	75 12                	jne    80bc5f <tcp_enqueue+0x337>
  80bc4d:	89 fb                	mov    %edi,%ebx
  80bc4f:	8b 7d dc             	mov    -0x24(%ebp),%edi
        /* If allocation fails, we have to deallocate the data pbuf as
         * well. */
        pbuf_free(p);
  80bc52:	89 1c 24             	mov    %ebx,(%esp)
  80bc55:	e8 fe c2 ff ff       	call   807f58 <pbuf_free>
        LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: could not allocate memory for header pbuf\n"));
        goto memerr;
  80bc5a:	e9 4b 03 00 00       	jmp    80bfaa <tcp_enqueue+0x682>
      }
      queuelen += pbuf_clen(seg->p);
  80bc5f:	89 04 24             	mov    %eax,(%esp)
  80bc62:	e8 89 be ff ff       	call   807af0 <pbuf_clen>
  80bc67:	0f b6 c0             	movzbl %al,%eax
  80bc6a:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80bc6e:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  80bc72:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)

      /* Concatenate the headers and data pbufs together. */
      pbuf_cat(seg->p/*header*/, p/*data*/);
  80bc76:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80bc7a:	8b 43 04             	mov    0x4(%ebx),%eax
  80bc7d:	89 04 24             	mov    %eax,(%esp)
  80bc80:	e8 96 be ff ff       	call   807b1b <pbuf_cat>
      p = NULL;
    }

    /* Now that there are more segments queued, we check again if the
    length of the queue exceeds the configured maximum or overflows. */
    if ((queuelen > TCP_SND_QUEUELEN) || (queuelen > TCP_SNDQUEUELEN_OVERFLOW)) {
  80bc85:	66 83 7d e2 20       	cmpw   $0x20,-0x1e(%ebp)
  80bc8a:	0f 87 12 03 00 00    	ja     80bfa2 <tcp_enqueue+0x67a>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: queue too long %"U16_F" (%"U16_F")\n", queuelen, TCP_SND_QUEUELEN));
      goto memerr;
    }

    seg->len = seglen;
  80bc90:	66 89 73 0c          	mov    %si,0xc(%ebx)

    /* build TCP header */
    if (pbuf_header(seg->p, TCP_HLEN)) {
  80bc94:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  80bc9b:	00 
  80bc9c:	8b 43 04             	mov    0x4(%ebx),%eax
  80bc9f:	89 04 24             	mov    %eax,(%esp)
  80bca2:	e8 3c bf ff ff       	call   807be3 <pbuf_header>
  80bca7:	84 c0                	test   %al,%al
  80bca9:	0f 85 f8 02 00 00    	jne    80bfa7 <tcp_enqueue+0x67f>
      LWIP_DEBUGF(TCP_OUTPUT_DEBUG | 2, ("tcp_enqueue: no room for TCP header in pbuf.\n"));
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    seg->tcphdr = seg->p->payload;
  80bcaf:	8b 43 04             	mov    0x4(%ebx),%eax
  80bcb2:	8b 78 04             	mov    0x4(%eax),%edi
  80bcb5:	89 7b 10             	mov    %edi,0x10(%ebx)
    seg->tcphdr->src = htons(pcb->local_port);
  80bcb8:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80bcbb:	0f b7 41 1c          	movzwl 0x1c(%ecx),%eax
  80bcbf:	89 04 24             	mov    %eax,(%esp)
  80bcc2:	e8 8d f0 ff ff       	call   80ad54 <htons>
  80bcc7:	66 89 07             	mov    %ax,(%edi)
    seg->tcphdr->dest = htons(pcb->remote_port);
  80bcca:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bccd:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80bcd0:	0f b7 42 1e          	movzwl 0x1e(%edx),%eax
  80bcd4:	89 04 24             	mov    %eax,(%esp)
  80bcd7:	e8 78 f0 ff ff       	call   80ad54 <htons>
  80bcdc:	66 89 47 02          	mov    %ax,0x2(%edi)
    seg->tcphdr->seqno = htonl(seqno);
  80bce0:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bce3:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80bce6:	89 0c 24             	mov    %ecx,(%esp)
  80bce9:	e8 87 f0 ff ff       	call   80ad75 <htonl>
  80bcee:	89 47 04             	mov    %eax,0x4(%edi)
    seg->tcphdr->urgp = 0;
  80bcf1:	8b 43 10             	mov    0x10(%ebx),%eax
  80bcf4:	66 c7 40 12 00 00    	movw   $0x0,0x12(%eax)
    TCPH_FLAGS_SET(seg->tcphdr, flags);
  80bcfa:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bcfd:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bd01:	89 04 24             	mov    %eax,(%esp)
  80bd04:	e8 58 f0 ff ff       	call   80ad61 <ntohs>
  80bd09:	83 e0 c0             	and    $0xffffffc0,%eax
  80bd0c:	66 0b 45 c8          	or     -0x38(%ebp),%ax
  80bd10:	0f b7 c0             	movzwl %ax,%eax
  80bd13:	89 04 24             	mov    %eax,(%esp)
  80bd16:	e8 39 f0 ff ff       	call   80ad54 <htons>
  80bd1b:	66 89 47 0c          	mov    %ax,0xc(%edi)
    /* don't fill in tcphdr->ackno and tcphdr->wnd until later */

    /* Copy the options into the header, if they are present. */
    if (optdata == NULL) {
  80bd1f:	83 7d 1c 00          	cmpl   $0x0,0x1c(%ebp)
  80bd23:	75 23                	jne    80bd48 <tcp_enqueue+0x420>
      TCPH_HDRLEN_SET(seg->tcphdr, 5);
  80bd25:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bd28:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bd2c:	89 04 24             	mov    %eax,(%esp)
  80bd2f:	e8 2d f0 ff ff       	call   80ad61 <ntohs>
  80bd34:	83 e0 3f             	and    $0x3f,%eax
  80bd37:	80 cc 50             	or     $0x50,%ah
  80bd3a:	89 04 24             	mov    %eax,(%esp)
  80bd3d:	e8 12 f0 ff ff       	call   80ad54 <htons>
  80bd42:	66 89 47 0c          	mov    %ax,0xc(%edi)
  80bd46:	eb 3e                	jmp    80bd86 <tcp_enqueue+0x45e>
    }
    else {
      TCPH_HDRLEN_SET(seg->tcphdr, (5 + optlen / 4));
  80bd48:	8b 7b 10             	mov    0x10(%ebx),%edi
  80bd4b:	0f b7 47 0c          	movzwl 0xc(%edi),%eax
  80bd4f:	89 04 24             	mov    %eax,(%esp)
  80bd52:	e8 0a f0 ff ff       	call   80ad61 <ntohs>
  80bd57:	83 e0 3f             	and    $0x3f,%eax
  80bd5a:	66 0b 45 c6          	or     -0x3a(%ebp),%ax
  80bd5e:	0f b7 c0             	movzwl %ax,%eax
  80bd61:	89 04 24             	mov    %eax,(%esp)
  80bd64:	e8 eb ef ff ff       	call   80ad54 <htons>
  80bd69:	66 89 47 0c          	mov    %ax,0xc(%edi)
      /* Copy options into data portion of segment.
       Options can thus only be sent in non data carrying
       segments such as SYN|ACK. */
      SMEMCPY(seg->dataptr, optdata, optlen);
  80bd6d:	8b 45 cc             	mov    -0x34(%ebp),%eax
  80bd70:	89 44 24 08          	mov    %eax,0x8(%esp)
  80bd74:	8b 55 1c             	mov    0x1c(%ebp),%edx
  80bd77:	89 54 24 04          	mov    %edx,0x4(%esp)
  80bd7b:	8b 43 08             	mov    0x8(%ebx),%eax
  80bd7e:	89 04 24             	mov    %eax,(%esp)
  80bd81:	e8 0b 56 ff ff       	call   801391 <memcpy>
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE, ("tcp_enqueue: queueing %"U32_F":%"U32_F" (0x%"X16_F")\n",
      ntohl(seg->tcphdr->seqno),
      ntohl(seg->tcphdr->seqno) + TCP_TCPLEN(seg),
      (u16_t)flags));

    left -= seglen;
  80bd86:	66 29 75 e4          	sub    %si,-0x1c(%ebp)

  /* First, break up the data into segments and tuck them together in
   * the local "queue" variable. */
  useg = queue = seg = NULL;
  seglen = 0;
  while (queue == NULL || left > 0) {
  80bd8a:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bd8e:	0f 84 f7 fc ff ff    	je     80ba8b <tcp_enqueue+0x163>
  80bd94:	66 83 7d e4 00       	cmpw   $0x0,-0x1c(%ebp)
  80bd99:	0f 85 ec fc ff ff    	jne    80ba8b <tcp_enqueue+0x163>
  80bd9f:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bda2:	89 5d d8             	mov    %ebx,-0x28(%ebp)
  }

  /* Now that the data to be enqueued has been broken up into TCP
  segments in the queue variable, we add them to the end of the
  pcb->unsent queue. */
  if (pcb->unsent == NULL) {
  80bda5:	8b 4f 74             	mov    0x74(%edi),%ecx
  80bda8:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  80bdab:	85 c9                	test   %ecx,%ecx
  80bdad:	0f 84 1f 01 00 00    	je     80bed2 <tcp_enqueue+0x5aa>
  80bdb3:	89 ca                	mov    %ecx,%edx
    useg = NULL;
  }
  else {
    for (useg = pcb->unsent; useg->next != NULL; useg = useg->next);
  80bdb5:	89 d0                	mov    %edx,%eax
  80bdb7:	8b 12                	mov    (%edx),%edx
  80bdb9:	85 d2                	test   %edx,%edx
  80bdbb:	75 f8                	jne    80bdb5 <tcp_enqueue+0x48d>
  80bdbd:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bdc0:	85 c0                	test   %eax,%eax
  80bdc2:	0f 84 0a 01 00 00    	je     80bed2 <tcp_enqueue+0x5aa>
    TCP_TCPLEN(useg) != 0 &&
  80bdc8:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bdcc:	66 89 45 dc          	mov    %ax,-0x24(%ebp)
  80bdd0:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80bdd3:	8b 42 10             	mov    0x10(%edx),%eax
  80bdd6:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bdda:	89 04 24             	mov    %eax,(%esp)
  80bddd:	e8 7f ef ff ff       	call   80ad61 <ntohs>
  80bde2:	a8 01                	test   $0x1,%al
  80bde4:	75 1b                	jne    80be01 <tcp_enqueue+0x4d9>
  80bde6:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80bde9:	8b 41 10             	mov    0x10(%ecx),%eax
  80bdec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80bdf0:	89 04 24             	mov    %eax,(%esp)
  80bdf3:	e8 69 ef ff ff       	call   80ad61 <ntohs>
  80bdf8:	ba 00 00 00 00       	mov    $0x0,%edx
  80bdfd:	a8 02                	test   $0x2,%al
  80bdff:	74 05                	je     80be06 <tcp_enqueue+0x4de>
  80be01:	ba 01 00 00 00       	mov    $0x1,%edx
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80be06:	0f b7 45 dc          	movzwl -0x24(%ebp),%eax
  80be0a:	01 c2                	add    %eax,%edx
  80be0c:	0f 84 f0 01 00 00    	je     80c002 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
  80be12:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80be15:	8b 42 10             	mov    0x10(%edx),%eax
  80be18:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80be1c:	89 04 24             	mov    %eax,(%esp)
  80be1f:	e8 3d ef ff ff       	call   80ad61 <ntohs>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80be24:	a8 03                	test   $0x3,%al
  80be26:	0f 85 d6 01 00 00    	jne    80c002 <tcp_enqueue+0x6da>
  80be2c:	f6 45 bb 03          	testb  $0x3,-0x45(%ebp)
  80be30:	0f 85 cc 01 00 00    	jne    80c002 <tcp_enqueue+0x6da>
    TCP_TCPLEN(useg) != 0 &&
    !(TCPH_FLAGS(useg->tcphdr) & (TCP_SYN | TCP_FIN)) &&
    !(flags & (TCP_SYN | TCP_FIN)) &&
    /* fit within max seg size */
    useg->len + queue->len <= pcb->mss) {
  80be36:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80be39:	0f b7 51 0c          	movzwl 0xc(%ecx),%edx
  80be3d:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80be40:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80be44:	01 c2                	add    %eax,%edx
  80be46:	0f b7 47 34          	movzwl 0x34(%edi),%eax
  80be4a:	39 c2                	cmp    %eax,%edx
  80be4c:	0f 8f b0 01 00 00    	jg     80c002 <tcp_enqueue+0x6da>
    /* Remove TCP header from first segment of our to-be-queued list */
    if(pbuf_header(queue->p, -TCP_HLEN)) {
  80be52:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  80be59:	ff 
  80be5a:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80be5d:	8b 42 04             	mov    0x4(%edx),%eax
  80be60:	89 04 24             	mov    %eax,(%esp)
  80be63:	e8 7b bd ff ff       	call   807be3 <pbuf_header>
  80be68:	84 c0                	test   %al,%al
  80be6a:	74 1c                	je     80be88 <tcp_enqueue+0x560>
      /* Can we cope with this failing?  Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80be6c:	c7 44 24 08 0c 41 81 	movl   $0x81410c,0x8(%esp)
  80be73:	00 
  80be74:	c7 44 24 04 52 01 00 	movl   $0x152,0x4(%esp)
  80be7b:	00 
  80be7c:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80be83:	e8 4c 4b ff ff       	call   8009d4 <_panic>
      TCP_STATS_INC(tcp.err);
      goto memerr;
    }
    pbuf_cat(useg->p, queue->p);
  80be88:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80be8b:	8b 41 04             	mov    0x4(%ecx),%eax
  80be8e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80be92:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80be95:	8b 42 04             	mov    0x4(%edx),%eax
  80be98:	89 04 24             	mov    %eax,(%esp)
  80be9b:	e8 7b bc ff ff       	call   807b1b <pbuf_cat>
    useg->len += queue->len;
  80bea0:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bea3:	0f b7 41 0c          	movzwl 0xc(%ecx),%eax
  80bea7:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80beaa:	66 01 42 0c          	add    %ax,0xc(%edx)
    useg->next = queue->next;
  80beae:	8b 01                	mov    (%ecx),%eax
  80beb0:	89 02                	mov    %eax,(%edx)

    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_TRACE | LWIP_DBG_STATE, ("tcp_enqueue: chaining segments, new len %"U16_F"\n", useg->len));
    if (seg == queue) {
  80beb2:	39 4d d8             	cmp    %ecx,-0x28(%ebp)
  80beb5:	0f 94 c0             	sete   %al
  80beb8:	0f b6 c0             	movzbl %al,%eax
  80bebb:	83 e8 01             	sub    $0x1,%eax
  80bebe:	21 c3                	and    %eax,%ebx
      seg = NULL;
    }
    memp_free(MEMP_TCP_SEG, queue);
  80bec0:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80bec4:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  80becb:	e8 f0 b8 ff ff       	call   8077c0 <memp_free>
  }
  /* { useg is last segment on the unsent queue, NULL if list is empty } */

  /* If there is room in the last pbuf on the unsent queue,
  chain the first pbuf on the queue together with that. */
  if (useg != NULL &&
  80bed0:	eb 06                	jmp    80bed8 <tcp_enqueue+0x5b0>
  }
  else {
    /* empty list */
    if (useg == NULL) {
      /* initialize list with this segment */
      pcb->unsent = queue;
  80bed2:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bed5:	89 4f 74             	mov    %ecx,0x74(%edi)
    /* enqueue segment */
    else {
      useg->next = queue;
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
  80bed8:	f6 45 bb 02          	testb  $0x2,-0x45(%ebp)
  80bedc:	75 0c                	jne    80beea <tcp_enqueue+0x5c2>
  80bede:	f6 45 bb 01          	testb  $0x1,-0x45(%ebp)
  80bee2:	0f 85 27 01 00 00    	jne    80c00f <tcp_enqueue+0x6e7>
  80bee8:	eb 0f                	jmp    80bef9 <tcp_enqueue+0x5d1>
    ++len;
  80beea:	66 83 45 c2 01       	addw   $0x1,-0x3e(%ebp)
  }
  if (flags & TCP_FIN) {
  80beef:	f6 45 bb 01          	testb  $0x1,-0x45(%ebp)
  80bef3:	74 04                	je     80bef9 <tcp_enqueue+0x5d1>
    pcb->flags |= TF_FIN;
  80bef5:	80 4f 20 20          	orb    $0x20,0x20(%edi)
  }
  pcb->snd_lbb += len;
  80bef9:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  80befd:	01 47 68             	add    %eax,0x68(%edi)

  pcb->snd_buf -= len;
  80bf00:	0f b7 45 c2          	movzwl -0x3e(%ebp),%eax
  80bf04:	66 29 47 6e          	sub    %ax,0x6e(%edi)

  /* update number of segments on the queues */
  pcb->snd_queuelen = queuelen;
  80bf08:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80bf0c:	66 89 57 70          	mov    %dx,0x70(%edi)
  LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_enqueue: %"S16_F" (after enqueued)\n", pcb->snd_queuelen));
  if (pcb->snd_queuelen != 0) {
  80bf10:	66 85 d2             	test   %dx,%dx
  80bf13:	74 28                	je     80bf3d <tcp_enqueue+0x615>
    LWIP_ASSERT("tcp_enqueue: valid queue length",
  80bf15:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80bf19:	75 22                	jne    80bf3d <tcp_enqueue+0x615>
  80bf1b:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80bf1f:	75 1c                	jne    80bf3d <tcp_enqueue+0x615>
  80bf21:	c7 44 24 08 b0 40 81 	movl   $0x8140b0,0x8(%esp)
  80bf28:	00 
  80bf29:	c7 44 24 04 7a 01 00 	movl   $0x17a,0x4(%esp)
  80bf30:	00 
  80bf31:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80bf38:	e8 97 4a ff ff       	call   8009d4 <_panic>
      pcb->unacked != NULL || pcb->unsent != NULL);
  }

  /* Set the PSH flag in the last segment that we enqueued, but only
  if the segment has data (indicated by seglen > 0). */
  if (seg != NULL && seglen > 0 && seg->tcphdr != NULL && ((apiflags & TCP_WRITE_FLAG_MORE)==0)) {
  80bf3d:	85 db                	test   %ebx,%ebx
  80bf3f:	0f 84 b0 00 00 00    	je     80bff5 <tcp_enqueue+0x6cd>
  80bf45:	66 85 f6             	test   %si,%si
  80bf48:	0f 84 a7 00 00 00    	je     80bff5 <tcp_enqueue+0x6cd>
  80bf4e:	8b 5b 10             	mov    0x10(%ebx),%ebx
  80bf51:	85 db                	test   %ebx,%ebx
  80bf53:	0f 84 9c 00 00 00    	je     80bff5 <tcp_enqueue+0x6cd>
  80bf59:	f6 45 a8 02          	testb  $0x2,-0x58(%ebp)
  80bf5d:	8d 76 00             	lea    0x0(%esi),%esi
  80bf60:	0f 85 8f 00 00 00    	jne    80bff5 <tcp_enqueue+0x6cd>
    TCPH_SET_FLAG(seg->tcphdr, TCP_PSH);
  80bf66:	0f b7 43 0c          	movzwl 0xc(%ebx),%eax
  80bf6a:	89 04 24             	mov    %eax,(%esp)
  80bf6d:	e8 ef ed ff ff       	call   80ad61 <ntohs>
  80bf72:	83 c8 08             	or     $0x8,%eax
  80bf75:	0f b7 c0             	movzwl %ax,%eax
  80bf78:	89 04 24             	mov    %eax,(%esp)
  80bf7b:	e8 d4 ed ff ff       	call   80ad54 <htons>
  80bf80:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  80bf84:	b8 00 00 00 00       	mov    $0x0,%eax
  80bf89:	eb 6f                	jmp    80bffa <tcp_enqueue+0x6d2>
  80bf8b:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf8e:	eb 1a                	jmp    80bfaa <tcp_enqueue+0x682>
  80bf90:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf93:	eb 15                	jmp    80bfaa <tcp_enqueue+0x682>
  80bf95:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf98:	eb 10                	jmp    80bfaa <tcp_enqueue+0x682>
  80bf9a:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bf9d:	8d 76 00             	lea    0x0(%esi),%esi
  80bfa0:	eb 08                	jmp    80bfaa <tcp_enqueue+0x682>
  80bfa2:	8b 7d dc             	mov    -0x24(%ebp),%edi
  80bfa5:	eb 03                	jmp    80bfaa <tcp_enqueue+0x682>
  80bfa7:	8b 7d dc             	mov    -0x24(%ebp),%edi
  }

  return ERR_OK;
memerr:
  pcb->flags |= TF_NAGLEMEMERR;
  80bfaa:	80 4f 20 80          	orb    $0x80,0x20(%edi)
  TCP_STATS_INC(tcp.memerr);

  if (queue != NULL) {
  80bfae:	83 7d d4 00          	cmpl   $0x0,-0x2c(%ebp)
  80bfb2:	74 0b                	je     80bfbf <tcp_enqueue+0x697>
    tcp_segs_free(queue);
  80bfb4:	8b 4d d4             	mov    -0x2c(%ebp),%ecx
  80bfb7:	89 0c 24             	mov    %ecx,(%esp)
  80bfba:	e8 57 cb ff ff       	call   808b16 <tcp_segs_free>
  }
  if (pcb->snd_queuelen != 0) {
  80bfbf:	66 83 7f 70 00       	cmpw   $0x0,0x70(%edi)
  80bfc4:	74 28                	je     80bfee <tcp_enqueue+0x6c6>
    LWIP_ASSERT("tcp_enqueue: valid queue length", pcb->unacked != NULL ||
  80bfc6:	83 7f 78 00          	cmpl   $0x0,0x78(%edi)
  80bfca:	75 22                	jne    80bfee <tcp_enqueue+0x6c6>
  80bfcc:	83 7f 74 00          	cmpl   $0x0,0x74(%edi)
  80bfd0:	75 1c                	jne    80bfee <tcp_enqueue+0x6c6>
  80bfd2:	c7 44 24 08 b0 40 81 	movl   $0x8140b0,0x8(%esp)
  80bfd9:	00 
  80bfda:	c7 44 24 04 8d 01 00 	movl   $0x18d,0x4(%esp)
  80bfe1:	00 
  80bfe2:	c7 04 24 d0 40 81 00 	movl   $0x8140d0,(%esp)
  80bfe9:	e8 e6 49 ff ff       	call   8009d4 <_panic>
  80bfee:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80bff3:	eb 05                	jmp    80bffa <tcp_enqueue+0x6d2>
  80bff5:	b8 00 00 00 00       	mov    $0x0,%eax
      pcb->unsent != NULL);
  }
  LWIP_DEBUGF(TCP_QLEN_DEBUG | LWIP_DBG_STATE, ("tcp_enqueue: %"S16_F" (with mem err)\n", pcb->snd_queuelen));
  return ERR_MEM;
}
  80bffa:	83 c4 5c             	add    $0x5c,%esp
  80bffd:	5b                   	pop    %ebx
  80bffe:	5e                   	pop    %esi
  80bfff:	5f                   	pop    %edi
  80c000:	5d                   	pop    %ebp
  80c001:	c3                   	ret    
      /* initialize list with this segment */
      pcb->unsent = queue;
    }
    /* enqueue segment */
    else {
      useg->next = queue;
  80c002:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c005:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c008:	89 10                	mov    %edx,(%eax)
  80c00a:	e9 c9 fe ff ff       	jmp    80bed8 <tcp_enqueue+0x5b0>
    }
  }
  if ((flags & TCP_SYN) || (flags & TCP_FIN)) {
    ++len;
  80c00f:	66 83 45 c2 01       	addw   $0x1,-0x3e(%ebp)
  80c014:	e9 dc fe ff ff       	jmp    80bef5 <tcp_enqueue+0x5cd>

0080c019 <tcp_write>:
 * 
 * @see tcp_write()
 */
err_t
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  80c019:	55                   	push   %ebp
  80c01a:	89 e5                	mov    %esp,%ebp
  80c01c:	83 ec 28             	sub    $0x28,%esp
  80c01f:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c022:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c025:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c028:	0f b7 5d 10          	movzwl 0x10(%ebp),%ebx
  80c02c:	0f b6 75 14          	movzbl 0x14(%ebp),%esi
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
     pcb->state == CLOSE_WAIT ||
  80c030:	8b 51 10             	mov    0x10(%ecx),%edx
tcp_write(struct tcp_pcb *pcb, const void *data, u16_t len, u8_t apiflags)
{
  LWIP_DEBUGF(TCP_OUTPUT_DEBUG, ("tcp_write(pcb=%p, data=%p, len=%"U16_F", apiflags=%"U16_F")\n", (void *)pcb,
    data, len, (u16_t)apiflags));
  /* connection is in valid state for data transmission? */
  if (pcb->state == ESTABLISHED ||
  80c033:	83 fa 04             	cmp    $0x4,%edx
  80c036:	74 14                	je     80c04c <tcp_write+0x33>
  80c038:	83 fa 07             	cmp    $0x7,%edx
  80c03b:	74 0f                	je     80c04c <tcp_write+0x33>
  80c03d:	83 fa 02             	cmp    $0x2,%edx
  80c040:	74 0a                	je     80c04c <tcp_write+0x33>
  80c042:	b8 f8 ff ff ff       	mov    $0xfffffff8,%eax
  80c047:	83 fa 03             	cmp    $0x3,%edx
  80c04a:	75 42                	jne    80c08e <tcp_write+0x75>
     pcb->state == CLOSE_WAIT ||
     pcb->state == SYN_SENT ||
     pcb->state == SYN_RCVD) {
    if (len > 0) {
  80c04c:	b8 00 00 00 00       	mov    $0x0,%eax
  80c051:	66 85 db             	test   %bx,%bx
  80c054:	74 38                	je     80c08e <tcp_write+0x75>
      return tcp_enqueue(pcb, (void *)data, len, 0, apiflags, NULL, 0);
  80c056:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80c05d:	00 
  80c05e:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80c065:	00 
  80c066:	81 e6 ff 00 00 00    	and    $0xff,%esi
  80c06c:	89 74 24 10          	mov    %esi,0x10(%esp)
  80c070:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  80c077:	00 
  80c078:	0f b7 db             	movzwl %bx,%ebx
  80c07b:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80c07f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c082:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c086:	89 0c 24             	mov    %ecx,(%esp)
  80c089:	e8 9a f8 ff ff       	call   80b928 <tcp_enqueue>
    return ERR_OK;
  } else {
    LWIP_DEBUGF(TCP_OUTPUT_DEBUG | LWIP_DBG_STATE | 3, ("tcp_write() called in invalid state\n"));
    return ERR_CONN;
  }
}
  80c08e:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c091:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c094:	89 ec                	mov    %ebp,%esp
  80c096:	5d                   	pop    %ebp
  80c097:	c3                   	ret    

0080c098 <tcp_send_ctrl>:
 * @param flags the flags to set in the segment header
 * @return ERR_OK if sent, another err_t otherwise
 */
err_t
tcp_send_ctrl(struct tcp_pcb *pcb, u8_t flags)
{
  80c098:	55                   	push   %ebp
  80c099:	89 e5                	mov    %esp,%ebp
  80c09b:	83 ec 28             	sub    $0x28,%esp
  /* no data, no length, flags, copy=1, no optdata, no optdatalen */
  return tcp_enqueue(pcb, NULL, 0, flags, TCP_WRITE_FLAG_COPY, NULL, 0);
  80c09e:	c7 44 24 18 00 00 00 	movl   $0x0,0x18(%esp)
  80c0a5:	00 
  80c0a6:	c7 44 24 14 00 00 00 	movl   $0x0,0x14(%esp)
  80c0ad:	00 
  80c0ae:	c7 44 24 10 01 00 00 	movl   $0x1,0x10(%esp)
  80c0b5:	00 
  80c0b6:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  80c0ba:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c0be:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c0c5:	00 
  80c0c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c0cd:	00 
  80c0ce:	8b 45 08             	mov    0x8(%ebp),%eax
  80c0d1:	89 04 24             	mov    %eax,(%esp)
  80c0d4:	e8 4f f8 ff ff       	call   80b928 <tcp_enqueue>
}
  80c0d9:	c9                   	leave  
  80c0da:	c3                   	ret    
  80c0db:	00 00                	add    %al,(%eax)
  80c0dd:	00 00                	add    %al,(%eax)
	...

0080c0e0 <udp_disconnect>:
 *
 * @param pcb the udp pcb to disconnect.
 */
void
udp_disconnect(struct udp_pcb *pcb)
{
  80c0e0:	55                   	push   %ebp
  80c0e1:	89 e5                	mov    %esp,%ebp
  80c0e3:	8b 45 08             	mov    0x8(%ebp),%eax
  /* reset remote address association */
  ip_addr_set(&pcb->remote_ip, IP_ADDR_ANY);
  80c0e6:	8b 15 8c 3d 81 00    	mov    0x813d8c,%edx
  80c0ec:	89 50 04             	mov    %edx,0x4(%eax)
  pcb->remote_port = 0;
  80c0ef:	66 c7 40 14 00 00    	movw   $0x0,0x14(%eax)
  /* mark PCB as unconnected */
  pcb->flags &= ~UDP_FLAGS_CONNECTED;
  80c0f5:	80 60 10 fb          	andb   $0xfb,0x10(%eax)
}
  80c0f9:	5d                   	pop    %ebp
  80c0fa:	c3                   	ret    

0080c0fb <udp_recv>:
void
udp_recv(struct udp_pcb *pcb,
         void (* recv)(void *arg, struct udp_pcb *upcb, struct pbuf *p,
                       struct ip_addr *addr, u16_t port),
         void *recv_arg)
{
  80c0fb:	55                   	push   %ebp
  80c0fc:	89 e5                	mov    %esp,%ebp
  80c0fe:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  80c101:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c104:	89 50 18             	mov    %edx,0x18(%eax)
  pcb->recv_arg = recv_arg;
  80c107:	8b 55 10             	mov    0x10(%ebp),%edx
  80c10a:	89 50 1c             	mov    %edx,0x1c(%eax)
}
  80c10d:	5d                   	pop    %ebp
  80c10e:	c3                   	ret    

0080c10f <udp_new>:
 *
 * @see udp_remove()
 */
struct udp_pcb *
udp_new(void)
{
  80c10f:	55                   	push   %ebp
  80c110:	89 e5                	mov    %esp,%ebp
  80c112:	53                   	push   %ebx
  80c113:	83 ec 14             	sub    $0x14,%esp
  struct udp_pcb *pcb;
  pcb = memp_malloc(MEMP_UDP_PCB);
  80c116:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c11d:	e8 e2 b6 ff ff       	call   807804 <memp_malloc>
  80c122:	89 c3                	mov    %eax,%ebx
  /* could allocate UDP PCB? */
  if (pcb != NULL) {
  80c124:	85 c0                	test   %eax,%eax
  80c126:	74 1c                	je     80c144 <udp_new+0x35>
    /* UDP Lite: by initializing to all zeroes, chksum_len is set to 0
     * which means checksum is generated over the whole datagram per default
     * (recommended as default by RFC 3828). */
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct udp_pcb));
  80c128:	c7 44 24 08 20 00 00 	movl   $0x20,0x8(%esp)
  80c12f:	00 
  80c130:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80c137:	00 
  80c138:	89 04 24             	mov    %eax,(%esp)
  80c13b:	e8 76 51 ff ff       	call   8012b6 <memset>
    pcb->ttl = UDP_TTL;
  80c140:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
  }
  return pcb;
}
  80c144:	89 d8                	mov    %ebx,%eax
  80c146:	83 c4 14             	add    $0x14,%esp
  80c149:	5b                   	pop    %ebx
  80c14a:	5d                   	pop    %ebp
  80c14b:	c3                   	ret    

0080c14c <udp_remove>:
 *
 * @see udp_new()
 */
void
udp_remove(struct udp_pcb *pcb)
{
  80c14c:	55                   	push   %ebp
  80c14d:	89 e5                	mov    %esp,%ebp
  80c14f:	83 ec 18             	sub    $0x18,%esp
  80c152:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct udp_pcb *pcb2;

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
  80c155:	8b 15 20 f6 b3 00    	mov    0xb3f620,%edx
  80c15b:	39 ca                	cmp    %ecx,%edx
  80c15d:	74 06                	je     80c165 <udp_remove+0x19>
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80c15f:	85 d2                	test   %edx,%edx
  80c161:	75 0e                	jne    80c171 <udp_remove+0x25>
  80c163:	eb 21                	jmp    80c186 <udp_remove+0x3a>

  snmp_delete_udpidx_tree(pcb);
  /* pcb to be removed is first in list? */
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
  80c165:	8b 42 0c             	mov    0xc(%edx),%eax
  80c168:	a3 20 f6 b3 00       	mov    %eax,0xb3f620
  80c16d:	eb 17                	jmp    80c186 <udp_remove+0x3a>
  80c16f:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in udp_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  80c171:	8b 42 0c             	mov    0xc(%edx),%eax
  80c174:	85 c0                	test   %eax,%eax
  80c176:	74 0e                	je     80c186 <udp_remove+0x3a>
  80c178:	39 c1                	cmp    %eax,%ecx
  80c17a:	75 f3                	jne    80c16f <udp_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  80c17c:	8b 41 0c             	mov    0xc(%ecx),%eax
  80c17f:	89 42 0c             	mov    %eax,0xc(%edx)
  if (udp_pcbs == pcb) {
    /* make list start at 2nd pcb */
    udp_pcbs = udp_pcbs->next;
    /* pcb not 1st in list */
  } else
    for (pcb2 = udp_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  80c182:	85 c0                	test   %eax,%eax
  80c184:	75 e9                	jne    80c16f <udp_remove+0x23>
      if (pcb2->next != NULL && pcb2->next == pcb) {
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  memp_free(MEMP_UDP_PCB, pcb);
  80c186:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80c18a:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c191:	e8 2a b6 ff ff       	call   8077c0 <memp_free>
}
  80c196:	c9                   	leave  
  80c197:	c3                   	ret    

0080c198 <udp_bind>:
 *
 * @see udp_disconnect()
 */
err_t
udp_bind(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80c198:	55                   	push   %ebp
  80c199:	89 e5                	mov    %esp,%ebp
  80c19b:	57                   	push   %edi
  80c19c:	56                   	push   %esi
  80c19d:	53                   	push   %ebx
  80c19e:	83 ec 1c             	sub    $0x1c,%esp
  80c1a1:	8b 55 08             	mov    0x8(%ebp),%edx
  80c1a4:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80c1a7:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c1ab:	a1 20 f6 b3 00       	mov    0xb3f620,%eax
  80c1b0:	b9 00 00 00 00       	mov    $0x0,%ecx
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80c1b5:	bb 01 00 00 00       	mov    $0x1,%ebx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c1ba:	85 c0                	test   %eax,%eax
  80c1bc:	74 2d                	je     80c1eb <udp_bind+0x53>
    /* is this UDP PCB already on active list? */
    if (pcb == ipcb) {
  80c1be:	39 c2                	cmp    %eax,%edx
  80c1c0:	75 22                	jne    80c1e4 <udp_bind+0x4c>
      /* pcb may occur at most once in active list */
      LWIP_ASSERT("rebind == 0", rebind == 0);
  80c1c2:	84 c9                	test   %cl,%cl
  80c1c4:	74 1c                	je     80c1e2 <udp_bind+0x4a>
  80c1c6:	c7 44 24 08 20 41 81 	movl   $0x814120,0x8(%esp)
  80c1cd:	00 
  80c1ce:	c7 44 24 04 41 02 00 	movl   $0x241,0x4(%esp)
  80c1d5:	00 
  80c1d6:	c7 04 24 2c 41 81 00 	movl   $0x81412c,(%esp)
  80c1dd:	e8 f2 47 ff ff       	call   8009d4 <_panic>
  80c1e2:	89 d9                	mov    %ebx,%ecx
  ip_addr_debug_print(UDP_DEBUG, ipaddr);
  LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 3, (", port = %"U16_F")\n", port));

  rebind = 0;
  /* Check for double bind and rebind of the same pcb */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c1e4:	8b 40 0c             	mov    0xc(%eax),%eax
  80c1e7:	85 c0                	test   %eax,%eax
  80c1e9:	75 d3                	jne    80c1be <udp_bind+0x26>
        return ERR_USE;
      }
#endif
  }

  ip_addr_set(&pcb->local_ip, ipaddr);
  80c1eb:	b8 00 00 00 00       	mov    $0x0,%eax
  80c1f0:	85 ff                	test   %edi,%edi
  80c1f2:	74 02                	je     80c1f6 <udp_bind+0x5e>
  80c1f4:	8b 07                	mov    (%edi),%eax
  80c1f6:	89 02                	mov    %eax,(%edx)

  /* no port specified? */
  if (port == 0) {
  80c1f8:	66 85 f6             	test   %si,%si
  80c1fb:	75 39                	jne    80c236 <udp_bind+0x9e>
#ifndef UDP_LOCAL_PORT_RANGE_START
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
  80c1fd:	8b 3d 20 f6 b3 00    	mov    0xb3f620,%edi
  80c203:	89 f8                	mov    %edi,%eax
  80c205:	be 00 10 00 00       	mov    $0x1000,%esi
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80c20a:	eb 13                	jmp    80c21f <udp_bind+0x87>
      if (ipcb->local_port == port) {
  80c20c:	0f b7 58 12          	movzwl 0x12(%eax),%ebx
  80c210:	66 39 f3             	cmp    %si,%bx
  80c213:	75 07                	jne    80c21c <udp_bind+0x84>
        /* port is already used by another udp_pcb */
        port++;
  80c215:	8d 73 01             	lea    0x1(%ebx),%esi
  80c218:	89 f8                	mov    %edi,%eax
  80c21a:	eb 03                	jmp    80c21f <udp_bind+0x87>
        /* restart scanning all udp pcbs */
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
  80c21c:	8b 40 0c             	mov    0xc(%eax),%eax
#define UDP_LOCAL_PORT_RANGE_START 4096
#define UDP_LOCAL_PORT_RANGE_END   0x7fff
#endif
    port = UDP_LOCAL_PORT_RANGE_START;
    ipcb = udp_pcbs;
    while ((ipcb != NULL) && (port != UDP_LOCAL_PORT_RANGE_END)) {
  80c21f:	85 c0                	test   %eax,%eax
  80c221:	0f 95 c3             	setne  %bl
  80c224:	74 07                	je     80c22d <udp_bind+0x95>
  80c226:	66 81 fe ff 7f       	cmp    $0x7fff,%si
  80c22b:	75 df                	jne    80c20c <udp_bind+0x74>
        ipcb = udp_pcbs;
      } else
        /* go on with next udp pcb */
        ipcb = ipcb->next;
    }
    if (ipcb != NULL) {
  80c22d:	b8 f5 ff ff ff       	mov    $0xfffffff5,%eax
  80c232:	84 db                	test   %bl,%bl
  80c234:	75 20                	jne    80c256 <udp_bind+0xbe>
      /* no more ports available in local range */
      LWIP_DEBUGF(UDP_DEBUG, ("udp_bind: out of free UDP ports\n"));
      return ERR_USE;
    }
  }
  pcb->local_port = port;
  80c236:	66 89 72 12          	mov    %si,0x12(%edx)
  snmp_insert_udpidx_tree(pcb);
  /* pcb not active yet? */
  if (rebind == 0) {
  80c23a:	b8 00 00 00 00       	mov    $0x0,%eax
  80c23f:	84 c9                	test   %cl,%cl
  80c241:	75 13                	jne    80c256 <udp_bind+0xbe>
    /* place the PCB on the active list if not already there */
    pcb->next = udp_pcbs;
  80c243:	a1 20 f6 b3 00       	mov    0xb3f620,%eax
  80c248:	89 42 0c             	mov    %eax,0xc(%edx)
    udp_pcbs = pcb;
  80c24b:	89 15 20 f6 b3 00    	mov    %edx,0xb3f620
  80c251:	b8 00 00 00 00       	mov    $0x0,%eax
               (u16_t)(ntohl(pcb->local_ip.addr) >> 24 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->local_ip.addr) & 0xff), pcb->local_port));
  return ERR_OK;
}
  80c256:	83 c4 1c             	add    $0x1c,%esp
  80c259:	5b                   	pop    %ebx
  80c25a:	5e                   	pop    %esi
  80c25b:	5f                   	pop    %edi
  80c25c:	5d                   	pop    %ebp
  80c25d:	c3                   	ret    

0080c25e <udp_connect>:
 *
 * @see udp_disconnect()
 */
err_t
udp_connect(struct udp_pcb *pcb, struct ip_addr *ipaddr, u16_t port)
{
  80c25e:	55                   	push   %ebp
  80c25f:	89 e5                	mov    %esp,%ebp
  80c261:	57                   	push   %edi
  80c262:	56                   	push   %esi
  80c263:	53                   	push   %ebx
  80c264:	83 ec 1c             	sub    $0x1c,%esp
  80c267:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c26a:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80c26d:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct udp_pcb *ipcb;

  if (pcb->local_port == 0) {
  80c271:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80c276:	75 18                	jne    80c290 <udp_connect+0x32>
    err_t err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80c278:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c27f:	00 
  80c280:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c284:	89 1c 24             	mov    %ebx,(%esp)
  80c287:	e8 0c ff ff ff       	call   80c198 <udp_bind>
    if (err != ERR_OK)
  80c28c:	84 c0                	test   %al,%al
  80c28e:	75 48                	jne    80c2d8 <udp_connect+0x7a>
      return err;
  }

  ip_addr_set(&pcb->remote_ip, ipaddr);
  80c290:	b8 00 00 00 00       	mov    $0x0,%eax
  80c295:	85 ff                	test   %edi,%edi
  80c297:	74 02                	je     80c29b <udp_connect+0x3d>
  80c299:	8b 07                	mov    (%edi),%eax
  80c29b:	89 43 04             	mov    %eax,0x4(%ebx)
  pcb->remote_port = port;
  80c29e:	66 89 73 14          	mov    %si,0x14(%ebx)
  pcb->flags |= UDP_FLAGS_CONNECTED;
  80c2a2:	80 4b 10 04          	orb    $0x4,0x10(%ebx)
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c2a6:	8b 15 20 f6 b3 00    	mov    0xb3f620,%edx
  80c2ac:	85 d2                	test   %edx,%edx
  80c2ae:	74 13                	je     80c2c3 <udp_connect+0x65>
    if (pcb == ipcb) {
  80c2b0:	89 d0                	mov    %edx,%eax
  80c2b2:	39 d3                	cmp    %edx,%ebx
  80c2b4:	75 06                	jne    80c2bc <udp_connect+0x5e>
  80c2b6:	eb 1b                	jmp    80c2d3 <udp_connect+0x75>
  80c2b8:	39 c3                	cmp    %eax,%ebx
  80c2ba:	74 17                	je     80c2d3 <udp_connect+0x75>
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 16 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) >> 8 & 0xff),
               (u16_t)(ntohl(pcb->remote_ip.addr) & 0xff), pcb->remote_port));

  /* Insert UDP PCB into the list of active UDP PCBs. */
  for (ipcb = udp_pcbs; ipcb != NULL; ipcb = ipcb->next) {
  80c2bc:	8b 40 0c             	mov    0xc(%eax),%eax
  80c2bf:	85 c0                	test   %eax,%eax
  80c2c1:	75 f5                	jne    80c2b8 <udp_connect+0x5a>
      /* already on the list, just return */
      return ERR_OK;
    }
  }
  /* PCB not yet on the list, add PCB now */
  pcb->next = udp_pcbs;
  80c2c3:	89 53 0c             	mov    %edx,0xc(%ebx)
  udp_pcbs = pcb;
  80c2c6:	89 1d 20 f6 b3 00    	mov    %ebx,0xb3f620
  80c2cc:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
  80c2d1:	eb 05                	jmp    80c2d8 <udp_connect+0x7a>
  80c2d3:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80c2d8:	83 c4 1c             	add    $0x1c,%esp
  80c2db:	5b                   	pop    %ebx
  80c2dc:	5e                   	pop    %esi
  80c2dd:	5f                   	pop    %edi
  80c2de:	5d                   	pop    %ebp
  80c2df:	c3                   	ret    

0080c2e0 <udp_sendto_if>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto_if(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port, struct netif *netif)
{
  80c2e0:	55                   	push   %ebp
  80c2e1:	89 e5                	mov    %esp,%ebp
  80c2e3:	57                   	push   %edi
  80c2e4:	56                   	push   %esi
  80c2e5:	53                   	push   %ebx
  80c2e6:	83 ec 3c             	sub    $0x3c,%esp
  80c2e9:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80c2ec:	0f b7 45 14          	movzwl 0x14(%ebp),%eax
  80c2f0:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  struct ip_addr *src_ip;
  err_t err;
  struct pbuf *q; /* q will be sent down the stack */

  /* if the PCB is not yet bound to a port, bind it here */
  if (pcb->local_port == 0) {
  80c2f4:	66 83 7b 12 00       	cmpw   $0x0,0x12(%ebx)
  80c2f9:	75 1e                	jne    80c319 <udp_sendto_if+0x39>
    LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: not yet bound to a port, binding now\n"));
    err = udp_bind(pcb, &pcb->local_ip, pcb->local_port);
  80c2fb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c302:	00 
  80c303:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c307:	89 1c 24             	mov    %ebx,(%esp)
  80c30a:	e8 89 fe ff ff       	call   80c198 <udp_bind>
  80c30f:	89 c7                	mov    %eax,%edi
    if (err != ERR_OK) {
  80c311:	84 c0                	test   %al,%al
  80c313:	0f 85 6a 01 00 00    	jne    80c483 <udp_sendto_if+0x1a3>
      return err;
    }
  }

  /* not enough space to add an UDP header to first pbuf in given p chain? */
  if (pbuf_header(p, UDP_HLEN)) {
  80c319:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80c320:	00 
  80c321:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c324:	89 14 24             	mov    %edx,(%esp)
  80c327:	e8 b7 b8 ff ff       	call   807be3 <pbuf_header>
  80c32c:	84 c0                	test   %al,%al
  80c32e:	75 05                	jne    80c335 <udp_sendto_if+0x55>
  80c330:	8b 75 0c             	mov    0xc(%ebp),%esi
  80c333:	eb 3a                	jmp    80c36f <udp_sendto_if+0x8f>
    /* allocate header in a separate new pbuf */
    q = pbuf_alloc(PBUF_IP, UDP_HLEN, PBUF_RAM);
  80c335:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c33c:	00 
  80c33d:	c7 44 24 04 08 00 00 	movl   $0x8,0x4(%esp)
  80c344:	00 
  80c345:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c34c:	e8 c2 be ff ff       	call   808213 <pbuf_alloc>
  80c351:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  80c353:	bf ff ff ff ff       	mov    $0xffffffff,%edi
  80c358:	85 c0                	test   %eax,%eax
  80c35a:	0f 84 23 01 00 00    	je     80c483 <udp_sendto_if+0x1a3>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE | 2, ("udp_send: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  80c360:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c363:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c367:	89 34 24             	mov    %esi,(%esp)
  80c36a:	e8 4d b8 ff ff       	call   807bbc <pbuf_chain>
    /* adding space for header within p succeeded */
    /* first pbuf q equals given pbuf */
    q = p;
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: added header in given pbuf %p\n", (void *)p));
  }
  LWIP_ASSERT("check that first pbuf can hold struct udp_hdr",
  80c36f:	66 83 7e 0a 07       	cmpw   $0x7,0xa(%esi)
  80c374:	77 1c                	ja     80c392 <udp_sendto_if+0xb2>
  80c376:	c7 44 24 08 54 41 81 	movl   $0x814154,0x8(%esp)
  80c37d:	00 
  80c37e:	c7 44 24 04 b2 01 00 	movl   $0x1b2,0x4(%esp)
  80c385:	00 
  80c386:	c7 04 24 2c 41 81 00 	movl   $0x81412c,(%esp)
  80c38d:	e8 42 46 ff ff       	call   8009d4 <_panic>
              (q->len >= sizeof(struct udp_hdr)));
  /* q now represents the packet to be sent */
  udphdr = q->payload;
  80c392:	8b 7e 04             	mov    0x4(%esi),%edi
  udphdr->src = htons(pcb->local_port);
  80c395:	0f b7 43 12          	movzwl 0x12(%ebx),%eax
  80c399:	89 04 24             	mov    %eax,(%esp)
  80c39c:	e8 b3 e9 ff ff       	call   80ad54 <htons>
  80c3a1:	66 89 07             	mov    %ax,(%edi)
  udphdr->dest = htons(dst_port);
  80c3a4:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  80c3a8:	89 04 24             	mov    %eax,(%esp)
  80c3ab:	e8 a4 e9 ff ff       	call   80ad54 <htons>
  80c3b0:	66 89 47 02          	mov    %ax,0x2(%edi)
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 
  80c3b4:	66 c7 47 06 00 00    	movw   $0x0,0x6(%edi)

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80c3ba:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80c3bd:	85 db                	test   %ebx,%ebx
  80c3bf:	74 06                	je     80c3c7 <udp_sendto_if+0xe7>
  80c3c1:	8b 03                	mov    (%ebx),%eax
  80c3c3:	85 c0                	test   %eax,%eax
  80c3c5:	75 0b                	jne    80c3d2 <udp_sendto_if+0xf2>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  80c3c7:	8b 55 18             	mov    0x18(%ebp),%edx
  80c3ca:	83 c2 04             	add    $0x4,%edx
  80c3cd:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  udphdr->dest = htons(dst_port);
  /* in UDP, 0 checksum means 'no checksum' */
  udphdr->chksum = 0x0000; 

  /* PCB local address is IP_ANY_ADDR? */
  if (ip_addr_isany(&pcb->local_ip)) {
  80c3d0:	eb 23                	jmp    80c3f5 <udp_sendto_if+0x115>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  } else {
    /* check if UDP PCB local IP address is correct
     * this could be an old address if netif->ip_addr has changed */
    if (!ip_addr_cmp(&(pcb->local_ip), &(netif->ip_addr))) {
  80c3d2:	8b 55 18             	mov    0x18(%ebp),%edx
  80c3d5:	3b 42 04             	cmp    0x4(%edx),%eax
  80c3d8:	74 1b                	je     80c3f5 <udp_sendto_if+0x115>
      /* local_ip doesn't match, drop the packet */
      if (q != p) {
  80c3da:	bf f7 ff ff ff       	mov    $0xfffffff7,%edi
  80c3df:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80c3e2:	0f 84 9b 00 00 00    	je     80c483 <udp_sendto_if+0x1a3>
        /* free the header pbuf */
        pbuf_free(q);
  80c3e8:	89 34 24             	mov    %esi,(%esp)
  80c3eb:	e8 68 bb ff ff       	call   807f58 <pbuf_free>
  80c3f0:	e9 8e 00 00 00       	jmp    80c483 <udp_sendto_if+0x1a3>
#endif /* LWIP_NETIF_HWADDRHINT*/
  } else
#endif /* LWIP_UDPLITE */
  {      /* UDP */
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: UDP packet length %"U16_F"\n", q->tot_len));
    udphdr->len = htons(q->tot_len);
  80c3f5:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c3f9:	89 04 24             	mov    %eax,(%esp)
  80c3fc:	e8 53 e9 ff ff       	call   80ad54 <htons>
  80c401:	66 89 47 04          	mov    %ax,0x4(%edi)
    /* calculate checksum */
#if CHECKSUM_GEN_UDP
    if ((pcb->flags & UDP_FLAGS_NOCHKSUM) == 0) {
  80c405:	f6 43 10 01          	testb  $0x1,0x10(%ebx)
  80c409:	75 34                	jne    80c43f <udp_sendto_if+0x15f>
      udphdr->chksum = inet_chksum_pseudo(q, src_ip, dst_ip, IP_PROTO_UDP, q->tot_len);
  80c40b:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80c40f:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c413:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c41a:	00 
  80c41b:	8b 45 10             	mov    0x10(%ebp),%eax
  80c41e:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c422:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c425:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c429:	89 34 24             	mov    %esi,(%esp)
  80c42c:	e8 1f e6 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80c431:	89 c2                	mov    %eax,%edx
      /* chksum zero must become 0xffff, as zero means 'no checksum' */
      if (udphdr->chksum == 0x0000) udphdr->chksum = 0xffff;
  80c433:	66 83 f8 01          	cmp    $0x1,%ax
  80c437:	19 c0                	sbb    %eax,%eax
  80c439:	09 d0                	or     %edx,%eax
  80c43b:	66 89 47 06          	mov    %ax,0x6(%edi)
    LWIP_DEBUGF(UDP_DEBUG, ("udp_send: ip_output_if (,,,,IP_PROTO_UDP,)\n"));
    /* output to IP */
#if LWIP_NETIF_HWADDRHINT
    netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
    err = ip_output_if(q, src_ip, dst_ip, pcb->ttl, pcb->tos, IP_PROTO_UDP, netif);    
  80c43f:	8b 45 18             	mov    0x18(%ebp),%eax
  80c442:	89 44 24 18          	mov    %eax,0x18(%esp)
  80c446:	c7 44 24 14 11 00 00 	movl   $0x11,0x14(%esp)
  80c44d:	00 
  80c44e:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  80c452:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c456:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  80c45a:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80c45e:	8b 55 10             	mov    0x10(%ebp),%edx
  80c461:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c465:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c468:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c46c:	89 34 24             	mov    %esi,(%esp)
  80c46f:	e8 1c d5 ff ff       	call   809990 <ip_output_if>
  80c474:	89 c7                	mov    %eax,%edi
  }
  /* TODO: must this be increased even if error occured? */
  snmp_inc_udpoutdatagrams();

  /* did we chain a separate header pbuf earlier? */
  if (q != p) {
  80c476:	3b 75 0c             	cmp    0xc(%ebp),%esi
  80c479:	74 08                	je     80c483 <udp_sendto_if+0x1a3>
    /* free the header pbuf */
    pbuf_free(q);
  80c47b:	89 34 24             	mov    %esi,(%esp)
  80c47e:	e8 d5 ba ff ff       	call   807f58 <pbuf_free>
    /* p is still referenced by the caller, and will live on */
  }

  UDP_STATS_INC(udp.xmit);
  return err;
}
  80c483:	89 f8                	mov    %edi,%eax
  80c485:	83 c4 3c             	add    $0x3c,%esp
  80c488:	5b                   	pop    %ebx
  80c489:	5e                   	pop    %esi
  80c48a:	5f                   	pop    %edi
  80c48b:	5d                   	pop    %ebp
  80c48c:	c3                   	ret    

0080c48d <udp_sendto>:
 * @see udp_disconnect() udp_send()
 */
err_t
udp_sendto(struct udp_pcb *pcb, struct pbuf *p,
  struct ip_addr *dst_ip, u16_t dst_port)
{
  80c48d:	55                   	push   %ebp
  80c48e:	89 e5                	mov    %esp,%ebp
  80c490:	83 ec 28             	sub    $0x28,%esp
  80c493:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80c496:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80c499:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80c49c:	0f b7 75 14          	movzwl 0x14(%ebp),%esi

  /* find the outgoing network interface for this packet */
#if LWIP_IGMP
  netif = ip_route((ip_addr_ismulticast(dst_ip))?(&(pcb->multicast_ip)):(dst_ip));
#else
  netif = ip_route(dst_ip);
  80c4a0:	89 1c 24             	mov    %ebx,(%esp)
  80c4a3:	e8 99 d6 ff ff       	call   809b41 <ip_route>
  80c4a8:	89 c2                	mov    %eax,%edx
#endif /* LWIP_IGMP */

  /* no outgoing network interface could be found? */
  if (netif == NULL) {
  80c4aa:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80c4af:	85 d2                	test   %edx,%edx
  80c4b1:	74 21                	je     80c4d4 <udp_sendto+0x47>
    LWIP_DEBUGF(UDP_DEBUG | 1, ("udp_send: No route to 0x%"X32_F"\n", dst_ip->addr));
    UDP_STATS_INC(udp.rterr);
    return ERR_RTE;
  }
  return udp_sendto_if(pcb, p, dst_ip, dst_port, netif);
  80c4b3:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c4b7:	0f b7 f6             	movzwl %si,%esi
  80c4ba:	89 74 24 0c          	mov    %esi,0xc(%esp)
  80c4be:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80c4c2:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c4c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c4c9:	8b 45 08             	mov    0x8(%ebp),%eax
  80c4cc:	89 04 24             	mov    %eax,(%esp)
  80c4cf:	e8 0c fe ff ff       	call   80c2e0 <udp_sendto_if>
}
  80c4d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80c4d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80c4da:	89 ec                	mov    %ebp,%esp
  80c4dc:	5d                   	pop    %ebp
  80c4dd:	c3                   	ret    

0080c4de <udp_send>:
 *
 * @see udp_disconnect() udp_sendto()
 */
err_t
udp_send(struct udp_pcb *pcb, struct pbuf *p)
{
  80c4de:	55                   	push   %ebp
  80c4df:	89 e5                	mov    %esp,%ebp
  80c4e1:	83 ec 18             	sub    $0x18,%esp
  80c4e4:	8b 45 08             	mov    0x8(%ebp),%eax
  /* send to the packet using remote ip and port stored in the pcb */
  return udp_sendto(pcb, p, &pcb->remote_ip, pcb->remote_port);
  80c4e7:	0f b7 50 14          	movzwl 0x14(%eax),%edx
  80c4eb:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c4ef:	8d 50 04             	lea    0x4(%eax),%edx
  80c4f2:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c4f6:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c4f9:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c4fd:	89 04 24             	mov    %eax,(%esp)
  80c500:	e8 88 ff ff ff       	call   80c48d <udp_sendto>
}
  80c505:	c9                   	leave  
  80c506:	c3                   	ret    

0080c507 <udp_input>:
 * @param inp network interface on which the datagram was received.
 *
 */
void
udp_input(struct pbuf *p, struct netif *inp)
{
  80c507:	55                   	push   %ebp
  80c508:	89 e5                	mov    %esp,%ebp
  80c50a:	57                   	push   %edi
  80c50b:	56                   	push   %esi
  80c50c:	53                   	push   %ebx
  80c50d:	83 ec 4c             	sub    $0x4c,%esp

  PERF_START;

  UDP_STATS_INC(udp.recv);

  iphdr = p->payload;
  80c510:	8b 45 08             	mov    0x8(%ebp),%eax
  80c513:	8b 40 04             	mov    0x4(%eax),%eax
  80c516:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  /* Check minimum length (IP header + UDP header)
   * and move payload pointer to UDP header */
  if (p->tot_len < (IPH_HL(iphdr) * 4 + UDP_HLEN) || pbuf_header(p, -(s16_t)(IPH_HL(iphdr) * 4))) {
  80c519:	8b 55 08             	mov    0x8(%ebp),%edx
  80c51c:	0f b7 5a 08          	movzwl 0x8(%edx),%ebx
  80c520:	0f b7 00             	movzwl (%eax),%eax
  80c523:	89 04 24             	mov    %eax,(%esp)
  80c526:	e8 36 e8 ff ff       	call   80ad61 <ntohs>
  80c52b:	0f b6 c4             	movzbl %ah,%eax
  80c52e:	83 e0 0f             	and    $0xf,%eax
  80c531:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c538:	39 c3                	cmp    %eax,%ebx
  80c53a:	7c 2b                	jl     80c567 <udp_input+0x60>
  80c53c:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c53f:	0f b7 02             	movzwl (%edx),%eax
  80c542:	89 04 24             	mov    %eax,(%esp)
  80c545:	e8 17 e8 ff ff       	call   80ad61 <ntohs>
  80c54a:	66 c1 e8 06          	shr    $0x6,%ax
  80c54e:	83 e0 3c             	and    $0x3c,%eax
  80c551:	f7 d8                	neg    %eax
  80c553:	98                   	cwtl   
  80c554:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c558:	8b 45 08             	mov    0x8(%ebp),%eax
  80c55b:	89 04 24             	mov    %eax,(%esp)
  80c55e:	e8 80 b6 ff ff       	call   807be3 <pbuf_header>
  80c563:	84 c0                	test   %al,%al
  80c565:	74 10                	je     80c577 <udp_input+0x70>
    LWIP_DEBUGF(UDP_DEBUG,
                ("udp_input: short UDP datagram (%"U16_F" bytes) discarded\n", p->tot_len));
    UDP_STATS_INC(udp.lenerr);
    UDP_STATS_INC(udp.drop);
    snmp_inc_udpinerrors();
    pbuf_free(p);
  80c567:	8b 55 08             	mov    0x8(%ebp),%edx
  80c56a:	89 14 24             	mov    %edx,(%esp)
  80c56d:	e8 e6 b9 ff ff       	call   807f58 <pbuf_free>
    goto end;
  80c572:	e9 f4 02 00 00       	jmp    80c86b <udp_input+0x364>
  }

  udphdr = (struct udp_hdr *)p->payload;
  80c577:	8b 45 08             	mov    0x8(%ebp),%eax
  80c57a:	8b 40 04             	mov    0x4(%eax),%eax
  80c57d:	89 45 d8             	mov    %eax,-0x28(%ebp)

  LWIP_DEBUGF(UDP_DEBUG, ("udp_input: received datagram of length %"U16_F"\n", p->tot_len));

  /* convert src and dest ports to host byte order */
  src = ntohs(udphdr->src);
  80c580:	0f b7 00             	movzwl (%eax),%eax
  80c583:	89 04 24             	mov    %eax,(%esp)
  80c586:	e8 d6 e7 ff ff       	call   80ad61 <ntohs>
  80c58b:	66 89 45 e2          	mov    %ax,-0x1e(%ebp)
  dest = ntohs(udphdr->dest);
  80c58f:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80c592:	0f b7 42 02          	movzwl 0x2(%edx),%eax
  80c596:	89 04 24             	mov    %eax,(%esp)
  80c599:	e8 c3 e7 ff ff       	call   80ad61 <ntohs>
  80c59e:	89 c6                	mov    %eax,%esi

#if LWIP_DHCP
  pcb = NULL;
  /* when LWIP_DHCP is active, packets to DHCP_CLIENT_PORT may only be processed by
     the dhcp module, no other UDP pcb may use the local UDP port DHCP_CLIENT_PORT */
  if (dest == DHCP_CLIENT_PORT) {
  80c5a0:	66 83 f8 44          	cmp    $0x44,%ax
  80c5a4:	75 49                	jne    80c5ef <udp_input+0xe8>
    /* all packets for DHCP_CLIENT_PORT not coming from DHCP_SERVER_PORT are dropped! */
    if (src == DHCP_SERVER_PORT) {
  80c5a6:	66 83 7d e2 43       	cmpw   $0x43,-0x1e(%ebp)
  80c5ab:	0f 85 fa 00 00 00    	jne    80c6ab <udp_input+0x1a4>
      if ((inp->dhcp != NULL) && (inp->dhcp->pcb != NULL)) {
  80c5b1:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c5b4:	8b 42 20             	mov    0x20(%edx),%eax
  80c5b7:	85 c0                	test   %eax,%eax
  80c5b9:	0f 84 ec 00 00 00    	je     80c6ab <udp_input+0x1a4>
  80c5bf:	8b 58 08             	mov    0x8(%eax),%ebx
  80c5c2:	85 db                	test   %ebx,%ebx
  80c5c4:	0f 84 e6 00 00 00    	je     80c6b0 <udp_input+0x1a9>
        /* accept the packe if 
           (- broadcast or directed to us) -> DHCP is link-layer-addressed, local ip is always ANY!
           - inp->dhcp->pcb->remote == ANY or iphdr->src */
        if ((ip_addr_isany(&inp->dhcp->pcb->remote_ip) ||
  80c5ca:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c5cd:	0f 84 ef 00 00 00    	je     80c6c2 <udp_input+0x1bb>
  80c5d3:	8b 43 04             	mov    0x4(%ebx),%eax
  80c5d6:	85 c0                	test   %eax,%eax
  80c5d8:	0f 84 e4 00 00 00    	je     80c6c2 <udp_input+0x1bb>
           ip_addr_cmp(&(inp->dhcp->pcb->remote_ip), &(iphdr->src)))) {
  80c5de:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c5e1:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c5e4:	0f 85 c1 00 00 00    	jne    80c6ab <udp_input+0x1a4>
  80c5ea:	e9 d3 00 00 00       	jmp    80c6c2 <udp_input+0x1bb>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c5ef:	8b 1d 20 f6 b3 00    	mov    0xb3f620,%ebx
  80c5f5:	85 db                	test   %ebx,%ebx
  80c5f7:	0f 84 62 02 00 00    	je     80c85f <udp_input+0x358>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c5fd:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c600:	83 c0 10             	add    $0x10,%eax
  80c603:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80c606:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80c60d:	bf 00 00 00 00       	mov    $0x0,%edi
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c612:	66 3b 73 12          	cmp    0x12(%ebx),%si
  80c616:	75 76                	jne    80c68e <udp_input+0x187>
          (ip_addr_isany(&pcb->local_ip) ||
  80c618:	85 db                	test   %ebx,%ebx
  80c61a:	74 24                	je     80c640 <udp_input+0x139>
  80c61c:	8b 03                	mov    (%ebx),%eax
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c61e:	85 c0                	test   %eax,%eax
  80c620:	74 1e                	je     80c640 <udp_input+0x139>
          (ip_addr_isany(&pcb->local_ip) ||
           ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest)) || 
  80c622:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c625:	3b 42 10             	cmp    0x10(%edx),%eax
  80c628:	74 16                	je     80c640 <udp_input+0x139>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
  80c62a:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c62d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c631:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80c634:	89 14 24             	mov    %edx,(%esp)
  80c637:	e8 0c d3 ff ff       	call   809948 <ip_addr_isbroadcast>
                   ip4_addr3(&pcb->local_ip), ip4_addr4(&pcb->local_ip), pcb->local_port,
                   ip4_addr1(&pcb->remote_ip), ip4_addr2(&pcb->remote_ip),
                   ip4_addr3(&pcb->remote_ip), ip4_addr4(&pcb->remote_ip), pcb->remote_port));

      /* compare PCB local addr+port to UDP destination addr+port */
      if ((pcb->local_port == dest) &&
  80c63c:	84 c0                	test   %al,%al
  80c63e:	74 4e                	je     80c68e <udp_input+0x187>
#if LWIP_IGMP
           ip_addr_ismulticast(&(iphdr->dest)) ||
#endif /* LWIP_IGMP */
           ip_addr_isbroadcast(&(iphdr->dest), inp))) {
        local_match = 1;
        if ((uncon_pcb == NULL) && 
  80c640:	83 7d dc 00          	cmpl   $0x0,-0x24(%ebp)
  80c644:	0f 85 02 02 00 00    	jne    80c84c <udp_input+0x345>
            ((pcb->flags & UDP_FLAGS_CONNECTED) == 0)) {
  80c64a:	f6 43 10 04          	testb  $0x4,0x10(%ebx)
  80c64e:	66 90                	xchg   %ax,%ax
  80c650:	0f 84 f3 01 00 00    	je     80c849 <udp_input+0x342>
  80c656:	66 90                	xchg   %ax,%ax
  80c658:	e9 ef 01 00 00       	jmp    80c84c <udp_input+0x345>
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
  80c65d:	83 fb fc             	cmp    $0xfffffffc,%ebx
  80c660:	74 0f                	je     80c671 <udp_input+0x16a>
  80c662:	8b 43 04             	mov    0x4(%ebx),%eax
          /* the first unconnected matching PCB */     
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
  80c665:	85 c0                	test   %eax,%eax
  80c667:	74 08                	je     80c671 <udp_input+0x16a>
          (pcb->remote_port == src) &&
          (ip_addr_isany(&pcb->remote_ip) ||
           ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)))) {
  80c669:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c66c:	3b 42 0c             	cmp    0xc(%edx),%eax
  80c66f:	75 1d                	jne    80c68e <udp_input+0x187>
  80c671:	89 d8                	mov    %ebx,%eax
        /* the first fully matching PCB */
        if (prev != NULL) {
  80c673:	85 ff                	test   %edi,%edi
  80c675:	74 27                	je     80c69e <udp_input+0x197>
          /* move the pcb to the front of udp_pcbs so that is
             found faster next time */
          prev->next = pcb->next;
  80c677:	8b 53 0c             	mov    0xc(%ebx),%edx
  80c67a:	89 57 0c             	mov    %edx,0xc(%edi)
          pcb->next = udp_pcbs;
  80c67d:	8b 15 20 f6 b3 00    	mov    0xb3f620,%edx
  80c683:	89 53 0c             	mov    %edx,0xc(%ebx)
          udp_pcbs = pcb;
  80c686:	89 1d 20 f6 b3 00    	mov    %ebx,0xb3f620
  80c68c:	eb 10                	jmp    80c69e <udp_input+0x197>
    uncon_pcb = NULL;
    /* Iterate through the UDP pcb list for a matching pcb.
     * 'Perfect match' pcbs (connected to the remote port & ip address) are
     * preferred. If no perfect match is found, the first unconnected pcb that
     * matches the local port and ip address gets the datagram. */
    for (pcb = udp_pcbs; pcb != NULL; pcb = pcb->next) {
  80c68e:	8b 43 0c             	mov    0xc(%ebx),%eax
  80c691:	85 c0                	test   %eax,%eax
  80c693:	74 0d                	je     80c6a2 <udp_input+0x19b>
  80c695:	89 df                	mov    %ebx,%edi
  80c697:	89 c3                	mov    %eax,%ebx
  80c699:	e9 74 ff ff ff       	jmp    80c612 <udp_input+0x10b>
        break;
      }
      prev = pcb;
    }
    /* no fully matching pcb found? then look for an unconnected pcb */
    if (pcb == NULL) {
  80c69e:	85 c0                	test   %eax,%eax
  80c6a0:	75 20                	jne    80c6c2 <udp_input+0x1bb>
  80c6a2:	8b 5d dc             	mov    -0x24(%ebp),%ebx
      pcb = uncon_pcb;
    }
  }

  /* Check checksum if this is a match or if it was directed at us. */
  if (pcb != NULL || ip_addr_cmp(&inp->ip_addr, &iphdr->dest)) {
  80c6a5:	85 db                	test   %ebx,%ebx
  80c6a7:	75 19                	jne    80c6c2 <udp_input+0x1bb>
  80c6a9:	eb 05                	jmp    80c6b0 <udp_input+0x1a9>
  80c6ab:	bb 00 00 00 00       	mov    $0x0,%ebx
  80c6b0:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c6b3:	8b 42 04             	mov    0x4(%edx),%eax
  80c6b6:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c6b9:	3b 42 10             	cmp    0x10(%edx),%eax
  80c6bc:	0f 85 7a 01 00 00    	jne    80c83c <udp_input+0x335>
#endif /* CHECKSUM_CHECK_UDP */
    } else
#endif /* LWIP_UDPLITE */
    {
#if CHECKSUM_CHECK_UDP
      if (udphdr->chksum != 0) {
  80c6c2:	8b 45 d8             	mov    -0x28(%ebp),%eax
  80c6c5:	66 83 78 06 00       	cmpw   $0x0,0x6(%eax)
  80c6ca:	74 44                	je     80c710 <udp_input+0x209>
        if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  80c6cc:	8b 55 08             	mov    0x8(%ebp),%edx
  80c6cf:	0f b7 42 08          	movzwl 0x8(%edx),%eax
  80c6d3:	89 44 24 10          	mov    %eax,0x10(%esp)
  80c6d7:	c7 44 24 0c 11 00 00 	movl   $0x11,0xc(%esp)
  80c6de:	00 
  80c6df:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c6e2:	83 c0 10             	add    $0x10,%eax
  80c6e5:	89 44 24 08          	mov    %eax,0x8(%esp)
  80c6e9:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c6ec:	83 c0 0c             	add    $0xc,%eax
  80c6ef:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c6f3:	89 14 24             	mov    %edx,(%esp)
  80c6f6:	e8 55 e3 ff ff       	call   80aa50 <inet_chksum_pseudo>
  80c6fb:	66 85 c0             	test   %ax,%ax
  80c6fe:	74 10                	je     80c710 <udp_input+0x209>
          LWIP_DEBUGF(UDP_DEBUG | 2,
                      ("udp_input: UDP datagram discarded due to failing checksum\n"));
          UDP_STATS_INC(udp.chkerr);
          UDP_STATS_INC(udp.drop);
          snmp_inc_udpinerrors();
          pbuf_free(p);
  80c700:	8b 45 08             	mov    0x8(%ebp),%eax
  80c703:	89 04 24             	mov    %eax,(%esp)
  80c706:	e8 4d b8 ff ff       	call   807f58 <pbuf_free>
          goto end;
  80c70b:	e9 5b 01 00 00       	jmp    80c86b <udp_input+0x364>
        }
      }
#endif /* CHECKSUM_CHECK_UDP */
    }
    if(pbuf_header(p, -UDP_HLEN)) {
  80c710:	c7 44 24 04 f8 ff ff 	movl   $0xfffffff8,0x4(%esp)
  80c717:	ff 
  80c718:	8b 55 08             	mov    0x8(%ebp),%edx
  80c71b:	89 14 24             	mov    %edx,(%esp)
  80c71e:	e8 c0 b4 ff ff       	call   807be3 <pbuf_header>
  80c723:	84 c0                	test   %al,%al
  80c725:	74 1c                	je     80c743 <udp_input+0x23c>
      /* Can we cope with this failing? Just assert for now */
      LWIP_ASSERT("pbuf_header failed\n", 0);
  80c727:	c7 44 24 08 0c 41 81 	movl   $0x81410c,0x8(%esp)
  80c72e:	00 
  80c72f:	c7 44 24 04 0a 01 00 	movl   $0x10a,0x4(%esp)
  80c736:	00 
  80c737:	c7 04 24 2c 41 81 00 	movl   $0x81412c,(%esp)
  80c73e:	e8 91 42 ff ff       	call   8009d4 <_panic>
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpinerrors();
      pbuf_free(p);
      goto end;
    }
    if (pcb != NULL) {
  80c743:	85 db                	test   %ebx,%ebx
  80c745:	74 41                	je     80c788 <udp_input+0x281>
      snmp_inc_udpindatagrams();
      /* callback */
      if (pcb->recv != NULL) {
  80c747:	8b 43 18             	mov    0x18(%ebx),%eax
  80c74a:	85 c0                	test   %eax,%eax
  80c74c:	74 2a                	je     80c778 <udp_input+0x271>
        /* now the recv function is responsible for freeing p */
        pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src), src);
  80c74e:	0f b7 55 e2          	movzwl -0x1e(%ebp),%edx
  80c752:	89 54 24 10          	mov    %edx,0x10(%esp)
  80c756:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c759:	83 c2 0c             	add    $0xc,%edx
  80c75c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80c760:	8b 55 08             	mov    0x8(%ebp),%edx
  80c763:	89 54 24 08          	mov    %edx,0x8(%esp)
  80c767:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80c76b:	8b 53 1c             	mov    0x1c(%ebx),%edx
  80c76e:	89 14 24             	mov    %edx,(%esp)
  80c771:	ff d0                	call   *%eax
  80c773:	e9 f3 00 00 00       	jmp    80c86b <udp_input+0x364>
      } else {
        /* no recv function registered? then we have to free the pbuf! */
        pbuf_free(p);
  80c778:	8b 45 08             	mov    0x8(%ebp),%eax
  80c77b:	89 04 24             	mov    %eax,(%esp)
  80c77e:	e8 d5 b7 ff ff       	call   807f58 <pbuf_free>
        goto end;
  80c783:	e9 e3 00 00 00       	jmp    80c86b <udp_input+0x364>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c788:	8b 55 0c             	mov    0xc(%ebp),%edx
  80c78b:	89 54 24 04          	mov    %edx,0x4(%esp)
  80c78f:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c792:	83 c0 10             	add    $0x10,%eax
  80c795:	89 04 24             	mov    %eax,(%esp)
  80c798:	e8 ab d1 ff ff       	call   809948 <ip_addr_isbroadcast>
  80c79d:	84 c0                	test   %al,%al
  80c79f:	0f 85 8a 00 00 00    	jne    80c82f <udp_input+0x328>
          !ip_addr_ismulticast(&iphdr->dest)) {
  80c7a5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c7a8:	8b 70 10             	mov    0x10(%eax),%esi
  80c7ab:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80c7b2:	e8 e3 e7 ff ff       	call   80af9a <ntohl>
  80c7b7:	89 c3                	mov    %eax,%ebx
  80c7b9:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80c7c0:	e8 d5 e7 ff ff       	call   80af9a <ntohl>
      LWIP_DEBUGF(UDP_DEBUG | LWIP_DBG_TRACE, ("udp_input: not for us.\n"));

#if LWIP_ICMP
      /* No match was found, send ICMP destination port unreachable unless
         destination address was broadcast/multicast. */
      if (!ip_addr_isbroadcast(&iphdr->dest, inp) &&
  80c7c5:	21 f3                	and    %esi,%ebx
  80c7c7:	39 c3                	cmp    %eax,%ebx
  80c7c9:	74 64                	je     80c82f <udp_input+0x328>
          !ip_addr_ismulticast(&iphdr->dest)) {
        /* move payload pointer back to ip header */
        pbuf_header(p, (IPH_HL(iphdr) * 4) + UDP_HLEN);
  80c7cb:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c7ce:	0f b7 02             	movzwl (%edx),%eax
  80c7d1:	89 04 24             	mov    %eax,(%esp)
  80c7d4:	e8 88 e5 ff ff       	call   80ad61 <ntohs>
  80c7d9:	0f b6 c4             	movzbl %ah,%eax
  80c7dc:	83 e0 0f             	and    $0xf,%eax
  80c7df:	8d 04 85 08 00 00 00 	lea    0x8(,%eax,4),%eax
  80c7e6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c7ea:	8b 45 08             	mov    0x8(%ebp),%eax
  80c7ed:	89 04 24             	mov    %eax,(%esp)
  80c7f0:	e8 ee b3 ff ff       	call   807be3 <pbuf_header>
        LWIP_ASSERT("p->payload == iphdr", (p->payload == iphdr));
  80c7f5:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80c7f8:	8b 55 08             	mov    0x8(%ebp),%edx
  80c7fb:	39 42 04             	cmp    %eax,0x4(%edx)
  80c7fe:	74 1c                	je     80c81c <udp_input+0x315>
  80c800:	c7 44 24 08 40 41 81 	movl   $0x814140,0x8(%esp)
  80c807:	00 
  80c808:	c7 44 24 04 25 01 00 	movl   $0x125,0x4(%esp)
  80c80f:	00 
  80c810:	c7 04 24 2c 41 81 00 	movl   $0x81412c,(%esp)
  80c817:	e8 b8 41 ff ff       	call   8009d4 <_panic>
        icmp_dest_unreach(p, ICMP_DUR_PORT);
  80c81c:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80c823:	00 
  80c824:	8b 55 08             	mov    0x8(%ebp),%edx
  80c827:	89 14 24             	mov    %edx,(%esp)
  80c82a:	e8 b3 55 00 00       	call   811de2 <icmp_dest_unreach>
      }
#endif /* LWIP_ICMP */
      UDP_STATS_INC(udp.proterr);
      UDP_STATS_INC(udp.drop);
      snmp_inc_udpnoports();
      pbuf_free(p);
  80c82f:	8b 45 08             	mov    0x8(%ebp),%eax
  80c832:	89 04 24             	mov    %eax,(%esp)
  80c835:	e8 1e b7 ff ff       	call   807f58 <pbuf_free>
  80c83a:	eb 2f                	jmp    80c86b <udp_input+0x364>
    }
  } else {
    pbuf_free(p);
  80c83c:	8b 55 08             	mov    0x8(%ebp),%edx
  80c83f:	89 14 24             	mov    %edx,(%esp)
  80c842:	e8 11 b7 ff ff       	call   807f58 <pbuf_free>
  80c847:	eb 22                	jmp    80c86b <udp_input+0x364>
  }
end:
  PERF_STOP("udp_input");
}
  80c849:	89 5d dc             	mov    %ebx,-0x24(%ebp)
          uncon_pcb = pcb;
        }
      }
      /* compare PCB remote addr+port to UDP source addr+port */
      if ((local_match != 0) &&
          (pcb->remote_port == src) &&
  80c84c:	0f b7 45 e2          	movzwl -0x1e(%ebp),%eax
  80c850:	66 3b 43 14          	cmp    0x14(%ebx),%ax
  80c854:	0f 85 34 fe ff ff    	jne    80c68e <udp_input+0x187>
  80c85a:	e9 fe fd ff ff       	jmp    80c65d <udp_input+0x156>
  80c85f:	c7 45 dc 00 00 00 00 	movl   $0x0,-0x24(%ebp)
  80c866:	e9 37 fe ff ff       	jmp    80c6a2 <udp_input+0x19b>
  } else {
    pbuf_free(p);
  }
end:
  PERF_STOP("udp_input");
}
  80c86b:	83 c4 4c             	add    $0x4c,%esp
  80c86e:	5b                   	pop    %ebx
  80c86f:	5e                   	pop    %esi
  80c870:	5f                   	pop    %edi
  80c871:	5d                   	pop    %ebp
  80c872:	c3                   	ret    
	...

0080c880 <etharp_send_ip>:
 * @params dst the destination MAC address to be copied into the ethernet header
 * @return ERR_OK if the packet was sent, any other err_t on failure
 */
static err_t
etharp_send_ip(struct netif *netif, struct pbuf *p, struct eth_addr *src, struct eth_addr *dst)
{
  80c880:	55                   	push   %ebp
  80c881:	89 e5                	mov    %esp,%ebp
  80c883:	57                   	push   %edi
  80c884:	56                   	push   %esi
  80c885:	53                   	push   %ebx
  80c886:	83 ec 2c             	sub    $0x2c,%esp
  80c889:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80c88c:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80c88f:	89 ce                	mov    %ecx,%esi
  80c891:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct eth_hdr *ethhdr = p->payload;
  80c894:	8b 5a 04             	mov    0x4(%edx),%ebx
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c897:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80c89b:	74 1c                	je     80c8b9 <etharp_send_ip+0x39>
  80c89d:	c7 44 24 08 84 41 81 	movl   $0x814184,0x8(%esp)
  80c8a4:	00 
  80c8a5:	c7 44 24 04 b3 01 00 	movl   $0x1b3,0x4(%esp)
  80c8ac:	00 
  80c8ad:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80c8b4:	e8 1b 41 ff ff       	call   8009d4 <_panic>
  80c8b9:	ba 06 00 00 00       	mov    $0x6,%edx
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
    k--;
  80c8be:	83 ea 01             	sub    $0x1,%edx
    ethhdr->dest.addr[k] = dst->addr[k];
  80c8c1:	0f b6 c2             	movzbl %dl,%eax
  80c8c4:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c8c8:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
    ethhdr->src.addr[k]  = src->addr[k];
  80c8cb:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c8cf:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  u8_t k;

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
              (netif->hwaddr_len == ETHARP_HWADDR_LEN));
  k = ETHARP_HWADDR_LEN;
  while(k > 0) {
  80c8d3:	84 d2                	test   %dl,%dl
  80c8d5:	75 e7                	jne    80c8be <etharp_send_ip+0x3e>
    k--;
    ethhdr->dest.addr[k] = dst->addr[k];
    ethhdr->src.addr[k]  = src->addr[k];
  }
  ethhdr->type = htons(ETHTYPE_IP);
  80c8d7:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c8de:	e8 71 e4 ff ff       	call   80ad54 <htons>
  80c8e3:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_send_ip: sending packet %p\n", (void *)p));
  /* send the packet */
  return netif->linkoutput(netif, p);
  80c8e7:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80c8ea:	89 44 24 04          	mov    %eax,0x4(%esp)
  80c8ee:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c8f1:	89 14 24             	mov    %edx,(%esp)
  80c8f4:	ff 52 18             	call   *0x18(%edx)
}
  80c8f7:	83 c4 2c             	add    $0x2c,%esp
  80c8fa:	5b                   	pop    %ebx
  80c8fb:	5e                   	pop    %esi
  80c8fc:	5f                   	pop    %edi
  80c8fd:	5d                   	pop    %ebp
  80c8fe:	c3                   	ret    

0080c8ff <etharp_request>:
 *         ERR_MEM if the ARP packet couldn't be allocated
 *         any other err_t on failure
 */
err_t
etharp_request(struct netif *netif, struct ip_addr *ipaddr)
{
  80c8ff:	55                   	push   %ebp
  80c900:	89 e5                	mov    %esp,%ebp
  80c902:	57                   	push   %edi
  80c903:	56                   	push   %esi
  80c904:	53                   	push   %ebx
  80c905:	83 ec 3c             	sub    $0x3c,%esp
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
  80c908:	8b 75 08             	mov    0x8(%ebp),%esi
  80c90b:	83 c6 25             	add    $0x25,%esi
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  /* allocate a pbuf for the outgoing ARP request packet */
  p = pbuf_alloc(PBUF_LINK, sizeof(struct etharp_hdr), PBUF_RAM);
  80c90e:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80c915:	00 
  80c916:	c7 44 24 04 2a 00 00 	movl   $0x2a,0x4(%esp)
  80c91d:	00 
  80c91e:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80c925:	e8 e9 b8 ff ff       	call   808213 <pbuf_alloc>
  80c92a:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  /* could allocate a pbuf for an ARP request? */
  if (p == NULL) {
  80c92d:	bb ff ff ff ff       	mov    $0xffffffff,%ebx
  80c932:	85 c0                	test   %eax,%eax
  80c934:	0f 84 02 01 00 00    	je     80ca3c <etharp_request+0x13d>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 2, ("etharp_raw: could not allocate pbuf for ARP request.\n"));
    ETHARP_STATS_INC(etharp.memerr);
    return ERR_MEM;
  }
  LWIP_ASSERT("check that first pbuf can hold struct etharp_hdr",
  80c93a:	66 83 78 0a 29       	cmpw   $0x29,0xa(%eax)
  80c93f:	77 1c                	ja     80c95d <etharp_request+0x5e>
  80c941:	c7 44 24 08 c8 41 81 	movl   $0x8141c8,0x8(%esp)
  80c948:	00 
  80c949:	c7 44 24 04 1c 04 00 	movl   $0x41c,0x4(%esp)
  80c950:	00 
  80c951:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80c958:	e8 77 40 ff ff       	call   8009d4 <_panic>
              (p->len >= sizeof(struct etharp_hdr)));

  hdr = p->payload;
  80c95d:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80c960:	8b 5a 04             	mov    0x4(%edx),%ebx
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_raw: sending raw ARP packet.\n"));
  hdr->opcode = htons(opcode);
  80c963:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c96a:	e8 e5 e3 ff ff       	call   80ad54 <htons>
  80c96f:	66 89 43 14          	mov    %ax,0x14(%ebx)

  LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80c973:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80c976:	80 79 24 06          	cmpb   $0x6,0x24(%ecx)
  80c97a:	74 1c                	je     80c998 <etharp_request+0x99>
  80c97c:	c7 44 24 08 84 41 81 	movl   $0x814184,0x8(%esp)
  80c983:	00 
  80c984:	c7 44 24 04 23 04 00 	movl   $0x423,0x4(%esp)
  80c98b:	00 
  80c98c:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80c993:	e8 3c 40 ff ff       	call   8009d4 <_panic>
  80c998:	ba 06 00 00 00       	mov    $0x6,%edx
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c99d:	bf e9 42 81 00       	mov    $0x8142e9,%edi
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
    k--;
  80c9a2:	83 ea 01             	sub    $0x1,%edx
    /* Write the ARP MAC-Addresses */
    hdr->shwaddr.addr[k] = hwsrc_addr->addr[k];
  80c9a5:	0f b6 c2             	movzbl %dl,%eax
  80c9a8:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c9ac:	88 4c 03 16          	mov    %cl,0x16(%ebx,%eax,1)
    hdr->dhwaddr.addr[k] = hwdst_addr->addr[k];
  80c9b0:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80c9b4:	88 4c 03 20          	mov    %cl,0x20(%ebx,%eax,1)
    /* Write the Ethernet MAC-Addresses */
#if LWIP_AUTOIP
    hdr->ethhdr.dest.addr[k] = ethdst_hwaddr[k];
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
  80c9b8:	0f b6 88 e3 42 81 00 	movzbl 0x8142e3(%eax),%ecx
  80c9bf:	88 0c 03             	mov    %cl,(%ebx,%eax,1)
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  80c9c2:	0f b6 0c 06          	movzbl (%esi,%eax,1),%ecx
  80c9c6:	88 4c 03 06          	mov    %cl,0x6(%ebx,%eax,1)
  /* If we are using Link-Local, ARP packets must be broadcast on the
   * link layer. (See RFC3927 Section 2.5) */
  ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : ethdst_addr->addr;
#endif /* LWIP_AUTOIP */
  /* Write MAC-Addresses (combined loop for both headers) */
  while(k > 0) {
  80c9ca:	84 d2                	test   %dl,%dl
  80c9cc:	75 d4                	jne    80c9a2 <etharp_request+0xa3>
#else  /* LWIP_AUTOIP */
    hdr->ethhdr.dest.addr[k] = ethdst_addr->addr[k];
#endif /* LWIP_AUTOIP */
    hdr->ethhdr.src.addr[k]  = ethsrc_addr->addr[k];
  }
  hdr->sipaddr = *(struct ip_addr2 *)ipsrc_addr;
  80c9ce:	8b 55 08             	mov    0x8(%ebp),%edx
  80c9d1:	8b 42 04             	mov    0x4(%edx),%eax
  80c9d4:	89 43 1c             	mov    %eax,0x1c(%ebx)
  hdr->dipaddr = *(struct ip_addr2 *)ipdst_addr;
  80c9d7:	8b 45 0c             	mov    0xc(%ebp),%eax
  80c9da:	8b 00                	mov    (%eax),%eax
  80c9dc:	89 43 26             	mov    %eax,0x26(%ebx)

  hdr->hwtype = htons(HWTYPE_ETHERNET);
  80c9df:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80c9e6:	e8 69 e3 ff ff       	call   80ad54 <htons>
  80c9eb:	66 89 43 0e          	mov    %ax,0xe(%ebx)
  hdr->proto = htons(ETHTYPE_IP);
  80c9ef:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80c9f6:	e8 59 e3 ff ff       	call   80ad54 <htons>
  80c9fb:	66 89 43 10          	mov    %ax,0x10(%ebx)
  /* set hwlen and protolen together */
  hdr->_hwlen_protolen = htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr));
  80c9ff:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80ca06:	e8 49 e3 ff ff       	call   80ad54 <htons>
  80ca0b:	66 89 43 12          	mov    %ax,0x12(%ebx)

  hdr->ethhdr.type = htons(ETHTYPE_ARP);
  80ca0f:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80ca16:	e8 39 e3 ff ff       	call   80ad54 <htons>
  80ca1b:	66 89 43 0c          	mov    %ax,0xc(%ebx)
  /* send ARP query */
  result = netif->linkoutput(netif, p);
  80ca1f:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80ca22:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  80ca26:	8b 45 08             	mov    0x8(%ebp),%eax
  80ca29:	89 04 24             	mov    %eax,(%esp)
  80ca2c:	ff 50 18             	call   *0x18(%eax)
  80ca2f:	89 c3                	mov    %eax,%ebx
  ETHARP_STATS_INC(etharp.xmit);
  /* free ARP query packet */
  pbuf_free(p);
  80ca31:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80ca34:	89 0c 24             	mov    %ecx,(%esp)
  80ca37:	e8 1c b5 ff ff       	call   807f58 <pbuf_free>
{
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_request: sending ARP request.\n"));
  return etharp_raw(netif, (struct eth_addr *)netif->hwaddr, &ethbroadcast,
                    (struct eth_addr *)netif->hwaddr, &netif->ip_addr, &ethzero,
                    ipaddr, ARP_REQUEST);
}
  80ca3c:	89 d8                	mov    %ebx,%eax
  80ca3e:	83 c4 3c             	add    $0x3c,%esp
  80ca41:	5b                   	pop    %ebx
  80ca42:	5e                   	pop    %esi
  80ca43:	5f                   	pop    %edi
  80ca44:	5d                   	pop    %ebp
  80ca45:	c3                   	ret    

0080ca46 <free_etharp_q>:
 *
 * @param q a qeueue of etharp_q_entry's to free
 */
static void
free_etharp_q(struct etharp_q_entry *q)
{
  80ca46:	55                   	push   %ebp
  80ca47:	89 e5                	mov    %esp,%ebp
  80ca49:	56                   	push   %esi
  80ca4a:	53                   	push   %ebx
  80ca4b:	83 ec 10             	sub    $0x10,%esp
  80ca4e:	89 c6                	mov    %eax,%esi
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  80ca50:	85 c0                	test   %eax,%eax
  80ca52:	75 1c                	jne    80ca70 <free_etharp_q+0x2a>
  80ca54:	c7 44 24 08 37 3a 81 	movl   $0x813a37,0x8(%esp)
  80ca5b:	00 
  80ca5c:	c7 44 24 04 93 00 00 	movl   $0x93,0x4(%esp)
  80ca63:	00 
  80ca64:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80ca6b:	e8 64 3f ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80ca70:	8b 40 04             	mov    0x4(%eax),%eax
  80ca73:	85 c0                	test   %eax,%eax
  80ca75:	74 04                	je     80ca7b <free_etharp_q+0x35>
  while (q) {
    r = q;
    q = q->next;
  80ca77:	8b 1e                	mov    (%esi),%ebx
  80ca79:	eb 45                	jmp    80cac0 <free_etharp_q+0x7a>
static void
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  80ca7b:	c7 44 24 08 85 42 81 	movl   $0x814285,0x8(%esp)
  80ca82:	00 
  80ca83:	c7 44 24 04 94 00 00 	movl   $0x94,0x4(%esp)
  80ca8a:	00 
  80ca8b:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80ca92:	e8 3d 3f ff ff       	call   8009d4 <_panic>
  while (q) {
    r = q;
    q = q->next;
  80ca97:	8b 13                	mov    (%ebx),%edx
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
  80ca99:	8b 43 04             	mov    0x4(%ebx),%eax
  80ca9c:	85 c0                	test   %eax,%eax
  80ca9e:	75 1c                	jne    80cabc <free_etharp_q+0x76>
  80caa0:	c7 44 24 08 92 42 81 	movl   $0x814292,0x8(%esp)
  80caa7:	00 
  80caa8:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80caaf:	00 
  80cab0:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80cab7:	e8 18 3f ff ff       	call   8009d4 <_panic>
  80cabc:	89 de                	mov    %ebx,%esi
  80cabe:	89 d3                	mov    %edx,%ebx
    pbuf_free(r->p);
  80cac0:	89 04 24             	mov    %eax,(%esp)
  80cac3:	e8 90 b4 ff ff       	call   807f58 <pbuf_free>
    memp_free(MEMP_ARP_QUEUE, r);
  80cac8:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cacc:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80cad3:	e8 e8 ac ff ff       	call   8077c0 <memp_free>
free_etharp_q(struct etharp_q_entry *q)
{
  struct etharp_q_entry *r;
  LWIP_ASSERT("q != NULL", q != NULL);
  LWIP_ASSERT("q->p != NULL", q->p != NULL);
  while (q) {
  80cad8:	85 db                	test   %ebx,%ebx
  80cada:	75 bb                	jne    80ca97 <free_etharp_q+0x51>
    q = q->next;
    LWIP_ASSERT("r->p != NULL", (r->p != NULL));
    pbuf_free(r->p);
    memp_free(MEMP_ARP_QUEUE, r);
  }
}
  80cadc:	83 c4 10             	add    $0x10,%esp
  80cadf:	5b                   	pop    %ebx
  80cae0:	5e                   	pop    %esi
  80cae1:	5d                   	pop    %ebp
  80cae2:	c3                   	ret    

0080cae3 <find_entry>:
#if LWIP_NETIF_HWADDRHINT
find_entry(struct ip_addr *ipaddr, u8_t flags, struct netif *netif)
#else /* LWIP_NETIF_HWADDRHINT */
find_entry(struct ip_addr *ipaddr, u8_t flags)
#endif /* LWIP_NETIF_HWADDRHINT */
{
  80cae3:	55                   	push   %ebp
  80cae4:	89 e5                	mov    %esp,%ebp
  80cae6:	57                   	push   %edi
  80cae7:	56                   	push   %esi
  80cae8:	53                   	push   %ebx
  80cae9:	83 ec 3c             	sub    $0x3c,%esp
  80caec:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80caef:	88 55 dd             	mov    %dl,-0x23(%ebp)
  u8_t age_queue = 0;
#endif

  /* First, test if the last call to this function asked for the
   * same address. If so, we're really fast! */
  if (ipaddr) {
  80caf2:	85 c0                	test   %eax,%eax
  80caf4:	74 16                	je     80cb0c <find_entry+0x29>
          return per_pcb_cache;
        }
      }
    }
#else /* #if LWIP_NETIF_HWADDRHINT */
    if (arp_table[etharp_cached_entry].state == ETHARP_STATE_STABLE) {
  80caf6:	0f b6 05 f8 8e b3 00 	movzbl 0xb38ef8,%eax
  80cafd:	0f b6 d0             	movzbl %al,%edx
  80cb00:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80cb03:	83 b9 f0 8d b3 00 02 	cmpl   $0x2,0xb38df0(%ecx)
  80cb0a:	74 2a                	je     80cb36 <find_entry+0x53>
  80cb0c:	ba f4 8d b3 00       	mov    $0xb38df4,%edx
  80cb11:	be 00 00 00 00       	mov    $0x0,%esi
  80cb16:	c6 45 df 0a          	movb   $0xa,-0x21(%ebp)
  80cb1a:	bf 00 00 00 00       	mov    $0x0,%edi
  80cb1f:	c6 45 e7 00          	movb   $0x0,-0x19(%ebp)
  80cb23:	b8 00 00 00 00       	mov    $0x0,%eax
  80cb28:	c6 45 e5 0a          	movb   $0xa,-0x1b(%ebp)
  80cb2c:	c6 45 de 0a          	movb   $0xa,-0x22(%ebp)
  80cb30:	c6 45 dc 0a          	movb   $0xa,-0x24(%ebp)
  80cb34:	eb 22                	jmp    80cb58 <find_entry+0x75>
      /* the cached entry is stable */
      if (ip_addr_cmp(ipaddr, &arp_table[etharp_cached_entry].ipaddr)) {
  80cb36:	6b d2 1c             	imul   $0x1c,%edx,%edx
  80cb39:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cb3c:	8b 0b                	mov    (%ebx),%ecx
  80cb3e:	3b 8a e4 8d b3 00    	cmp    0xb38de4(%edx),%ecx
  80cb44:	75 c6                	jne    80cb0c <find_entry+0x29>
  80cb46:	e9 c4 01 00 00       	jmp    80cd0f <find_entry+0x22c>
        /* cached entry was the right one! */
        ETHARP_STATS_INC(etharp.cachehit);
        return etharp_cached_entry;
  80cb4b:	89 ce                	mov    %ecx,%esi
  80cb4d:	0f b6 7d d7          	movzbl -0x29(%ebp),%edi
  80cb51:	0f b6 4d e6          	movzbl -0x1a(%ebp),%ecx
  80cb55:	88 4d e7             	mov    %cl,-0x19(%ebp)
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    /* no empty entry found yet and now we do find one? */
    if ((empty == ARP_TABLE_SIZE) && (arp_table[i].state == ETHARP_STATE_EMPTY)) {
  80cb58:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80cb5c:	75 1c                	jne    80cb7a <find_entry+0x97>
  80cb5e:	83 7a fc 00          	cmpl   $0x0,-0x4(%edx)
  80cb62:	75 16                	jne    80cb7a <find_entry+0x97>
  80cb64:	88 45 e5             	mov    %al,-0x1b(%ebp)
  80cb67:	89 f1                	mov    %esi,%ecx
  80cb69:	89 fb                	mov    %edi,%ebx
  80cb6b:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cb6e:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cb72:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cb75:	e9 a0 00 00 00       	jmp    80cc1a <find_entry+0x137>
      LWIP_DEBUGF(ETHARP_DEBUG, ("find_entry: found empty entry %"U16_F"\n", (u16_t)i));
      /* remember first empty entry */
      empty = i;
    }
    /* pending entry? */
    else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80cb7a:	8b 4a fc             	mov    -0x4(%edx),%ecx
  80cb7d:	83 f9 01             	cmp    $0x1,%ecx
  80cb80:	75 51                	jne    80cbd3 <find_entry+0xf0>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80cb82:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cb86:	74 14                	je     80cb9c <find_entry+0xb9>
  80cb88:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cb8b:	8b 0b                	mov    (%ebx),%ecx
  80cb8d:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80cb90:	75 0a                	jne    80cb9c <find_entry+0xb9>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching pending entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80cb92:	a2 f8 8e b3 00       	mov    %al,0xb38ef8
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80cb97:	e9 73 01 00 00       	jmp    80cd0f <find_entry+0x22c>
#if ARP_QUEUEING
      /* pending with queued packets? */
      } else if (arp_table[i].q != NULL) {
  80cb9c:	83 7a ec 00          	cmpl   $0x0,-0x14(%edx)
  80cba0:	74 1a                	je     80cbbc <find_entry+0xd9>
        if (arp_table[i].ctime >= age_queue) {
  80cba2:	0f b6 0a             	movzbl (%edx),%ecx
  80cba5:	89 f3                	mov    %esi,%ebx
  80cba7:	38 cb                	cmp    %cl,%bl
  80cba9:	77 61                	ja     80cc0c <find_entry+0x129>
  80cbab:	88 45 df             	mov    %al,-0x21(%ebp)
  80cbae:	89 fb                	mov    %edi,%ebx
  80cbb0:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cbb3:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cbb7:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cbba:	eb 5e                	jmp    80cc1a <find_entry+0x137>
          age_queue = arp_table[i].ctime;
        }
#endif
      /* pending without queued packets? */
      } else {
        if (arp_table[i].ctime >= age_pending) {
  80cbbc:	0f b6 0a             	movzbl (%edx),%ecx
  80cbbf:	88 4d e6             	mov    %cl,-0x1a(%ebp)
  80cbc2:	38 4d e7             	cmp    %cl,-0x19(%ebp)
  80cbc5:	77 45                	ja     80cc0c <find_entry+0x129>
  80cbc7:	88 45 dc             	mov    %al,-0x24(%ebp)
  80cbca:	89 f1                	mov    %esi,%ecx
  80cbcc:	89 fb                	mov    %edi,%ebx
  80cbce:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cbd1:	eb 47                	jmp    80cc1a <find_entry+0x137>
          age_pending = arp_table[i].ctime;
        }
      }        
    }
    /* stable entry? */
    else if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80cbd3:	83 f9 02             	cmp    $0x2,%ecx
  80cbd6:	75 34                	jne    80cc0c <find_entry+0x129>
      /* if given, does IP address match IP address in ARP entry? */
      if (ipaddr && ip_addr_cmp(ipaddr, &arp_table[i].ipaddr)) {
  80cbd8:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cbdc:	74 14                	je     80cbf2 <find_entry+0x10f>
  80cbde:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  80cbe1:	8b 0b                	mov    (%ebx),%ecx
  80cbe3:	3b 4a f0             	cmp    -0x10(%edx),%ecx
  80cbe6:	75 0a                	jne    80cbf2 <find_entry+0x10f>
        LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: found matching stable entry %"U16_F"\n", (u16_t)i));
        /* found exact IP address match, simply bail out */
#if LWIP_NETIF_HWADDRHINT
        NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
        etharp_cached_entry = i;
  80cbe8:	a2 f8 8e b3 00       	mov    %al,0xb38ef8
#endif /* #if LWIP_NETIF_HWADDRHINT */
        return i;
  80cbed:	e9 1d 01 00 00       	jmp    80cd0f <find_entry+0x22c>
      /* remember entry with oldest stable entry in oldest, its age in maxtime */
      } else if (arp_table[i].ctime >= age_stable) {
  80cbf2:	0f b6 0a             	movzbl (%edx),%ecx
  80cbf5:	88 4d d7             	mov    %cl,-0x29(%ebp)
  80cbf8:	89 fb                	mov    %edi,%ebx
  80cbfa:	38 cb                	cmp    %cl,%bl
  80cbfc:	77 0e                	ja     80cc0c <find_entry+0x129>
  80cbfe:	88 45 de             	mov    %al,-0x22(%ebp)
  80cc01:	89 f1                	mov    %esi,%ecx
  80cc03:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cc07:	88 5d e6             	mov    %bl,-0x1a(%ebp)
  80cc0a:	eb 0e                	jmp    80cc1a <find_entry+0x137>
  80cc0c:	89 f1                	mov    %esi,%ecx
  80cc0e:	89 fb                	mov    %edi,%ebx
  80cc10:	88 5d d7             	mov    %bl,-0x29(%ebp)
  80cc13:	0f b6 5d e7          	movzbl -0x19(%ebp),%ebx
  80cc17:	88 5d e6             	mov    %bl,-0x1a(%ebp)
   * 4) remember the oldest pending entry with queued packets (if any)
   * 5) search for a matching IP entry, either pending or stable
   *    until 5 matches, or all entries are searched for.
   */

  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80cc1a:	83 c0 01             	add    $0x1,%eax
  80cc1d:	83 c2 1c             	add    $0x1c,%edx
  80cc20:	3c 0a                	cmp    $0xa,%al
  80cc22:	0f 85 23 ff ff ff    	jne    80cb4b <find_entry+0x68>
    }
  }
  /* { we have no match } => try to create a new entry */
   
  /* no empty entry found and not allowed to recycle? */
  if (((empty == ARP_TABLE_SIZE) && ((flags & ETHARP_TRY_HARD) == 0))
  80cc28:	80 7d e5 0a          	cmpb   $0xa,-0x1b(%ebp)
  80cc2c:	75 0a                	jne    80cc38 <find_entry+0x155>
  80cc2e:	f6 45 dd 01          	testb  $0x1,-0x23(%ebp)
  80cc32:	0f 84 d2 00 00 00    	je     80cd0a <find_entry+0x227>
  80cc38:	f6 45 dd 02          	testb  $0x2,-0x23(%ebp)
  80cc3c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80cc40:	0f 85 c4 00 00 00    	jne    80cd0a <find_entry+0x227>
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
    i = empty;
  80cc46:	0f b6 5d e5          	movzbl -0x1b(%ebp),%ebx
   * 
   * { ETHARP_TRY_HARD is set at this point }
   */ 

  /* 1) empty entry available? */
  if (empty < ARP_TABLE_SIZE) {
  80cc4a:	80 fb 09             	cmp    $0x9,%bl
  80cc4d:	8d 76 00             	lea    0x0(%esi),%esi
  80cc50:	7e 62                	jle    80ccb4 <find_entry+0x1d1>
    i = empty;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting empty entry %"U16_F"\n", (u16_t)i));
  }
  /* 2) found recyclable stable entry? */
  else if (old_stable < ARP_TABLE_SIZE) {
  80cc52:	80 7d de 09          	cmpb   $0x9,-0x22(%ebp)
  80cc56:	7f 2f                	jg     80cc87 <find_entry+0x1a4>
    /* recycle oldest stable*/
    i = old_stable;
  80cc58:	0f b6 5d de          	movzbl -0x22(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest stable entry %"U16_F"\n", (u16_t)i));
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
  80cc5c:	0f b6 c3             	movzbl %bl,%eax
  80cc5f:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80cc62:	83 b8 e0 8d b3 00 00 	cmpl   $0x0,0xb38de0(%eax)
  80cc69:	74 49                	je     80ccb4 <find_entry+0x1d1>
  80cc6b:	c7 44 24 08 9f 42 81 	movl   $0x81429f,0x8(%esp)
  80cc72:	00 
  80cc73:	c7 44 24 04 75 01 00 	movl   $0x175,0x4(%esp)
  80cc7a:	00 
  80cc7b:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80cc82:	e8 4d 3d ff ff       	call   8009d4 <_panic>
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
    /* recycle oldest pending */
    i = old_pending;
  80cc87:	0f b6 5d dc          	movzbl -0x24(%ebp),%ebx
#if ARP_QUEUEING
    /* no queued packets should exist on stable entries */
    LWIP_ASSERT("arp_table[i].q == NULL", arp_table[i].q == NULL);
#endif
  /* 3) found recyclable pending entry without queued packets? */
  } else if (old_pending < ARP_TABLE_SIZE) {
  80cc8b:	80 fb 09             	cmp    $0x9,%bl
  80cc8e:	7e 24                	jle    80ccb4 <find_entry+0x1d1>
    /* recycle oldest pending */
    i = old_pending;
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F" (without queue)\n", (u16_t)i));
#if ARP_QUEUEING
  /* 4) found recyclable pending entry with queued packets? */
  } else if (old_queue < ARP_TABLE_SIZE) {
  80cc90:	80 7d df 09          	cmpb   $0x9,-0x21(%ebp)
  80cc94:	7f 74                	jg     80cd0a <find_entry+0x227>
    /* recycle oldest pending */
    i = old_queue;
  80cc96:	0f b6 5d df          	movzbl -0x21(%ebp),%ebx
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("find_entry: selecting oldest pending entry %"U16_F", freeing packet queue %p\n", (u16_t)i, (void *)(arp_table[i].q)));
    free_etharp_q(arp_table[i].q);
  80cc9a:	0f b6 f3             	movzbl %bl,%esi
  80cc9d:	bf e0 8d b3 00       	mov    $0xb38de0,%edi
  80cca2:	6b f6 1c             	imul   $0x1c,%esi,%esi
  80cca5:	8b 04 3e             	mov    (%esi,%edi,1),%eax
  80cca8:	e8 99 fd ff ff       	call   80ca46 <free_etharp_q>
    arp_table[i].q = NULL;
  80ccad:	c7 04 3e 00 00 00 00 	movl   $0x0,(%esi,%edi,1)
  } else {
    return (s8_t)ERR_MEM;
  }

  /* { empty or recyclable entry found } */
  LWIP_ASSERT("i < ARP_TABLE_SIZE", i < ARP_TABLE_SIZE);
  80ccb4:	80 fb 09             	cmp    $0x9,%bl
  80ccb7:	76 1c                	jbe    80ccd5 <find_entry+0x1f2>
  80ccb9:	c7 44 24 08 b6 42 81 	movl   $0x8142b6,0x8(%esp)
  80ccc0:	00 
  80ccc1:	c7 44 24 04 8b 01 00 	movl   $0x18b,0x4(%esp)
  80ccc8:	00 
  80ccc9:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80ccd0:	e8 ff 3c ff ff       	call   8009d4 <_panic>
  if (arp_table[i].state != ETHARP_STATE_EMPTY)
  {
    snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
  }
  /* recycle entry (no-op for an already empty entry) */
  arp_table[i].state = ETHARP_STATE_EMPTY;
  80ccd5:	0f b6 c3             	movzbl %bl,%eax
  80ccd8:	6b d0 1c             	imul   $0x1c,%eax,%edx
  80ccdb:	c7 82 f0 8d b3 00 00 	movl   $0x0,0xb38df0(%edx)
  80cce2:	00 00 00 

  /* IP address given? */
  if (ipaddr != NULL) {
  80cce5:	83 7d e0 00          	cmpl   $0x0,-0x20(%ebp)
  80cce9:	74 0b                	je     80ccf6 <find_entry+0x213>
    /* set IP address */
    ip_addr_set(&arp_table[i].ipaddr, ipaddr);
  80cceb:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80ccee:	8b 0e                	mov    (%esi),%ecx
  80ccf0:	89 8a e4 8d b3 00    	mov    %ecx,0xb38de4(%edx)
  }
  arp_table[i].ctime = 0;
  80ccf6:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80ccf9:	c6 80 f4 8d b3 00 00 	movb   $0x0,0xb38df4(%eax)
#if LWIP_NETIF_HWADDRHINT
  NETIF_SET_HINT(netif, i);
#else /* #if LWIP_NETIF_HWADDRHINT */
  etharp_cached_entry = i;
  80cd00:	88 1d f8 8e b3 00    	mov    %bl,0xb38ef8
#endif /* #if LWIP_NETIF_HWADDRHINT */
  return (err_t)i;
  80cd06:	89 d8                	mov    %ebx,%eax
  80cd08:	eb 05                	jmp    80cd0f <find_entry+0x22c>
  80cd0a:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
}
  80cd0f:	83 c4 3c             	add    $0x3c,%esp
  80cd12:	5b                   	pop    %ebx
  80cd13:	5e                   	pop    %esi
  80cd14:	5f                   	pop    %edi
  80cd15:	5d                   	pop    %ebp
  80cd16:	c3                   	ret    

0080cd17 <etharp_query>:
 * - ERR_ARG Non-unicast address given, those will not appear in ARP cache.
 *
 */
err_t
etharp_query(struct netif *netif, struct ip_addr *ipaddr, struct pbuf *q)
{
  80cd17:	55                   	push   %ebp
  80cd18:	89 e5                	mov    %esp,%ebp
  80cd1a:	83 ec 38             	sub    $0x38,%esp
  80cd1d:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cd20:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cd23:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cd26:	8b 75 08             	mov    0x8(%ebp),%esi
  80cd29:	8b 5d 0c             	mov    0xc(%ebp),%ebx
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80cd2c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80cd30:	89 1c 24             	mov    %ebx,(%esp)
  80cd33:	e8 10 cc ff ff       	call   809948 <ip_addr_isbroadcast>
  80cd38:	84 c0                	test   %al,%al
  80cd3a:	0f 85 c7 01 00 00    	jne    80cf07 <etharp_query+0x1f0>
      ip_addr_ismulticast(ipaddr) ||
  80cd40:	8b 03                	mov    (%ebx),%eax
  80cd42:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80cd45:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cd4c:	e8 49 e2 ff ff       	call   80af9a <ntohl>
  80cd51:	89 c7                	mov    %eax,%edi
  80cd53:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cd5a:	e8 3b e2 ff ff       	call   80af9a <ntohl>
  struct eth_addr * srcaddr = (struct eth_addr *)netif->hwaddr;
  err_t result = ERR_MEM;
  s8_t i; /* ARP entry index */

  /* non-unicast address? */
  if (ip_addr_isbroadcast(ipaddr, netif) ||
  80cd5f:	23 7d e4             	and    -0x1c(%ebp),%edi
  80cd62:	39 c7                	cmp    %eax,%edi
  80cd64:	0f 84 9d 01 00 00    	je     80cf07 <etharp_query+0x1f0>
  80cd6a:	85 db                	test   %ebx,%ebx
  80cd6c:	0f 84 95 01 00 00    	je     80cf07 <etharp_query+0x1f0>
      ip_addr_ismulticast(ipaddr) ||
      ip_addr_isany(ipaddr)) {
  80cd72:	83 3b 00             	cmpl   $0x0,(%ebx)
  80cd75:	0f 84 8c 01 00 00    	je     80cf07 <etharp_query+0x1f0>

  /* find entry in ARP cache, ask to create entry if queueing packet */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_TRY_HARD, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_TRY_HARD);
  80cd7b:	ba 01 00 00 00       	mov    $0x1,%edx
  80cd80:	89 d8                	mov    %ebx,%eax
  80cd82:	e8 5c fd ff ff       	call   80cae3 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */

  /* could not find or create entry? */
  if (i < 0) {
  80cd87:	84 c0                	test   %al,%al
  80cd89:	0f 88 83 01 00 00    	js     80cf12 <etharp_query+0x1fb>
    }
    return (err_t)i;
  }

  /* mark a fresh entry as pending (we just sent a request) */
  if (arp_table[i].state == ETHARP_STATE_EMPTY) {
  80cd8f:	0f be f8             	movsbl %al,%edi
  80cd92:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cd95:	8b 80 f0 8d b3 00    	mov    0xb38df0(%eax),%eax
  80cd9b:	85 c0                	test   %eax,%eax
  80cd9d:	75 0f                	jne    80cdae <etharp_query+0x97>
    arp_table[i].state = ETHARP_STATE_PENDING;
  80cd9f:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cda2:	c7 80 f0 8d b3 00 01 	movl   $0x1,0xb38df0(%eax)
  80cda9:	00 00 00 
  80cdac:	eb 33                	jmp    80cde1 <etharp_query+0xca>
  }

  /* { i is either a STABLE or (new or existing) PENDING entry } */
  LWIP_ASSERT("arp_table[i].state == PENDING or STABLE",
  80cdae:	8d 50 ff             	lea    -0x1(%eax),%edx
  80cdb1:	83 fa 01             	cmp    $0x1,%edx
  80cdb4:	76 1c                	jbe    80cdd2 <etharp_query+0xbb>
  80cdb6:	c7 44 24 08 fc 41 81 	movl   $0x8141fc,0x8(%esp)
  80cdbd:	00 
  80cdbe:	c7 44 24 04 92 03 00 	movl   $0x392,0x4(%esp)
  80cdc5:	00 
  80cdc6:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80cdcd:	e8 02 3c ff ff       	call   8009d4 <_panic>
  ((arp_table[i].state == ETHARP_STATE_PENDING) ||
   (arp_table[i].state == ETHARP_STATE_STABLE)));

  /* do we have a pending entry? or an implicit query request? */
  if ((arp_table[i].state == ETHARP_STATE_PENDING) || (q == NULL)) {
  80cdd2:	83 f8 01             	cmp    $0x1,%eax
  80cdd5:	74 0a                	je     80cde1 <etharp_query+0xca>
  80cdd7:	c6 45 e4 ff          	movb   $0xff,-0x1c(%ebp)
  80cddb:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80cddf:	75 0f                	jne    80cdf0 <etharp_query+0xd9>
    /* try to resolve it; send out ARP request */
    result = etharp_request(netif, ipaddr);
  80cde1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cde5:	89 34 24             	mov    %esi,(%esp)
  80cde8:	e8 12 fb ff ff       	call   80c8ff <etharp_request>
  80cded:	88 45 e4             	mov    %al,-0x1c(%ebp)
         etharp_query again could lead to sending the queued packets. */
    }
  }
  
  /* packet given? */
  if (q != NULL) {
  80cdf0:	83 7d 10 00          	cmpl   $0x0,0x10(%ebp)
  80cdf4:	0f 84 14 01 00 00    	je     80cf0e <etharp_query+0x1f7>
    /* stable entry? */
    if (arp_table[i].state == ETHARP_STATE_STABLE) {
  80cdfa:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80cdfd:	8b 80 f0 8d b3 00    	mov    0xb38df0(%eax),%eax
  80ce03:	83 f8 02             	cmp    $0x2,%eax
  80ce06:	75 1d                	jne    80ce25 <etharp_query+0x10e>
      /* we have a valid IP->Ethernet address mapping */
      /* send the packet */
      result = etharp_send_ip(netif, q, srcaddr, &(arp_table[i].ethaddr));
  80ce08:	8d 4e 25             	lea    0x25(%esi),%ecx
  80ce0b:	6b c7 1c             	imul   $0x1c,%edi,%eax
  80ce0e:	05 e8 8d b3 00       	add    $0xb38de8,%eax
  80ce13:	89 04 24             	mov    %eax,(%esp)
  80ce16:	8b 55 10             	mov    0x10(%ebp),%edx
  80ce19:	89 f0                	mov    %esi,%eax
  80ce1b:	e8 60 fa ff ff       	call   80c880 <etharp_send_ip>
  80ce20:	e9 ed 00 00 00       	jmp    80cf12 <etharp_query+0x1fb>
    /* pending entry? (either just created or already pending */
    } else if (arp_table[i].state == ETHARP_STATE_PENDING) {
  80ce25:	83 f8 01             	cmp    $0x1,%eax
  80ce28:	0f 85 e0 00 00 00    	jne    80cf0e <etharp_query+0x1f7>
  80ce2e:	8b 45 10             	mov    0x10(%ebp),%eax
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
        LWIP_ASSERT("no packet queues allowed!", (p->len != p->tot_len) || (p->next == 0));
  80ce31:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  80ce35:	66 3b 50 08          	cmp    0x8(%eax),%dx
  80ce39:	75 21                	jne    80ce5c <etharp_query+0x145>
  80ce3b:	83 38 00             	cmpl   $0x0,(%eax)
  80ce3e:	74 1c                	je     80ce5c <etharp_query+0x145>
  80ce40:	c7 44 24 08 c9 42 81 	movl   $0x8142c9,0x8(%esp)
  80ce47:	00 
  80ce48:	c7 44 24 04 b1 03 00 	movl   $0x3b1,0x4(%esp)
  80ce4f:	00 
  80ce50:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80ce57:	e8 78 3b ff ff       	call   8009d4 <_panic>
        if(p->type != PBUF_ROM) {
  80ce5c:	80 78 0c 01          	cmpb   $0x1,0xc(%eax)
  80ce60:	75 0b                	jne    80ce6d <etharp_query+0x156>
          copy_needed = 1;
          break;
        }
        p = p->next;
  80ce62:	8b 00                	mov    (%eax),%eax
      int copy_needed = 0;
      /* IF q includes a PBUF_REF, PBUF_POOL or PBUF_RAM, we have no choice but
       * to copy the whole queue into a new PBUF_RAM (see bug #11400) 
       * PBUF_ROMs can be left as they are, since ROM must not get changed. */
      p = q;
      while (p) {
  80ce64:	85 c0                	test   %eax,%eax
  80ce66:	75 c9                	jne    80ce31 <etharp_query+0x11a>
  80ce68:	e9 b2 00 00 00       	jmp    80cf1f <etharp_query+0x208>
        }
        p = p->next;
      }
      if(copy_needed) {
        /* copy the whole packet into new pbufs */
        p = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80ce6d:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80ce71:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ce78:	00 
  80ce79:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ce7d:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80ce84:	e8 8a b3 ff ff       	call   808213 <pbuf_alloc>
  80ce89:	89 c3                	mov    %eax,%ebx
        if(p != NULL) {
  80ce8b:	85 c0                	test   %eax,%eax
  80ce8d:	74 7f                	je     80cf0e <etharp_query+0x1f7>
          if (pbuf_copy(p, q) != ERR_OK) {
  80ce8f:	8b 45 10             	mov    0x10(%ebp),%eax
  80ce92:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ce96:	89 1c 24             	mov    %ebx,(%esp)
  80ce99:	e8 07 af ff ff       	call   807da5 <pbuf_copy>
  80ce9e:	84 c0                	test   %al,%al
  80cea0:	74 10                	je     80ceb2 <etharp_query+0x19b>
            pbuf_free(p);
  80cea2:	89 1c 24             	mov    %ebx,(%esp)
  80cea5:	e8 ae b0 ff ff       	call   807f58 <pbuf_free>
  80ceaa:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
  80ceae:	66 90                	xchg   %ax,%ax
  80ceb0:	eb 60                	jmp    80cf12 <etharp_query+0x1fb>
      /* packet could be taken over? */
      if (p != NULL) {
        /* queue packet ... */
        struct etharp_q_entry *new_entry;
        /* allocate a new arp queue entry */
        new_entry = memp_malloc(MEMP_ARP_QUEUE);
  80ceb2:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80ceb9:	e8 46 a9 ff ff       	call   807804 <memp_malloc>
        if (new_entry != NULL) {
  80cebe:	85 c0                	test   %eax,%eax
  80cec0:	74 37                	je     80cef9 <etharp_query+0x1e2>
          new_entry->next = 0;
  80cec2:	c7 00 00 00 00 00    	movl   $0x0,(%eax)
          new_entry->p = p;
  80cec8:	89 58 04             	mov    %ebx,0x4(%eax)
          if(arp_table[i].q != NULL) {
  80cecb:	6b d7 1c             	imul   $0x1c,%edi,%edx
  80cece:	8b 92 e0 8d b3 00    	mov    0xb38de0(%edx),%edx
  80ced4:	85 d2                	test   %edx,%edx
  80ced6:	74 11                	je     80cee9 <etharp_query+0x1d2>
            /* queue was already existent, append the new entry to the end */
            struct etharp_q_entry *r;
            r = arp_table[i].q;
            while (r->next != NULL) {
  80ced8:	89 d1                	mov    %edx,%ecx
  80ceda:	8b 12                	mov    (%edx),%edx
  80cedc:	85 d2                	test   %edx,%edx
  80cede:	75 f8                	jne    80ced8 <etharp_query+0x1c1>
              r = r->next;
            }
            r->next = new_entry;
  80cee0:	89 01                	mov    %eax,(%ecx)
  80cee2:	b8 00 00 00 00       	mov    $0x0,%eax
  80cee7:	eb 29                	jmp    80cf12 <etharp_query+0x1fb>
          } else {
            /* queue did not exist, first item in queue */
            arp_table[i].q = new_entry;
  80cee9:	6b ff 1c             	imul   $0x1c,%edi,%edi
  80ceec:	89 87 e0 8d b3 00    	mov    %eax,0xb38de0(%edi)
  80cef2:	b8 00 00 00 00       	mov    $0x0,%eax
  80cef7:	eb 19                	jmp    80cf12 <etharp_query+0x1fb>
          }
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: queued packet %p on ARP entry %"S16_F"\n", (void *)q, (s16_t)i));
          result = ERR_OK;
        } else {
          /* the pool MEMP_ARP_QUEUE is empty */
          pbuf_free(p);
  80cef9:	89 1c 24             	mov    %ebx,(%esp)
  80cefc:	e8 57 b0 ff ff       	call   807f58 <pbuf_free>
  80cf01:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
          LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: could not queue a copy of PBUF_REF packet %p (out of memory)\n", (void *)q));
  80cf05:	eb 0b                	jmp    80cf12 <etharp_query+0x1fb>
  80cf07:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
  80cf0c:	eb 04                	jmp    80cf12 <etharp_query+0x1fb>
  80cf0e:	0f b6 45 e4          	movzbl -0x1c(%ebp),%eax
      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_query: Ethernet destination address unknown, queueing disabled, packet %p dropped\n", (void *)q));
#endif
    }
  }
  return result;
}
  80cf12:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80cf15:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80cf18:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80cf1b:	89 ec                	mov    %ebp,%esp
  80cf1d:	5d                   	pop    %ebp
  80cf1e:	c3                   	ret    
          }
        }
      } else {
        /* referencing the old pbuf is enough */
        p = q;
        pbuf_ref(p);
  80cf1f:	8b 45 10             	mov    0x10(%ebp),%eax
  80cf22:	89 04 24             	mov    %eax,(%esp)
  80cf25:	e8 e0 ab ff ff       	call   807b0a <pbuf_ref>
  80cf2a:	8b 5d 10             	mov    0x10(%ebp),%ebx
  80cf2d:	eb 83                	jmp    80ceb2 <etharp_query+0x19b>

0080cf2f <etharp_output>:
 * - ERR_RTE No route to destination (no gateway to external networks),
 * or the return type of either etharp_query() or etharp_send_ip().
 */
err_t
etharp_output(struct netif *netif, struct pbuf *q, struct ip_addr *ipaddr)
{
  80cf2f:	55                   	push   %ebp
  80cf30:	89 e5                	mov    %esp,%ebp
  80cf32:	83 ec 48             	sub    $0x48,%esp
  80cf35:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80cf38:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80cf3b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80cf3e:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80cf41:	8b 75 0c             	mov    0xc(%ebp),%esi
  80cf44:	8b 7d 10             	mov    0x10(%ebp),%edi
  struct eth_addr *dest, mcastaddr;

  /* make room for Ethernet header - should not fail */
  if (pbuf_header(q, sizeof(struct eth_hdr)) != 0) {
  80cf47:	c7 44 24 04 0e 00 00 	movl   $0xe,0x4(%esp)
  80cf4e:	00 
  80cf4f:	89 34 24             	mov    %esi,(%esp)
  80cf52:	e8 8c ac ff ff       	call   807be3 <pbuf_header>
  80cf57:	89 c2                	mov    %eax,%edx
  80cf59:	b8 fe ff ff ff       	mov    $0xfffffffe,%eax
  80cf5e:	84 d2                	test   %dl,%dl
  80cf60:	0f 85 bd 00 00 00    	jne    80d023 <etharp_output+0xf4>
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80cf66:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80cf6a:	89 3c 24             	mov    %edi,(%esp)
  80cf6d:	e8 d6 c9 ff ff       	call   809948 <ip_addr_isbroadcast>
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80cf72:	ba e3 42 81 00       	mov    $0x8142e3,%edx
  dest = NULL;
  /* Determine on destination hardware address. Broadcasts and multicasts
   * are special, other IP addresses are looked up in the ARP table. */

  /* broadcast destination IP address? */
  if (ip_addr_isbroadcast(ipaddr, netif)) {
  80cf77:	84 c0                	test   %al,%al
  80cf79:	0f 85 95 00 00 00    	jne    80d014 <etharp_output+0xe5>
    /* broadcast on Ethernet also */
    dest = (struct eth_addr *)&ethbroadcast;
  /* multicast destination IP address? */
  } else if (ip_addr_ismulticast(ipaddr)) {
  80cf7f:	8b 07                	mov    (%edi),%eax
  80cf81:	89 45 d0             	mov    %eax,-0x30(%ebp)
  80cf84:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80cf8b:	e8 0a e0 ff ff       	call   80af9a <ntohl>
  80cf90:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  80cf93:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80cf9a:	e8 fb df ff ff       	call   80af9a <ntohl>
  80cf9f:	8b 55 d4             	mov    -0x2c(%ebp),%edx
  80cfa2:	23 55 d0             	and    -0x30(%ebp),%edx
  80cfa5:	39 c2                	cmp    %eax,%edx
  80cfa7:	75 41                	jne    80cfea <etharp_output+0xbb>
    /* Hash IP multicast address to MAC address.*/
    mcastaddr.addr[0] = 0x01;
  80cfa9:	c6 45 e2 01          	movb   $0x1,-0x1e(%ebp)
    mcastaddr.addr[1] = 0x00;
  80cfad:	c6 45 e3 00          	movb   $0x0,-0x1d(%ebp)
    mcastaddr.addr[2] = 0x5e;
  80cfb1:	c6 45 e4 5e          	movb   $0x5e,-0x1c(%ebp)
    mcastaddr.addr[3] = ip4_addr2(ipaddr) & 0x7f;
  80cfb5:	8b 07                	mov    (%edi),%eax
  80cfb7:	89 04 24             	mov    %eax,(%esp)
  80cfba:	e8 db df ff ff       	call   80af9a <ntohl>
  80cfbf:	c1 e8 10             	shr    $0x10,%eax
  80cfc2:	83 e0 7f             	and    $0x7f,%eax
  80cfc5:	88 45 e5             	mov    %al,-0x1b(%ebp)
    mcastaddr.addr[4] = ip4_addr3(ipaddr);
  80cfc8:	8b 07                	mov    (%edi),%eax
  80cfca:	89 04 24             	mov    %eax,(%esp)
  80cfcd:	e8 c8 df ff ff       	call   80af9a <ntohl>
  80cfd2:	c1 e8 08             	shr    $0x8,%eax
  80cfd5:	88 45 e6             	mov    %al,-0x1a(%ebp)
    mcastaddr.addr[5] = ip4_addr4(ipaddr);
  80cfd8:	8b 07                	mov    (%edi),%eax
  80cfda:	89 04 24             	mov    %eax,(%esp)
  80cfdd:	e8 b8 df ff ff       	call   80af9a <ntohl>
  80cfe2:	88 45 e7             	mov    %al,-0x19(%ebp)
  80cfe5:	8d 55 e2             	lea    -0x1e(%ebp),%edx
  80cfe8:	eb 2a                	jmp    80d014 <etharp_output+0xe5>
    /* destination Ethernet address is multicast */
    dest = &mcastaddr;
  /* unicast destination IP address? */
  } else {
    /* outside local network? */
    if (!ip_addr_netcmp(ipaddr, &(netif->ip_addr), &(netif->netmask))) {
  80cfea:	8b 43 04             	mov    0x4(%ebx),%eax
  80cfed:	33 07                	xor    (%edi),%eax
  80cfef:	85 43 08             	test   %eax,0x8(%ebx)
  80cff2:	74 0e                	je     80d002 <etharp_output+0xd3>
      /* interface has default gateway? */
      if (netif->gw.addr != 0) {
  80cff4:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80cff9:	83 7b 0c 00          	cmpl   $0x0,0xc(%ebx)
  80cffd:	74 24                	je     80d023 <etharp_output+0xf4>
        /* send to hardware address of default gateway IP address */
        ipaddr = &(netif->gw);
  80cfff:	8d 7b 0c             	lea    0xc(%ebx),%edi
        /* no route to destination error (default gateway missing) */
        return ERR_RTE;
      }
    }
    /* queue on destination Ethernet address belonging to ipaddr */
    return etharp_query(netif, ipaddr, q);
  80d002:	89 74 24 08          	mov    %esi,0x8(%esp)
  80d006:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80d00a:	89 1c 24             	mov    %ebx,(%esp)
  80d00d:	e8 05 fd ff ff       	call   80cd17 <etharp_query>
  80d012:	eb 0f                	jmp    80d023 <etharp_output+0xf4>
  }

  /* continuation for multicast/broadcast destinations */
  /* obtain source Ethernet address of the given interface */
  /* send packet directly on the link */
  return etharp_send_ip(netif, q, (struct eth_addr*)(netif->hwaddr), dest);
  80d014:	8d 4b 25             	lea    0x25(%ebx),%ecx
  80d017:	89 14 24             	mov    %edx,(%esp)
  80d01a:	89 f2                	mov    %esi,%edx
  80d01c:	89 d8                	mov    %ebx,%eax
  80d01e:	e8 5d f8 ff ff       	call   80c880 <etharp_send_ip>
}
  80d023:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d026:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d029:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d02c:	89 ec                	mov    %ebp,%esp
  80d02e:	5d                   	pop    %ebp
  80d02f:	c3                   	ret    

0080d030 <etharp_find_addr>:
 * @return table index if found, -1 otherwise
 */
s8_t
etharp_find_addr(struct netif *netif, struct ip_addr *ipaddr,
         struct eth_addr **eth_ret, struct ip_addr **ip_ret)
{
  80d030:	55                   	push   %ebp
  80d031:	89 e5                	mov    %esp,%ebp
  80d033:	53                   	push   %ebx
  80d034:	83 ec 04             	sub    $0x4,%esp
  LWIP_UNUSED_ARG(netif);

#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, ETHARP_FIND_ONLY, NULL);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, ETHARP_FIND_ONLY);
  80d037:	ba 02 00 00 00       	mov    $0x2,%edx
  80d03c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80d03f:	e8 9f fa ff ff       	call   80cae3 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  if((i >= 0) && arp_table[i].state == ETHARP_STATE_STABLE) {
  80d044:	84 c0                	test   %al,%al
  80d046:	78 29                	js     80d071 <etharp_find_addr+0x41>
  80d048:	0f be d0             	movsbl %al,%edx
  80d04b:	6b ca 1c             	imul   $0x1c,%edx,%ecx
  80d04e:	83 b9 f0 8d b3 00 02 	cmpl   $0x2,0xb38df0(%ecx)
  80d055:	75 1a                	jne    80d071 <etharp_find_addr+0x41>
      *eth_ret = &arp_table[i].ethaddr;
  80d057:	89 ca                	mov    %ecx,%edx
  80d059:	81 c2 e0 8d b3 00    	add    $0xb38de0,%edx
  80d05f:	8d 5a 08             	lea    0x8(%edx),%ebx
  80d062:	8b 4d 10             	mov    0x10(%ebp),%ecx
  80d065:	89 19                	mov    %ebx,(%ecx)
      *ip_ret = &arp_table[i].ipaddr;
  80d067:	83 c2 04             	add    $0x4,%edx
  80d06a:	8b 4d 14             	mov    0x14(%ebp),%ecx
  80d06d:	89 11                	mov    %edx,(%ecx)
      return i;
  80d06f:	eb 05                	jmp    80d076 <etharp_find_addr+0x46>
  80d071:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  }
  return -1;
}
  80d076:	83 c4 04             	add    $0x4,%esp
  80d079:	5b                   	pop    %ebx
  80d07a:	5d                   	pop    %ebp
  80d07b:	c3                   	ret    

0080d07c <etharp_tmr>:
 * This function should be called every ETHARP_TMR_INTERVAL microseconds (5 seconds),
 * in order to expire entries in the ARP table.
 */
void
etharp_tmr(void)
{
  80d07c:	55                   	push   %ebp
  80d07d:	89 e5                	mov    %esp,%ebp
  80d07f:	57                   	push   %edi
  80d080:	56                   	push   %esi
  80d081:	53                   	push   %ebx
  80d082:	83 ec 0c             	sub    $0xc,%esp
  80d085:	bb 00 00 00 00       	mov    $0x0,%ebx
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80d08a:	be f4 8d b3 00       	mov    $0xb38df4,%esi
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80d08f:	bf f0 8d b3 00       	mov    $0xb38df0,%edi
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
    arp_table[i].ctime++;
  80d094:	0f b6 14 1e          	movzbl (%esi,%ebx,1),%edx
  80d098:	83 c2 01             	add    $0x1,%edx
  80d09b:	88 14 1e             	mov    %dl,(%esi,%ebx,1)
    if (((arp_table[i].state == ETHARP_STATE_STABLE) &&
  80d09e:	8b 04 1f             	mov    (%edi,%ebx,1),%eax
  80d0a1:	83 f8 02             	cmp    $0x2,%eax
  80d0a4:	75 07                	jne    80d0ad <etharp_tmr+0x31>
  80d0a6:	80 fa ef             	cmp    $0xef,%dl
  80d0a9:	77 0f                	ja     80d0ba <etharp_tmr+0x3e>
  80d0ab:	eb 2d                	jmp    80d0da <etharp_tmr+0x5e>
  80d0ad:	83 f8 01             	cmp    $0x1,%eax
  80d0b0:	75 28                	jne    80d0da <etharp_tmr+0x5e>
  80d0b2:	80 fa 01             	cmp    $0x1,%dl
  80d0b5:	8d 76 00             	lea    0x0(%esi),%esi
  80d0b8:	76 20                	jbe    80d0da <etharp_tmr+0x5e>
      /* clean up entries that have just been expired */
      /* remove from SNMP ARP index tree */
      snmp_delete_arpidx_tree(arp_table[i].netif, &arp_table[i].ipaddr);
#if ARP_QUEUEING
      /* and empty packet queue */
      if (arp_table[i].q != NULL) {
  80d0ba:	8b 83 e0 8d b3 00    	mov    0xb38de0(%ebx),%eax
  80d0c0:	85 c0                	test   %eax,%eax
  80d0c2:	74 0f                	je     80d0d3 <etharp_tmr+0x57>
        /* remove all queued packets */
        LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer: freeing entry %"U16_F", packet queue %p.\n", (u16_t)i, (void *)(arp_table[i].q)));
        free_etharp_q(arp_table[i].q);
  80d0c4:	e8 7d f9 ff ff       	call   80ca46 <free_etharp_q>
        arp_table[i].q = NULL;
  80d0c9:	c7 83 e0 8d b3 00 00 	movl   $0x0,0xb38de0(%ebx)
  80d0d0:	00 00 00 
      }
#endif
      /* recycle entry for re-use */      
      arp_table[i].state = ETHARP_STATE_EMPTY;
  80d0d3:	c7 04 1f 00 00 00 00 	movl   $0x0,(%edi,%ebx,1)
  80d0da:	83 c3 1c             	add    $0x1c,%ebx
{
  u8_t i;

  LWIP_DEBUGF(ETHARP_DEBUG, ("etharp_timer\n"));
  /* remove expired entries from the ARP table */
  for (i = 0; i < ARP_TABLE_SIZE; ++i) {
  80d0dd:	81 fb 18 01 00 00    	cmp    $0x118,%ebx
  80d0e3:	75 af                	jne    80d094 <etharp_tmr+0x18>
    if (arp_table[i].state == ETHARP_STATE_PENDING) {
        /* resend an ARP query here? */
    }
#endif
  }
}
  80d0e5:	83 c4 0c             	add    $0xc,%esp
  80d0e8:	5b                   	pop    %ebx
  80d0e9:	5e                   	pop    %esi
  80d0ea:	5f                   	pop    %edi
  80d0eb:	5d                   	pop    %ebp
  80d0ec:	c3                   	ret    

0080d0ed <update_arp_entry>:
 *
 * @see pbuf_free()
 */
static err_t
update_arp_entry(struct netif *netif, struct ip_addr *ipaddr, struct eth_addr *ethaddr, u8_t flags)
{
  80d0ed:	55                   	push   %ebp
  80d0ee:	89 e5                	mov    %esp,%ebp
  80d0f0:	83 ec 38             	sub    $0x38,%esp
  80d0f3:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d0f6:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d0f9:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d0fc:	89 c6                	mov    %eax,%esi
  80d0fe:	89 d3                	mov    %edx,%ebx
  80d100:	89 cf                	mov    %ecx,%edi
  80d102:	0f b6 45 08          	movzbl 0x8(%ebp),%eax
  80d106:	88 45 e4             	mov    %al,-0x1c(%ebp)
  s8_t i;
  u8_t k;
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 3, ("update_arp_entry()\n"));
  LWIP_ASSERT("netif->hwaddr_len == ETHARP_HWADDR_LEN", netif->hwaddr_len == ETHARP_HWADDR_LEN);
  80d109:	80 7e 24 06          	cmpb   $0x6,0x24(%esi)
  80d10d:	74 1c                	je     80d12b <update_arp_entry+0x3e>
  80d10f:	c7 44 24 08 24 42 81 	movl   $0x814224,0x8(%esp)
  80d116:	00 
  80d117:	c7 44 24 04 d9 01 00 	movl   $0x1d9,0x4(%esp)
  80d11e:	00 
  80d11f:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80d126:	e8 a9 38 ff ff       	call   8009d4 <_panic>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d12b:	85 d2                	test   %edx,%edx
  80d12d:	0f 84 14 01 00 00    	je     80d247 <update_arp_entry+0x15a>
  80d133:	83 3a 00             	cmpl   $0x0,(%edx)
  80d136:	0f 84 0b 01 00 00    	je     80d247 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
  80d13c:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d140:	89 14 24             	mov    %edx,(%esp)
  80d143:	e8 00 c8 ff ff       	call   809948 <ip_addr_isbroadcast>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d148:	84 c0                	test   %al,%al
  80d14a:	0f 85 f7 00 00 00    	jne    80d247 <update_arp_entry+0x15a>
      ip_addr_isbroadcast(ipaddr, netif) ||
      ip_addr_ismulticast(ipaddr)) {
  80d150:	8b 13                	mov    (%ebx),%edx
  80d152:	89 55 e0             	mov    %edx,-0x20(%ebp)
  80d155:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  80d15c:	e8 39 de ff ff       	call   80af9a <ntohl>
  80d161:	89 45 dc             	mov    %eax,-0x24(%ebp)
  80d164:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  80d16b:	e8 2a de ff ff       	call   80af9a <ntohl>
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: %"U16_F".%"U16_F".%"U16_F".%"U16_F" - %02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F":%02"X16_F"\n",
                                        ip4_addr1(ipaddr), ip4_addr2(ipaddr), ip4_addr3(ipaddr), ip4_addr4(ipaddr), 
                                        ethaddr->addr[0], ethaddr->addr[1], ethaddr->addr[2],
                                        ethaddr->addr[3], ethaddr->addr[4], ethaddr->addr[5]));
  /* non-unicast address? */
  if (ip_addr_isany(ipaddr) ||
  80d170:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80d173:	23 55 e0             	and    -0x20(%ebp),%edx
  80d176:	39 c2                	cmp    %eax,%edx
  80d178:	0f 84 c9 00 00 00    	je     80d247 <update_arp_entry+0x15a>
  }
  /* find or create ARP entry */
#if LWIP_NETIF_HWADDRHINT
  i = find_entry(ipaddr, flags, netif);
#else /* LWIP_NETIF_HWADDRHINT */
  i = find_entry(ipaddr, flags);
  80d17e:	0f b6 55 e4          	movzbl -0x1c(%ebp),%edx
  80d182:	89 d8                	mov    %ebx,%eax
  80d184:	e8 5a f9 ff ff       	call   80cae3 <find_entry>
#endif /* LWIP_NETIF_HWADDRHINT */
  /* bail out if no entry could be found */
  if (i < 0)
  80d189:	84 c0                	test   %al,%al
  80d18b:	0f 88 bb 00 00 00    	js     80d24c <update_arp_entry+0x15f>
    return (err_t)i;
  
  /* mark it stable */
  arp_table[i].state = ETHARP_STATE_STABLE;
  80d191:	0f be c0             	movsbl %al,%eax
  80d194:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d197:	6b c0 1c             	imul   $0x1c,%eax,%eax
  80d19a:	c7 80 f0 8d b3 00 02 	movl   $0x2,0xb38df0(%eax)
  80d1a1:	00 00 00 
  /* record network interface */
  arp_table[i].netif = netif;
  80d1a4:	89 b0 f8 8d b3 00    	mov    %esi,0xb38df8(%eax)
  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("update_arp_entry: updating stable entry %"S16_F"\n", (s16_t)i));
  /* update address */
  k = ETHARP_HWADDR_LEN;
  while (k > 0) {
    k--;
    arp_table[i].ethaddr.addr[k] = ethaddr->addr[k];
  80d1aa:	0f b6 5f 05          	movzbl 0x5(%edi),%ebx
  80d1ae:	88 98 ed 8d b3 00    	mov    %bl,0xb38ded(%eax)
  80d1b4:	6b 4d e0 07          	imul   $0x7,-0x20(%ebp),%ecx
  80d1b8:	bb e0 8d b3 00       	mov    $0xb38de0,%ebx
  80d1bd:	0f b6 57 04          	movzbl 0x4(%edi),%edx
  80d1c1:	88 54 8b 0c          	mov    %dl,0xc(%ebx,%ecx,4)
  80d1c5:	0f b6 4f 03          	movzbl 0x3(%edi),%ecx
  80d1c9:	88 88 eb 8d b3 00    	mov    %cl,0xb38deb(%eax)
  80d1cf:	6b 4d e0 0e          	imul   $0xe,-0x20(%ebp),%ecx
  80d1d3:	0f b6 57 02          	movzbl 0x2(%edi),%edx
  80d1d7:	88 54 4b 0a          	mov    %dl,0xa(%ebx,%ecx,2)
  80d1db:	0f b6 4f 01          	movzbl 0x1(%edi),%ecx
  80d1df:	88 88 e9 8d b3 00    	mov    %cl,0xb38de9(%eax)
  80d1e5:	0f b6 0f             	movzbl (%edi),%ecx
  80d1e8:	88 4c 18 08          	mov    %cl,0x8(%eax,%ebx,1)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
  80d1ec:	c6 80 f4 8d b3 00 00 	movb   $0x0,0xb38df4(%eax)
    /* get the packet pointer */
    p = q->p;
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80d1f3:	8d 4e 25             	lea    0x25(%esi),%ecx
  80d1f6:	89 4d dc             	mov    %ecx,-0x24(%ebp)
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80d1f9:	6b 45 e0 1c          	imul   $0x1c,-0x20(%ebp),%eax
  80d1fd:	89 45 e0             	mov    %eax,-0x20(%ebp)
  80d200:	eb 39                	jmp    80d23b <update_arp_entry+0x14e>
    struct pbuf *p;
    /* remember remainder of queue */
    struct etharp_q_entry *q = arp_table[i].q;
    /* pop first item off the queue */
    arp_table[i].q = q->next;
  80d202:	8b 10                	mov    (%eax),%edx
  80d204:	8b 4d e0             	mov    -0x20(%ebp),%ecx
  80d207:	89 14 19             	mov    %edx,(%ecx,%ebx,1)
    /* get the packet pointer */
    p = q->p;
  80d20a:	8b 50 04             	mov    0x4(%eax),%edx
  80d20d:	89 55 e4             	mov    %edx,-0x1c(%ebp)
    /* now queue entry can be freed */
    memp_free(MEMP_ARP_QUEUE, q);
  80d210:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d214:	c7 04 24 0a 00 00 00 	movl   $0xa,(%esp)
  80d21b:	e8 a0 a5 ff ff       	call   8077c0 <memp_free>
    /* send the queued IP packet */
    etharp_send_ip(netif, p, (struct eth_addr*)(netif->hwaddr), ethaddr);
  80d220:	89 3c 24             	mov    %edi,(%esp)
  80d223:	8b 4d dc             	mov    -0x24(%ebp),%ecx
  80d226:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  80d229:	89 f0                	mov    %esi,%eax
  80d22b:	e8 50 f6 ff ff       	call   80c880 <etharp_send_ip>
    /* free the queued IP packet */
    pbuf_free(p);
  80d230:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  80d233:	89 0c 24             	mov    %ecx,(%esp)
  80d236:	e8 1d ad ff ff       	call   807f58 <pbuf_free>
  }
  /* reset time stamp */
  arp_table[i].ctime = 0;
#if ARP_QUEUEING
  /* this is where we will send out queued packets! */
  while (arp_table[i].q != NULL) {
  80d23b:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80d23e:	8b 04 1a             	mov    (%edx,%ebx,1),%eax
  80d241:	85 c0                	test   %eax,%eax
  80d243:	75 bd                	jne    80d202 <update_arp_entry+0x115>
  80d245:	eb 05                	jmp    80d24c <update_arp_entry+0x15f>
  80d247:	b8 f6 ff ff ff       	mov    $0xfffffff6,%eax
    /* free the queued IP packet */
    pbuf_free(p);
  }
#endif
  return ERR_OK;
}
  80d24c:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d24f:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d252:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d255:	89 ec                	mov    %ebp,%esp
  80d257:	5d                   	pop    %ebp
  80d258:	c3                   	ret    

0080d259 <etharp_ip_input>:
 *
 * @see pbuf_free()
 */
void
etharp_ip_input(struct netif *netif, struct pbuf *p)
{
  80d259:	55                   	push   %ebp
  80d25a:	89 e5                	mov    %esp,%ebp
  80d25c:	83 ec 18             	sub    $0x18,%esp
  80d25f:	8b 45 08             	mov    0x8(%ebp),%eax
  struct ethip_hdr *hdr;
  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80d262:	85 c0                	test   %eax,%eax
  80d264:	75 1c                	jne    80d282 <etharp_ip_input+0x29>
  80d266:	c7 44 24 08 e3 34 81 	movl   $0x8134e3,0x8(%esp)
  80d26d:	00 
  80d26e:	c7 44 24 04 48 02 00 	movl   $0x248,0x4(%esp)
  80d275:	00 
  80d276:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80d27d:	e8 52 37 ff ff       	call   8009d4 <_panic>
  /* Only insert an entry if the source IP address of the
     incoming IP packet comes from a host on the local network. */
  hdr = p->payload;
  80d282:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d285:	8b 52 04             	mov    0x4(%edx),%edx
  /* source is not on the local network? */
  if (!ip_addr_netcmp(&(hdr->ip.src), &(netif->ip_addr), &(netif->netmask))) {
  80d288:	8b 48 04             	mov    0x4(%eax),%ecx
  80d28b:	33 4a 1c             	xor    0x1c(%edx),%ecx
  80d28e:	85 48 08             	test   %ecx,0x8(%eax)
  80d291:	75 12                	jne    80d2a5 <etharp_ip_input+0x4c>

  LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_ip_input: updating ETHARP table.\n"));
  /* update ARP table */
  /* @todo We could use ETHARP_TRY_HARD if we think we are going to talk
   * back soon (for example, if the destination IP address is ours. */
  update_arp_entry(netif, &(hdr->ip.src), &(hdr->eth.src), 0);
  80d293:	8d 4a 06             	lea    0x6(%edx),%ecx
  80d296:	83 c2 1c             	add    $0x1c,%edx
  80d299:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d2a0:	e8 48 fe ff ff       	call   80d0ed <update_arp_entry>
}
  80d2a5:	c9                   	leave  
  80d2a6:	c3                   	ret    

0080d2a7 <etharp_arp_input>:
 *
 * @see pbuf_free()
 */
void
etharp_arp_input(struct netif *netif, struct eth_addr *ethaddr, struct pbuf *p)
{
  80d2a7:	55                   	push   %ebp
  80d2a8:	89 e5                	mov    %esp,%ebp
  80d2aa:	83 ec 38             	sub    $0x38,%esp
  80d2ad:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80d2b0:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80d2b3:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80d2b6:	8b 5d 10             	mov    0x10(%ebp),%ebx
  u8_t for_us;
#if LWIP_AUTOIP
  const u8_t * ethdst_hwaddr;
#endif /* LWIP_AUTOIP */

  LWIP_ERROR("netif != NULL", (netif != NULL), return;);
  80d2b9:	83 7d 08 00          	cmpl   $0x0,0x8(%ebp)
  80d2bd:	75 1c                	jne    80d2db <etharp_arp_input+0x34>
  80d2bf:	c7 44 24 08 e3 34 81 	movl   $0x8134e3,0x8(%esp)
  80d2c6:	00 
  80d2c7:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80d2ce:	00 
  80d2cf:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80d2d6:	e8 f9 36 ff ff       	call   8009d4 <_panic>
  
  /* drop short ARP packets: we have to check for p->len instead of p->tot_len here
     since a struct etharp_hdr is pointed to p->payload, so it musn't be chained! */
  if (p->len < sizeof(struct etharp_hdr)) {
  80d2db:	66 83 7b 0a 29       	cmpw   $0x29,0xa(%ebx)
  80d2e0:	77 0d                	ja     80d2ef <etharp_arp_input+0x48>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1, ("etharp_arp_input: packet dropped, too short (%"S16_F"/%"S16_F")\n", p->tot_len, (s16_t)sizeof(struct etharp_hdr)));
    ETHARP_STATS_INC(etharp.lenerr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80d2e2:	89 1c 24             	mov    %ebx,(%esp)
  80d2e5:	e8 6e ac ff ff       	call   807f58 <pbuf_free>
    return;
  80d2ea:	e9 ab 01 00 00       	jmp    80d49a <etharp_arp_input+0x1f3>
  }

  hdr = p->payload;
  80d2ef:	8b 73 04             	mov    0x4(%ebx),%esi

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d2f2:	0f b7 7e 0e          	movzwl 0xe(%esi),%edi
  80d2f6:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d2fd:	e8 52 da ff ff       	call   80ad54 <htons>
  80d302:	66 39 c7             	cmp    %ax,%di
  80d305:	75 3f                	jne    80d346 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
  80d307:	0f b7 7e 12          	movzwl 0x12(%esi),%edi
  80d30b:	c7 04 24 04 06 00 00 	movl   $0x604,(%esp)
  80d312:	e8 3d da ff ff       	call   80ad54 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d317:	66 39 c7             	cmp    %ax,%di
  80d31a:	75 2a                	jne    80d346 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
  80d31c:	0f b7 7e 10          	movzwl 0x10(%esi),%edi
  80d320:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  80d327:	e8 28 da ff ff       	call   80ad54 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d32c:	66 39 c7             	cmp    %ax,%di
  80d32f:	75 15                	jne    80d346 <etharp_arp_input+0x9f>
      (hdr->_hwlen_protolen != htons((ETHARP_HWADDR_LEN << 8) | sizeof(struct ip_addr))) ||
      (hdr->proto != htons(ETHTYPE_IP)) ||
      (hdr->ethhdr.type != htons(ETHTYPE_ARP)))  {
  80d331:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  80d335:	c7 04 24 06 08 00 00 	movl   $0x806,(%esp)
  80d33c:	e8 13 da ff ff       	call   80ad54 <htons>
  }

  hdr = p->payload;

  /* RFC 826 "Packet Reception": */
  if ((hdr->hwtype != htons(HWTYPE_ETHERNET)) ||
  80d341:	66 39 c7             	cmp    %ax,%di
  80d344:	74 0f                	je     80d355 <etharp_arp_input+0xae>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE | 1,
      ("etharp_arp_input: packet dropped, wrong hw type, hwlen, proto, protolen or ethernet type (%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F"/%"U16_F")\n",
      hdr->hwtype, ARPH_HWLEN(hdr), hdr->proto, ARPH_PROTOLEN(hdr), hdr->ethhdr.type));
    ETHARP_STATS_INC(etharp.proterr);
    ETHARP_STATS_INC(etharp.drop);
    pbuf_free(p);
  80d346:	89 1c 24             	mov    %ebx,(%esp)
  80d349:	e8 0a ac ff ff       	call   807f58 <pbuf_free>
    return;
  80d34e:	66 90                	xchg   %ax,%ax
  80d350:	e9 45 01 00 00       	jmp    80d49a <etharp_arp_input+0x1f3>
  autoip_arp_reply(netif, hdr);
#endif /* LWIP_AUTOIP */

  /* Copy struct ip_addr2 to aligned ip_addr, to support compilers without
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  80d355:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d35c:	00 
  80d35d:	8d 46 1c             	lea    0x1c(%esi),%eax
  80d360:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d364:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d367:	89 04 24             	mov    %eax,(%esp)
  80d36a:	e8 22 40 ff ff       	call   801391 <memcpy>
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));
  80d36f:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d376:	00 
  80d377:	8d 46 26             	lea    0x26(%esi),%eax
  80d37a:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d37e:	8d 45 e0             	lea    -0x20(%ebp),%eax
  80d381:	89 04 24             	mov    %eax,(%esp)
  80d384:	e8 08 40 ff ff       	call   801391 <memcpy>

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80d389:	8b 55 08             	mov    0x8(%ebp),%edx
  80d38c:	8b 42 04             	mov    0x4(%edx),%eax

  /* ARP message directed to us? */
  if (for_us) {
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80d38f:	bf 00 00 00 00       	mov    $0x0,%edi
   * structure packing (not using structure copy which breaks strict-aliasing rules). */
  SMEMCPY(&sipaddr, &hdr->sipaddr, sizeof(sipaddr));
  SMEMCPY(&dipaddr, &hdr->dipaddr, sizeof(dipaddr));

  /* this interface is not configured? */
  if (netif->ip_addr.addr == 0) {
  80d394:	85 c0                	test   %eax,%eax
  80d396:	74 21                	je     80d3b9 <etharp_arp_input+0x112>
    for_us = 0;
  } else {
    /* ARP packet directed to us? */
    for_us = ip_addr_cmp(&dipaddr, &(netif->ip_addr));
  80d398:	3b 45 e0             	cmp    -0x20(%ebp),%eax
  }

  /* ARP message directed to us? */
  if (for_us) {
  80d39b:	0f 94 c0             	sete   %al
  80d39e:	89 c7                	mov    %eax,%edi
  80d3a0:	75 17                	jne    80d3b9 <etharp_arp_input+0x112>
    /* add IP address in ARP cache; assume requester wants to talk to us.
     * can result in directly sending the queued packets for this host. */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), ETHARP_TRY_HARD);
  80d3a2:	8d 4e 16             	lea    0x16(%esi),%ecx
  80d3a5:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80d3a8:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  80d3af:	8b 45 08             	mov    0x8(%ebp),%eax
  80d3b2:	e8 36 fd ff ff       	call   80d0ed <update_arp_entry>
  80d3b7:	eb 15                	jmp    80d3ce <etharp_arp_input+0x127>
  /* ARP message not directed to us? */
  } else {
    /* update the source IP address in the cache, if present */
    update_arp_entry(netif, &sipaddr, &(hdr->shwaddr), 0);
  80d3b9:	8d 4e 16             	lea    0x16(%esi),%ecx
  80d3bc:	8d 55 e4             	lea    -0x1c(%ebp),%edx
  80d3bf:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80d3c6:	8b 45 08             	mov    0x8(%ebp),%eax
  80d3c9:	e8 1f fd ff ff       	call   80d0ed <update_arp_entry>
  }

  /* now act on the message itself */
  switch (htons(hdr->opcode)) {
  80d3ce:	0f b7 46 14          	movzwl 0x14(%esi),%eax
  80d3d2:	89 04 24             	mov    %eax,(%esp)
  80d3d5:	e8 7a d9 ff ff       	call   80ad54 <htons>
  80d3da:	66 83 f8 01          	cmp    $0x1,%ax
  80d3de:	74 15                	je     80d3f5 <etharp_arp_input+0x14e>
  80d3e0:	66 83 f8 02          	cmp    $0x2,%ax
  80d3e4:	0f 85 a8 00 00 00    	jne    80d492 <etharp_arp_input+0x1eb>
  80d3ea:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d3f0:	e9 8b 00 00 00       	jmp    80d480 <etharp_arp_input+0x1d9>
     * reply. In any case, we time-stamp any existing ARP entry,
     * and possiby send out an IP packet that was queued on it. */

    LWIP_DEBUGF (ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: incoming ARP request\n"));
    /* ARP request for our address? */
    if (for_us) {
  80d3f5:	89 fa                	mov    %edi,%edx
  80d3f7:	84 d2                	test   %dl,%dl
  80d3f9:	0f 84 93 00 00 00    	je     80d492 <etharp_arp_input+0x1eb>

      LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: replying to ARP request for our IP address\n"));
      /* Re-use pbuf to send ARP reply.
         Since we are re-using an existing pbuf, we can't call etharp_raw since
         that would allocate a new pbuf. */
      hdr->opcode = htons(ARP_REPLY);
  80d3ff:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  80d406:	e8 49 d9 ff ff       	call   80ad54 <htons>
  80d40b:	66 89 46 14          	mov    %ax,0x14(%esi)

      hdr->dipaddr = hdr->sipaddr;
  80d40f:	8b 46 1c             	mov    0x1c(%esi),%eax
  80d412:	89 46 26             	mov    %eax,0x26(%esi)
      hdr->sipaddr = *(struct ip_addr2 *)&netif->ip_addr;
  80d415:	8b 55 08             	mov    0x8(%ebp),%edx
  80d418:	8b 42 04             	mov    0x4(%edx),%eax
  80d41b:	89 46 1c             	mov    %eax,0x1c(%esi)

      LWIP_ASSERT("netif->hwaddr_len must be the same as ETHARP_HWADDR_LEN for etharp!",
  80d41e:	ba 06 00 00 00       	mov    $0x6,%edx
  80d423:	8b 45 08             	mov    0x8(%ebp),%eax
  80d426:	80 78 24 06          	cmpb   $0x6,0x24(%eax)
  80d42a:	74 1c                	je     80d448 <etharp_arp_input+0x1a1>
  80d42c:	c7 44 24 08 84 41 81 	movl   $0x814184,0x8(%esp)
  80d433:	00 
  80d434:	c7 44 24 04 c7 02 00 	movl   $0x2c7,0x4(%esp)
  80d43b:	00 
  80d43c:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80d443:	e8 8c 35 ff ff       	call   8009d4 <_panic>
  80d448:	8b 7d 0c             	mov    0xc(%ebp),%edi
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
        i--;
  80d44b:	83 ea 01             	sub    $0x1,%edx
        hdr->dhwaddr.addr[i] = hdr->shwaddr.addr[i];
  80d44e:	0f b6 c2             	movzbl %dl,%eax
  80d451:	0f b6 4c 06 16       	movzbl 0x16(%esi,%eax,1),%ecx
  80d456:	88 4c 06 20          	mov    %cl,0x20(%esi,%eax,1)
#if LWIP_AUTOIP
        hdr->ethhdr.dest.addr[i] = ethdst_hwaddr[i];
#else  /* LWIP_AUTOIP */
        hdr->ethhdr.dest.addr[i] = hdr->shwaddr.addr[i];
  80d45a:	88 0c 06             	mov    %cl,(%esi,%eax,1)
#endif /* LWIP_AUTOIP */
        hdr->shwaddr.addr[i] = ethaddr->addr[i];
  80d45d:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80d461:	88 4c 06 16          	mov    %cl,0x16(%esi,%eax,1)
        hdr->ethhdr.src.addr[i] = ethaddr->addr[i];
  80d465:	0f b6 0c 07          	movzbl (%edi,%eax,1),%ecx
  80d469:	88 4c 06 06          	mov    %cl,0x6(%esi,%eax,1)
      /* If we are using Link-Local, ARP packets must be broadcast on the
       * link layer. (See RFC3927 Section 2.5) */
      ethdst_hwaddr = ((netif->autoip != NULL) && (netif->autoip->state != AUTOIP_STATE_OFF)) ? (u8_t*)(ethbroadcast.addr) : hdr->shwaddr.addr;
#endif /* LWIP_AUTOIP */

      while(i > 0) {
  80d46d:	84 d2                	test   %dl,%dl
  80d46f:	75 da                	jne    80d44b <etharp_arp_input+0x1a4>

      /* hwtype, hwaddr_len, proto, protolen and the type in the ethernet header
         are already correct, we tested that before */

      /* return ARP reply */
      netif->linkoutput(netif, p);
  80d471:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d475:	8b 55 08             	mov    0x8(%ebp),%edx
  80d478:	89 14 24             	mov    %edx,(%esp)
  80d47b:	ff 52 18             	call   *0x18(%edx)
  80d47e:	eb 12                	jmp    80d492 <etharp_arp_input+0x1eb>
#if (LWIP_DHCP && DHCP_DOES_ARP_CHECK)
    /* DHCP wants to know about ARP replies from any host with an
     * IP address also offered to us by the DHCP server. We do not
     * want to take a duplicate IP address on a single network.
     * @todo How should we handle redundant (fail-over) interfaces? */
    dhcp_arp_reply(netif, &sipaddr);
  80d480:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80d483:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d487:	8b 45 08             	mov    0x8(%ebp),%eax
  80d48a:	89 04 24             	mov    %eax,(%esp)
  80d48d:	e8 75 90 ff ff       	call   806507 <dhcp_arp_reply>
    LWIP_DEBUGF(ETHARP_DEBUG | LWIP_DBG_TRACE, ("etharp_arp_input: ARP unknown opcode type %"S16_F"\n", htons(hdr->opcode)));
    ETHARP_STATS_INC(etharp.err);
    break;
  }
  /* free ARP packet */
  pbuf_free(p);
  80d492:	89 1c 24             	mov    %ebx,(%esp)
  80d495:	e8 be aa ff ff       	call   807f58 <pbuf_free>
}
  80d49a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80d49d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80d4a0:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80d4a3:	89 ec                	mov    %ebp,%esp
  80d4a5:	5d                   	pop    %ebp
  80d4a6:	c3                   	ret    

0080d4a7 <ethernet_input>:
 * @param p the recevied packet, p->payload pointing to the ethernet header
 * @param netif the network interface on which the packet was received
 */
err_t
ethernet_input(struct pbuf *p, struct netif *netif)
{
  80d4a7:	55                   	push   %ebp
  80d4a8:	89 e5                	mov    %esp,%ebp
  80d4aa:	83 ec 18             	sub    $0x18,%esp
  80d4ad:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80d4b0:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80d4b3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80d4b6:	8b 75 0c             	mov    0xc(%ebp),%esi
     (unsigned)ethhdr->dest.addr[3], (unsigned)ethhdr->dest.addr[4], (unsigned)ethhdr->dest.addr[5],
     (unsigned)ethhdr->src.addr[0], (unsigned)ethhdr->src.addr[1], (unsigned)ethhdr->src.addr[2],
     (unsigned)ethhdr->src.addr[3], (unsigned)ethhdr->src.addr[4], (unsigned)ethhdr->src.addr[5],
     (unsigned)htons(ethhdr->type)));

  switch (htons(ethhdr->type)) {
  80d4b9:	8b 43 04             	mov    0x4(%ebx),%eax
  80d4bc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80d4c0:	89 04 24             	mov    %eax,(%esp)
  80d4c3:	e8 8c d8 ff ff       	call   80ad54 <htons>
  80d4c8:	66 3d 00 08          	cmp    $0x800,%ax
  80d4cc:	74 0c                	je     80d4da <ethernet_input+0x33>
  80d4ce:	66 3d 06 08          	cmp    $0x806,%ax
  80d4d2:	75 65                	jne    80d539 <ethernet_input+0x92>
  80d4d4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d4d8:	eb 4a                	jmp    80d524 <ethernet_input+0x7d>
    /* IP packet? */
    case ETHTYPE_IP:
#if ETHARP_TRUST_IP_MAC
      /* update ARP table */
      etharp_ip_input(netif, p);
  80d4da:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80d4de:	89 34 24             	mov    %esi,(%esp)
  80d4e1:	e8 73 fd ff ff       	call   80d259 <etharp_ip_input>
#endif /* ETHARP_TRUST_IP_MAC */
      /* skip Ethernet header */
      if(pbuf_header(p, -(s16_t)sizeof(struct eth_hdr))) {
  80d4e6:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80d4ed:	ff 
  80d4ee:	89 1c 24             	mov    %ebx,(%esp)
  80d4f1:	e8 ed a6 ff ff       	call   807be3 <pbuf_header>
  80d4f6:	84 c0                	test   %al,%al
  80d4f8:	74 1c                	je     80d516 <ethernet_input+0x6f>
        LWIP_ASSERT("Can't move over header in packet", 0);
  80d4fa:	c7 44 24 08 4c 42 81 	movl   $0x81424c,0x8(%esp)
  80d501:	00 
  80d502:	c7 44 24 04 7e 04 00 	movl   $0x47e,0x4(%esp)
  80d509:	00 
  80d50a:	c7 04 24 6d 42 81 00 	movl   $0x81426d,(%esp)
  80d511:	e8 be 34 ff ff       	call   8009d4 <_panic>
        pbuf_free(p);
        p = NULL;
      } else {
        /* pass to IP layer */
        ip_input(p, netif);
  80d516:	89 74 24 04          	mov    %esi,0x4(%esp)
  80d51a:	89 1c 24             	mov    %ebx,(%esp)
  80d51d:	e8 f2 c6 ff ff       	call   809c14 <ip_input>
      }
      break;
  80d522:	eb 1d                	jmp    80d541 <ethernet_input+0x9a>
      
    case ETHTYPE_ARP:
      /* pass p to ARP module */
      etharp_arp_input(netif, (struct eth_addr*)(netif->hwaddr), p);
  80d524:	89 5c 24 08          	mov    %ebx,0x8(%esp)
  80d528:	8d 46 25             	lea    0x25(%esi),%eax
  80d52b:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d52f:	89 34 24             	mov    %esi,(%esp)
  80d532:	e8 70 fd ff ff       	call   80d2a7 <etharp_arp_input>
      break;
  80d537:	eb 08                	jmp    80d541 <ethernet_input+0x9a>
#endif /* PPPOE_SUPPORT */

    default:
      ETHARP_STATS_INC(etharp.proterr);
      ETHARP_STATS_INC(etharp.drop);
      pbuf_free(p);
  80d539:	89 1c 24             	mov    %ebx,(%esp)
  80d53c:	e8 17 aa ff ff       	call   807f58 <pbuf_free>
  }

  /* This means the pbuf is freed or consumed,
     so the caller doesn't have to free it again */
  return ERR_OK;
}
  80d541:	b8 00 00 00 00       	mov    $0x0,%eax
  80d546:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80d549:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80d54c:	89 ec                	mov    %ebp,%esp
  80d54e:	5d                   	pop    %ebp
  80d54f:	c3                   	ret    

0080d550 <sys_init>:
enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
{
  80d550:	55                   	push   %ebp
  80d551:	89 e5                	mov    %esp,%ebp
  80d553:	56                   	push   %esi
  80d554:	53                   	push   %ebx
  80d555:	b8 00 8f b3 00       	mov    $0xb38f00,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80d55a:	be 00 a3 b3 00       	mov    $0xb3a300,%esi
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
  80d55f:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80d565:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
  80d567:	8b 15 00 a3 b3 00    	mov    0xb3a300,%edx
  80d56d:	89 50 0c             	mov    %edx,0xc(%eax)
  80d570:	85 d2                	test   %edx,%edx
  80d572:	74 06                	je     80d57a <sys_init+0x2a>
  80d574:	8d 58 0c             	lea    0xc(%eax),%ebx
  80d577:	89 5a 10             	mov    %ebx,0x10(%edx)
  80d57a:	89 0d 00 a3 b3 00    	mov    %ecx,0xb3a300
  80d580:	c7 40 10 00 a3 b3 00 	movl   $0xb3a300,0x10(%eax)
  80d587:	83 c0 14             	add    $0x14,%eax

void
sys_init(void)
{
    int i = 0;
    for (i = 0; i < NSEM; i++) {
  80d58a:	39 f0                	cmp    %esi,%eax
  80d58c:	75 d1                	jne    80d55f <sys_init+0xf>
  80d58e:	b8 20 a3 b3 00       	mov    $0xb3a320,%eax

enum { thread_hash_size = 257 };
static LIST_HEAD(thread_list, sys_thread) threads[thread_hash_size];

void
sys_init(void)
  80d593:	be 20 f1 b3 00       	mov    $0xb3f120,%esi
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
	mboxes[i].freed = 1;
  80d598:	c7 00 01 00 00 00    	movl   $0x1,(%eax)
  80d59e:	89 c1                	mov    %eax,%ecx
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
  80d5a0:	8b 15 20 f1 b3 00    	mov    0xb3f120,%edx
  80d5a6:	89 90 94 00 00 00    	mov    %edx,0x94(%eax)
  80d5ac:	85 d2                	test   %edx,%edx
  80d5ae:	74 0c                	je     80d5bc <sys_init+0x6c>
  80d5b0:	8d 98 94 00 00 00    	lea    0x94(%eax),%ebx
  80d5b6:	89 9a 98 00 00 00    	mov    %ebx,0x98(%edx)
  80d5bc:	89 0d 20 f1 b3 00    	mov    %ecx,0xb3f120
  80d5c2:	c7 80 98 00 00 00 20 	movl   $0xb3f120,0x98(%eax)
  80d5c9:	f1 b3 00 
  80d5cc:	05 9c 00 00 00       	add    $0x9c,%eax
    for (i = 0; i < NSEM; i++) {
	sems[i].freed = 1;
	LIST_INSERT_HEAD(&sem_free, &sems[i], link);
    }

    for (i = 0; i < NMBOX; i++) {
  80d5d1:	39 f0                	cmp    %esi,%eax
  80d5d3:	75 c3                	jne    80d598 <sys_init+0x48>
	mboxes[i].freed = 1;
	LIST_INSERT_HEAD(&mbox_free, &mboxes[i], link);
    }
}
  80d5d5:	5b                   	pop    %ebx
  80d5d6:	5e                   	pop    %esi
  80d5d7:	5d                   	pop    %ebp
  80d5d8:	c3                   	ret    

0080d5d9 <lwip_core_lock>:
    return &t->tmo;
}

void
lwip_core_lock(void)
{
  80d5d9:	55                   	push   %ebp
  80d5da:	89 e5                	mov    %esp,%ebp
}
  80d5dc:	5d                   	pop    %ebp
  80d5dd:	c3                   	ret    

0080d5de <lwip_core_unlock>:

void
lwip_core_unlock(void)
{
  80d5de:	55                   	push   %ebp
  80d5df:	89 e5                	mov    %esp,%ebp
}
  80d5e1:	5d                   	pop    %ebp
  80d5e2:	c3                   	ret    

0080d5e3 <sys_sem_free>:
    return se - &sems[0];
}

void
sys_sem_free(sys_sem_t sem)
{
  80d5e3:	55                   	push   %ebp
  80d5e4:	89 e5                	mov    %esp,%ebp
  80d5e6:	83 ec 18             	sub    $0x18,%esp
  80d5e9:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80d5ec:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80d5ef:	83 3c 95 00 8f b3 00 	cmpl   $0x0,0xb38f00(,%edx,4)
  80d5f6:	00 
  80d5f7:	74 24                	je     80d61d <sys_sem_free+0x3a>
  80d5f9:	c7 44 24 0c ef 42 81 	movl   $0x8142ef,0xc(%esp)
  80d600:	00 
  80d601:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80d608:	00 
  80d609:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80d610:	00 
  80d611:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d618:	e8 b7 33 ff ff       	call   8009d4 <_panic>
    sems[sem].freed = 1;
  80d61d:	ba 00 8f b3 00       	mov    $0xb38f00,%edx
  80d622:	8d 04 80             	lea    (%eax,%eax,4),%eax
  80d625:	c1 e0 02             	shl    $0x2,%eax
  80d628:	c7 04 10 01 00 00 00 	movl   $0x1,(%eax,%edx,1)
    sems[sem].gen++;
  80d62f:	83 44 02 04 01       	addl   $0x1,0x4(%edx,%eax,1)
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
  80d634:	01 d0                	add    %edx,%eax
  80d636:	8b 15 00 a3 b3 00    	mov    0xb3a300,%edx
  80d63c:	89 50 0c             	mov    %edx,0xc(%eax)
  80d63f:	85 d2                	test   %edx,%edx
  80d641:	74 06                	je     80d649 <sys_sem_free+0x66>
  80d643:	8d 48 0c             	lea    0xc(%eax),%ecx
  80d646:	89 4a 10             	mov    %ecx,0x10(%edx)
  80d649:	a3 00 a3 b3 00       	mov    %eax,0xb3a300
  80d64e:	c7 40 10 00 a3 b3 00 	movl   $0xb3a300,0x10(%eax)
}
  80d655:	c9                   	leave  
  80d656:	c3                   	ret    

0080d657 <sys_mbox_free>:
    return i;
}

void
sys_mbox_free(sys_mbox_t mbox)
{
  80d657:	55                   	push   %ebp
  80d658:	89 e5                	mov    %esp,%ebp
  80d65a:	56                   	push   %esi
  80d65b:	53                   	push   %ebx
  80d65c:	83 ec 10             	sub    $0x10,%esp
  80d65f:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80d662:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80d668:	83 b8 20 a3 b3 00 00 	cmpl   $0x0,0xb3a320(%eax)
  80d66f:	74 24                	je     80d695 <sys_mbox_free+0x3e>
  80d671:	c7 44 24 0c 1d 43 81 	movl   $0x81431d,0xc(%esp)
  80d678:	00 
  80d679:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80d680:	00 
  80d681:	c7 44 24 04 62 00 00 	movl   $0x62,0x4(%esp)
  80d688:	00 
  80d689:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d690:	e8 3f 33 ff ff       	call   8009d4 <_panic>
    sys_sem_free(mboxes[mbox].queued_msg);
  80d695:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80d69b:	8b 83 ac a3 b3 00    	mov    0xb3a3ac(%ebx),%eax
  80d6a1:	89 04 24             	mov    %eax,(%esp)
  80d6a4:	e8 3a ff ff ff       	call   80d5e3 <sys_sem_free>
    sys_sem_free(mboxes[mbox].free_msg);
  80d6a9:	8b 83 b0 a3 b3 00    	mov    0xb3a3b0(%ebx),%eax
  80d6af:	89 04 24             	mov    %eax,(%esp)
  80d6b2:	e8 2c ff ff ff       	call   80d5e3 <sys_sem_free>
    LIST_INSERT_HEAD(&mbox_free, &mboxes[mbox], link);
  80d6b7:	81 c3 20 a3 b3 00    	add    $0xb3a320,%ebx
  80d6bd:	a1 20 f1 b3 00       	mov    0xb3f120,%eax
  80d6c2:	89 83 94 00 00 00    	mov    %eax,0x94(%ebx)
  80d6c8:	85 c0                	test   %eax,%eax
  80d6ca:	74 0c                	je     80d6d8 <sys_mbox_free+0x81>
  80d6cc:	8d 93 94 00 00 00    	lea    0x94(%ebx),%edx
  80d6d2:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80d6d8:	89 1d 20 f1 b3 00    	mov    %ebx,0xb3f120
  80d6de:	c7 83 98 00 00 00 20 	movl   $0xb3f120,0x98(%ebx)
  80d6e5:	f1 b3 00 
    mboxes[mbox].freed = 1;
  80d6e8:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80d6ee:	c7 86 20 a3 b3 00 01 	movl   $0x1,0xb3a320(%esi)
  80d6f5:	00 00 00 
}
  80d6f8:	83 c4 10             	add    $0x10,%esp
  80d6fb:	5b                   	pop    %ebx
  80d6fc:	5e                   	pop    %esi
  80d6fd:	5d                   	pop    %ebp
  80d6fe:	c3                   	ret    

0080d6ff <sys_arch_timeouts>:
    lwip_core_unlock();
}

struct sys_timeouts *
sys_arch_timeouts(void)
{
  80d6ff:	55                   	push   %ebp
  80d700:	89 e5                	mov    %esp,%ebp
  80d702:	57                   	push   %edi
  80d703:	56                   	push   %esi
  80d704:	53                   	push   %ebx
  80d705:	83 ec 1c             	sub    $0x1c,%esp
    thread_id_t tid = thread_id();
  80d708:	e8 e6 07 00 00       	call   80def3 <thread_id>
  80d70d:	89 c6                	mov    %eax,%esi

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d70f:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d714:	f7 e2                	mul    %edx
  80d716:	c1 ea 08             	shr    $0x8,%edx
  80d719:	89 d0                	mov    %edx,%eax
  80d71b:	c1 e0 08             	shl    $0x8,%eax
  80d71e:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d721:	89 f0                	mov    %esi,%eax
  80d723:	29 d0                	sub    %edx,%eax
  80d725:	8d 3c 85 40 f1 b3 00 	lea    0xb3f140(,%eax,4),%edi
  80d72c:	8b 1f                	mov    (%edi),%ebx
  80d72e:	85 db                	test   %ebx,%ebx
  80d730:	74 20                	je     80d752 <sys_arch_timeouts+0x53>
	if (t->tid == tid)
  80d732:	3b 33                	cmp    (%ebx),%esi
  80d734:	75 10                	jne    80d746 <sys_arch_timeouts+0x47>
  80d736:	e9 b0 00 00 00       	jmp    80d7eb <sys_arch_timeouts+0xec>
  80d73b:	3b 33                	cmp    (%ebx),%esi
  80d73d:	8d 76 00             	lea    0x0(%esi),%esi
  80d740:	0f 84 a5 00 00 00    	je     80d7eb <sys_arch_timeouts+0xec>
sys_arch_timeouts(void)
{
    thread_id_t tid = thread_id();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d746:	8b 5b 08             	mov    0x8(%ebx),%ebx
  80d749:	85 db                	test   %ebx,%ebx
  80d74b:	90                   	nop
  80d74c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80d750:	75 e9                	jne    80d73b <sys_arch_timeouts+0x3c>
	if (t->tid == tid)
	    goto out;

    t = malloc(sizeof(*t));
  80d752:	c7 04 24 10 00 00 00 	movl   $0x10,(%esp)
  80d759:	e8 e5 55 ff ff       	call   802d43 <malloc>
  80d75e:	89 c3                	mov    %eax,%ebx
    if (t == 0)
  80d760:	85 c0                	test   %eax,%eax
  80d762:	75 1c                	jne    80d780 <sys_arch_timeouts+0x81>
	panic("sys_arch_timeouts: cannot malloc");
  80d764:	c7 44 24 08 80 43 81 	movl   $0x814380,0x8(%esp)
  80d76b:	00 
  80d76c:	c7 44 24 04 2c 01 00 	movl   $0x12c,0x4(%esp)
  80d773:	00 
  80d774:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d77b:	e8 54 32 ff ff       	call   8009d4 <_panic>

    int r = thread_onhalt(timeout_cleanup);
  80d780:	c7 04 24 f6 d7 80 00 	movl   $0x80d7f6,(%esp)
  80d787:	e8 ba 07 00 00       	call   80df46 <thread_onhalt>
    if (r < 0)
  80d78c:	85 c0                	test   %eax,%eax
  80d78e:	79 28                	jns    80d7b8 <sys_arch_timeouts+0xb9>
	panic("thread_onhalt failed: %s", e2s(r));
  80d790:	89 04 24             	mov    %eax,(%esp)
  80d793:	e8 20 0b 00 00       	call   80e2b8 <e2s>
  80d798:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d79c:	c7 44 24 08 31 43 81 	movl   $0x814331,0x8(%esp)
  80d7a3:	00 
  80d7a4:	c7 44 24 04 30 01 00 	movl   $0x130,0x4(%esp)
  80d7ab:	00 
  80d7ac:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d7b3:	e8 1c 32 ff ff       	call   8009d4 <_panic>

    t->tid = tid;
  80d7b8:	89 33                	mov    %esi,(%ebx)
    memset(&t->tmo, 0, sizeof(t->tmo));
  80d7ba:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80d7c1:	00 
  80d7c2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80d7c9:	00 
  80d7ca:	8d 43 04             	lea    0x4(%ebx),%eax
  80d7cd:	89 04 24             	mov    %eax,(%esp)
  80d7d0:	e8 e1 3a ff ff       	call   8012b6 <memset>
    LIST_INSERT_HEAD(&threads[tid % thread_hash_size], t, link);
  80d7d5:	8b 07                	mov    (%edi),%eax
  80d7d7:	89 43 08             	mov    %eax,0x8(%ebx)
  80d7da:	85 c0                	test   %eax,%eax
  80d7dc:	74 08                	je     80d7e6 <sys_arch_timeouts+0xe7>
  80d7de:	8b 07                	mov    (%edi),%eax
  80d7e0:	8d 53 08             	lea    0x8(%ebx),%edx
  80d7e3:	89 50 0c             	mov    %edx,0xc(%eax)
  80d7e6:	89 1f                	mov    %ebx,(%edi)
  80d7e8:	89 7b 0c             	mov    %edi,0xc(%ebx)
  80d7eb:	8d 43 04             	lea    0x4(%ebx),%eax

out:
    return &t->tmo;
}
  80d7ee:	83 c4 1c             	add    $0x1c,%esp
  80d7f1:	5b                   	pop    %ebx
  80d7f2:	5e                   	pop    %esi
  80d7f3:	5f                   	pop    %edi
  80d7f4:	5d                   	pop    %ebp
  80d7f5:	c3                   	ret    

0080d7f6 <timeout_cleanup>:
    return tid;
}

static void
timeout_cleanup(thread_id_t tid)
{
  80d7f6:	55                   	push   %ebp
  80d7f7:	89 e5                	mov    %esp,%ebp
  80d7f9:	83 ec 18             	sub    $0x18,%esp
  80d7fc:	8b 4d 08             	mov    0x8(%ebp),%ecx
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d7ff:	ba 01 ff 00 ff       	mov    $0xff00ff01,%edx
  80d804:	89 c8                	mov    %ecx,%eax
  80d806:	f7 e2                	mul    %edx
  80d808:	c1 ea 08             	shr    $0x8,%edx
  80d80b:	89 d0                	mov    %edx,%eax
  80d80d:	c1 e0 08             	shl    $0x8,%eax
  80d810:	8d 14 10             	lea    (%eax,%edx,1),%edx
  80d813:	89 c8                	mov    %ecx,%eax
  80d815:	29 d0                	sub    %edx,%eax
  80d817:	8b 04 85 40 f1 b3 00 	mov    0xb3f140(,%eax,4),%eax
  80d81e:	85 c0                	test   %eax,%eax
  80d820:	74 36                	je     80d858 <timeout_cleanup+0x62>
	if (t->tid == tid) {
  80d822:	39 08                	cmp    %ecx,(%eax)
  80d824:	75 2b                	jne    80d851 <timeout_cleanup+0x5b>
  80d826:	eb 0a                	jmp    80d832 <timeout_cleanup+0x3c>
  80d828:	39 08                	cmp    %ecx,(%eax)
  80d82a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  80d830:	75 1f                	jne    80d851 <timeout_cleanup+0x5b>
	    LIST_REMOVE(t, link);
  80d832:	8b 50 08             	mov    0x8(%eax),%edx
  80d835:	85 d2                	test   %edx,%edx
  80d837:	74 06                	je     80d83f <timeout_cleanup+0x49>
  80d839:	8b 48 0c             	mov    0xc(%eax),%ecx
  80d83c:	89 4a 0c             	mov    %ecx,0xc(%edx)
  80d83f:	8b 50 0c             	mov    0xc(%eax),%edx
  80d842:	8b 48 08             	mov    0x8(%eax),%ecx
  80d845:	89 0a                	mov    %ecx,(%edx)
	    free(t);
  80d847:	89 04 24             	mov    %eax,(%esp)
  80d84a:	e8 21 54 ff ff       	call   802c70 <free>
	    goto done;
  80d84f:	eb 07                	jmp    80d858 <timeout_cleanup+0x62>
timeout_cleanup(thread_id_t tid)
{
    lwip_core_lock();

    struct sys_thread *t;
    LIST_FOREACH(t, &threads[tid % thread_hash_size], link)
  80d851:	8b 40 08             	mov    0x8(%eax),%eax
  80d854:	85 c0                	test   %eax,%eax
  80d856:	75 d0                	jne    80d828 <timeout_cleanup+0x32>
	}

    if (debug) cprintf("timeout_cleanup: bogus tid %ld\n", tid);
 done:
    lwip_core_unlock();
}
  80d858:	c9                   	leave  
  80d859:	c3                   	ret    

0080d85a <lwip_thread_entry>:
    void *arg;
};

static void
lwip_thread_entry(uint32_t arg)
{
  80d85a:	55                   	push   %ebp
  80d85b:	89 e5                	mov    %esp,%ebp
  80d85d:	53                   	push   %ebx
  80d85e:	83 ec 14             	sub    $0x14,%esp
  80d861:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct lwip_thread *lt = (struct lwip_thread *)arg;
    lwip_core_lock();
    lt->func(lt->arg);
  80d864:	8b 43 04             	mov    0x4(%ebx),%eax
  80d867:	89 04 24             	mov    %eax,(%esp)
  80d86a:	ff 13                	call   *(%ebx)
    lwip_core_unlock();
    free(lt);
  80d86c:	89 1c 24             	mov    %ebx,(%esp)
  80d86f:	e8 fc 53 ff ff       	call   802c70 <free>
}
  80d874:	83 c4 14             	add    $0x14,%esp
  80d877:	5b                   	pop    %ebx
  80d878:	5d                   	pop    %ebp
  80d879:	c3                   	ret    

0080d87a <sys_thread_new>:

sys_thread_t
sys_thread_new(char *name, void (* thread)(void *arg), void *arg, 
	       int stacksize, int prio)
{
  80d87a:	55                   	push   %ebp
  80d87b:	89 e5                	mov    %esp,%ebp
  80d87d:	53                   	push   %ebx
  80d87e:	83 ec 24             	sub    $0x24,%esp
  80d881:	8b 5d 14             	mov    0x14(%ebp),%ebx
    struct lwip_thread *lt = malloc(sizeof(*lt));
  80d884:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80d88b:	e8 b3 54 ff ff       	call   802d43 <malloc>
    if (lt == 0)
  80d890:	85 c0                	test   %eax,%eax
  80d892:	75 1c                	jne    80d8b0 <sys_thread_new+0x36>
	panic("sys_thread_new: cannot allocate thread struct");
  80d894:	c7 44 24 08 a4 43 81 	movl   $0x8143a4,0x8(%esp)
  80d89b:	00 
  80d89c:	c7 44 24 04 fd 00 00 	movl   $0xfd,0x4(%esp)
  80d8a3:	00 
  80d8a4:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d8ab:	e8 24 31 ff ff       	call   8009d4 <_panic>

    if (stacksize > PGSIZE)
  80d8b0:	81 fb 00 10 00 00    	cmp    $0x1000,%ebx
  80d8b6:	7e 20                	jle    80d8d8 <sys_thread_new+0x5e>
	panic("large stack %d", stacksize);
  80d8b8:	89 5c 24 0c          	mov    %ebx,0xc(%esp)
  80d8bc:	c7 44 24 08 4a 43 81 	movl   $0x81434a,0x8(%esp)
  80d8c3:	00 
  80d8c4:	c7 44 24 04 00 01 00 	movl   $0x100,0x4(%esp)
  80d8cb:	00 
  80d8cc:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d8d3:	e8 fc 30 ff ff       	call   8009d4 <_panic>

    lt->func = thread;
  80d8d8:	8b 55 0c             	mov    0xc(%ebp),%edx
  80d8db:	89 10                	mov    %edx,(%eax)
    lt->arg = arg;
  80d8dd:	8b 55 10             	mov    0x10(%ebp),%edx
  80d8e0:	89 50 04             	mov    %edx,0x4(%eax)

    thread_id_t tid;
    int r = thread_create(&tid, name, lwip_thread_entry, (uint32_t)lt);
  80d8e3:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d8e7:	c7 44 24 08 5a d8 80 	movl   $0x80d85a,0x8(%esp)
  80d8ee:	00 
  80d8ef:	8b 45 08             	mov    0x8(%ebp),%eax
  80d8f2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80d8f6:	8d 45 f4             	lea    -0xc(%ebp),%eax
  80d8f9:	89 04 24             	mov    %eax,(%esp)
  80d8fc:	e8 b6 07 00 00       	call   80e0b7 <thread_create>

    if (r < 0)
  80d901:	85 c0                	test   %eax,%eax
  80d903:	79 28                	jns    80d92d <sys_thread_new+0xb3>
	panic("lwip: sys_thread_new: cannot create: %s\n", e2s(r));
  80d905:	89 04 24             	mov    %eax,(%esp)
  80d908:	e8 ab 09 00 00       	call   80e2b8 <e2s>
  80d90d:	89 44 24 0c          	mov    %eax,0xc(%esp)
  80d911:	c7 44 24 08 d4 43 81 	movl   $0x8143d4,0x8(%esp)
  80d918:	00 
  80d919:	c7 44 24 04 09 01 00 	movl   $0x109,0x4(%esp)
  80d920:	00 
  80d921:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d928:	e8 a7 30 ff ff       	call   8009d4 <_panic>

    return tid;
}
  80d92d:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80d930:	83 c4 24             	add    $0x24,%esp
  80d933:	5b                   	pop    %ebx
  80d934:	5d                   	pop    %ebp
  80d935:	c3                   	ret    

0080d936 <sys_arch_sem_wait>:
    }
}

u32_t
sys_arch_sem_wait(sys_sem_t sem, u32_t tm_msec)
{
  80d936:	55                   	push   %ebp
  80d937:	89 e5                	mov    %esp,%ebp
  80d939:	57                   	push   %edi
  80d93a:	56                   	push   %esi
  80d93b:	53                   	push   %ebx
  80d93c:	83 ec 3c             	sub    $0x3c,%esp
    assert(!sems[sem].freed);
  80d93f:	8b 55 08             	mov    0x8(%ebp),%edx
  80d942:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d945:	83 3c 85 00 8f b3 00 	cmpl   $0x0,0xb38f00(,%eax,4)
  80d94c:	00 
  80d94d:	74 24                	je     80d973 <sys_arch_sem_wait+0x3d>
  80d94f:	c7 44 24 0c ef 42 81 	movl   $0x8142ef,0xc(%esp)
  80d956:	00 
  80d957:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80d95e:	00 
  80d95f:	c7 44 24 04 ac 00 00 	movl   $0xac,0x4(%esp)
  80d966:	00 
  80d967:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80d96e:	e8 61 30 ff ff       	call   8009d4 <_panic>
    u32_t waited = 0;

    int gen = sems[sem].gen;
  80d973:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d976:	8d 04 89             	lea    (%ecx,%ecx,4),%eax
  80d979:	8b 04 85 04 8f b3 00 	mov    0xb38f04(,%eax,4),%eax
  80d980:	89 45 dc             	mov    %eax,-0x24(%ebp)

    while (tm_msec == 0 || waited < tm_msec) {
  80d983:	83 7d 0c 00          	cmpl   $0x0,0xc(%ebp)
  80d987:	0f 94 45 d7          	sete   -0x29(%ebp)
  80d98b:	0f 95 45 e3          	setne  -0x1d(%ebp)
  80d98f:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80d993:	75 0a                	jne    80d99f <sys_arch_sem_wait+0x69>
  80d995:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80d999:	0f 84 d7 00 00 00    	je     80da76 <sys_arch_sem_wait+0x140>
	if (sems[sem].counter > 0) {
  80d99f:	8b 55 08             	mov    0x8(%ebp),%edx
  80d9a2:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d9a5:	0f b7 04 85 08 8f b3 	movzwl 0xb38f08(,%eax,4),%eax
  80d9ac:	00 
  80d9ad:	bf 00 00 00 00       	mov    $0x0,%edi
  80d9b2:	66 85 c0             	test   %ax,%ax
  80d9b5:	75 17                	jne    80d9ce <sys_arch_sem_wait+0x98>
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
  80d9b7:	83 7d 0c fe          	cmpl   $0xfffffffe,0xc(%ebp)
  80d9bb:	75 27                	jne    80d9e4 <sys_arch_sem_wait+0xae>
  80d9bd:	e9 b4 00 00 00       	jmp    80da76 <sys_arch_sem_wait+0x140>
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
	if (sems[sem].counter > 0) {
  80d9c2:	0f b7 83 08 8f b3 00 	movzwl 0xb38f08(%ebx),%eax
  80d9c9:	66 85 c0             	test   %ax,%ax
  80d9cc:	74 31                	je     80d9ff <sys_arch_sem_wait+0xc9>
	    sems[sem].counter--;
  80d9ce:	8b 4d 08             	mov    0x8(%ebp),%ecx
  80d9d1:	8d 14 89             	lea    (%ecx,%ecx,4),%edx
  80d9d4:	83 e8 01             	sub    $0x1,%eax
  80d9d7:	66 89 04 95 08 8f b3 	mov    %ax,0xb38f08(,%edx,4)
  80d9de:	00 
	    return waited;
  80d9df:	e9 97 00 00 00       	jmp    80da7b <sys_arch_sem_wait+0x145>
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80d9e4:	8b 55 08             	mov    0x8(%ebp),%edx
  80d9e7:	8d 04 92             	lea    (%edx,%edx,4),%eax
  80d9ea:	8d 04 85 08 8f b3 00 	lea    0xb38f08(,%eax,4),%eax
  80d9f1:	89 45 d8             	mov    %eax,-0x28(%ebp)
  80d9f4:	bf 00 00 00 00       	mov    $0x0,%edi
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
	    sems[sem].waiters = 1;
  80d9f9:	8d 1c 92             	lea    (%edx,%edx,4),%ebx
  80d9fc:	c1 e3 02             	shl    $0x2,%ebx
	    sems[sem].counter--;
	    return waited;
 	} else if (tm_msec == SYS_ARCH_NOWAIT) {
	    return SYS_ARCH_TIMEOUT;
	} else {
	    uint32_t a = sys_time_msec();
  80d9ff:	e8 a8 3c ff ff       	call   8016ac <sys_time_msec>
  80da04:	89 45 e4             	mov    %eax,-0x1c(%ebp)
	    uint32_t sleep_until = tm_msec ? a + (tm_msec - waited) : ~0;
  80da07:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80da0c:	80 7d e3 00          	cmpb   $0x0,-0x1d(%ebp)
  80da10:	74 08                	je     80da1a <sys_arch_sem_wait+0xe4>
  80da12:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80da15:	03 45 0c             	add    0xc(%ebp),%eax
  80da18:	29 f8                	sub    %edi,%eax
	    sems[sem].waiters = 1;
  80da1a:	be 00 8f b3 00       	mov    $0xb38f00,%esi
  80da1f:	66 c7 44 33 0a 01 00 	movw   $0x1,0xa(%ebx,%esi,1)
	    uint32_t cur_v = sems[sem].v;
	    lwip_core_unlock();
	    thread_wait(&sems[sem].v, cur_v, sleep_until);
  80da26:	89 44 24 08          	mov    %eax,0x8(%esp)
  80da2a:	8b 44 33 08          	mov    0x8(%ebx,%esi,1),%eax
  80da2e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80da32:	8b 4d d8             	mov    -0x28(%ebp),%ecx
  80da35:	89 0c 24             	mov    %ecx,(%esp)
  80da38:	e8 c2 07 00 00       	call   80e1ff <thread_wait>
	    lwip_core_lock();
	    if (gen != sems[sem].gen) {
  80da3d:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80da40:	39 44 33 04          	cmp    %eax,0x4(%ebx,%esi,1)
  80da44:	74 13                	je     80da59 <sys_arch_sem_wait+0x123>
		cprintf("sys_arch_sem_wait: sem freed under waiter!\n");
  80da46:	c7 04 24 00 44 81 00 	movl   $0x814400,(%esp)
  80da4d:	e8 47 30 ff ff       	call   800a99 <cprintf>
  80da52:	bf ff ff ff ff       	mov    $0xffffffff,%edi
		return SYS_ARCH_TIMEOUT;
  80da57:	eb 22                	jmp    80da7b <sys_arch_sem_wait+0x145>
	    }
	    uint32_t b = sys_time_msec();
  80da59:	e8 4e 3c ff ff       	call   8016ac <sys_time_msec>
	    waited += (b - a);
  80da5e:	2b 45 e4             	sub    -0x1c(%ebp),%eax
  80da61:	01 c7                	add    %eax,%edi
    assert(!sems[sem].freed);
    u32_t waited = 0;

    int gen = sems[sem].gen;

    while (tm_msec == 0 || waited < tm_msec) {
  80da63:	39 7d 0c             	cmp    %edi,0xc(%ebp)
  80da66:	0f 87 56 ff ff ff    	ja     80d9c2 <sys_arch_sem_wait+0x8c>
  80da6c:	80 7d d7 00          	cmpb   $0x0,-0x29(%ebp)
  80da70:	0f 85 4c ff ff ff    	jne    80d9c2 <sys_arch_sem_wait+0x8c>
  80da76:	bf ff ff ff ff       	mov    $0xffffffff,%edi
	    waited += (b - a);
	}
    }

    return SYS_ARCH_TIMEOUT;
}
  80da7b:	89 f8                	mov    %edi,%eax
  80da7d:	83 c4 3c             	add    $0x3c,%esp
  80da80:	5b                   	pop    %ebx
  80da81:	5e                   	pop    %esi
  80da82:	5f                   	pop    %edi
  80da83:	5d                   	pop    %ebp
  80da84:	c3                   	ret    

0080da85 <sys_sem_new>:
    return ERR_OK;
}

sys_sem_t
sys_sem_new(u8_t count)
{
  80da85:	55                   	push   %ebp
  80da86:	89 e5                	mov    %esp,%ebp
  80da88:	53                   	push   %ebx
  80da89:	83 ec 14             	sub    $0x14,%esp
  80da8c:	0f b6 4d 08          	movzbl 0x8(%ebp),%ecx
    struct sys_sem_entry *se = LIST_FIRST(&sem_free);
  80da90:	a1 00 a3 b3 00       	mov    0xb3a300,%eax
    if (!se) {
  80da95:	85 c0                	test   %eax,%eax
  80da97:	75 13                	jne    80daac <sys_sem_new+0x27>
	cprintf("lwip: sys_sem_new: out of semaphores\n");
  80da99:	c7 04 24 2c 44 81 00 	movl   $0x81442c,(%esp)
  80daa0:	e8 f4 2f ff ff       	call   800a99 <cprintf>
  80daa5:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
	return SYS_SEM_NULL;
  80daaa:	eb 5d                	jmp    80db09 <sys_sem_new+0x84>
    }
    LIST_REMOVE(se, link);
  80daac:	8b 50 0c             	mov    0xc(%eax),%edx
  80daaf:	85 d2                	test   %edx,%edx
  80dab1:	74 06                	je     80dab9 <sys_sem_new+0x34>
  80dab3:	8b 58 10             	mov    0x10(%eax),%ebx
  80dab6:	89 5a 10             	mov    %ebx,0x10(%edx)
  80dab9:	8b 50 10             	mov    0x10(%eax),%edx
  80dabc:	8b 58 0c             	mov    0xc(%eax),%ebx
  80dabf:	89 1a                	mov    %ebx,(%edx)
    assert(se->freed);
  80dac1:	83 38 00             	cmpl   $0x0,(%eax)
  80dac4:	75 24                	jne    80daea <sys_sem_new+0x65>
  80dac6:	c7 44 24 0c 59 43 81 	movl   $0x814359,0xc(%esp)
  80dacd:	00 
  80dace:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80dad5:	00 
  80dad6:	c7 44 24 04 8d 00 00 	movl   $0x8d,0x4(%esp)
  80dadd:	00 
  80dade:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80dae5:	e8 ea 2e ff ff       	call   8009d4 <_panic>
    se->freed = 0;
  80daea:	c7 00 00 00 00 00    	movl   $0x0,(%eax)

    se->counter = count;
  80daf0:	0f b6 c9             	movzbl %cl,%ecx
  80daf3:	66 89 48 08          	mov    %cx,0x8(%eax)
    se->gen++;
  80daf7:	83 40 04 01          	addl   $0x1,0x4(%eax)
    return se - &sems[0];
  80dafb:	2d 00 8f b3 00       	sub    $0xb38f00,%eax
  80db00:	c1 f8 02             	sar    $0x2,%eax
  80db03:	69 c0 cd cc cc cc    	imul   $0xcccccccd,%eax,%eax
}
  80db09:	83 c4 14             	add    $0x14,%esp
  80db0c:	5b                   	pop    %ebx
  80db0d:	5d                   	pop    %ebp
  80db0e:	c3                   	ret    

0080db0f <sys_mbox_new>:
    }
}

sys_mbox_t
sys_mbox_new(int size)
{
  80db0f:	55                   	push   %ebp
  80db10:	89 e5                	mov    %esp,%ebp
  80db12:	56                   	push   %esi
  80db13:	53                   	push   %ebx
  80db14:	83 ec 10             	sub    $0x10,%esp
    assert(size < MBOXSLOTS);
  80db17:	83 7d 08 1f          	cmpl   $0x1f,0x8(%ebp)
  80db1b:	7e 24                	jle    80db41 <sys_mbox_new+0x32>
  80db1d:	c7 44 24 0c 63 43 81 	movl   $0x814363,0xc(%esp)
  80db24:	00 
  80db25:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80db2c:	00 
  80db2d:	c7 44 24 04 45 00 00 	movl   $0x45,0x4(%esp)
  80db34:	00 
  80db35:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80db3c:	e8 93 2e ff ff       	call   8009d4 <_panic>
    struct sys_mbox_entry *mbe = LIST_FIRST(&mbox_free);
  80db41:	8b 1d 20 f1 b3 00    	mov    0xb3f120,%ebx
    if (!mbe) {
  80db47:	85 db                	test   %ebx,%ebx
  80db49:	75 16                	jne    80db61 <sys_mbox_new+0x52>
	cprintf("lwip: sys_mbox_new: out of mailboxes\n");
  80db4b:	c7 04 24 54 44 81 00 	movl   $0x814454,(%esp)
  80db52:	e8 42 2f ff ff       	call   800a99 <cprintf>
  80db57:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
  80db5c:	e9 bd 00 00 00       	jmp    80dc1e <sys_mbox_new+0x10f>
    }
    LIST_REMOVE(mbe, link);
  80db61:	8b 83 94 00 00 00    	mov    0x94(%ebx),%eax
  80db67:	85 c0                	test   %eax,%eax
  80db69:	74 0c                	je     80db77 <sys_mbox_new+0x68>
  80db6b:	8b 93 98 00 00 00    	mov    0x98(%ebx),%edx
  80db71:	89 90 98 00 00 00    	mov    %edx,0x98(%eax)
  80db77:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  80db7d:	8b 93 94 00 00 00    	mov    0x94(%ebx),%edx
  80db83:	89 10                	mov    %edx,(%eax)
    assert(mbe->freed);
  80db85:	83 3b 00             	cmpl   $0x0,(%ebx)
  80db88:	75 24                	jne    80dbae <sys_mbox_new+0x9f>
  80db8a:	c7 44 24 0c 74 43 81 	movl   $0x814374,0xc(%esp)
  80db91:	00 
  80db92:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80db99:	00 
  80db9a:	c7 44 24 04 4c 00 00 	movl   $0x4c,0x4(%esp)
  80dba1:	00 
  80dba2:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80dba9:	e8 26 2e ff ff       	call   8009d4 <_panic>
    mbe->freed = 0;
  80dbae:	c7 03 00 00 00 00    	movl   $0x0,(%ebx)

    int i = mbe - &mboxes[0];
  80dbb4:	89 de                	mov    %ebx,%esi
  80dbb6:	81 ee 20 a3 b3 00    	sub    $0xb3a320,%esi
  80dbbc:	c1 fe 02             	sar    $0x2,%esi
  80dbbf:	69 f6 97 6f f9 96    	imul   $0x96f96f97,%esi,%esi
    mbe->head = -1;
  80dbc5:	c7 43 04 ff ff ff ff 	movl   $0xffffffff,0x4(%ebx)
    mbe->nextq = 0;
  80dbcc:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    mbe->queued_msg = sys_sem_new(0);
  80dbd3:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80dbda:	e8 a6 fe ff ff       	call   80da85 <sys_sem_new>
  80dbdf:	89 83 8c 00 00 00    	mov    %eax,0x8c(%ebx)
    mbe->free_msg = sys_sem_new(MBOXSLOTS);
  80dbe5:	c7 04 24 20 00 00 00 	movl   $0x20,(%esp)
  80dbec:	e8 94 fe ff ff       	call   80da85 <sys_sem_new>
  80dbf1:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)

    if (mbe->queued_msg == SYS_SEM_NULL ||
  80dbf7:	83 bb 8c 00 00 00 ff 	cmpl   $0xffffffff,0x8c(%ebx)
  80dbfe:	74 05                	je     80dc05 <sys_mbox_new+0xf6>
  80dc00:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dc03:	75 19                	jne    80dc1e <sys_mbox_new+0x10f>
	mbe->free_msg == SYS_SEM_NULL)
    {
	sys_mbox_free(i);
  80dc05:	89 34 24             	mov    %esi,(%esp)
  80dc08:	e8 4a fa ff ff       	call   80d657 <sys_mbox_free>
	cprintf("lwip: sys_mbox_new: can't get semaphore\n");
  80dc0d:	c7 04 24 7c 44 81 00 	movl   $0x81447c,(%esp)
  80dc14:	e8 80 2e ff ff       	call   800a99 <cprintf>
  80dc19:	be ff ff ff ff       	mov    $0xffffffff,%esi
	return SYS_MBOX_NULL;
    }
    return i;
}
  80dc1e:	89 f0                	mov    %esi,%eax
  80dc20:	83 c4 10             	add    $0x10,%esp
  80dc23:	5b                   	pop    %ebx
  80dc24:	5e                   	pop    %esi
  80dc25:	5d                   	pop    %ebp
  80dc26:	c3                   	ret    

0080dc27 <sys_sem_signal>:
    LIST_INSERT_HEAD(&sem_free, &sems[sem], link);
}

void
sys_sem_signal(sys_sem_t sem)
{
  80dc27:	55                   	push   %ebp
  80dc28:	89 e5                	mov    %esp,%ebp
  80dc2a:	83 ec 18             	sub    $0x18,%esp
  80dc2d:	8b 45 08             	mov    0x8(%ebp),%eax
    assert(!sems[sem].freed);
  80dc30:	8d 14 80             	lea    (%eax,%eax,4),%edx
  80dc33:	83 3c 95 00 8f b3 00 	cmpl   $0x0,0xb38f00(,%edx,4)
  80dc3a:	00 
  80dc3b:	74 24                	je     80dc61 <sys_sem_signal+0x3a>
  80dc3d:	c7 44 24 0c ef 42 81 	movl   $0x8142ef,0xc(%esp)
  80dc44:	00 
  80dc45:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80dc4c:	00 
  80dc4d:	c7 44 24 04 a1 00 00 	movl   $0xa1,0x4(%esp)
  80dc54:	00 
  80dc55:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80dc5c:	e8 73 2d ff ff       	call   8009d4 <_panic>
    sems[sem].counter++;
  80dc61:	ba 00 8f b3 00       	mov    $0xb38f00,%edx
  80dc66:	8d 0c 80             	lea    (%eax,%eax,4),%ecx
  80dc69:	c1 e1 02             	shl    $0x2,%ecx
  80dc6c:	66 83 44 0a 08 01    	addw   $0x1,0x8(%edx,%ecx,1)
    if (sems[sem].waiters) {
  80dc72:	66 83 7c 11 0a 00    	cmpw   $0x0,0xa(%ecx,%edx,1)
  80dc78:	74 18                	je     80dc92 <sys_sem_signal+0x6b>
	sems[sem].waiters = 0;
  80dc7a:	89 c8                	mov    %ecx,%eax
  80dc7c:	66 c7 81 0a 8f b3 00 	movw   $0x0,0xb38f0a(%ecx)
  80dc83:	00 00 
	thread_wakeup(&sems[sem].v);
  80dc85:	05 08 8f b3 00       	add    $0xb38f08,%eax
  80dc8a:	89 04 24             	mov    %eax,(%esp)
  80dc8d:	e8 6d 02 00 00       	call   80deff <thread_wakeup>
    }
}
  80dc92:	c9                   	leave  
  80dc93:	c3                   	ret    

0080dc94 <sys_arch_mbox_fetch>:
    return SYS_ARCH_TIMEOUT;
}

u32_t
sys_arch_mbox_fetch(sys_mbox_t mbox, void **msg, u32_t tm_msec)
{
  80dc94:	55                   	push   %ebp
  80dc95:	89 e5                	mov    %esp,%ebp
  80dc97:	83 ec 28             	sub    $0x28,%esp
  80dc9a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80dc9d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80dca0:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80dca3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80dca6:	8b 7d 0c             	mov    0xc(%ebp),%edi
    assert(!mboxes[mbox].freed);
  80dca9:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dcaf:	83 b8 20 a3 b3 00 00 	cmpl   $0x0,0xb3a320(%eax)
  80dcb6:	74 24                	je     80dcdc <sys_arch_mbox_fetch+0x48>
  80dcb8:	c7 44 24 0c 1d 43 81 	movl   $0x81431d,0xc(%esp)
  80dcbf:	00 
  80dcc0:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80dcc7:	00 
  80dcc8:	c7 44 24 04 ce 00 00 	movl   $0xce,0x4(%esp)
  80dccf:	00 
  80dcd0:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80dcd7:	e8 f8 2c ff ff       	call   8009d4 <_panic>

    u32_t waited = sys_arch_sem_wait(mboxes[mbox].queued_msg, tm_msec);
  80dcdc:	8b 45 10             	mov    0x10(%ebp),%eax
  80dcdf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80dce3:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dce9:	8b 80 ac a3 b3 00    	mov    0xb3a3ac(%eax),%eax
  80dcef:	89 04 24             	mov    %eax,(%esp)
  80dcf2:	e8 3f fc ff ff       	call   80d936 <sys_arch_sem_wait>
  80dcf7:	89 c6                	mov    %eax,%esi
    if (waited == SYS_ARCH_TIMEOUT)
  80dcf9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dcfc:	0f 84 85 00 00 00    	je     80dd87 <sys_arch_mbox_fetch+0xf3>
	return waited;

    int slot = mboxes[mbox].head;
  80dd02:	69 c3 9c 00 00 00    	imul   $0x9c,%ebx,%eax
  80dd08:	8b 80 24 a3 b3 00    	mov    0xb3a324(%eax),%eax
    if (slot == -1)
  80dd0e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80dd11:	75 1c                	jne    80dd2f <sys_arch_mbox_fetch+0x9b>
	panic("lwip: sys_arch_mbox_fetch: no message");
  80dd13:	c7 44 24 08 a8 44 81 	movl   $0x8144a8,0x8(%esp)
  80dd1a:	00 
  80dd1b:	c7 44 24 04 d6 00 00 	movl   $0xd6,0x4(%esp)
  80dd22:	00 
  80dd23:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80dd2a:	e8 a5 2c ff ff       	call   8009d4 <_panic>
    if (msg)
  80dd2f:	85 ff                	test   %edi,%edi
  80dd31:	74 0e                	je     80dd41 <sys_arch_mbox_fetch+0xad>
	*msg = mboxes[mbox].msg[slot];
  80dd33:	6b d3 27             	imul   $0x27,%ebx,%edx
  80dd36:	01 c2                	add    %eax,%edx
  80dd38:	8b 14 95 2c a3 b3 00 	mov    0xb3a32c(,%edx,4),%edx
  80dd3f:	89 17                	mov    %edx,(%edi)

    mboxes[mbox].head = (slot + 1) % MBOXSLOTS;
  80dd41:	8d 48 01             	lea    0x1(%eax),%ecx
  80dd44:	89 ca                	mov    %ecx,%edx
  80dd46:	c1 fa 1f             	sar    $0x1f,%edx
  80dd49:	c1 ea 1b             	shr    $0x1b,%edx
  80dd4c:	8d 04 11             	lea    (%ecx,%edx,1),%eax
  80dd4f:	83 e0 1f             	and    $0x1f,%eax
  80dd52:	29 d0                	sub    %edx,%eax
  80dd54:	ba 20 a3 b3 00       	mov    $0xb3a320,%edx
  80dd59:	69 cb 9c 00 00 00    	imul   $0x9c,%ebx,%ecx
  80dd5f:	89 44 11 04          	mov    %eax,0x4(%ecx,%edx,1)
    if (mboxes[mbox].head == mboxes[mbox].nextq)
  80dd63:	3b 44 11 08          	cmp    0x8(%ecx,%edx,1),%eax
  80dd67:	75 0a                	jne    80dd73 <sys_arch_mbox_fetch+0xdf>
	mboxes[mbox].head = -1;
  80dd69:	c7 81 24 a3 b3 00 ff 	movl   $0xffffffff,0xb3a324(%ecx)
  80dd70:	ff ff ff 

    sys_sem_signal(mboxes[mbox].free_msg);
  80dd73:	69 db 9c 00 00 00    	imul   $0x9c,%ebx,%ebx
  80dd79:	8b 83 b0 a3 b3 00    	mov    0xb3a3b0(%ebx),%eax
  80dd7f:	89 04 24             	mov    %eax,(%esp)
  80dd82:	e8 a0 fe ff ff       	call   80dc27 <sys_sem_signal>
    return waited;
}
  80dd87:	89 f0                	mov    %esi,%eax
  80dd89:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80dd8c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80dd8f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80dd92:	89 ec                	mov    %ebp,%esp
  80dd94:	5d                   	pop    %ebp
  80dd95:	c3                   	ret    

0080dd96 <sys_arch_mbox_tryfetch>:

u32_t 
sys_arch_mbox_tryfetch(sys_mbox_t mbox, void **msg)
{
  80dd96:	55                   	push   %ebp
  80dd97:	89 e5                	mov    %esp,%ebp
  80dd99:	83 ec 18             	sub    $0x18,%esp
    return sys_arch_mbox_fetch(mbox, msg, SYS_ARCH_NOWAIT);
  80dd9c:	c7 44 24 08 fe ff ff 	movl   $0xfffffffe,0x8(%esp)
  80dda3:	ff 
  80dda4:	8b 45 0c             	mov    0xc(%ebp),%eax
  80dda7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ddab:	8b 45 08             	mov    0x8(%ebp),%eax
  80ddae:	89 04 24             	mov    %eax,(%esp)
  80ddb1:	e8 de fe ff ff       	call   80dc94 <sys_arch_mbox_fetch>
}
  80ddb6:	c9                   	leave  
  80ddb7:	c3                   	ret    

0080ddb8 <sys_mbox_trypost>:
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
}

err_t 
sys_mbox_trypost(sys_mbox_t mbox, void *msg)
{
  80ddb8:	55                   	push   %ebp
  80ddb9:	89 e5                	mov    %esp,%ebp
  80ddbb:	83 ec 28             	sub    $0x28,%esp
  80ddbe:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80ddc1:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80ddc4:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80ddc7:	8b 75 08             	mov    0x8(%ebp),%esi
    assert(!mboxes[mbox].freed);
  80ddca:	69 c6 9c 00 00 00    	imul   $0x9c,%esi,%eax
  80ddd0:	83 b8 20 a3 b3 00 00 	cmpl   $0x0,0xb3a320(%eax)
  80ddd7:	74 24                	je     80ddfd <sys_mbox_trypost+0x45>
  80ddd9:	c7 44 24 0c 1d 43 81 	movl   $0x81431d,0xc(%esp)
  80dde0:	00 
  80dde1:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80dde8:	00 
  80dde9:	c7 44 24 04 72 00 00 	movl   $0x72,0x4(%esp)
  80ddf0:	00 
  80ddf1:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80ddf8:	e8 d7 2b ff ff       	call   8009d4 <_panic>

    sys_arch_sem_wait(mboxes[mbox].free_msg, 0);
  80ddfd:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80de04:	00 
  80de05:	69 de 9c 00 00 00    	imul   $0x9c,%esi,%ebx
  80de0b:	8b 83 b0 a3 b3 00    	mov    0xb3a3b0(%ebx),%eax
  80de11:	89 04 24             	mov    %eax,(%esp)
  80de14:	e8 1d fb ff ff       	call   80d936 <sys_arch_sem_wait>
    if (mboxes[mbox].nextq == mboxes[mbox].head)
  80de19:	b9 20 a3 b3 00       	mov    $0xb3a320,%ecx
  80de1e:	8b 54 0b 08          	mov    0x8(%ebx,%ecx,1),%edx
  80de22:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80de27:	3b 54 0b 04          	cmp    0x4(%ebx,%ecx,1),%edx
  80de2b:	74 4c                	je     80de79 <sys_mbox_trypost+0xc1>
	return ERR_MEM;

    int slot = mboxes[mbox].nextq;
    mboxes[mbox].nextq = (slot + 1) % MBOXSLOTS;
  80de2d:	89 c8                	mov    %ecx,%eax
  80de2f:	89 d9                	mov    %ebx,%ecx
  80de31:	8d 7a 01             	lea    0x1(%edx),%edi
  80de34:	89 fb                	mov    %edi,%ebx
  80de36:	c1 fb 1f             	sar    $0x1f,%ebx
  80de39:	c1 eb 1b             	shr    $0x1b,%ebx
  80de3c:	01 df                	add    %ebx,%edi
  80de3e:	83 e7 1f             	and    $0x1f,%edi
  80de41:	29 df                	sub    %ebx,%edi
  80de43:	89 7c 01 08          	mov    %edi,0x8(%ecx,%eax,1)
    mboxes[mbox].msg[slot] = msg;
  80de47:	6b de 27             	imul   $0x27,%esi,%ebx
  80de4a:	01 d3                	add    %edx,%ebx
  80de4c:	8b 7d 0c             	mov    0xc(%ebp),%edi
  80de4f:	89 7c 98 0c          	mov    %edi,0xc(%eax,%ebx,4)

    if (mboxes[mbox].head == -1)
  80de53:	83 7c 01 04 ff       	cmpl   $0xffffffff,0x4(%ecx,%eax,1)
  80de58:	75 06                	jne    80de60 <sys_mbox_trypost+0xa8>
	mboxes[mbox].head = slot;
  80de5a:	89 91 24 a3 b3 00    	mov    %edx,0xb3a324(%ecx)

    sys_sem_signal(mboxes[mbox].queued_msg);
  80de60:	69 f6 9c 00 00 00    	imul   $0x9c,%esi,%esi
  80de66:	8b 86 ac a3 b3 00    	mov    0xb3a3ac(%esi),%eax
  80de6c:	89 04 24             	mov    %eax,(%esp)
  80de6f:	e8 b3 fd ff ff       	call   80dc27 <sys_sem_signal>
  80de74:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80de79:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80de7c:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80de7f:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80de82:	89 ec                	mov    %ebp,%esp
  80de84:	5d                   	pop    %ebp
  80de85:	c3                   	ret    

0080de86 <sys_mbox_post>:
    mboxes[mbox].freed = 1;
}

void
sys_mbox_post(sys_mbox_t mbox, void *msg)
{
  80de86:	55                   	push   %ebp
  80de87:	89 e5                	mov    %esp,%ebp
  80de89:	83 ec 18             	sub    $0x18,%esp
    assert(sys_mbox_trypost(mbox, msg) == ERR_OK);
  80de8c:	8b 45 0c             	mov    0xc(%ebp),%eax
  80de8f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80de93:	8b 45 08             	mov    0x8(%ebp),%eax
  80de96:	89 04 24             	mov    %eax,(%esp)
  80de99:	e8 1a ff ff ff       	call   80ddb8 <sys_mbox_trypost>
  80de9e:	84 c0                	test   %al,%al
  80dea0:	74 24                	je     80dec6 <sys_mbox_post+0x40>
  80dea2:	c7 44 24 0c d0 44 81 	movl   $0x8144d0,0xc(%esp)
  80dea9:	00 
  80deaa:	c7 44 24 08 10 2e 81 	movl   $0x812e10,0x8(%esp)
  80deb1:	00 
  80deb2:	c7 44 24 04 6c 00 00 	movl   $0x6c,0x4(%esp)
  80deb9:	00 
  80deba:	c7 04 24 00 43 81 00 	movl   $0x814300,(%esp)
  80dec1:	e8 0e 2b ff ff       	call   8009d4 <_panic>
}
  80dec6:	c9                   	leave  
  80dec7:	c3                   	ret    
	...

0080ded0 <thread_init>:

static struct thread_queue thread_queue;
static struct thread_queue kill_queue;

void
thread_init(void) {
  80ded0:	55                   	push   %ebp
  80ded1:	89 e5                	mov    %esp,%ebp
};

static inline void 
threadq_init(struct thread_queue *tq)
{
    tq->tq_first = 0;
  80ded3:	c7 05 4c f5 b3 00 00 	movl   $0x0,0xb3f54c
  80deda:	00 00 00 
    tq->tq_last = 0;
  80dedd:	c7 05 50 f5 b3 00 00 	movl   $0x0,0xb3f550
  80dee4:	00 00 00 
    threadq_init(&thread_queue);
    max_tid = 0;
  80dee7:	c7 05 44 f5 b3 00 00 	movl   $0x0,0xb3f544
  80deee:	00 00 00 
}
  80def1:	5d                   	pop    %ebp
  80def2:	c3                   	ret    

0080def3 <thread_id>:

uint32_t
thread_id(void) {
  80def3:	55                   	push   %ebp
  80def4:	89 e5                	mov    %esp,%ebp
  80def6:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
  80defb:	8b 00                	mov    (%eax),%eax
    return cur_tc->tc_tid;
}
  80defd:	5d                   	pop    %ebp
  80defe:	c3                   	ret    

0080deff <thread_wakeup>:

void
thread_wakeup(volatile uint32_t *addr) {
  80deff:	55                   	push   %ebp
  80df00:	89 e5                	mov    %esp,%ebp
  80df02:	8b 55 08             	mov    0x8(%ebp),%edx
    struct thread_context *tc = thread_queue.tq_first;
  80df05:	a1 4c f5 b3 00       	mov    0xb3f54c,%eax
    while (tc) {
  80df0a:	85 c0                	test   %eax,%eax
  80df0c:	74 10                	je     80df1e <thread_wakeup+0x1f>
	if (tc->tc_wait_addr == addr)
  80df0e:	39 50 48             	cmp    %edx,0x48(%eax)
  80df11:	75 04                	jne    80df17 <thread_wakeup+0x18>
	    tc->tc_wakeup = 1;
  80df13:	c6 40 4c 01          	movb   $0x1,0x4c(%eax)
	tc = tc->tc_queue_link;
  80df17:	8b 40 64             	mov    0x64(%eax),%eax
}

void
thread_wakeup(volatile uint32_t *addr) {
    struct thread_context *tc = thread_queue.tq_first;
    while (tc) {
  80df1a:	85 c0                	test   %eax,%eax
  80df1c:	75 f0                	jne    80df0e <thread_wakeup+0xf>
	if (tc->tc_wait_addr == addr)
	    tc->tc_wakeup = 1;
	tc = tc->tc_queue_link;
    }
}
  80df1e:	5d                   	pop    %ebp
  80df1f:	90                   	nop
  80df20:	c3                   	ret    

0080df21 <thread_wakeups_pending>:
    cur_tc->tc_wakeup = 0;
}

int
thread_wakeups_pending(void)
{
  80df21:	55                   	push   %ebp
  80df22:	89 e5                	mov    %esp,%ebp
    struct thread_context *tc = thread_queue.tq_first;
  80df24:	8b 15 4c f5 b3 00    	mov    0xb3f54c,%edx
    int n = 0;
    while (tc) {
  80df2a:	b8 00 00 00 00       	mov    $0x0,%eax
  80df2f:	85 d2                	test   %edx,%edx
  80df31:	74 11                	je     80df44 <thread_wakeups_pending+0x23>
	if (tc->tc_wakeup)
  80df33:	0f b6 4a 4c          	movzbl 0x4c(%edx),%ecx
	    ++n;
  80df37:	80 f9 01             	cmp    $0x1,%cl
  80df3a:	83 d8 ff             	sbb    $0xffffffff,%eax
	tc = tc->tc_queue_link;
  80df3d:	8b 52 64             	mov    0x64(%edx),%edx
int
thread_wakeups_pending(void)
{
    struct thread_context *tc = thread_queue.tq_first;
    int n = 0;
    while (tc) {
  80df40:	85 d2                	test   %edx,%edx
  80df42:	75 ef                	jne    80df33 <thread_wakeups_pending+0x12>
	if (tc->tc_wakeup)
	    ++n;
	tc = tc->tc_queue_link;
    }
    return n;
}
  80df44:	5d                   	pop    %ebp
  80df45:	c3                   	ret    

0080df46 <thread_onhalt>:

int
thread_onhalt(void (*fun)(thread_id_t)) {
  80df46:	55                   	push   %ebp
  80df47:	89 e5                	mov    %esp,%ebp
    if (cur_tc->tc_nonhalt >= THREAD_NUM_ONHALT)
  80df49:	8b 15 48 f5 b3 00    	mov    0xb3f548,%edx
  80df4f:	8b 4a 60             	mov    0x60(%edx),%ecx
  80df52:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80df57:	83 f9 03             	cmp    $0x3,%ecx
  80df5a:	7f 12                	jg     80df6e <thread_onhalt+0x28>
	return -E_NO_MEM;

    cur_tc->tc_onhalt[cur_tc->tc_nonhalt++] = fun;
  80df5c:	8b 45 08             	mov    0x8(%ebp),%eax
  80df5f:	89 44 8a 50          	mov    %eax,0x50(%edx,%ecx,4)
  80df63:	83 c1 01             	add    $0x1,%ecx
  80df66:	89 4a 60             	mov    %ecx,0x60(%edx)
  80df69:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80df6e:	5d                   	pop    %ebp
  80df6f:	c3                   	ret    

0080df70 <thread_yield>:
    // when yield has no thread to run, it will return here!
    exit();
}

void
thread_yield(void) {
  80df70:	55                   	push   %ebp
  80df71:	89 e5                	mov    %esp,%ebp
  80df73:	53                   	push   %ebx
  80df74:	83 ec 14             	sub    $0x14,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80df77:	8b 1d 4c f5 b3 00    	mov    0xb3f54c,%ebx
  80df7d:	85 db                	test   %ebx,%ebx
  80df7f:	74 69                	je     80dfea <thread_yield+0x7a>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80df81:	8b 43 64             	mov    0x64(%ebx),%eax
  80df84:	a3 4c f5 b3 00       	mov    %eax,0xb3f54c
    tc->tc_queue_link = 0;
  80df89:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    struct thread_context *next_tc = threadq_pop(&thread_queue);

    if (!next_tc)
	return;

    if (cur_tc) {
  80df90:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
  80df95:	85 c0                	test   %eax,%eax
  80df97:	74 3e                	je     80dfd7 <thread_yield+0x67>
	if (jos_setjmp(&cur_tc->tc_jb) != 0)
  80df99:	83 c0 30             	add    $0x30,%eax
  80df9c:	89 04 24             	mov    %eax,(%esp)
  80df9f:	e8 cc 02 00 00       	call   80e270 <jos_setjmp>
  80dfa4:	85 c0                	test   %eax,%eax
  80dfa6:	75 42                	jne    80dfea <thread_yield+0x7a>
	    return;
	threadq_push(&thread_queue, cur_tc);
  80dfa8:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80dfad:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80dfb4:	83 3d 4c f5 b3 00 00 	cmpl   $0x0,0xb3f54c
  80dfbb:	75 0c                	jne    80dfc9 <thread_yield+0x59>
	tq->tq_first = tc;
  80dfbd:	a3 4c f5 b3 00       	mov    %eax,0xb3f54c
	tq->tq_last = tc;
  80dfc2:	a3 50 f5 b3 00       	mov    %eax,0xb3f550
  80dfc7:	eb 0e                	jmp    80dfd7 <thread_yield+0x67>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80dfc9:	8b 15 50 f5 b3 00    	mov    0xb3f550,%edx
  80dfcf:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80dfd2:	a3 50 f5 b3 00       	mov    %eax,0xb3f550
    }

    cur_tc = next_tc;
  80dfd7:	89 1d 48 f5 b3 00    	mov    %ebx,0xb3f548
    jos_longjmp(&cur_tc->tc_jb, 1);
  80dfdd:	8d 43 30             	lea    0x30(%ebx),%eax
  80dfe0:	ba 01 00 00 00       	mov    $0x1,%edx
  80dfe5:	e8 b6 02 00 00       	call   80e2a0 <jos_longjmp>
}
  80dfea:	83 c4 14             	add    $0x14,%esp
  80dfed:	5b                   	pop    %ebx
  80dfee:	5d                   	pop    %ebp
  80dfef:	c3                   	ret    

0080dff0 <thread_halt>:
    free(tc->tc_stack_bottom);
    free(tc);
}

void
thread_halt() {
  80dff0:	55                   	push   %ebp
  80dff1:	89 e5                	mov    %esp,%ebp
  80dff3:	56                   	push   %esi
  80dff4:	53                   	push   %ebx
  80dff5:	83 ec 10             	sub    $0x10,%esp
}

static inline struct thread_context *
threadq_pop(struct thread_queue *tq)
{
    if (!tq->tq_first)
  80dff8:	8b 1d 54 f5 b3 00    	mov    0xb3f554,%ebx
  80dffe:	85 db                	test   %ebx,%ebx
  80e000:	0f 84 88 00 00 00    	je     80e08e <thread_halt+0x9e>
	return 0;

    struct thread_context *tc = tq->tq_first;
    tq->tq_first = tc->tc_queue_link;
  80e006:	8b 43 64             	mov    0x64(%ebx),%eax
  80e009:	a3 54 f5 b3 00       	mov    %eax,0xb3f554
    tc->tc_queue_link = 0;
  80e00e:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80e015:	83 7b 60 00          	cmpl   $0x0,0x60(%ebx)
  80e019:	7e 16                	jle    80e031 <thread_halt+0x41>
  80e01b:	be 00 00 00 00       	mov    $0x0,%esi
	tc->tc_onhalt[i](tc->tc_tid);
  80e020:	8b 03                	mov    (%ebx),%eax
  80e022:	89 04 24             	mov    %eax,(%esp)
  80e025:	ff 54 b3 50          	call   *0x50(%ebx,%esi,4)
static void
thread_clean(struct thread_context *tc) {
    if (!tc) return;

    int i;
    for (i = 0; i < tc->tc_nonhalt; i++)
  80e029:	83 c6 01             	add    $0x1,%esi
  80e02c:	3b 73 60             	cmp    0x60(%ebx),%esi
  80e02f:	7c ef                	jl     80e020 <thread_halt+0x30>
	tc->tc_onhalt[i](tc->tc_tid);
    free(tc->tc_stack_bottom);
  80e031:	8b 43 04             	mov    0x4(%ebx),%eax
  80e034:	89 04 24             	mov    %eax,(%esp)
  80e037:	e8 34 4c ff ff       	call   802c70 <free>
    free(tc);
  80e03c:	89 1c 24             	mov    %ebx,(%esp)
  80e03f:	e8 2c 4c ff ff       	call   802c70 <free>
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80e044:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80e049:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
    if (!tq->tq_first) {
  80e050:	83 3d 54 f5 b3 00 00 	cmpl   $0x0,0xb3f554
  80e057:	75 0c                	jne    80e065 <thread_halt+0x75>
	tq->tq_first = tc;
  80e059:	a3 54 f5 b3 00       	mov    %eax,0xb3f554
	tq->tq_last = tc;
  80e05e:	a3 58 f5 b3 00       	mov    %eax,0xb3f558
  80e063:	eb 0e                	jmp    80e073 <thread_halt+0x83>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80e065:	8b 15 58 f5 b3 00    	mov    0xb3f558,%edx
  80e06b:	89 42 64             	mov    %eax,0x64(%edx)
	tq->tq_last = tc;
  80e06e:	a3 58 f5 b3 00       	mov    %eax,0xb3f558
    cur_tc = NULL;
  80e073:	c7 05 48 f5 b3 00 00 	movl   $0x0,0xb3f548
  80e07a:	00 00 00 
    thread_yield();
  80e07d:	e8 ee fe ff ff       	call   80df70 <thread_yield>
    // WHAT IF THERE ARE NO MORE THREADS? HOW DO WE STOP?
    // when yield has no thread to run, it will return here!
    exit();
  80e082:	e8 31 29 ff ff       	call   8009b8 <exit>
}
  80e087:	83 c4 10             	add    $0x10,%esp
  80e08a:	5b                   	pop    %ebx
  80e08b:	5e                   	pop    %esi
  80e08c:	5d                   	pop    %ebp
  80e08d:	c3                   	ret    
thread_halt() {
    // right now the kill_queue will never be more than one
    // clean up a thread if one is on the queue
    thread_clean(threadq_pop(&kill_queue));

    threadq_push(&kill_queue, cur_tc);
  80e08e:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
}

static inline void
threadq_push(struct thread_queue *tq, struct thread_context *tc)
{
    tc->tc_queue_link = 0;
  80e093:	c7 40 64 00 00 00 00 	movl   $0x0,0x64(%eax)
  80e09a:	eb bd                	jmp    80e059 <thread_halt+0x69>

0080e09c <thread_entry>:
    strncpy(tc->tc_name, name, name_size - 1);
    tc->tc_name[name_size - 1] = 0;
}

static void
thread_entry(void) {
  80e09c:	55                   	push   %ebp
  80e09d:	89 e5                	mov    %esp,%ebp
  80e09f:	83 ec 18             	sub    $0x18,%esp
    cur_tc->tc_entry(cur_tc->tc_arg);
  80e0a2:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
  80e0a7:	8b 50 2c             	mov    0x2c(%eax),%edx
  80e0aa:	89 14 24             	mov    %edx,(%esp)
  80e0ad:	ff 50 28             	call   *0x28(%eax)
    thread_halt();
  80e0b0:	e8 3b ff ff ff       	call   80dff0 <thread_halt>
}
  80e0b5:	c9                   	leave  
  80e0b6:	c3                   	ret    

0080e0b7 <thread_create>:

int
thread_create(thread_id_t *tid, const char *name, 
		void (*entry)(uint32_t), uint32_t arg) {
  80e0b7:	55                   	push   %ebp
  80e0b8:	89 e5                	mov    %esp,%ebp
  80e0ba:	57                   	push   %edi
  80e0bb:	56                   	push   %esi
  80e0bc:	53                   	push   %ebx
  80e0bd:	83 ec 1c             	sub    $0x1c,%esp
  80e0c0:	8b 7d 08             	mov    0x8(%ebp),%edi
    struct thread_context *tc = malloc(sizeof(struct thread_context));
  80e0c3:	c7 04 24 68 00 00 00 	movl   $0x68,(%esp)
  80e0ca:	e8 74 4c ff ff       	call   802d43 <malloc>
  80e0cf:	89 c3                	mov    %eax,%ebx
    if (!tc)
  80e0d1:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
  80e0d6:	85 db                	test   %ebx,%ebx
  80e0d8:	0f 84 19 01 00 00    	je     80e1f7 <thread_create+0x140>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
  80e0de:	c7 44 24 08 68 00 00 	movl   $0x68,0x8(%esp)
  80e0e5:	00 
  80e0e6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e0ed:	00 
  80e0ee:	89 1c 24             	mov    %ebx,(%esp)
  80e0f1:	e8 c0 31 ff ff       	call   8012b6 <memset>
}

static void
thread_set_name(struct thread_context *tc, const char *name)
{
    strncpy(tc->tc_name, name, name_size - 1);
  80e0f6:	c7 44 24 08 1f 00 00 	movl   $0x1f,0x8(%esp)
  80e0fd:	00 
  80e0fe:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e101:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e105:	8d 43 08             	lea    0x8(%ebx),%eax
  80e108:	89 04 24             	mov    %eax,(%esp)
  80e10b:	e8 6a 30 ff ff       	call   80117a <strncpy>
    tc->tc_name[name_size - 1] = 0;
  80e110:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    return 0;
}

static thread_id_t
alloc_tid(void) {
    int tid = max_tid++;
  80e114:	a1 44 f5 b3 00       	mov    0xb3f544,%eax
  80e119:	8d 50 01             	lea    0x1(%eax),%edx
  80e11c:	89 15 44 f5 b3 00    	mov    %edx,0xb3f544
    if (max_tid == (uint32_t)~0)
  80e122:	83 fa ff             	cmp    $0xffffffff,%edx
  80e125:	75 1c                	jne    80e143 <thread_create+0x8c>
	panic("alloc_tid: no more thread ids");
  80e127:	c7 44 24 08 f6 44 81 	movl   $0x8144f6,0x8(%esp)
  80e12e:	00 
  80e12f:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80e136:	00 
  80e137:	c7 04 24 14 45 81 00 	movl   $0x814514,(%esp)
  80e13e:	e8 91 28 ff ff       	call   8009d4 <_panic>
	return -E_NO_MEM;

    memset(tc, 0, sizeof(struct thread_context));
    
    thread_set_name(tc, name);
    tc->tc_tid = alloc_tid();
  80e143:	89 03                	mov    %eax,(%ebx)

    tc->tc_stack_bottom = malloc(stack_size);
  80e145:	c7 04 24 00 10 00 00 	movl   $0x1000,(%esp)
  80e14c:	e8 f2 4b ff ff       	call   802d43 <malloc>
  80e151:	89 43 04             	mov    %eax,0x4(%ebx)
    if (!tc->tc_stack_bottom) {
  80e154:	85 c0                	test   %eax,%eax
  80e156:	75 12                	jne    80e16a <thread_create+0xb3>
	free(tc);
  80e158:	89 1c 24             	mov    %ebx,(%esp)
  80e15b:	e8 10 4b ff ff       	call   802c70 <free>
  80e160:	b8 fc ff ff ff       	mov    $0xfffffffc,%eax
	return -E_NO_MEM;
  80e165:	e9 8d 00 00 00       	jmp    80e1f7 <thread_create+0x140>
    }

    void *stacktop = tc->tc_stack_bottom + stack_size;
    // Terminate stack unwinding
    stacktop = stacktop - 4;
  80e16a:	8d b0 fc 0f 00 00    	lea    0xffc(%eax),%esi
    memset(stacktop, 0, 4);
  80e170:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80e177:	00 
  80e178:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e17f:	00 
  80e180:	89 34 24             	mov    %esi,(%esp)
  80e183:	e8 2e 31 ff ff       	call   8012b6 <memset>
    
    memset(&tc->tc_jb, 0, sizeof(tc->tc_jb));
  80e188:	c7 44 24 08 18 00 00 	movl   $0x18,0x8(%esp)
  80e18f:	00 
  80e190:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80e197:	00 
  80e198:	8d 43 30             	lea    0x30(%ebx),%eax
  80e19b:	89 04 24             	mov    %eax,(%esp)
  80e19e:	e8 13 31 ff ff       	call   8012b6 <memset>
    tc->tc_jb.jb_esp = (uint32_t)stacktop;
  80e1a3:	89 73 34             	mov    %esi,0x34(%ebx)
    tc->tc_jb.jb_eip = (uint32_t)&thread_entry;
  80e1a6:	c7 43 30 9c e0 80 00 	movl   $0x80e09c,0x30(%ebx)
    tc->tc_entry = entry;
  80e1ad:	8b 45 10             	mov    0x10(%ebp),%eax
  80e1b0:	89 43 28             	mov    %eax,0x28(%ebx)
    tc->tc_arg = arg;
  80e1b3:	8b 45 14             	mov    0x14(%ebp),%eax
  80e1b6:	89 43 2c             	mov    %eax,0x2c(%ebx)
  80e1b9:	c7 43 64 00 00 00 00 	movl   $0x0,0x64(%ebx)
    if (!tq->tq_first) {
  80e1c0:	83 3d 4c f5 b3 00 00 	cmpl   $0x0,0xb3f54c
  80e1c7:	75 0e                	jne    80e1d7 <thread_create+0x120>
	tq->tq_first = tc;
  80e1c9:	89 1d 4c f5 b3 00    	mov    %ebx,0xb3f54c
	tq->tq_last = tc;
  80e1cf:	89 1d 50 f5 b3 00    	mov    %ebx,0xb3f550
  80e1d5:	eb 0e                	jmp    80e1e5 <thread_create+0x12e>
    } else {
	tq->tq_last->tc_queue_link = tc;
  80e1d7:	a1 50 f5 b3 00       	mov    0xb3f550,%eax
  80e1dc:	89 58 64             	mov    %ebx,0x64(%eax)
	tq->tq_last = tc;
  80e1df:	89 1d 50 f5 b3 00    	mov    %ebx,0xb3f550

    threadq_push(&thread_queue, tc);

    if (tid)
  80e1e5:	b8 00 00 00 00       	mov    $0x0,%eax
  80e1ea:	85 ff                	test   %edi,%edi
  80e1ec:	74 09                	je     80e1f7 <thread_create+0x140>
	*tid = tc->tc_tid;
  80e1ee:	8b 03                	mov    (%ebx),%eax
  80e1f0:	89 07                	mov    %eax,(%edi)
  80e1f2:	b8 00 00 00 00       	mov    $0x0,%eax
    return 0;
}
  80e1f7:	83 c4 1c             	add    $0x1c,%esp
  80e1fa:	5b                   	pop    %ebx
  80e1fb:	5e                   	pop    %esi
  80e1fc:	5f                   	pop    %edi
  80e1fd:	5d                   	pop    %ebp
  80e1fe:	c3                   	ret    

0080e1ff <thread_wait>:
	tc = tc->tc_queue_link;
    }
}

void
thread_wait(volatile uint32_t *addr, uint32_t val, uint32_t msec) {
  80e1ff:	55                   	push   %ebp
  80e200:	89 e5                	mov    %esp,%ebp
  80e202:	57                   	push   %edi
  80e203:	56                   	push   %esi
  80e204:	53                   	push   %ebx
  80e205:	83 ec 0c             	sub    $0xc,%esp
  80e208:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e20b:	8b 7d 10             	mov    0x10(%ebp),%edi
    uint32_t s = sys_time_msec();
  80e20e:	e8 99 34 ff ff       	call   8016ac <sys_time_msec>
  80e213:	89 c6                	mov    %eax,%esi
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
  80e215:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
  80e21a:	89 58 48             	mov    %ebx,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80e21d:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)

    while (p < msec) {
  80e221:	39 fe                	cmp    %edi,%esi
  80e223:	72 06                	jb     80e22b <thread_wait+0x2c>
  80e225:	eb 2d                	jmp    80e254 <thread_wait+0x55>
	if (p < s)
  80e227:	39 c6                	cmp    %eax,%esi
  80e229:	77 29                	ja     80e254 <thread_wait+0x55>
	    break;
	if (addr && *addr != val)
  80e22b:	85 db                	test   %ebx,%ebx
  80e22d:	8d 76 00             	lea    0x0(%esi),%esi
  80e230:	74 07                	je     80e239 <thread_wait+0x3a>
  80e232:	8b 03                	mov    (%ebx),%eax
  80e234:	3b 45 0c             	cmp    0xc(%ebp),%eax
  80e237:	75 1b                	jne    80e254 <thread_wait+0x55>
	    break;
	if (cur_tc->tc_wakeup)
  80e239:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
  80e23e:	0f b6 40 4c          	movzbl 0x4c(%eax),%eax
  80e242:	84 c0                	test   %al,%al
  80e244:	75 0e                	jne    80e254 <thread_wait+0x55>
	    break;

	thread_yield();
  80e246:	e8 25 fd ff ff       	call   80df70 <thread_yield>
	p = sys_time_msec();
  80e24b:	e8 5c 34 ff ff       	call   8016ac <sys_time_msec>
    uint32_t p = s;

    cur_tc->tc_wait_addr = addr;
    cur_tc->tc_wakeup = 0;

    while (p < msec) {
  80e250:	39 c7                	cmp    %eax,%edi
  80e252:	77 d3                	ja     80e227 <thread_wait+0x28>

	thread_yield();
	p = sys_time_msec();
    }

    cur_tc->tc_wait_addr = 0;
  80e254:	a1 48 f5 b3 00       	mov    0xb3f548,%eax
  80e259:	c7 40 48 00 00 00 00 	movl   $0x0,0x48(%eax)
    cur_tc->tc_wakeup = 0;
  80e260:	c6 40 4c 00          	movb   $0x0,0x4c(%eax)
}
  80e264:	83 c4 0c             	add    $0xc,%esp
  80e267:	5b                   	pop    %ebx
  80e268:	5e                   	pop    %esi
  80e269:	5f                   	pop    %edi
  80e26a:	5d                   	pop    %ebp
  80e26b:	c3                   	ret    
  80e26c:	00 00                	add    %al,(%eax)
	...

0080e270 <jos_setjmp>:
#define ENTRY(x) \
        .text; _ALIGN_TEXT; .globl x; .type x,@function; x:


ENTRY(jos_setjmp)
	movl	4(%esp), %ecx	// jos_jmp_buf
  80e270:	8b 4c 24 04          	mov    0x4(%esp),%ecx

	movl	0(%esp), %edx	// %eip as pushed by call
  80e274:	8b 14 24             	mov    (%esp),%edx
	movl	%edx,  0(%ecx)
  80e277:	89 11                	mov    %edx,(%ecx)

	leal	4(%esp), %edx	// where %esp will point when we return
  80e279:	8d 54 24 04          	lea    0x4(%esp),%edx
	movl	%edx,  4(%ecx)
  80e27d:	89 51 04             	mov    %edx,0x4(%ecx)

	movl	%ebp,  8(%ecx)
  80e280:	89 69 08             	mov    %ebp,0x8(%ecx)
	movl	%ebx, 12(%ecx)
  80e283:	89 59 0c             	mov    %ebx,0xc(%ecx)
	movl	%esi, 16(%ecx)
  80e286:	89 71 10             	mov    %esi,0x10(%ecx)
	movl	%edi, 20(%ecx)
  80e289:	89 79 14             	mov    %edi,0x14(%ecx)

	movl	$0, %eax
  80e28c:	b8 00 00 00 00       	mov    $0x0,%eax
	ret
  80e291:	c3                   	ret    
  80e292:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80e299:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi

0080e2a0 <jos_longjmp>:

ENTRY(jos_longjmp)
	// %eax is the jos_jmp_buf*
	// %edx is the return value

	movl	 0(%eax), %ecx	// %eip
  80e2a0:	8b 08                	mov    (%eax),%ecx
	movl	 4(%eax), %esp
  80e2a2:	8b 60 04             	mov    0x4(%eax),%esp
	movl	 8(%eax), %ebp
  80e2a5:	8b 68 08             	mov    0x8(%eax),%ebp
	movl	12(%eax), %ebx
  80e2a8:	8b 58 0c             	mov    0xc(%eax),%ebx
	movl	16(%eax), %esi
  80e2ab:	8b 70 10             	mov    0x10(%eax),%esi
	movl	20(%eax), %edi
  80e2ae:	8b 78 14             	mov    0x14(%eax),%edi

	movl	%edx, %eax
  80e2b1:	89 d0                	mov    %edx,%eax
	jmp	*%ecx
  80e2b3:	ff e1                	jmp    *%ecx
  80e2b5:	00 00                	add    %al,(%eax)
	...

0080e2b8 <e2s>:
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
}

const char *
e2s(int err) {
  80e2b8:	55                   	push   %ebp
  80e2b9:	89 e5                	mov    %esp,%ebp
  80e2bb:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2be:	8b 04 85 a0 90 81 00 	mov    0x8190a0(,%eax,4),%eax
	return sys_errlist[err];
}
  80e2c5:	5d                   	pop    %ebp
  80e2c6:	c3                   	ret    

0080e2c7 <perror>:
  [ENSRQUERYDOMAINTOOLONG] = "ENSRQUERYDOMAINTOOLONG",  /* Domain name is too long */
  [ENSRCNAMELOOP] = "ENSRCNAMELOOP" /* Domain name is too long */
};

void
perror(const char *s) {
  80e2c7:	55                   	push   %ebp
  80e2c8:	89 e5                	mov    %esp,%ebp
  80e2ca:	83 ec 18             	sub    $0x18,%esp
	int err = errno;
	cprintf("%s: %s\n", s, e2s(err));
  80e2cd:	a1 a0 f5 b3 00       	mov    0xb3f5a0,%eax
  80e2d2:	89 04 24             	mov    %eax,(%esp)
  80e2d5:	e8 de ff ff ff       	call   80e2b8 <e2s>
  80e2da:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e2de:	8b 45 08             	mov    0x8(%ebp),%eax
  80e2e1:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e2e5:	c7 04 24 2f 45 81 00 	movl   $0x81452f,(%esp)
  80e2ec:	e8 a8 27 ff ff       	call   800a99 <cprintf>
}
  80e2f1:	c9                   	leave  
  80e2f2:	c3                   	ret    
	...

0080e300 <jif_init>:
 *
 */

err_t
jif_init(struct netif *netif)
{
  80e300:	55                   	push   %ebp
  80e301:	89 e5                	mov    %esp,%ebp
  80e303:	83 ec 38             	sub    $0x38,%esp
  80e306:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80e309:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80e30c:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80e30f:	8b 5d 08             	mov    0x8(%ebp),%ebx
    struct jif *jif;
    envid_t *output_envid; 

    jif = mem_malloc(sizeof(struct jif));
  80e312:	c7 04 24 08 00 00 00 	movl   $0x8,(%esp)
  80e319:	e8 a2 8e ff ff       	call   8071c0 <mem_malloc>
  80e31e:	89 c6                	mov    %eax,%esi

    if (jif == NULL) {
  80e320:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80e325:	85 f6                	test   %esi,%esi
  80e327:	0f 84 8a 00 00 00    	je     80e3b7 <jif_init+0xb7>
	LWIP_DEBUGF(NETIF_DEBUG, ("jif_init: out of memory\n"));
	return ERR_MEM;
    }

    output_envid = (envid_t *)netif->state;
  80e32d:	8b 7b 1c             	mov    0x1c(%ebx),%edi

    netif->state = jif;
  80e330:	89 73 1c             	mov    %esi,0x1c(%ebx)
    netif->output = jif_output;
  80e333:	c7 43 14 d9 e4 80 00 	movl   $0x80e4d9,0x14(%ebx)
    netif->linkoutput = low_level_output;
  80e33a:	c7 43 18 c4 e3 80 00 	movl   $0x80e3c4,0x18(%ebx)
    memcpy(&netif->name[0], "en", 2);
  80e341:	c7 44 24 08 02 00 00 	movl   $0x2,0x8(%esp)
  80e348:	00 
  80e349:	c7 44 24 04 43 2e 81 	movl   $0x812e43,0x4(%esp)
  80e350:	00 
  80e351:	8d 43 2f             	lea    0x2f(%ebx),%eax
  80e354:	89 04 24             	mov    %eax,(%esp)
  80e357:	e8 35 30 ff ff       	call   801391 <memcpy>

    jif->ethaddr = (struct eth_addr *)&(netif->hwaddr[0]);
  80e35c:	8d 43 25             	lea    0x25(%ebx),%eax
  80e35f:	89 06                	mov    %eax,(%esi)
    jif->envid = *output_envid; 
  80e361:	8b 07                	mov    (%edi),%eax
  80e363:	89 46 04             	mov    %eax,0x4(%esi)
static void
low_level_init(struct netif *netif)
{
    int r;

    netif->hwaddr_len = 6;
  80e366:	c6 43 24 06          	movb   $0x6,0x24(%ebx)
    netif->mtu = 1500;
  80e36a:	66 c7 43 2c dc 05    	movw   $0x5dc,0x2c(%ebx)
    netif->flags = NETIF_FLAG_BROADCAST;
  80e370:	c6 43 2e 02          	movb   $0x2,0x2e(%ebx)

    // MAC address is hardcoded to eliminate a system call
    netif->hwaddr[0] = 0x52;
  80e374:	c6 43 25 52          	movb   $0x52,0x25(%ebx)
    netif->hwaddr[1] = 0x54;
  80e378:	c6 43 26 54          	movb   $0x54,0x26(%ebx)
    netif->hwaddr[2] = 0x00;
  80e37c:	c6 43 27 00          	movb   $0x0,0x27(%ebx)
    netif->hwaddr[3] = 0x12;
  80e380:	c6 43 28 12          	movb   $0x12,0x28(%ebx)
    netif->hwaddr[4] = 0x34;
  80e384:	c6 43 29 34          	movb   $0x34,0x29(%ebx)
    netif->hwaddr[5] = 0x56;
  80e388:	c6 43 2a 56          	movb   $0x56,0x2a(%ebx)
    etharp_init();

    // qemu user-net is dumb; if the host OS does not send and ARP request
    // first, the qemu will send packets destined for the host using the mac
    // addr 00:00:00:00:00; do a arp request for the user-net NAT at 10.0.2.2
    uint32_t ipaddr = inet_addr("10.0.2.2");
  80e38c:	c7 04 24 49 25 81 00 	movl   $0x812549,(%esp)
  80e393:	e8 e0 cb ff ff       	call   80af78 <inet_addr>
  80e398:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    etharp_query(netif, (struct ip_addr *) &ipaddr, 0);
  80e39b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e3a2:	00 
  80e3a3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e3a6:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e3aa:	89 1c 24             	mov    %ebx,(%esp)
  80e3ad:	e8 65 e9 ff ff       	call   80cd17 <etharp_query>
  80e3b2:	b8 00 00 00 00       	mov    $0x0,%eax

    return ERR_OK;
}
  80e3b7:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80e3ba:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80e3bd:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80e3c0:	89 ec                	mov    %ebp,%esp
  80e3c2:	5d                   	pop    %ebp
  80e3c3:	c3                   	ret    

0080e3c4 <low_level_output>:
 * might be chained.
 *
 */
static err_t
low_level_output(struct netif *netif, struct pbuf *p)
{
  80e3c4:	55                   	push   %ebp
  80e3c5:	89 e5                	mov    %esp,%ebp
  80e3c7:	57                   	push   %edi
  80e3c8:	56                   	push   %esi
  80e3c9:	53                   	push   %ebx
  80e3ca:	83 ec 2c             	sub    $0x2c,%esp
  80e3cd:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    int r = sys_page_alloc(0, (void *)PKTMAP, PTE_U|PTE_W|PTE_P);
  80e3d0:	c7 44 24 08 07 00 00 	movl   $0x7,0x8(%esp)
  80e3d7:	00 
  80e3d8:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e3df:	10 
  80e3e0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e3e7:	e8 5f 35 ff ff       	call   80194b <sys_page_alloc>
    if (r < 0)
  80e3ec:	85 c0                	test   %eax,%eax
  80e3ee:	79 1c                	jns    80e40c <low_level_output+0x48>
	panic("jif: could not allocate page of memory");
  80e3f0:	c7 44 24 08 28 4a 81 	movl   $0x814a28,0x8(%esp)
  80e3f7:	00 
  80e3f8:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80e3ff:	00 
  80e400:	c7 04 24 11 4a 81 00 	movl   $0x814a11,(%esp)
  80e407:	e8 c8 25 ff ff       	call   8009d4 <_panic>
    struct jif_pkt *pkt = (struct jif_pkt *)PKTMAP;

    struct jif *jif;
    jif = netif->state;
  80e40c:	8b 45 08             	mov    0x8(%ebp),%eax
  80e40f:	8b 78 1c             	mov    0x1c(%eax),%edi

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e412:	be 00 00 00 00       	mov    $0x0,%esi
  80e417:	85 db                	test   %ebx,%ebx
  80e419:	74 74                	je     80e48f <low_level_output+0xcb>
	/* Send the data from the pbuf to the interface, one pbuf at a
	   time. The size of the data in each pbuf is kept in the ->len
	   variable. */

	if (txsize + q->len > 2000)
  80e41b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e41f:	0f b7 d0             	movzwl %ax,%edx
  80e422:	81 fa d0 07 00 00    	cmp    $0x7d0,%edx
  80e428:	7e 38                	jle    80e462 <low_level_output+0x9e>
  80e42a:	eb 12                	jmp    80e43e <low_level_output+0x7a>
  80e42c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e430:	0f b7 d0             	movzwl %ax,%edx
  80e433:	8d 0c 16             	lea    (%esi,%edx,1),%ecx
  80e436:	81 f9 d0 07 00 00    	cmp    $0x7d0,%ecx
  80e43c:	7e 29                	jle    80e467 <low_level_output+0xa3>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
  80e43e:	89 74 24 10          	mov    %esi,0x10(%esp)
  80e442:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80e446:	c7 44 24 08 50 4a 81 	movl   $0x814a50,0x8(%esp)
  80e44d:	00 
  80e44e:	c7 44 24 04 64 00 00 	movl   $0x64,0x4(%esp)
  80e455:	00 
  80e456:	c7 04 24 11 4a 81 00 	movl   $0x814a11,(%esp)
  80e45d:	e8 72 25 ff ff       	call   8009d4 <_panic>
  80e462:	be 00 00 00 00       	mov    $0x0,%esi
	memcpy(&txbuf[txsize], q->payload, q->len);
  80e467:	8d 96 04 00 00 10    	lea    0x10000004(%esi),%edx
  80e46d:	0f b7 c0             	movzwl %ax,%eax
  80e470:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e474:	8b 43 04             	mov    0x4(%ebx),%eax
  80e477:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e47b:	89 14 24             	mov    %edx,(%esp)
  80e47e:	e8 0e 2f ff ff       	call   801391 <memcpy>
	txsize += q->len;
  80e483:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e487:	01 c6                	add    %eax,%esi
    jif = netif->state;

    char *txbuf = pkt->jp_data;
    int txsize = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e489:	8b 1b                	mov    (%ebx),%ebx
  80e48b:	85 db                	test   %ebx,%ebx
  80e48d:	75 9d                	jne    80e42c <low_level_output+0x68>
	    panic("oversized packet, fragment %d txsize %d\n", q->len, txsize);
	memcpy(&txbuf[txsize], q->payload, q->len);
	txsize += q->len;
    }

    pkt->jp_len = txsize;
  80e48f:	89 35 00 00 00 10    	mov    %esi,0x10000000

    ipc_send(jif->envid, NSREQ_OUTPUT, (void *)pkt, PTE_P|PTE_W|PTE_U);
  80e495:	c7 44 24 0c 07 00 00 	movl   $0x7,0xc(%esp)
  80e49c:	00 
  80e49d:	c7 44 24 08 00 00 00 	movl   $0x10000000,0x8(%esp)
  80e4a4:	10 
  80e4a5:	c7 44 24 04 0b 00 00 	movl   $0xb,0x4(%esp)
  80e4ac:	00 
  80e4ad:	8b 47 04             	mov    0x4(%edi),%eax
  80e4b0:	89 04 24             	mov    %eax,(%esp)
  80e4b3:	e8 78 39 ff ff       	call   801e30 <ipc_send>
    sys_page_unmap(0, (void *)pkt);
  80e4b8:	c7 44 24 04 00 00 00 	movl   $0x10000000,0x4(%esp)
  80e4bf:	10 
  80e4c0:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80e4c7:	e8 c3 33 ff ff       	call   80188f <sys_page_unmap>

    return ERR_OK;
}
  80e4cc:	b8 00 00 00 00       	mov    $0x0,%eax
  80e4d1:	83 c4 2c             	add    $0x2c,%esp
  80e4d4:	5b                   	pop    %ebx
  80e4d5:	5e                   	pop    %esi
  80e4d6:	5f                   	pop    %edi
  80e4d7:	5d                   	pop    %ebp
  80e4d8:	c3                   	ret    

0080e4d9 <jif_output>:
 */

static err_t
jif_output(struct netif *netif, struct pbuf *p,
      struct ip_addr *ipaddr)
{
  80e4d9:	55                   	push   %ebp
  80e4da:	89 e5                	mov    %esp,%ebp
  80e4dc:	83 ec 18             	sub    $0x18,%esp
    /* resolve hardware address, then send (or queue) packet */
    return etharp_output(netif, p, ipaddr);
  80e4df:	8b 45 10             	mov    0x10(%ebp),%eax
  80e4e2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e4e6:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e4e9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e4ed:	8b 45 08             	mov    0x8(%ebp),%eax
  80e4f0:	89 04 24             	mov    %eax,(%esp)
  80e4f3:	e8 37 ea ff ff       	call   80cf2f <etharp_output>
}
  80e4f8:	c9                   	leave  
  80e4f9:	c3                   	ret    

0080e4fa <jif_input>:
 *
 */

void
jif_input(struct netif *netif, void *va)
{
  80e4fa:	55                   	push   %ebp
  80e4fb:	89 e5                	mov    %esp,%ebp
  80e4fd:	57                   	push   %edi
  80e4fe:	56                   	push   %esi
  80e4ff:	53                   	push   %ebx
  80e500:	83 ec 2c             	sub    $0x2c,%esp
    struct jif *jif;
    struct eth_hdr *ethhdr;
    struct pbuf *p;

    jif = netif->state;
  80e503:	8b 45 08             	mov    0x8(%ebp),%eax
  80e506:	8b 40 1c             	mov    0x1c(%eax),%eax
  80e509:	89 45 d8             	mov    %eax,-0x28(%ebp)
 *
 */
static struct pbuf *
low_level_input(void *va)
{
    struct jif_pkt *pkt = (struct jif_pkt *)va;
  80e50c:	8b 5d 0c             	mov    0xc(%ebp),%ebx
    s16_t len = pkt->jp_len;
  80e50f:	0f b7 33             	movzwl (%ebx),%esi

    struct pbuf *p = pbuf_alloc(PBUF_RAW, len, PBUF_POOL);
  80e512:	c7 44 24 08 03 00 00 	movl   $0x3,0x8(%esp)
  80e519:	00 
  80e51a:	0f b7 c6             	movzwl %si,%eax
  80e51d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e521:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80e528:	e8 e6 9c ff ff       	call   808213 <pbuf_alloc>
  80e52d:	89 45 dc             	mov    %eax,-0x24(%ebp)
    if (p == 0)
  80e530:	85 c0                	test   %eax,%eax
  80e532:	0f 84 ca 00 00 00    	je     80e602 <jif_input+0x108>
	return 0;

    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
  80e538:	83 c3 04             	add    $0x4,%ebx
  80e53b:	89 5d e4             	mov    %ebx,-0x1c(%ebp)
  80e53e:	89 c3                	mov    %eax,%ebx
  80e540:	bf 00 00 00 00       	mov    $0x0,%edi
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
	/* Read enough bytes to fill this pbuf in the chain. The
	 * available data in the pbuf is given by the q->len
	 * variable. */
	int bytes = q->len;
  80e545:	0f bf f6             	movswl %si,%esi
  80e548:	89 75 e0             	mov    %esi,-0x20(%ebp)
  80e54b:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  80e54f:	8b 75 e0             	mov    -0x20(%ebp),%esi
  80e552:	29 fe                	sub    %edi,%esi
  80e554:	39 c6                	cmp    %eax,%esi
  80e556:	7e 02                	jle    80e55a <jif_input+0x60>
  80e558:	89 c6                	mov    %eax,%esi
	if (bytes > (len - copied))
	    bytes = len - copied;
	memcpy(q->payload, rxbuf + copied, bytes);
  80e55a:	89 74 24 08          	mov    %esi,0x8(%esp)
  80e55e:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  80e561:	01 f8                	add    %edi,%eax
  80e563:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e567:	8b 43 04             	mov    0x4(%ebx),%eax
  80e56a:	89 04 24             	mov    %eax,(%esp)
  80e56d:	e8 1f 2e ff ff       	call   801391 <memcpy>
	copied += bytes;
  80e572:	01 f7                	add    %esi,%edi
    /* We iterate over the pbuf chain until we have read the entire
     * packet into the pbuf. */
    void *rxbuf = (void *) pkt->jp_data;
    int copied = 0;
    struct pbuf *q;
    for (q = p; q != NULL; q = q->next) {
  80e574:	8b 1b                	mov    (%ebx),%ebx
  80e576:	85 db                	test   %ebx,%ebx
  80e578:	75 d1                	jne    80e54b <jif_input+0x51>
  80e57a:	eb 61                	jmp    80e5dd <jif_input+0xe3>
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
    case ETHTYPE_IP:
	/* update ARP table */
	etharp_ip_input(netif, p);
  80e57c:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e57f:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e583:	8b 45 08             	mov    0x8(%ebp),%eax
  80e586:	89 04 24             	mov    %eax,(%esp)
  80e589:	e8 cb ec ff ff       	call   80d259 <etharp_ip_input>
	/* skip Ethernet header */
	pbuf_header(p, -(int)sizeof(struct eth_hdr));
  80e58e:	c7 44 24 04 f2 ff ff 	movl   $0xfffffff2,0x4(%esp)
  80e595:	ff 
  80e596:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e599:	89 14 24             	mov    %edx,(%esp)
  80e59c:	e8 42 96 ff ff       	call   807be3 <pbuf_header>
	/* pass to network layer */
	netif->input(p, netif);
  80e5a1:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5a4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e5a8:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e5ab:	89 14 24             	mov    %edx,(%esp)
  80e5ae:	ff 50 10             	call   *0x10(%eax)
	break;
  80e5b1:	eb 4f                	jmp    80e602 <jif_input+0x108>
      
    case ETHTYPE_ARP:
	/* pass p to ARP module  */
	etharp_arp_input(netif, jif->ethaddr, p);
  80e5b3:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80e5b6:	89 44 24 08          	mov    %eax,0x8(%esp)
  80e5ba:	8b 55 d8             	mov    -0x28(%ebp),%edx
  80e5bd:	8b 02                	mov    (%edx),%eax
  80e5bf:	89 44 24 04          	mov    %eax,0x4(%esp)
  80e5c3:	8b 45 08             	mov    0x8(%ebp),%eax
  80e5c6:	89 04 24             	mov    %eax,(%esp)
  80e5c9:	e8 d9 ec ff ff       	call   80d2a7 <etharp_arp_input>
	break;
  80e5ce:	eb 32                	jmp    80e602 <jif_input+0x108>

    default:
	pbuf_free(p);
  80e5d0:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e5d3:	89 14 24             	mov    %edx,(%esp)
  80e5d6:	e8 7d 99 ff ff       	call   807f58 <pbuf_free>
  80e5db:	eb 25                	jmp    80e602 <jif_input+0x108>
    /* no packet could be read, silently ignore this */
    if (p == NULL) return;
    /* points to packet payload, which starts with an Ethernet header */
    ethhdr = p->payload;

    switch (htons(ethhdr->type)) {
  80e5dd:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80e5e0:	8b 42 04             	mov    0x4(%edx),%eax
  80e5e3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80e5e7:	89 04 24             	mov    %eax,(%esp)
  80e5ea:	e8 65 c7 ff ff       	call   80ad54 <htons>
  80e5ef:	66 3d 00 08          	cmp    $0x800,%ax
  80e5f3:	74 87                	je     80e57c <jif_input+0x82>
  80e5f5:	66 3d 06 08          	cmp    $0x806,%ax
  80e5f9:	75 d5                	jne    80e5d0 <jif_input+0xd6>
  80e5fb:	90                   	nop
  80e5fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80e600:	eb b1                	jmp    80e5b3 <jif_input+0xb9>
	break;

    default:
	pbuf_free(p);
    }
}
  80e602:	83 c4 2c             	add    $0x2c,%esp
  80e605:	5b                   	pop    %ebx
  80e606:	5e                   	pop    %esi
  80e607:	5f                   	pop    %edi
  80e608:	5d                   	pop    %ebp
  80e609:	c3                   	ret    
  80e60a:	00 00                	add    %al,(%eax)
  80e60c:	00 00                	add    %al,(%eax)
	...

0080e610 <netconn_type>:
 * @param conn the netconn of which to get the type
 * @return the netconn_type of conn
 */
enum netconn_type
netconn_type(struct netconn *conn)
{
  80e610:	55                   	push   %ebp
  80e611:	89 e5                	mov    %esp,%ebp
  80e613:	83 ec 18             	sub    $0x18,%esp
  80e616:	8b 45 08             	mov    0x8(%ebp),%eax
  LWIP_ERROR("netconn_type: invalid conn", (conn != NULL), return NETCONN_INVALID;);
  80e619:	85 c0                	test   %eax,%eax
  80e61b:	75 1c                	jne    80e639 <netconn_type+0x29>
  80e61d:	c7 44 24 08 79 4a 81 	movl   $0x814a79,0x8(%esp)
  80e624:	00 
  80e625:	c7 44 24 04 84 00 00 	movl   $0x84,0x4(%esp)
  80e62c:	00 
  80e62d:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e634:	e8 9b 23 ff ff       	call   8009d4 <_panic>
  80e639:	8b 00                	mov    (%eax),%eax
  return conn->type;
}
  80e63b:	c9                   	leave  
  80e63c:	c3                   	ret    

0080e63d <netconn_close>:
 * @param conn the TCP netconn to close
 * @return ERR_OK if the netconn was closed, any other err_t on error
 */
err_t
netconn_close(struct netconn *conn)
{
  80e63d:	55                   	push   %ebp
  80e63e:	89 e5                	mov    %esp,%ebp
  80e640:	53                   	push   %ebx
  80e641:	83 ec 34             	sub    $0x34,%esp
  80e644:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_close: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e647:	85 db                	test   %ebx,%ebx
  80e649:	75 1c                	jne    80e667 <netconn_close+0x2a>
  80e64b:	c7 44 24 08 ab 4a 81 	movl   $0x814aab,0x8(%esp)
  80e652:	00 
  80e653:	c7 44 24 04 ed 01 00 	movl   $0x1ed,0x4(%esp)
  80e65a:	00 
  80e65b:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e662:	e8 6d 23 ff ff       	call   8009d4 <_panic>

  msg.function = do_close;
  80e667:	c7 45 e4 4f f0 80 00 	movl   $0x80f04f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e66e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80e671:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e674:	89 04 24             	mov    %eax,(%esp)
  80e677:	e8 eb 6b ff ff       	call   805267 <tcpip_apimsg>
  80e67c:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e680:	83 c4 34             	add    $0x34,%esp
  80e683:	5b                   	pop    %ebx
  80e684:	5d                   	pop    %ebp
  80e685:	c3                   	ret    

0080e686 <netconn_write>:
 * - NETCONN_MORE (0x02) for TCP connection, PSH flag will be set on last segment sent
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_write(struct netconn *conn, const void *dataptr, int size, u8_t apiflags)
{
  80e686:	55                   	push   %ebp
  80e687:	89 e5                	mov    %esp,%ebp
  80e689:	53                   	push   %ebx
  80e68a:	83 ec 34             	sub    $0x34,%esp
  80e68d:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e690:	0f b6 45 14          	movzbl 0x14(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_write: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e694:	85 db                	test   %ebx,%ebx
  80e696:	75 1c                	jne    80e6b4 <netconn_write+0x2e>
  80e698:	c7 44 24 08 c7 4a 81 	movl   $0x814ac7,0x8(%esp)
  80e69f:	00 
  80e6a0:	c7 44 24 04 d3 01 00 	movl   $0x1d3,0x4(%esp)
  80e6a7:	00 
  80e6a8:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e6af:	e8 20 23 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netconn_write: invalid conn->type",  (conn->type == NETCONN_TCP), return ERR_VAL;);
  80e6b4:	83 3b 10             	cmpl   $0x10,(%ebx)
  80e6b7:	74 1c                	je     80e6d5 <netconn_write+0x4f>
  80e6b9:	c7 44 24 08 14 4c 81 	movl   $0x814c14,0x8(%esp)
  80e6c0:	00 
  80e6c1:	c7 44 24 04 d4 01 00 	movl   $0x1d4,0x4(%esp)
  80e6c8:	00 
  80e6c9:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e6d0:	e8 ff 22 ff ff       	call   8009d4 <_panic>

  msg.function = do_write;
  80e6d5:	c7 45 e4 de f3 80 00 	movl   $0x80f3de,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e6dc:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.w.dataptr = dataptr;
  80e6df:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e6e2:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.w.apiflags = apiflags;
  80e6e5:	88 45 f4             	mov    %al,-0xc(%ebp)
  msg.msg.msg.w.len = size;
  80e6e8:	8b 45 10             	mov    0x10(%ebp),%eax
  80e6eb:	89 45 f0             	mov    %eax,-0x10(%ebp)
  /* For locking the core: this _can_ be delayed on low memory/low send buffer,
     but if it is, this is done inside api_msg.c:do_write(), so we can use the
     non-blocking version here. */
  TCPIP_APIMSG(&msg);
  80e6ee:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e6f1:	89 04 24             	mov    %eax,(%esp)
  80e6f4:	e8 6e 6b ff ff       	call   805267 <tcpip_apimsg>
  80e6f9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e6fd:	83 c4 34             	add    $0x34,%esp
  80e700:	5b                   	pop    %ebx
  80e701:	5d                   	pop    %ebp
  80e702:	c3                   	ret    

0080e703 <netconn_send>:
 * @param buf a netbuf containing the data to send
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_send(struct netconn *conn, struct netbuf *buf)
{
  80e703:	55                   	push   %ebp
  80e704:	89 e5                	mov    %esp,%ebp
  80e706:	53                   	push   %ebx
  80e707:	83 ec 34             	sub    $0x34,%esp
  80e70a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_send: invalid conn",  (conn != NULL), return ERR_ARG;);
  80e70d:	85 db                	test   %ebx,%ebx
  80e70f:	75 1c                	jne    80e72d <netconn_send+0x2a>
  80e711:	c7 44 24 08 e3 4a 81 	movl   $0x814ae3,0x8(%esp)
  80e718:	00 
  80e719:	c7 44 24 04 b9 01 00 	movl   $0x1b9,0x4(%esp)
  80e720:	00 
  80e721:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e728:	e8 a7 22 ff ff       	call   8009d4 <_panic>

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_send: sending %d bytes\n", buf->p->tot_len));
  msg.function = do_send;
  80e72d:	c7 45 e4 6c f4 80 00 	movl   $0x80f46c,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e734:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.b = buf;
  80e737:	8b 45 0c             	mov    0xc(%ebp),%eax
  80e73a:	89 45 ec             	mov    %eax,-0x14(%ebp)
  TCPIP_APIMSG(&msg);
  80e73d:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e740:	89 04 24             	mov    %eax,(%esp)
  80e743:	e8 1f 6b ff ff       	call   805267 <tcpip_apimsg>
  80e748:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e74c:	83 c4 34             	add    $0x34,%esp
  80e74f:	5b                   	pop    %ebx
  80e750:	5d                   	pop    %ebp
  80e751:	c3                   	ret    

0080e752 <netconn_sendto>:
 * @param port the remote port to which to send the data
 * @return ERR_OK if data was sent, any other err_t on error
 */
err_t
netconn_sendto(struct netconn *conn, struct netbuf *buf, struct ip_addr *addr, u16_t port)
{
  80e752:	55                   	push   %ebp
  80e753:	89 e5                	mov    %esp,%ebp
  80e755:	83 ec 18             	sub    $0x18,%esp
  80e758:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e75b:	0f b7 4d 14          	movzwl 0x14(%ebp),%ecx
  if (buf != NULL) {
  80e75f:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80e764:	85 d2                	test   %edx,%edx
  80e766:	74 19                	je     80e781 <netconn_sendto+0x2f>
    buf->addr = addr;
  80e768:	8b 45 10             	mov    0x10(%ebp),%eax
  80e76b:	89 42 08             	mov    %eax,0x8(%edx)
    buf->port = port;
  80e76e:	66 89 4a 0c          	mov    %cx,0xc(%edx)
    return netconn_send(conn, buf);
  80e772:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e776:	8b 45 08             	mov    0x8(%ebp),%eax
  80e779:	89 04 24             	mov    %eax,(%esp)
  80e77c:	e8 82 ff ff ff       	call   80e703 <netconn_send>
  }
  return ERR_VAL;
}
  80e781:	c9                   	leave  
  80e782:	c3                   	ret    

0080e783 <netconn_listen_with_backlog>:
 * @return ERR_OK if the netconn was set to listen (UDP and RAW netconns
 *         don't return any error (yet?))
 */
err_t
netconn_listen_with_backlog(struct netconn *conn, u8_t backlog)
{
  80e783:	55                   	push   %ebp
  80e784:	89 e5                	mov    %esp,%ebp
  80e786:	53                   	push   %ebx
  80e787:	83 ec 34             	sub    $0x34,%esp
  80e78a:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* This does no harm. If TCP_LISTEN_BACKLOG is off, backlog is unused. */
  LWIP_UNUSED_ARG(backlog);

  LWIP_ERROR("netconn_listen: invalid conn", (conn != NULL), return ERR_ARG;);
  80e78d:	85 db                	test   %ebx,%ebx
  80e78f:	75 1c                	jne    80e7ad <netconn_listen_with_backlog+0x2a>
  80e791:	c7 44 24 08 fe 4a 81 	movl   $0x814afe,0x8(%esp)
  80e798:	00 
  80e799:	c7 44 24 04 fa 00 00 	movl   $0xfa,0x4(%esp)
  80e7a0:	00 
  80e7a1:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e7a8:	e8 27 22 ff ff       	call   8009d4 <_panic>

  msg.function = do_listen;
  80e7ad:	c7 45 e4 2f f5 80 00 	movl   $0x80f52f,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e7b4:	89 5d e8             	mov    %ebx,-0x18(%ebp)
#if TCP_LISTEN_BACKLOG
  msg.msg.msg.lb.backlog = backlog;
#endif /* TCP_LISTEN_BACKLOG */
  TCPIP_APIMSG(&msg);
  80e7b7:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e7ba:	89 04 24             	mov    %eax,(%esp)
  80e7bd:	e8 a5 6a ff ff       	call   805267 <tcpip_apimsg>
  80e7c2:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e7c6:	83 c4 34             	add    $0x34,%esp
  80e7c9:	5b                   	pop    %ebx
  80e7ca:	5d                   	pop    %ebp
  80e7cb:	c3                   	ret    

0080e7cc <netconn_disconnect>:
 * @param conn the netconn to disconnect
 * @return TODO: return value is not set here...
 */
err_t
netconn_disconnect(struct netconn *conn)
{
  80e7cc:	55                   	push   %ebp
  80e7cd:	89 e5                	mov    %esp,%ebp
  80e7cf:	53                   	push   %ebx
  80e7d0:	83 ec 34             	sub    $0x34,%esp
  80e7d3:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  LWIP_ERROR("netconn_disconnect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e7d6:	85 db                	test   %ebx,%ebx
  80e7d8:	75 1c                	jne    80e7f6 <netconn_disconnect+0x2a>
  80e7da:	c7 44 24 08 38 4c 81 	movl   $0x814c38,0x8(%esp)
  80e7e1:	00 
  80e7e2:	c7 44 24 04 e2 00 00 	movl   $0xe2,0x4(%esp)
  80e7e9:	00 
  80e7ea:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e7f1:	e8 de 21 ff ff       	call   8009d4 <_panic>

  msg.function = do_disconnect;
  80e7f6:	c7 45 e4 f9 f6 80 00 	movl   $0x80f6f9,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e7fd:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  TCPIP_APIMSG(&msg);
  80e800:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e803:	89 04 24             	mov    %eax,(%esp)
  80e806:	e8 5c 6a ff ff       	call   805267 <tcpip_apimsg>
  80e80b:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e80f:	83 c4 34             	add    $0x34,%esp
  80e812:	5b                   	pop    %ebx
  80e813:	5d                   	pop    %ebp
  80e814:	c3                   	ret    

0080e815 <netconn_connect>:
 * @param port the remote port to connect to (no used for RAW)
 * @return ERR_OK if connected, return value of tcp_/udp_/raw_connect otherwise
 */
err_t
netconn_connect(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e815:	55                   	push   %ebp
  80e816:	89 e5                	mov    %esp,%ebp
  80e818:	53                   	push   %ebx
  80e819:	83 ec 34             	sub    $0x34,%esp
  80e81c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e81f:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_connect: invalid conn", (conn != NULL), return ERR_ARG;);
  80e823:	85 db                	test   %ebx,%ebx
  80e825:	75 1c                	jne    80e843 <netconn_connect+0x2e>
  80e827:	c7 44 24 08 1b 4b 81 	movl   $0x814b1b,0x8(%esp)
  80e82e:	00 
  80e82f:	c7 44 24 04 cc 00 00 	movl   $0xcc,0x4(%esp)
  80e836:	00 
  80e837:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e83e:	e8 91 21 ff ff       	call   8009d4 <_panic>

  msg.function = do_connect;
  80e843:	c7 45 e4 30 f7 80 00 	movl   $0x80f730,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e84a:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e84d:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e850:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e853:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  /* This is the only function which need to not block tcpip_thread */
  tcpip_apimsg(&msg);
  80e857:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e85a:	89 04 24             	mov    %eax,(%esp)
  80e85d:	e8 05 6a ff ff       	call   805267 <tcpip_apimsg>
  80e862:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e866:	83 c4 34             	add    $0x34,%esp
  80e869:	5b                   	pop    %ebx
  80e86a:	5d                   	pop    %ebp
  80e86b:	c3                   	ret    

0080e86c <netconn_bind>:
 * @param port the local port to bind the netconn to (not used for RAW)
 * @return ERR_OK if bound, any other err_t on failure
 */
err_t
netconn_bind(struct netconn *conn, struct ip_addr *addr, u16_t port)
{
  80e86c:	55                   	push   %ebp
  80e86d:	89 e5                	mov    %esp,%ebp
  80e86f:	53                   	push   %ebx
  80e870:	83 ec 34             	sub    $0x34,%esp
  80e873:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e876:	0f b7 45 10          	movzwl 0x10(%ebp),%eax
  struct api_msg msg;

  LWIP_ERROR("netconn_bind: invalid conn", (conn != NULL), return ERR_ARG;);
  80e87a:	85 db                	test   %ebx,%ebx
  80e87c:	75 1c                	jne    80e89a <netconn_bind+0x2e>
  80e87e:	c7 44 24 08 39 4b 81 	movl   $0x814b39,0x8(%esp)
  80e885:	00 
  80e886:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  80e88d:	00 
  80e88e:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e895:	e8 3a 21 ff ff       	call   8009d4 <_panic>

  msg.function = do_bind;
  80e89a:	c7 45 e4 f8 f7 80 00 	movl   $0x80f7f8,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e8a1:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.bc.ipaddr = addr;
  80e8a4:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e8a7:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.bc.port = port;
  80e8aa:	66 89 45 f0          	mov    %ax,-0x10(%ebp)
  TCPIP_APIMSG(&msg);
  80e8ae:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e8b1:	89 04 24             	mov    %eax,(%esp)
  80e8b4:	e8 ae 69 ff ff       	call   805267 <tcpip_apimsg>
  80e8b9:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax
  return conn->err;
}
  80e8bd:	83 c4 34             	add    $0x34,%esp
  80e8c0:	5b                   	pop    %ebx
  80e8c1:	5d                   	pop    %ebp
  80e8c2:	c3                   	ret    

0080e8c3 <netconn_getaddr>:
 * @return ERR_CONN for invalid connections
 *         ERR_OK if the information was retrieved
 */
err_t
netconn_getaddr(struct netconn *conn, struct ip_addr *addr, u16_t *port, u8_t local)
{
  80e8c3:	55                   	push   %ebp
  80e8c4:	89 e5                	mov    %esp,%ebp
  80e8c6:	53                   	push   %ebx
  80e8c7:	83 ec 34             	sub    $0x34,%esp
  80e8ca:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80e8cd:	8b 55 0c             	mov    0xc(%ebp),%edx
  80e8d0:	8b 45 10             	mov    0x10(%ebp),%eax
  80e8d3:	0f b6 4d 14          	movzbl 0x14(%ebp),%ecx
  struct api_msg msg;

  LWIP_ERROR("netconn_getaddr: invalid conn", (conn != NULL), return ERR_ARG;);
  80e8d7:	85 db                	test   %ebx,%ebx
  80e8d9:	75 1c                	jne    80e8f7 <netconn_getaddr+0x34>
  80e8db:	c7 44 24 08 54 4b 81 	movl   $0x814b54,0x8(%esp)
  80e8e2:	00 
  80e8e3:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  80e8ea:	00 
  80e8eb:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e8f2:	e8 dd 20 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid addr", (addr != NULL), return ERR_ARG;);
  80e8f7:	85 d2                	test   %edx,%edx
  80e8f9:	75 1c                	jne    80e917 <netconn_getaddr+0x54>
  80e8fb:	c7 44 24 08 72 4b 81 	movl   $0x814b72,0x8(%esp)
  80e902:	00 
  80e903:	c7 44 24 04 99 00 00 	movl   $0x99,0x4(%esp)
  80e90a:	00 
  80e90b:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e912:	e8 bd 20 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netconn_getaddr: invalid port", (port != NULL), return ERR_ARG;);
  80e917:	85 c0                	test   %eax,%eax
  80e919:	75 1c                	jne    80e937 <netconn_getaddr+0x74>
  80e91b:	c7 44 24 08 90 4b 81 	movl   $0x814b90,0x8(%esp)
  80e922:	00 
  80e923:	c7 44 24 04 9a 00 00 	movl   $0x9a,0x4(%esp)
  80e92a:	00 
  80e92b:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e932:	e8 9d 20 ff ff       	call   8009d4 <_panic>

  msg.function = do_getaddr;
  80e937:	c7 45 e4 e0 ec 80 00 	movl   $0x80ece0,-0x1c(%ebp)
  msg.msg.conn = conn;
  80e93e:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  msg.msg.msg.ad.ipaddr = addr;
  80e941:	89 55 ec             	mov    %edx,-0x14(%ebp)
  msg.msg.msg.ad.port = port;
  80e944:	89 45 f0             	mov    %eax,-0x10(%ebp)
  msg.msg.msg.ad.local = local;
  80e947:	88 4d f4             	mov    %cl,-0xc(%ebp)
  TCPIP_APIMSG(&msg);
  80e94a:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80e94d:	89 04 24             	mov    %eax,(%esp)
  80e950:	e8 12 69 ff ff       	call   805267 <tcpip_apimsg>
  80e955:	0f b6 43 0c          	movzbl 0xc(%ebx),%eax

  return conn->err;
}
  80e959:	83 c4 34             	add    $0x34,%esp
  80e95c:	5b                   	pop    %ebx
  80e95d:	5d                   	pop    %ebp
  80e95e:	c3                   	ret    

0080e95f <netconn_accept>:
 * @param conn the TCP listen netconn
 * @return the newly accepted netconn or NULL on timeout
 */
struct netconn *
netconn_accept(struct netconn *conn)
{
  80e95f:	55                   	push   %ebp
  80e960:	89 e5                	mov    %esp,%ebp
  80e962:	53                   	push   %ebx
  80e963:	83 ec 24             	sub    $0x24,%esp
  80e966:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct netconn *newconn;

  LWIP_ERROR("netconn_accept: invalid conn",       (conn != NULL),                      return NULL;);
  80e969:	85 db                	test   %ebx,%ebx
  80e96b:	75 1c                	jne    80e989 <netconn_accept+0x2a>
  80e96d:	c7 44 24 08 ae 4b 81 	movl   $0x814bae,0x8(%esp)
  80e974:	00 
  80e975:	c7 44 24 04 10 01 00 	movl   $0x110,0x4(%esp)
  80e97c:	00 
  80e97d:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e984:	e8 4b 20 ff ff       	call   8009d4 <_panic>
  LWIP_ERROR("netconn_accept: invalid acceptmbox", (conn->acceptmbox != SYS_MBOX_NULL), return NULL;);
  80e989:	8b 43 18             	mov    0x18(%ebx),%eax
  80e98c:	83 f8 ff             	cmp    $0xffffffff,%eax
  80e98f:	75 1c                	jne    80e9ad <netconn_accept+0x4e>
  80e991:	c7 44 24 08 5c 4c 81 	movl   $0x814c5c,0x8(%esp)
  80e998:	00 
  80e999:	c7 44 24 04 11 01 00 	movl   $0x111,0x4(%esp)
  80e9a0:	00 
  80e9a1:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80e9a8:	e8 27 20 ff ff       	call   8009d4 <_panic>
#if LWIP_SO_RCVTIMEO
  if (sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, conn->recv_timeout) == SYS_ARCH_TIMEOUT) {
    newconn = NULL;
  } else
#else
  sys_arch_mbox_fetch(conn->acceptmbox, (void *)&newconn, 0);
  80e9ad:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e9b4:	00 
  80e9b5:	8d 55 f4             	lea    -0xc(%ebp),%edx
  80e9b8:	89 54 24 04          	mov    %edx,0x4(%esp)
  80e9bc:	89 04 24             	mov    %eax,(%esp)
  80e9bf:	e8 d0 f2 ff ff       	call   80dc94 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
  {
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, 0);
  80e9c4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80e9c7:	85 c0                	test   %eax,%eax
  80e9c9:	74 15                	je     80e9e0 <netconn_accept+0x81>
  80e9cb:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80e9d2:	00 
  80e9d3:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80e9da:	00 
  80e9db:	89 1c 24             	mov    %ebx,(%esp)
  80e9de:	ff d0                	call   *%eax
    }
#endif /* TCP_LISTEN_BACKLOG */
  }

  return newconn;
}
  80e9e0:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80e9e3:	83 c4 24             	add    $0x24,%esp
  80e9e6:	5b                   	pop    %ebx
  80e9e7:	5d                   	pop    %ebp
  80e9e8:	c3                   	ret    

0080e9e9 <netconn_recv>:
 * @param conn the netconn from which to receive data
 * @return a new netbuf containing received data or NULL on memory error or timeout
 */
struct netbuf *
netconn_recv(struct netconn *conn)
{
  80e9e9:	55                   	push   %ebp
  80e9ea:	89 e5                	mov    %esp,%ebp
  80e9ec:	53                   	push   %ebx
  80e9ed:	83 ec 34             	sub    $0x34,%esp
  80e9f0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;
  struct netbuf *buf = NULL;
  80e9f3:	c7 45 e0 00 00 00 00 	movl   $0x0,-0x20(%ebp)
  struct pbuf *p;
  u16_t len;

  LWIP_ERROR("netconn_recv: invalid conn",  (conn != NULL), return NULL;);
  80e9fa:	85 db                	test   %ebx,%ebx
  80e9fc:	75 1c                	jne    80ea1a <netconn_recv+0x31>
  80e9fe:	c7 44 24 08 cb 4b 81 	movl   $0x814bcb,0x8(%esp)
  80ea05:	00 
  80ea06:	c7 44 24 04 3a 01 00 	movl   $0x13a,0x4(%esp)
  80ea0d:	00 
  80ea0e:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80ea15:	e8 ba 1f ff ff       	call   8009d4 <_panic>

  if (conn->recvmbox == SYS_MBOX_NULL) {
  80ea1a:	8b 43 14             	mov    0x14(%ebx),%eax
  80ea1d:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ea20:	75 0e                	jne    80ea30 <netconn_recv+0x47>
    /* @todo: should calling netconn_recv on a TCP listen conn be fatal (ERR_CONN)?? */
    /* TCP listen conns don't have a recvmbox! */
    conn->err = ERR_CONN;
  80ea22:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80ea26:	b8 00 00 00 00       	mov    $0x0,%eax
    return NULL;
  80ea2b:	e9 65 01 00 00       	jmp    80eb95 <netconn_recv+0x1ac>
  }

  if (ERR_IS_FATAL(conn->err)) {
  80ea30:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80ea34:	0f 8c 56 01 00 00    	jl     80eb90 <netconn_recv+0x1a7>
    return NULL;
  }

  if (conn->type == NETCONN_TCP) {
  80ea3a:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ea3d:	8d 76 00             	lea    0x0(%esi),%esi
  80ea40:	0f 85 fc 00 00 00    	jne    80eb42 <netconn_recv+0x159>
#if LWIP_TCP
    if (conn->state == NETCONN_LISTEN) {
  80ea46:	83 7b 04 02          	cmpl   $0x2,0x4(%ebx)
  80ea4a:	75 0e                	jne    80ea5a <netconn_recv+0x71>
      /* @todo: should calling netconn_recv on a TCP listen conn be fatal?? */
      conn->err = ERR_CONN;
  80ea4c:	c6 43 0c f8          	movb   $0xf8,0xc(%ebx)
  80ea50:	b8 00 00 00 00       	mov    $0x0,%eax
      return NULL;
  80ea55:	e9 3b 01 00 00       	jmp    80eb95 <netconn_recv+0x1ac>
    }

    buf = memp_malloc(MEMP_NETBUF);
  80ea5a:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ea61:	e8 9e 8d ff ff       	call   807804 <memp_malloc>
  80ea66:	89 45 e0             	mov    %eax,-0x20(%ebp)

    if (buf == NULL) {
  80ea69:	85 c0                	test   %eax,%eax
  80ea6b:	75 09                	jne    80ea76 <netconn_recv+0x8d>
      conn->err = ERR_MEM;
  80ea6d:	c6 43 0c ff          	movb   $0xff,0xc(%ebx)
      return NULL;
  80ea71:	e9 1f 01 00 00       	jmp    80eb95 <netconn_recv+0x1ac>
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      conn->err = ERR_TIMEOUT;
      p = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&p, 0);
  80ea76:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80ea7d:	00 
  80ea7e:	8d 45 dc             	lea    -0x24(%ebp),%eax
  80ea81:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ea85:	8b 43 14             	mov    0x14(%ebx),%eax
  80ea88:	89 04 24             	mov    %eax,(%esp)
  80ea8b:	e8 04 f2 ff ff       	call   80dc94 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/

    if (p != NULL) {
  80ea90:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80ea93:	b8 00 00 00 00       	mov    $0x0,%eax
  80ea98:	85 d2                	test   %edx,%edx
  80ea9a:	74 08                	je     80eaa4 <netconn_recv+0xbb>
      len = p->tot_len;
  80ea9c:	0f b7 42 08          	movzwl 0x8(%edx),%eax
      SYS_ARCH_DEC(conn->recv_avail, len);
  80eaa0:	66 29 43 20          	sub    %ax,0x20(%ebx)
    } else {
      len = 0;
    }

    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVMINUS, len);
  80eaa4:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80eaa7:	85 d2                	test   %edx,%edx
  80eaa9:	74 14                	je     80eabf <netconn_recv+0xd6>
  80eaab:	0f b7 c0             	movzwl %ax,%eax
  80eaae:	89 44 24 08          	mov    %eax,0x8(%esp)
  80eab2:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80eab9:	00 
  80eaba:	89 1c 24             	mov    %ebx,(%esp)
  80eabd:	ff d2                	call   *%edx

    /* If we are closed, we indicate that we no longer wish to use the socket */
    if (p == NULL) {
  80eabf:	8b 45 dc             	mov    -0x24(%ebp),%eax
  80eac2:	85 c0                	test   %eax,%eax
  80eac4:	75 2b                	jne    80eaf1 <netconn_recv+0x108>
      memp_free(MEMP_NETBUF, buf);
  80eac6:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eac9:	89 44 24 04          	mov    %eax,0x4(%esp)
  80eacd:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80ead4:	e8 e7 8c ff ff       	call   8077c0 <memp_free>
      /* Avoid to lose any previous error code */
      if (conn->err == ERR_OK) {
  80ead9:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80eadd:	0f 85 ad 00 00 00    	jne    80eb90 <netconn_recv+0x1a7>
        conn->err = ERR_CLSD;
  80eae3:	c6 43 0c f9          	movb   $0xf9,0xc(%ebx)
  80eae7:	b8 00 00 00 00       	mov    $0x0,%eax
  80eaec:	e9 a4 00 00 00       	jmp    80eb95 <netconn_recv+0x1ac>
      }
      return NULL;
    }

    buf->p = p;
  80eaf1:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eaf4:	89 02                	mov    %eax,(%edx)
    buf->ptr = p;
  80eaf6:	8b 55 dc             	mov    -0x24(%ebp),%edx
  80eaf9:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eafc:	89 50 04             	mov    %edx,0x4(%eax)
    buf->port = 0;
  80eaff:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eb02:	66 c7 40 0c 00 00    	movw   $0x0,0xc(%eax)
    buf->addr = NULL;
  80eb08:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eb0b:	c7 40 08 00 00 00 00 	movl   $0x0,0x8(%eax)

    /* Let the stack know that we have taken the data. */
    msg.function = do_recv;
  80eb12:	c7 45 e4 2b f4 80 00 	movl   $0x80f42b,-0x1c(%ebp)
    msg.msg.conn = conn;
  80eb19:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    if (buf != NULL) {
  80eb1c:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eb1f:	85 c0                	test   %eax,%eax
  80eb21:	74 0c                	je     80eb2f <netconn_recv+0x146>
      msg.msg.msg.r.len = buf->p->tot_len;
  80eb23:	8b 00                	mov    (%eax),%eax
  80eb25:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80eb29:	66 89 45 ec          	mov    %ax,-0x14(%ebp)
  80eb2d:	eb 06                	jmp    80eb35 <netconn_recv+0x14c>
    } else {
      msg.msg.msg.r.len = 1;
  80eb2f:	66 c7 45 ec 01 00    	movw   $0x1,-0x14(%ebp)
    }
    TCPIP_APIMSG(&msg);
  80eb35:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80eb38:	89 04 24             	mov    %eax,(%esp)
  80eb3b:	e8 27 67 ff ff       	call   805267 <tcpip_apimsg>
  80eb40:	eb 49                	jmp    80eb8b <netconn_recv+0x1a2>
#if LWIP_SO_RCVTIMEO
    if (sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, conn->recv_timeout)==SYS_ARCH_TIMEOUT) {
      buf = NULL;
    }
#else
    sys_arch_mbox_fetch(conn->recvmbox, (void *)&buf, 0);
  80eb42:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80eb49:	00 
  80eb4a:	8d 55 e0             	lea    -0x20(%ebp),%edx
  80eb4d:	89 54 24 04          	mov    %edx,0x4(%esp)
  80eb51:	89 04 24             	mov    %eax,(%esp)
  80eb54:	e8 3b f1 ff ff       	call   80dc94 <sys_arch_mbox_fetch>
#endif /* LWIP_SO_RCVTIMEO*/
    if (buf!=NULL) {
  80eb59:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eb5c:	85 c0                	test   %eax,%eax
  80eb5e:	74 2b                	je     80eb8b <netconn_recv+0x1a2>
      SYS_ARCH_DEC(conn->recv_avail, buf->p->tot_len);
  80eb60:	8b 00                	mov    (%eax),%eax
  80eb62:	0f b7 40 08          	movzwl 0x8(%eax),%eax
  80eb66:	66 29 43 20          	sub    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVMINUS, buf->p->tot_len);
  80eb6a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80eb6d:	85 c0                	test   %eax,%eax
  80eb6f:	74 1a                	je     80eb8b <netconn_recv+0x1a2>
  80eb71:	8b 55 e0             	mov    -0x20(%ebp),%edx
  80eb74:	8b 12                	mov    (%edx),%edx
  80eb76:	0f b7 52 08          	movzwl 0x8(%edx),%edx
  80eb7a:	89 54 24 08          	mov    %edx,0x8(%esp)
  80eb7e:	c7 44 24 04 01 00 00 	movl   $0x1,0x4(%esp)
  80eb85:	00 
  80eb86:	89 1c 24             	mov    %ebx,(%esp)
  80eb89:	ff d0                	call   *%eax
#endif /* (LWIP_UDP || LWIP_RAW) */
  }

  LWIP_DEBUGF(API_LIB_DEBUG, ("netconn_recv: received %p (err %d)\n", (void *)buf, conn->err));

  return buf;
  80eb8b:	8b 45 e0             	mov    -0x20(%ebp),%eax
  80eb8e:	eb 05                	jmp    80eb95 <netconn_recv+0x1ac>
  80eb90:	b8 00 00 00 00       	mov    $0x0,%eax
}
  80eb95:	83 c4 34             	add    $0x34,%esp
  80eb98:	5b                   	pop    %ebx
  80eb99:	5d                   	pop    %ebp
  80eb9a:	c3                   	ret    

0080eb9b <netconn_delete>:
 * @param conn the netconn to delete
 * @return ERR_OK if the connection was deleted
 */
err_t
netconn_delete(struct netconn *conn)
{
  80eb9b:	55                   	push   %ebp
  80eb9c:	89 e5                	mov    %esp,%ebp
  80eb9e:	53                   	push   %ebx
  80eb9f:	83 ec 34             	sub    $0x34,%esp
  80eba2:	8b 5d 08             	mov    0x8(%ebp),%ebx
  struct api_msg msg;

  /* No ASSERT here because possible to get a (conn == NULL) if we got an accept error */
  if (conn == NULL) {
  80eba5:	85 db                	test   %ebx,%ebx
  80eba7:	74 24                	je     80ebcd <netconn_delete+0x32>
    return ERR_OK;
  }

  msg.function = do_delconn;
  80eba9:	c7 45 e4 99 f8 80 00 	movl   $0x80f899,-0x1c(%ebp)
  msg.msg.conn = conn;
  80ebb0:	89 5d e8             	mov    %ebx,-0x18(%ebp)
  tcpip_apimsg(&msg);
  80ebb3:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ebb6:	89 04 24             	mov    %eax,(%esp)
  80ebb9:	e8 a9 66 ff ff       	call   805267 <tcpip_apimsg>

  conn->pcb.tcp = NULL;
  80ebbe:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
  netconn_free(conn);
  80ebc5:	89 1c 24             	mov    %ebx,(%esp)
  80ebc8:	e8 84 0d 00 00       	call   80f951 <netconn_free>

  return ERR_OK;
}
  80ebcd:	b8 00 00 00 00       	mov    $0x0,%eax
  80ebd2:	83 c4 34             	add    $0x34,%esp
  80ebd5:	5b                   	pop    %ebx
  80ebd6:	5d                   	pop    %ebp
  80ebd7:	c3                   	ret    

0080ebd8 <netconn_new_with_proto_and_callback>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_new_with_proto_and_callback(enum netconn_type t, u8_t proto, netconn_callback callback)
{
  80ebd8:	55                   	push   %ebp
  80ebd9:	89 e5                	mov    %esp,%ebp
  80ebdb:	56                   	push   %esi
  80ebdc:	53                   	push   %ebx
  80ebdd:	83 ec 30             	sub    $0x30,%esp
  80ebe0:	0f b6 75 0c          	movzbl 0xc(%ebp),%esi
  struct netconn *conn;
  struct api_msg msg;

  conn = netconn_alloc(t, callback);
  80ebe4:	8b 45 10             	mov    0x10(%ebp),%eax
  80ebe7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80ebeb:	8b 45 08             	mov    0x8(%ebp),%eax
  80ebee:	89 04 24             	mov    %eax,(%esp)
  80ebf1:	e8 57 0f 00 00       	call   80fb4d <netconn_alloc>
  80ebf6:	89 c3                	mov    %eax,%ebx
  
  if (conn != NULL ) {
  80ebf8:	85 c0                	test   %eax,%eax
  80ebfa:	0f 84 d6 00 00 00    	je     80ecd6 <netconn_new_with_proto_and_callback+0xfe>
    msg.function = do_newconn;
  80ec00:	c7 45 e4 ba fc 80 00 	movl   $0x80fcba,-0x1c(%ebp)
    msg.msg.msg.n.proto = proto;
  80ec07:	89 f0                	mov    %esi,%eax
  80ec09:	88 45 ec             	mov    %al,-0x14(%ebp)
    msg.msg.conn = conn;
  80ec0c:	89 5d e8             	mov    %ebx,-0x18(%ebp)
    TCPIP_APIMSG(&msg);
  80ec0f:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  80ec12:	89 04 24             	mov    %eax,(%esp)
  80ec15:	e8 4d 66 ff ff       	call   805267 <tcpip_apimsg>

    if (conn->err != ERR_OK) {
  80ec1a:	80 7b 0c 00          	cmpb   $0x0,0xc(%ebx)
  80ec1e:	0f 84 b2 00 00 00    	je     80ecd6 <netconn_new_with_proto_and_callback+0xfe>
      LWIP_ASSERT("freeing conn without freeing pcb", conn->pcb.tcp == NULL);
  80ec24:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80ec28:	74 1c                	je     80ec46 <netconn_new_with_proto_and_callback+0x6e>
  80ec2a:	c7 44 24 08 80 4c 81 	movl   $0x814c80,0x8(%esp)
  80ec31:	00 
  80ec32:	c7 44 24 04 52 00 00 	movl   $0x52,0x4(%esp)
  80ec39:	00 
  80ec3a:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80ec41:	e8 8e 1d ff ff       	call   8009d4 <_panic>
      LWIP_ASSERT("conn has no op_completed", conn->op_completed != SYS_SEM_NULL);
  80ec46:	8b 43 10             	mov    0x10(%ebx),%eax
  80ec49:	83 f8 ff             	cmp    $0xffffffff,%eax
  80ec4c:	75 1c                	jne    80ec6a <netconn_new_with_proto_and_callback+0x92>
  80ec4e:	c7 44 24 08 e6 4b 81 	movl   $0x814be6,0x8(%esp)
  80ec55:	00 
  80ec56:	c7 44 24 04 53 00 00 	movl   $0x53,0x4(%esp)
  80ec5d:	00 
  80ec5e:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80ec65:	e8 6a 1d ff ff       	call   8009d4 <_panic>
      LWIP_ASSERT("conn has no recvmbox", conn->recvmbox != SYS_MBOX_NULL);
  80ec6a:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80ec6e:	75 1c                	jne    80ec8c <netconn_new_with_proto_and_callback+0xb4>
  80ec70:	c7 44 24 08 ff 4b 81 	movl   $0x814bff,0x8(%esp)
  80ec77:	00 
  80ec78:	c7 44 24 04 54 00 00 	movl   $0x54,0x4(%esp)
  80ec7f:	00 
  80ec80:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80ec87:	e8 48 1d ff ff       	call   8009d4 <_panic>
      LWIP_ASSERT("conn->acceptmbox shouldn't exist", conn->acceptmbox == SYS_MBOX_NULL);
  80ec8c:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80ec90:	74 1c                	je     80ecae <netconn_new_with_proto_and_callback+0xd6>
  80ec92:	c7 44 24 08 a4 4c 81 	movl   $0x814ca4,0x8(%esp)
  80ec99:	00 
  80ec9a:	c7 44 24 04 55 00 00 	movl   $0x55,0x4(%esp)
  80eca1:	00 
  80eca2:	c7 04 24 94 4a 81 00 	movl   $0x814a94,(%esp)
  80eca9:	e8 26 1d ff ff       	call   8009d4 <_panic>
      sys_sem_free(conn->op_completed);
  80ecae:	89 04 24             	mov    %eax,(%esp)
  80ecb1:	e8 2d e9 ff ff       	call   80d5e3 <sys_sem_free>
      sys_mbox_free(conn->recvmbox);
  80ecb6:	8b 43 14             	mov    0x14(%ebx),%eax
  80ecb9:	89 04 24             	mov    %eax,(%esp)
  80ecbc:	e8 96 e9 ff ff       	call   80d657 <sys_mbox_free>
      memp_free(MEMP_NETCONN, conn);
  80ecc1:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80ecc5:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80eccc:	e8 ef 8a ff ff       	call   8077c0 <memp_free>
  80ecd1:	bb 00 00 00 00       	mov    $0x0,%ebx
      return NULL;
    }
  }
  return conn;
}
  80ecd6:	89 d8                	mov    %ebx,%eax
  80ecd8:	83 c4 30             	add    $0x30,%esp
  80ecdb:	5b                   	pop    %ebx
  80ecdc:	5e                   	pop    %esi
  80ecdd:	5d                   	pop    %ebp
  80ecde:	c3                   	ret    
	...

0080ece0 <do_getaddr>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_getaddr(struct api_msg_msg *msg)
{
  80ece0:	55                   	push   %ebp
  80ece1:	89 e5                	mov    %esp,%ebp
  80ece3:	83 ec 18             	sub    $0x18,%esp
  80ece6:	8b 45 08             	mov    0x8(%ebp),%eax
  if (msg->conn->pcb.ip != NULL) {
  80ece9:	8b 08                	mov    (%eax),%ecx
  80eceb:	8b 51 08             	mov    0x8(%ecx),%edx
  80ecee:	85 d2                	test   %edx,%edx
  80ecf0:	0f 84 9f 00 00 00    	je     80ed95 <do_getaddr+0xb5>
    *(msg->msg.ad.ipaddr) = (msg->msg.ad.local?msg->conn->pcb.ip->local_ip:msg->conn->pcb.ip->remote_ip);
  80ecf6:	8b 48 04             	mov    0x4(%eax),%ecx
  80ecf9:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ecfd:	74 06                	je     80ed05 <do_getaddr+0x25>
  80ecff:	8b 12                	mov    (%edx),%edx
  80ed01:	89 11                	mov    %edx,(%ecx)
  80ed03:	eb 05                	jmp    80ed0a <do_getaddr+0x2a>
  80ed05:	8b 52 04             	mov    0x4(%edx),%edx
  80ed08:	89 11                	mov    %edx,(%ecx)
    
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80ed0a:	8b 08                	mov    (%eax),%ecx
  80ed0c:	8b 11                	mov    (%ecx),%edx
  80ed0e:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80ed14:	83 fa 20             	cmp    $0x20,%edx
  80ed17:	74 2e                	je     80ed47 <do_getaddr+0x67>
  80ed19:	83 fa 40             	cmp    $0x40,%edx
  80ed1c:	74 0c                	je     80ed2a <do_getaddr+0x4a>
  80ed1e:	83 fa 10             	cmp    $0x10,%edx
  80ed21:	75 76                	jne    80ed99 <do_getaddr+0xb9>
  80ed23:	90                   	nop
  80ed24:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80ed28:	eb 4d                	jmp    80ed77 <do_getaddr+0x97>
#if LWIP_RAW
    case NETCONN_RAW:
      if (msg->msg.ad.local) {
  80ed2a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ed2e:	66 90                	xchg   %ax,%ax
  80ed30:	74 0f                	je     80ed41 <do_getaddr+0x61>
        *(msg->msg.ad.port) = msg->conn->pcb.raw->protocol;
  80ed32:	8b 50 08             	mov    0x8(%eax),%edx
  80ed35:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ed38:	0f b6 49 10          	movzbl 0x10(%ecx),%ecx
  80ed3c:	66 89 0a             	mov    %cx,(%edx)
  80ed3f:	eb 58                	jmp    80ed99 <do_getaddr+0xb9>
      } else {
        /* return an error as connecting is only a helper for upper layers */
        msg->conn->err = ERR_CONN;
  80ed41:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ed45:	eb 52                	jmp    80ed99 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      if (msg->msg.ad.local) {
  80ed47:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ed4b:	74 0f                	je     80ed5c <do_getaddr+0x7c>
        *(msg->msg.ad.port) = msg->conn->pcb.udp->local_port;
  80ed4d:	8b 50 08             	mov    0x8(%eax),%edx
  80ed50:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ed53:	0f b7 49 12          	movzwl 0x12(%ecx),%ecx
  80ed57:	66 89 0a             	mov    %cx,(%edx)
  80ed5a:	eb 3d                	jmp    80ed99 <do_getaddr+0xb9>
      } else {
        if ((msg->conn->pcb.udp->flags & UDP_FLAGS_CONNECTED) == 0) {
  80ed5c:	8b 51 08             	mov    0x8(%ecx),%edx
  80ed5f:	f6 42 10 04          	testb  $0x4,0x10(%edx)
  80ed63:	75 06                	jne    80ed6b <do_getaddr+0x8b>
          msg->conn->err = ERR_CONN;
  80ed65:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  80ed69:	eb 2e                	jmp    80ed99 <do_getaddr+0xb9>
        } else {
          *(msg->msg.ad.port) = msg->conn->pcb.udp->remote_port;
  80ed6b:	8b 48 08             	mov    0x8(%eax),%ecx
  80ed6e:	0f b7 52 14          	movzwl 0x14(%edx),%edx
  80ed72:	66 89 11             	mov    %dx,(%ecx)
  80ed75:	eb 22                	jmp    80ed99 <do_getaddr+0xb9>
      }
      break;
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      *(msg->msg.ad.port) = (msg->msg.ad.local?msg->conn->pcb.tcp->local_port:msg->conn->pcb.tcp->remote_port);
  80ed77:	8b 50 08             	mov    0x8(%eax),%edx
  80ed7a:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80ed7e:	74 09                	je     80ed89 <do_getaddr+0xa9>
  80ed80:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ed83:	0f b7 49 1c          	movzwl 0x1c(%ecx),%ecx
  80ed87:	eb 07                	jmp    80ed90 <do_getaddr+0xb0>
  80ed89:	8b 49 08             	mov    0x8(%ecx),%ecx
  80ed8c:	0f b7 49 1e          	movzwl 0x1e(%ecx),%ecx
  80ed90:	66 89 0a             	mov    %cx,(%edx)
  80ed93:	eb 04                	jmp    80ed99 <do_getaddr+0xb9>
      break;
#endif /* LWIP_TCP */
    }
  } else {
    msg->conn->err = ERR_CONN;
  80ed95:	c6 41 0c f8          	movb   $0xf8,0xc(%ecx)
  }
  TCPIP_APIMSG_ACK(msg);
  80ed99:	8b 00                	mov    (%eax),%eax
  80ed9b:	8b 40 10             	mov    0x10(%eax),%eax
  80ed9e:	89 04 24             	mov    %eax,(%esp)
  80eda1:	e8 81 ee ff ff       	call   80dc27 <sys_sem_signal>
}
  80eda6:	c9                   	leave  
  80eda7:	c3                   	ret    

0080eda8 <setup_tcp>:
 *
 * @param conn the TCP netconn to setup
 */
static void
setup_tcp(struct netconn *conn)
{
  80eda8:	55                   	push   %ebp
  80eda9:	89 e5                	mov    %esp,%ebp
  80edab:	53                   	push   %ebx
  80edac:	83 ec 14             	sub    $0x14,%esp
  struct tcp_pcb *pcb;

  pcb = conn->pcb.tcp;
  80edaf:	8b 58 08             	mov    0x8(%eax),%ebx
  tcp_arg(pcb, conn);
  80edb2:	89 44 24 04          	mov    %eax,0x4(%esp)
  80edb6:	89 1c 24             	mov    %ebx,(%esp)
  80edb9:	e8 08 9b ff ff       	call   8088c6 <tcp_arg>
  tcp_recv(pcb, recv_tcp);
  80edbe:	c7 44 24 04 20 f6 80 	movl   $0x80f620,0x4(%esp)
  80edc5:	00 
  80edc6:	89 1c 24             	mov    %ebx,(%esp)
  80edc9:	e8 06 9b ff ff       	call   8088d4 <tcp_recv>
  tcp_sent(pcb, sent_tcp);
  80edce:	c7 44 24 04 2c f3 80 	movl   $0x80f32c,0x4(%esp)
  80edd5:	00 
  80edd6:	89 1c 24             	mov    %ebx,(%esp)
  80edd9:	e8 07 9b ff ff       	call   8088e5 <tcp_sent>
  tcp_poll(pcb, poll_tcp, 4);
  80edde:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ede5:	00 
  80ede6:	c7 44 24 04 d7 f2 80 	movl   $0x80f2d7,0x4(%esp)
  80eded:	00 
  80edee:	89 1c 24             	mov    %ebx,(%esp)
  80edf1:	e8 1f 9b ff ff       	call   808915 <tcp_poll>
  tcp_err(pcb, err_tcp);
  80edf6:	c7 44 24 04 88 f0 80 	movl   $0x80f088,0x4(%esp)
  80edfd:	00 
  80edfe:	89 1c 24             	mov    %ebx,(%esp)
  80ee01:	e8 f0 9a ff ff       	call   8088f6 <tcp_err>
}
  80ee06:	83 c4 14             	add    $0x14,%esp
  80ee09:	5b                   	pop    %ebx
  80ee0a:	5d                   	pop    %ebp
  80ee0b:	c3                   	ret    

0080ee0c <do_connected>:
 *
 * @see tcp.h (struct tcp_pcb.connected) for parameters and return values
 */
static err_t
do_connected(void *arg, struct tcp_pcb *pcb, err_t err)
{
  80ee0c:	55                   	push   %ebp
  80ee0d:	89 e5                	mov    %esp,%ebp
  80ee0f:	53                   	push   %ebx
  80ee10:	83 ec 14             	sub    $0x14,%esp
  80ee13:	0f b6 55 10          	movzbl 0x10(%ebp),%edx
  struct netconn *conn;

  LWIP_UNUSED_ARG(pcb);

  conn = arg;
  80ee17:	8b 5d 08             	mov    0x8(%ebp),%ebx

  if (conn == NULL) {
  80ee1a:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
  80ee1f:	85 db                	test   %ebx,%ebx
  80ee21:	74 2a                	je     80ee4d <do_connected+0x41>
    return ERR_VAL;
  }

  conn->err = err;
  80ee23:	88 53 0c             	mov    %dl,0xc(%ebx)
  if ((conn->type == NETCONN_TCP) && (err == ERR_OK)) {
  80ee26:	83 3b 10             	cmpl   $0x10,(%ebx)
  80ee29:	75 0b                	jne    80ee36 <do_connected+0x2a>
  80ee2b:	84 d2                	test   %dl,%dl
  80ee2d:	75 07                	jne    80ee36 <do_connected+0x2a>
    setup_tcp(conn);
  80ee2f:	89 d8                	mov    %ebx,%eax
  80ee31:	e8 72 ff ff ff       	call   80eda8 <setup_tcp>
  }
  conn->state = NETCONN_NONE;
  80ee36:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  sys_sem_signal(conn->op_completed);
  80ee3d:	8b 43 10             	mov    0x10(%ebx),%eax
  80ee40:	89 04 24             	mov    %eax,(%esp)
  80ee43:	e8 df ed ff ff       	call   80dc27 <sys_sem_signal>
  80ee48:	b8 00 00 00 00       	mov    $0x0,%eax
  return ERR_OK;
}
  80ee4d:	83 c4 14             	add    $0x14,%esp
  80ee50:	5b                   	pop    %ebx
  80ee51:	5d                   	pop    %ebp
  80ee52:	c3                   	ret    

0080ee53 <do_close_internal>:
 *
 * @param conn the TCP netconn to close
 */
static void
do_close_internal(struct netconn *conn)
{
  80ee53:	55                   	push   %ebp
  80ee54:	89 e5                	mov    %esp,%ebp
  80ee56:	53                   	push   %ebx
  80ee57:	83 ec 14             	sub    $0x14,%esp
  80ee5a:	89 c3                	mov    %eax,%ebx
  err_t err;

  LWIP_ASSERT("invalid conn", (conn != NULL));
  80ee5c:	85 c0                	test   %eax,%eax
  80ee5e:	75 1c                	jne    80ee7c <do_close_internal+0x29>
  80ee60:	c7 44 24 08 f1 4a 81 	movl   $0x814af1,0x8(%esp)
  80ee67:	00 
  80ee68:	c7 44 24 04 53 02 00 	movl   $0x253,0x4(%esp)
  80ee6f:	00 
  80ee70:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80ee77:	e8 58 1b ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("this is for tcp netconns only", (conn->type == NETCONN_TCP));
  80ee7c:	83 38 10             	cmpl   $0x10,(%eax)
  80ee7f:	74 1c                	je     80ee9d <do_close_internal+0x4a>
  80ee81:	c7 44 24 08 dc 4c 81 	movl   $0x814cdc,0x8(%esp)
  80ee88:	00 
  80ee89:	c7 44 24 04 54 02 00 	movl   $0x254,0x4(%esp)
  80ee90:	00 
  80ee91:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80ee98:	e8 37 1b ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("conn must be in state NETCONN_CLOSE", (conn->state == NETCONN_CLOSE));
  80ee9d:	83 78 04 04          	cmpl   $0x4,0x4(%eax)
  80eea1:	74 1c                	je     80eebf <do_close_internal+0x6c>
  80eea3:	c7 44 24 08 a8 4d 81 	movl   $0x814da8,0x8(%esp)
  80eeaa:	00 
  80eeab:	c7 44 24 04 55 02 00 	movl   $0x255,0x4(%esp)
  80eeb2:	00 
  80eeb3:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80eeba:	e8 15 1b ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("pcb already closed", (conn->pcb.tcp != NULL));
  80eebf:	8b 40 08             	mov    0x8(%eax),%eax
  80eec2:	85 c0                	test   %eax,%eax
  80eec4:	75 1c                	jne    80eee2 <do_close_internal+0x8f>
  80eec6:	c7 44 24 08 fa 4c 81 	movl   $0x814cfa,0x8(%esp)
  80eecd:	00 
  80eece:	c7 44 24 04 56 02 00 	movl   $0x256,0x4(%esp)
  80eed5:	00 
  80eed6:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80eedd:	e8 f2 1a ff ff       	call   8009d4 <_panic>

  /* Set back some callback pointers */
  tcp_arg(conn->pcb.tcp, NULL);
  80eee2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80eee9:	00 
  80eeea:	89 04 24             	mov    %eax,(%esp)
  80eeed:	e8 d4 99 ff ff       	call   8088c6 <tcp_arg>
  if (conn->pcb.tcp->state == LISTEN) {
  80eef2:	8b 43 08             	mov    0x8(%ebx),%eax
  80eef5:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80eef9:	75 12                	jne    80ef0d <do_close_internal+0xba>
    tcp_accept(conn->pcb.tcp, NULL);
  80eefb:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef02:	00 
  80ef03:	89 04 24             	mov    %eax,(%esp)
  80ef06:	e8 fc 99 ff ff       	call   808907 <tcp_accept>
  80ef0b:	eb 64                	jmp    80ef71 <do_close_internal+0x11e>
  } else {
    tcp_recv(conn->pcb.tcp, NULL);
  80ef0d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef14:	00 
  80ef15:	89 04 24             	mov    %eax,(%esp)
  80ef18:	e8 b7 99 ff ff       	call   8088d4 <tcp_recv>
    tcp_accept(conn->pcb.tcp, NULL);
  80ef1d:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef24:	00 
  80ef25:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef28:	89 04 24             	mov    %eax,(%esp)
  80ef2b:	e8 d7 99 ff ff       	call   808907 <tcp_accept>
    /* some callbacks have to be reset if tcp_close is not successful */
    tcp_sent(conn->pcb.tcp, NULL);
  80ef30:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef37:	00 
  80ef38:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef3b:	89 04 24             	mov    %eax,(%esp)
  80ef3e:	e8 a2 99 ff ff       	call   8088e5 <tcp_sent>
    tcp_poll(conn->pcb.tcp, NULL, 4);
  80ef43:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80ef4a:	00 
  80ef4b:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef52:	00 
  80ef53:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef56:	89 04 24             	mov    %eax,(%esp)
  80ef59:	e8 b7 99 ff ff       	call   808915 <tcp_poll>
    tcp_err(conn->pcb.tcp, NULL);
  80ef5e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80ef65:	00 
  80ef66:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef69:	89 04 24             	mov    %eax,(%esp)
  80ef6c:	e8 85 99 ff ff       	call   8088f6 <tcp_err>
  }
  /* Try to close the connection */
  err = tcp_close(conn->pcb.tcp);
  80ef71:	8b 43 08             	mov    0x8(%ebx),%eax
  80ef74:	89 04 24             	mov    %eax,(%esp)
  80ef77:	e8 41 a8 ff ff       	call   8097bd <tcp_close>
  if (err == ERR_OK) {
  80ef7c:	84 c0                	test   %al,%al
  80ef7e:	75 57                	jne    80efd7 <do_close_internal+0x184>
    /* Closing succeeded */
    conn->state = NETCONN_NONE;
  80ef80:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* Set back some callback pointers as conn is going away */
    conn->pcb.tcp = NULL;
  80ef87:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    conn->err = ERR_OK;
  80ef8e:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
    /* Trigger select() in socket layer. This send should something else so the
       errorfd is set, not the read and write fd! */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80ef92:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80ef95:	85 c0                	test   %eax,%eax
  80ef97:	74 31                	je     80efca <do_close_internal+0x177>
  80ef99:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80efa0:	00 
  80efa1:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80efa8:	00 
  80efa9:	89 1c 24             	mov    %ebx,(%esp)
  80efac:	ff d0                	call   *%eax
    API_EVENT(conn, NETCONN_EVT_SENDPLUS, 0);
  80efae:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80efb1:	85 c0                	test   %eax,%eax
  80efb3:	74 15                	je     80efca <do_close_internal+0x177>
  80efb5:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80efbc:	00 
  80efbd:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80efc4:	00 
  80efc5:	89 1c 24             	mov    %ebx,(%esp)
  80efc8:	ff d0                	call   *%eax
    /* wake up the application task */
    sys_sem_signal(conn->op_completed);
  80efca:	8b 43 10             	mov    0x10(%ebx),%eax
  80efcd:	89 04 24             	mov    %eax,(%esp)
  80efd0:	e8 52 ec ff ff       	call   80dc27 <sys_sem_signal>
  80efd5:	eb 72                	jmp    80f049 <do_close_internal+0x1f6>
  } else {
    /* Closing failed, restore some of the callbacks */
    /* Closing of listen pcb will never fail! */
    LWIP_ASSERT("Closing a listen pcb may not fail!", (conn->pcb.tcp->state != LISTEN));
  80efd7:	8b 43 08             	mov    0x8(%ebx),%eax
  80efda:	83 78 10 01          	cmpl   $0x1,0x10(%eax)
  80efde:	75 1c                	jne    80effc <do_close_internal+0x1a9>
  80efe0:	c7 44 24 08 cc 4d 81 	movl   $0x814dcc,0x8(%esp)
  80efe7:	00 
  80efe8:	c7 44 24 04 75 02 00 	movl   $0x275,0x4(%esp)
  80efef:	00 
  80eff0:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80eff7:	e8 d8 19 ff ff       	call   8009d4 <_panic>
    tcp_sent(conn->pcb.tcp, sent_tcp);
  80effc:	c7 44 24 04 2c f3 80 	movl   $0x80f32c,0x4(%esp)
  80f003:	00 
  80f004:	89 04 24             	mov    %eax,(%esp)
  80f007:	e8 d9 98 ff ff       	call   8088e5 <tcp_sent>
    tcp_poll(conn->pcb.tcp, poll_tcp, 4);
  80f00c:	c7 44 24 08 04 00 00 	movl   $0x4,0x8(%esp)
  80f013:	00 
  80f014:	c7 44 24 04 d7 f2 80 	movl   $0x80f2d7,0x4(%esp)
  80f01b:	00 
  80f01c:	8b 43 08             	mov    0x8(%ebx),%eax
  80f01f:	89 04 24             	mov    %eax,(%esp)
  80f022:	e8 ee 98 ff ff       	call   808915 <tcp_poll>
    tcp_err(conn->pcb.tcp, err_tcp);
  80f027:	c7 44 24 04 88 f0 80 	movl   $0x80f088,0x4(%esp)
  80f02e:	00 
  80f02f:	8b 43 08             	mov    0x8(%ebx),%eax
  80f032:	89 04 24             	mov    %eax,(%esp)
  80f035:	e8 bc 98 ff ff       	call   8088f6 <tcp_err>
    tcp_arg(conn->pcb.tcp, conn);
  80f03a:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80f03e:	8b 43 08             	mov    0x8(%ebx),%eax
  80f041:	89 04 24             	mov    %eax,(%esp)
  80f044:	e8 7d 98 ff ff       	call   8088c6 <tcp_arg>
  }
  /* If closing didn't succeed, we get called again either
     from poll_tcp or from sent_tcp */
}
  80f049:	83 c4 14             	add    $0x14,%esp
  80f04c:	5b                   	pop    %ebx
  80f04d:	5d                   	pop    %ebp
  80f04e:	c3                   	ret    

0080f04f <do_close>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_close(struct api_msg_msg *msg)
{
  80f04f:	55                   	push   %ebp
  80f050:	89 e5                	mov    %esp,%ebp
  80f052:	83 ec 18             	sub    $0x18,%esp
  80f055:	8b 55 08             	mov    0x8(%ebp),%edx
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f058:	8b 02                	mov    (%edx),%eax
  80f05a:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f05e:	74 15                	je     80f075 <do_close+0x26>
  80f060:	83 38 10             	cmpl   $0x10,(%eax)
  80f063:	75 10                	jne    80f075 <do_close+0x26>
      msg->conn->state = NETCONN_CLOSE;
  80f065:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f06c:	8b 02                	mov    (%edx),%eax
  80f06e:	e8 e0 fd ff ff       	call   80ee53 <do_close_internal>
 */
void
do_close(struct api_msg_msg *msg)
{
#if LWIP_TCP
  if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f073:	eb 11                	jmp    80f086 <do_close+0x37>
      do_close_internal(msg->conn);
      /* for tcp netconns, do_close_internal ACKs the message */
  } else
#endif /* LWIP_TCP */
  {
    msg->conn->err = ERR_VAL;
  80f075:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
    TCPIP_APIMSG_ACK(msg);
  80f079:	8b 02                	mov    (%edx),%eax
  80f07b:	8b 40 10             	mov    0x10(%eax),%eax
  80f07e:	89 04 24             	mov    %eax,(%esp)
  80f081:	e8 a1 eb ff ff       	call   80dc27 <sys_sem_signal>
  }
}
  80f086:	c9                   	leave  
  80f087:	c3                   	ret    

0080f088 <err_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.err) for parameters
 */
static void
err_tcp(void *arg, err_t err)
{
  80f088:	55                   	push   %ebp
  80f089:	89 e5                	mov    %esp,%ebp
  80f08b:	53                   	push   %ebx
  80f08c:	83 ec 14             	sub    $0x14,%esp
  80f08f:	0f b6 45 0c          	movzbl 0xc(%ebp),%eax
  struct netconn *conn;

  conn = arg;
  80f093:	8b 5d 08             	mov    0x8(%ebp),%ebx
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f096:	85 db                	test   %ebx,%ebx
  80f098:	75 1c                	jne    80f0b6 <err_tcp+0x2e>
  80f09a:	c7 44 24 08 0d 4d 81 	movl   $0x814d0d,0x8(%esp)
  80f0a1:	00 
  80f0a2:	c7 44 24 04 22 01 00 	movl   $0x122,0x4(%esp)
  80f0a9:	00 
  80f0aa:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f0b1:	e8 1e 19 ff ff       	call   8009d4 <_panic>

  conn->pcb.tcp = NULL;
  80f0b6:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)

  conn->err = err;
  80f0bd:	88 43 0c             	mov    %al,0xc(%ebx)
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f0c0:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f0c4:	74 2f                	je     80f0f5 <err_tcp+0x6d>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f0c6:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f0c9:	85 c0                	test   %eax,%eax
  80f0cb:	74 15                	je     80f0e2 <err_tcp+0x5a>
  80f0cd:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f0d4:	00 
  80f0d5:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f0dc:	00 
  80f0dd:	89 1c 24             	mov    %ebx,(%esp)
  80f0e0:	ff d0                	call   *%eax
    sys_mbox_post(conn->recvmbox, NULL);
  80f0e2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f0e9:	00 
  80f0ea:	8b 43 14             	mov    0x14(%ebx),%eax
  80f0ed:	89 04 24             	mov    %eax,(%esp)
  80f0f0:	e8 91 ed ff ff       	call   80de86 <sys_mbox_post>
  }
  if (conn->op_completed != SYS_SEM_NULL && conn->state == NETCONN_CONNECT) {
  80f0f5:	83 7b 10 ff          	cmpl   $0xffffffff,0x10(%ebx)
  80f0f9:	74 18                	je     80f113 <err_tcp+0x8b>
  80f0fb:	83 7b 04 03          	cmpl   $0x3,0x4(%ebx)
  80f0ff:	75 12                	jne    80f113 <err_tcp+0x8b>
    conn->state = NETCONN_NONE;
  80f101:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    sys_sem_signal(conn->op_completed);
  80f108:	8b 43 10             	mov    0x10(%ebx),%eax
  80f10b:	89 04 24             	mov    %eax,(%esp)
  80f10e:	e8 14 eb ff ff       	call   80dc27 <sys_sem_signal>
  }
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f113:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f117:	74 2f                	je     80f148 <err_tcp+0xc0>
    /* Register event with callback */
    API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80f119:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f11c:	85 c0                	test   %eax,%eax
  80f11e:	74 15                	je     80f135 <err_tcp+0xad>
  80f120:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f127:	00 
  80f128:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f12f:	00 
  80f130:	89 1c 24             	mov    %ebx,(%esp)
  80f133:	ff d0                	call   *%eax
    sys_mbox_post(conn->acceptmbox, NULL);
  80f135:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f13c:	00 
  80f13d:	8b 43 18             	mov    0x18(%ebx),%eax
  80f140:	89 04 24             	mov    %eax,(%esp)
  80f143:	e8 3e ed ff ff       	call   80de86 <sys_mbox_post>
  }
  if ((conn->state == NETCONN_WRITE) || (conn->state == NETCONN_CLOSE)) {
  80f148:	8b 43 04             	mov    0x4(%ebx),%eax
  80f14b:	83 f8 01             	cmp    $0x1,%eax
  80f14e:	74 05                	je     80f155 <err_tcp+0xcd>
  80f150:	83 f8 04             	cmp    $0x4,%eax
  80f153:	75 12                	jne    80f167 <err_tcp+0xdf>
    /* calling do_writemore/do_close_internal is not necessary
       since the pcb has already been deleted! */
    conn->state = NETCONN_NONE;
  80f155:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
    /* wake up the waiting task */
    sys_sem_signal(conn->op_completed);
  80f15c:	8b 43 10             	mov    0x10(%ebx),%eax
  80f15f:	89 04 24             	mov    %eax,(%esp)
  80f162:	e8 c0 ea ff ff       	call   80dc27 <sys_sem_signal>
  }
}
  80f167:	83 c4 14             	add    $0x14,%esp
  80f16a:	5b                   	pop    %ebx
  80f16b:	5d                   	pop    %ebp
  80f16c:	c3                   	ret    

0080f16d <do_writemore>:
 * @return ERR_OK
 *         ERR_MEM if LWIP_TCPIP_CORE_LOCKING=1 and sending hasn't yet finished
 */
static err_t
do_writemore(struct netconn *conn)
{
  80f16d:	55                   	push   %ebp
  80f16e:	89 e5                	mov    %esp,%ebp
  80f170:	57                   	push   %edi
  80f171:	56                   	push   %esi
  80f172:	53                   	push   %ebx
  80f173:	83 ec 2c             	sub    $0x2c,%esp
  80f176:	89 c3                	mov    %eax,%ebx
  err_t err;
  void *dataptr;
  u16_t len, available;
  u8_t write_finished = 0;

  LWIP_ASSERT("conn->state == NETCONN_WRITE", (conn->state == NETCONN_WRITE));
  80f178:	83 78 04 01          	cmpl   $0x1,0x4(%eax)
  80f17c:	74 1c                	je     80f19a <do_writemore+0x2d>
  80f17e:	c7 44 24 08 1a 4d 81 	movl   $0x814d1a,0x8(%esp)
  80f185:	00 
  80f186:	c7 44 24 04 b8 03 00 	movl   $0x3b8,0x4(%esp)
  80f18d:	00 
  80f18e:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f195:	e8 3a 18 ff ff       	call   8009d4 <_panic>

  dataptr = (u8_t*)conn->write_msg->msg.w.dataptr + conn->write_offset;
  80f19a:	8b 50 24             	mov    0x24(%eax),%edx
  80f19d:	8b 42 04             	mov    0x4(%edx),%eax
  80f1a0:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  80f1a3:	8b 43 28             	mov    0x28(%ebx),%eax
  if ((conn->write_msg->msg.w.len - conn->write_offset > 0xffff)) { /* max_u16_t */
  80f1a6:	8b 72 08             	mov    0x8(%edx),%esi
  80f1a9:	89 f1                	mov    %esi,%ecx
  80f1ab:	29 c1                	sub    %eax,%ecx
  80f1ad:	66 29 c6             	sub    %ax,%si
  80f1b0:	66 89 75 e2          	mov    %si,-0x1e(%ebp)
  80f1b4:	81 f9 00 00 01 00    	cmp    $0x10000,%ecx
  80f1ba:	0f 9c c1             	setl   %cl
  80f1bd:	0f b6 f1             	movzbl %cl,%esi
  80f1c0:	83 ee 01             	sub    $0x1,%esi
    conn->write_delayed = 1;
#endif
  } else {
    len = conn->write_msg->msg.w.len - conn->write_offset;
  }
  available = tcp_sndbuf(conn->pcb.tcp);
  80f1c3:	8b 4b 08             	mov    0x8(%ebx),%ecx
#if LWIP_TCPIP_CORE_LOCKING
    conn->write_delayed = 1;
#endif
  }

  err = tcp_write(conn->pcb.tcp, dataptr, len, conn->write_msg->msg.w.apiflags);
  80f1c6:	0f b7 79 6e          	movzwl 0x6e(%ecx),%edi
  80f1ca:	66 0b 75 e2          	or     -0x1e(%ebp),%si
  80f1ce:	66 39 fe             	cmp    %di,%si
  80f1d1:	76 02                	jbe    80f1d5 <do_writemore+0x68>
  80f1d3:	89 fe                	mov    %edi,%esi
  80f1d5:	0f b7 f6             	movzwl %si,%esi
  80f1d8:	0f b6 52 0c          	movzbl 0xc(%edx),%edx
  80f1dc:	89 54 24 0c          	mov    %edx,0xc(%esp)
  80f1e0:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f1e4:	03 45 e4             	add    -0x1c(%ebp),%eax
  80f1e7:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f1eb:	89 0c 24             	mov    %ecx,(%esp)
  80f1ee:	e8 26 ce ff ff       	call   80c019 <tcp_write>
  LWIP_ASSERT("do_writemore: invalid length!", ((conn->write_offset + len) <= conn->write_msg->msg.w.len));
  80f1f3:	89 f2                	mov    %esi,%edx
  80f1f5:	03 53 28             	add    0x28(%ebx),%edx
  80f1f8:	8b 4b 24             	mov    0x24(%ebx),%ecx
  80f1fb:	3b 51 08             	cmp    0x8(%ecx),%edx
  80f1fe:	7e 1c                	jle    80f21c <do_writemore+0xaf>
  80f200:	c7 44 24 08 37 4d 81 	movl   $0x814d37,0x8(%esp)
  80f207:	00 
  80f208:	c7 44 24 04 cd 03 00 	movl   $0x3cd,0x4(%esp)
  80f20f:	00 
  80f210:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f217:	e8 b8 17 ff ff       	call   8009d4 <_panic>
  if (err == ERR_OK) {
  80f21c:	84 c0                	test   %al,%al
  80f21e:	75 72                	jne    80f292 <do_writemore+0x125>
    conn->write_offset += len;
  80f220:	89 53 28             	mov    %edx,0x28(%ebx)
    if (conn->write_offset == conn->write_msg->msg.w.len) {
  80f223:	8b 43 24             	mov    0x24(%ebx),%eax
  80f226:	bf 00 00 00 00       	mov    $0x0,%edi
  80f22b:	3b 50 08             	cmp    0x8(%eax),%edx
  80f22e:	75 13                	jne    80f243 <do_writemore+0xd6>
      /* everything was written */
      write_finished = 1;
      conn->write_msg = NULL;
  80f230:	c7 43 24 00 00 00 00 	movl   $0x0,0x24(%ebx)
      conn->write_offset = 0;
  80f237:	c7 43 28 00 00 00 00 	movl   $0x0,0x28(%ebx)
  80f23e:	bf 01 00 00 00       	mov    $0x1,%edi
    }
    err = tcp_output_nagle(conn->pcb.tcp);
  80f243:	8b 43 08             	mov    0x8(%ebx),%eax
  80f246:	83 78 78 00          	cmpl   $0x0,0x78(%eax)
  80f24a:	74 12                	je     80f25e <do_writemore+0xf1>
  80f24c:	f6 40 20 40          	testb  $0x40,0x20(%eax)
  80f250:	75 0c                	jne    80f25e <do_writemore+0xf1>
  80f252:	8b 50 74             	mov    0x74(%eax),%edx
  80f255:	85 d2                	test   %edx,%edx
  80f257:	74 78                	je     80f2d1 <do_writemore+0x164>
  80f259:	83 3a 00             	cmpl   $0x0,(%edx)
  80f25c:	74 73                	je     80f2d1 <do_writemore+0x164>
  80f25e:	89 04 24             	mov    %eax,(%esp)
  80f261:	e8 75 c1 ff ff       	call   80b3db <tcp_output>
    conn->err = err;
  80f266:	88 43 0c             	mov    %al,0xc(%ebx)
    if ((err == ERR_OK) && (tcp_sndbuf(conn->pcb.tcp) <= TCP_SNDLOWAT)) {
  80f269:	84 c0                	test   %al,%al
  80f26b:	75 3f                	jne    80f2ac <do_writemore+0x13f>
  80f26d:	8b 43 08             	mov    0x8(%ebx),%eax
  80f270:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f276:	77 34                	ja     80f2ac <do_writemore+0x13f>
      API_EVENT(conn, NETCONN_EVT_SENDMINUS, len);
  80f278:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f27b:	85 c0                	test   %eax,%eax
  80f27d:	74 2d                	je     80f2ac <do_writemore+0x13f>
  80f27f:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f283:	c7 44 24 04 03 00 00 	movl   $0x3,0x4(%esp)
  80f28a:	00 
  80f28b:	89 1c 24             	mov    %ebx,(%esp)
  80f28e:	ff d0                	call   *%eax
  80f290:	eb 1a                	jmp    80f2ac <do_writemore+0x13f>
    }
  } else if (err == ERR_MEM) {
  80f292:	3c ff                	cmp    $0xff,%al
  80f294:	75 11                	jne    80f2a7 <do_writemore+0x13a>
    /* If ERR_MEM, we wait for sent_tcp or poll_tcp to be called
       we do NOT return to the application thread, since ERR_MEM is
       only a temporary error! */

    /* tcp_enqueue returned ERR_MEM, try tcp_output anyway */
    err = tcp_output(conn->pcb.tcp);
  80f296:	8b 43 08             	mov    0x8(%ebx),%eax
  80f299:	89 04 24             	mov    %eax,(%esp)
  80f29c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f2a0:	e8 36 c1 ff ff       	call   80b3db <tcp_output>
  80f2a5:	eb 1d                	jmp    80f2c4 <do_writemore+0x157>
    conn->write_delayed = 1;
#endif
  } else {
    /* On errors != ERR_MEM, we don't try writing any more but return
       the error to the application thread. */
    conn->err = err;
  80f2a7:	88 43 0c             	mov    %al,0xc(%ebx)
  80f2aa:	eb 06                	jmp    80f2b2 <do_writemore+0x145>
    write_finished = 1;
  }

  if (write_finished) {
  80f2ac:	89 f8                	mov    %edi,%eax
  80f2ae:	84 c0                	test   %al,%al
  80f2b0:	74 12                	je     80f2c4 <do_writemore+0x157>
    /* everything was written: set back connection state
       and back to application task */
    conn->state = NETCONN_NONE;
  80f2b2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
#if LWIP_TCPIP_CORE_LOCKING
    if (conn->write_delayed != 0)
#endif
    {
      sys_sem_signal(conn->op_completed);
  80f2b9:	8b 43 10             	mov    0x10(%ebx),%eax
  80f2bc:	89 04 24             	mov    %eax,(%esp)
  80f2bf:	e8 63 e9 ff ff       	call   80dc27 <sys_sem_signal>
#if LWIP_TCPIP_CORE_LOCKING
  else
    return ERR_MEM;
#endif
  return ERR_OK;
}
  80f2c4:	b8 00 00 00 00       	mov    $0x0,%eax
  80f2c9:	83 c4 2c             	add    $0x2c,%esp
  80f2cc:	5b                   	pop    %ebx
  80f2cd:	5e                   	pop    %esi
  80f2ce:	5f                   	pop    %edi
  80f2cf:	5d                   	pop    %ebp
  80f2d0:	c3                   	ret    
      write_finished = 1;
      conn->write_msg = NULL;
      conn->write_offset = 0;
    }
    err = tcp_output_nagle(conn->pcb.tcp);
    conn->err = err;
  80f2d1:	c6 43 0c 00          	movb   $0x0,0xc(%ebx)
  80f2d5:	eb 96                	jmp    80f26d <do_writemore+0x100>

0080f2d7 <poll_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.poll) for parameters and return value
 */
static err_t
poll_tcp(void *arg, struct tcp_pcb *pcb)
{
  80f2d7:	55                   	push   %ebp
  80f2d8:	89 e5                	mov    %esp,%ebp
  80f2da:	83 ec 18             	sub    $0x18,%esp
  struct netconn *conn = arg;
  80f2dd:	8b 45 08             	mov    0x8(%ebp),%eax

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f2e0:	85 c0                	test   %eax,%eax
  80f2e2:	75 1c                	jne    80f300 <poll_tcp+0x29>
  80f2e4:	c7 44 24 08 0d 4d 81 	movl   $0x814d0d,0x8(%esp)
  80f2eb:	00 
  80f2ec:	c7 44 24 04 eb 00 00 	movl   $0xeb,0x4(%esp)
  80f2f3:	00 
  80f2f4:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f2fb:	e8 d4 16 ff ff       	call   8009d4 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80f300:	8b 50 04             	mov    0x4(%eax),%edx
  80f303:	83 fa 01             	cmp    $0x1,%edx
  80f306:	75 0a                	jne    80f312 <poll_tcp+0x3b>
    do_writemore(conn);
  80f308:	e8 60 fe ff ff       	call   80f16d <do_writemore>
  80f30d:	8d 76 00             	lea    0x0(%esi),%esi
  80f310:	eb 13                	jmp    80f325 <poll_tcp+0x4e>
  } else if (conn->state == NETCONN_CLOSE) {
  80f312:	83 fa 04             	cmp    $0x4,%edx
  80f315:	75 0e                	jne    80f325 <poll_tcp+0x4e>
    do_close_internal(conn);
  80f317:	89 f6                	mov    %esi,%esi
  80f319:	8d bc 27 00 00 00 00 	lea    0x0(%edi,%eiz,1),%edi
  80f320:	e8 2e fb ff ff       	call   80ee53 <do_close_internal>
  }

  return ERR_OK;
}
  80f325:	b8 00 00 00 00       	mov    $0x0,%eax
  80f32a:	c9                   	leave  
  80f32b:	c3                   	ret    

0080f32c <sent_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.sent) for parameters and return value
 */
static err_t
sent_tcp(void *arg, struct tcp_pcb *pcb, u16_t len)
{
  80f32c:	55                   	push   %ebp
  80f32d:	89 e5                	mov    %esp,%ebp
  80f32f:	83 ec 18             	sub    $0x18,%esp
  80f332:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f335:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f338:	0f b7 75 10          	movzwl 0x10(%ebp),%esi
  struct netconn *conn = arg;
  80f33c:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("conn != NULL", (conn != NULL));
  80f33f:	85 db                	test   %ebx,%ebx
  80f341:	75 1c                	jne    80f35f <sent_tcp+0x33>
  80f343:	c7 44 24 08 0d 4d 81 	movl   $0x814d0d,0x8(%esp)
  80f34a:	00 
  80f34b:	c7 44 24 04 03 01 00 	movl   $0x103,0x4(%esp)
  80f352:	00 
  80f353:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f35a:	e8 75 16 ff ff       	call   8009d4 <_panic>

  if (conn->state == NETCONN_WRITE) {
  80f35f:	8b 43 04             	mov    0x4(%ebx),%eax
  80f362:	83 f8 01             	cmp    $0x1,%eax
  80f365:	75 2b                	jne    80f392 <sent_tcp+0x66>
    LWIP_ASSERT("conn->pcb.tcp != NULL", conn->pcb.tcp != NULL);
  80f367:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f36b:	75 1c                	jne    80f389 <sent_tcp+0x5d>
  80f36d:	c7 44 24 08 55 4d 81 	movl   $0x814d55,0x8(%esp)
  80f374:	00 
  80f375:	c7 44 24 04 06 01 00 	movl   $0x106,0x4(%esp)
  80f37c:	00 
  80f37d:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f384:	e8 4b 16 ff ff       	call   8009d4 <_panic>
    do_writemore(conn);
  80f389:	89 d8                	mov    %ebx,%eax
  80f38b:	e8 dd fd ff ff       	call   80f16d <do_writemore>
  80f390:	eb 13                	jmp    80f3a5 <sent_tcp+0x79>
  } else if (conn->state == NETCONN_CLOSE) {
  80f392:	83 f8 04             	cmp    $0x4,%eax
  80f395:	75 0e                	jne    80f3a5 <sent_tcp+0x79>
    do_close_internal(conn);
  80f397:	89 d8                	mov    %ebx,%eax
  80f399:	8d b4 26 00 00 00 00 	lea    0x0(%esi,%eiz,1),%esi
  80f3a0:	e8 ae fa ff ff       	call   80ee53 <do_close_internal>
  }

  if (conn) {
    if ((conn->pcb.tcp != NULL) && (tcp_sndbuf(conn->pcb.tcp) > TCP_SNDLOWAT)) {
  80f3a5:	8b 43 08             	mov    0x8(%ebx),%eax
  80f3a8:	85 c0                	test   %eax,%eax
  80f3aa:	74 23                	je     80f3cf <sent_tcp+0xa3>
  80f3ac:	66 81 78 6e a0 2d    	cmpw   $0x2da0,0x6e(%eax)
  80f3b2:	76 1b                	jbe    80f3cf <sent_tcp+0xa3>
      API_EVENT(conn, NETCONN_EVT_SENDPLUS, len);
  80f3b4:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80f3b7:	85 c0                	test   %eax,%eax
  80f3b9:	74 14                	je     80f3cf <sent_tcp+0xa3>
  80f3bb:	0f b7 f6             	movzwl %si,%esi
  80f3be:	89 74 24 08          	mov    %esi,0x8(%esp)
  80f3c2:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f3c9:	00 
  80f3ca:	89 1c 24             	mov    %ebx,(%esp)
  80f3cd:	ff d0                	call   *%eax
    }
  }
  
  return ERR_OK;
}
  80f3cf:	b8 00 00 00 00       	mov    $0x0,%eax
  80f3d4:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f3d7:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f3da:	89 ec                	mov    %ebp,%esp
  80f3dc:	5d                   	pop    %ebp
  80f3dd:	c3                   	ret    

0080f3de <do_write>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_write(struct api_msg_msg *msg)
{
  80f3de:	55                   	push   %ebp
  80f3df:	89 e5                	mov    %esp,%ebp
  80f3e1:	83 ec 18             	sub    $0x18,%esp
  80f3e4:	8b 55 08             	mov    0x8(%ebp),%edx
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f3e7:	8b 02                	mov    (%edx),%eax
  80f3e9:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f3ed:	7c 2d                	jl     80f41c <do_write+0x3e>
    if ((msg->conn->pcb.tcp != NULL) && (msg->conn->type == NETCONN_TCP)) {
  80f3ef:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80f3f3:	74 23                	je     80f418 <do_write+0x3a>
  80f3f5:	83 38 10             	cmpl   $0x10,(%eax)
  80f3f8:	75 1e                	jne    80f418 <do_write+0x3a>
#if LWIP_TCP
      msg->conn->state = NETCONN_WRITE;
  80f3fa:	c7 40 04 01 00 00 00 	movl   $0x1,0x4(%eax)
      /* set all the variables used by do_writemore */
      msg->conn->write_msg = msg;
  80f401:	8b 02                	mov    (%edx),%eax
  80f403:	89 50 24             	mov    %edx,0x24(%eax)
      msg->conn->write_offset = 0;
  80f406:	8b 02                	mov    (%edx),%eax
  80f408:	c7 40 28 00 00 00 00 	movl   $0x0,0x28(%eax)
        sys_arch_sem_wait(msg->conn->op_completed, 0);
        LOCK_TCPIP_CORE();
        LWIP_ASSERT("state!", msg->conn->state == NETCONN_NONE);
      }
#else
      do_writemore(msg->conn);
  80f40f:	8b 02                	mov    (%edx),%eax
  80f411:	e8 57 fd ff ff       	call   80f16d <do_writemore>
#endif
      /* for both cases: if do_writemore was called, don't ACK the APIMSG! */
      return;
  80f416:	eb 11                	jmp    80f429 <do_write+0x4b>
#endif /* LWIP_TCP */
#if (LWIP_UDP || LWIP_RAW)
    } else {
      msg->conn->err = ERR_VAL;
  80f418:	c6 40 0c f7          	movb   $0xf7,0xc(%eax)
#endif /* (LWIP_UDP || LWIP_RAW) */
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f41c:	8b 02                	mov    (%edx),%eax
  80f41e:	8b 40 10             	mov    0x10(%eax),%eax
  80f421:	89 04 24             	mov    %eax,(%esp)
  80f424:	e8 fe e7 ff ff       	call   80dc27 <sys_sem_signal>
}
  80f429:	c9                   	leave  
  80f42a:	c3                   	ret    

0080f42b <do_recv>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_recv(struct api_msg_msg *msg)
{
  80f42b:	55                   	push   %ebp
  80f42c:	89 e5                	mov    %esp,%ebp
  80f42e:	53                   	push   %ebx
  80f42f:	83 ec 14             	sub    $0x14,%esp
  80f432:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f435:	8b 03                	mov    (%ebx),%eax
  80f437:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f43b:	7c 1c                	jl     80f459 <do_recv+0x2e>
    if (msg->conn->pcb.tcp != NULL) {
  80f43d:	8b 50 08             	mov    0x8(%eax),%edx
  80f440:	85 d2                	test   %edx,%edx
  80f442:	74 15                	je     80f459 <do_recv+0x2e>
      if (msg->conn->type == NETCONN_TCP) {
  80f444:	83 38 10             	cmpl   $0x10,(%eax)
  80f447:	75 10                	jne    80f459 <do_recv+0x2e>
        if (msg->conn->pcb.tcp->state == LISTEN) {
          tcp_accepted(msg->conn->pcb.tcp);
        } else
#endif /* TCP_LISTEN_BACKLOG */
        {
          tcp_recved(msg->conn->pcb.tcp, msg->msg.r.len);
  80f449:	0f b7 43 04          	movzwl 0x4(%ebx),%eax
  80f44d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f451:	89 14 24             	mov    %edx,(%esp)
  80f454:	e8 1d 95 ff ff       	call   808976 <tcp_recved>
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f459:	8b 03                	mov    (%ebx),%eax
  80f45b:	8b 40 10             	mov    0x10(%eax),%eax
  80f45e:	89 04 24             	mov    %eax,(%esp)
  80f461:	e8 c1 e7 ff ff       	call   80dc27 <sys_sem_signal>
}
  80f466:	83 c4 14             	add    $0x14,%esp
  80f469:	5b                   	pop    %ebx
  80f46a:	5d                   	pop    %ebp
  80f46b:	c3                   	ret    

0080f46c <do_send>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_send(struct api_msg_msg *msg)
{
  80f46c:	55                   	push   %ebp
  80f46d:	89 e5                	mov    %esp,%ebp
  80f46f:	83 ec 28             	sub    $0x28,%esp
  80f472:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f475:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f478:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f47b:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f47e:	8b 1e                	mov    (%esi),%ebx
  80f480:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f484:	0f 8c 8b 00 00 00    	jl     80f515 <do_send+0xa9>
    if (msg->conn->pcb.tcp != NULL) {
  80f48a:	8b 43 08             	mov    0x8(%ebx),%eax
  80f48d:	85 c0                	test   %eax,%eax
  80f48f:	0f 84 80 00 00 00    	je     80f515 <do_send+0xa9>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f495:	8b 13                	mov    (%ebx),%edx
  80f497:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f49d:	83 fa 20             	cmp    $0x20,%edx
  80f4a0:	74 39                	je     80f4db <do_send+0x6f>
  80f4a2:	83 fa 40             	cmp    $0x40,%edx
  80f4a5:	75 6e                	jne    80f515 <do_send+0xa9>
#if LWIP_RAW
      case NETCONN_RAW:
        if (msg->msg.b->addr == NULL) {
  80f4a7:	8b 56 04             	mov    0x4(%esi),%edx
  80f4aa:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f4ad:	85 c9                	test   %ecx,%ecx
  80f4af:	75 13                	jne    80f4c4 <do_send+0x58>
          msg->conn->err = raw_send(msg->conn->pcb.raw, msg->msg.b->p);
  80f4b1:	8b 12                	mov    (%edx),%edx
  80f4b3:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f4b7:	89 04 24             	mov    %eax,(%esp)
  80f4ba:	e8 43 27 00 00       	call   811c02 <raw_send>
  80f4bf:	88 43 0c             	mov    %al,0xc(%ebx)
  80f4c2:	eb 51                	jmp    80f515 <do_send+0xa9>
        } else {
          msg->conn->err = raw_sendto(msg->conn->pcb.raw, msg->msg.b->p, msg->msg.b->addr);
  80f4c4:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f4c8:	8b 12                	mov    (%edx),%edx
  80f4ca:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f4ce:	89 04 24             	mov    %eax,(%esp)
  80f4d1:	e8 22 26 00 00       	call   811af8 <raw_sendto>
  80f4d6:	88 43 0c             	mov    %al,0xc(%ebx)
  80f4d9:	eb 3a                	jmp    80f515 <do_send+0xa9>
        }
        break;
#endif
#if LWIP_UDP
      case NETCONN_UDP:
        if (msg->msg.b->addr == NULL) {
  80f4db:	8b 56 04             	mov    0x4(%esi),%edx
  80f4de:	8b 4a 08             	mov    0x8(%edx),%ecx
  80f4e1:	85 c9                	test   %ecx,%ecx
  80f4e3:	75 13                	jne    80f4f8 <do_send+0x8c>
          msg->conn->err = udp_send(msg->conn->pcb.udp, msg->msg.b->p);
  80f4e5:	8b 12                	mov    (%edx),%edx
  80f4e7:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f4eb:	89 04 24             	mov    %eax,(%esp)
  80f4ee:	e8 eb cf ff ff       	call   80c4de <udp_send>
  80f4f3:	88 43 0c             	mov    %al,0xc(%ebx)
  80f4f6:	eb 1d                	jmp    80f515 <do_send+0xa9>
        } else {
          msg->conn->err = udp_sendto(msg->conn->pcb.udp, msg->msg.b->p, msg->msg.b->addr, msg->msg.b->port);
  80f4f8:	0f b7 7a 0c          	movzwl 0xc(%edx),%edi
  80f4fc:	89 7c 24 0c          	mov    %edi,0xc(%esp)
  80f500:	89 4c 24 08          	mov    %ecx,0x8(%esp)
  80f504:	8b 12                	mov    (%edx),%edx
  80f506:	89 54 24 04          	mov    %edx,0x4(%esp)
  80f50a:	89 04 24             	mov    %eax,(%esp)
  80f50d:	e8 7b cf ff ff       	call   80c48d <udp_sendto>
  80f512:	88 43 0c             	mov    %al,0xc(%ebx)
      default:
        break;
      }
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f515:	8b 06                	mov    (%esi),%eax
  80f517:	8b 40 10             	mov    0x10(%eax),%eax
  80f51a:	89 04 24             	mov    %eax,(%esp)
  80f51d:	e8 05 e7 ff ff       	call   80dc27 <sys_sem_signal>
}
  80f522:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f525:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f528:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f52b:	89 ec                	mov    %ebp,%esp
  80f52d:	5d                   	pop    %ebp
  80f52e:	c3                   	ret    

0080f52f <do_listen>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_listen(struct api_msg_msg *msg)
{
  80f52f:	55                   	push   %ebp
  80f530:	89 e5                	mov    %esp,%ebp
  80f532:	83 ec 28             	sub    $0x28,%esp
  80f535:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80f538:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80f53b:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80f53e:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_TCP
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f541:	8b 03                	mov    (%ebx),%eax
  80f543:	80 78 0c fc          	cmpb   $0xfc,0xc(%eax)
  80f547:	0f 8c b9 00 00 00    	jl     80f606 <do_listen+0xd7>
    if (msg->conn->pcb.tcp != NULL) {
  80f54d:	8b 50 08             	mov    0x8(%eax),%edx
  80f550:	85 d2                	test   %edx,%edx
  80f552:	0f 84 ae 00 00 00    	je     80f606 <do_listen+0xd7>
      if (msg->conn->type == NETCONN_TCP) {
  80f558:	83 38 10             	cmpl   $0x10,(%eax)
  80f55b:	0f 85 a5 00 00 00    	jne    80f606 <do_listen+0xd7>
        if (msg->conn->pcb.tcp->state == CLOSED) {
  80f561:	83 7a 10 00          	cmpl   $0x0,0x10(%edx)
  80f565:	0f 85 97 00 00 00    	jne    80f602 <do_listen+0xd3>
#if TCP_LISTEN_BACKLOG
          struct tcp_pcb* lpcb = tcp_listen_with_backlog(msg->conn->pcb.tcp, msg->msg.lb.backlog);
#else  /* TCP_LISTEN_BACKLOG */
          struct tcp_pcb* lpcb = tcp_listen(msg->conn->pcb.tcp);
  80f56b:	c7 44 24 04 ff 00 00 	movl   $0xff,0x4(%esp)
  80f572:	00 
  80f573:	89 14 24             	mov    %edx,(%esp)
  80f576:	e8 3e 97 ff ff       	call   808cb9 <tcp_listen_with_backlog>
  80f57b:	89 c6                	mov    %eax,%esi
#endif /* TCP_LISTEN_BACKLOG */
          if (lpcb == NULL) {
  80f57d:	85 c0                	test   %eax,%eax
  80f57f:	75 08                	jne    80f589 <do_listen+0x5a>
            msg->conn->err = ERR_MEM;
  80f581:	8b 03                	mov    (%ebx),%eax
  80f583:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80f587:	eb 7d                	jmp    80f606 <do_listen+0xd7>
          } else {
            /* delete the recvmbox and allocate the acceptmbox */
            if (msg->conn->recvmbox != SYS_MBOX_NULL) {
  80f589:	8b 03                	mov    (%ebx),%eax
  80f58b:	8b 40 14             	mov    0x14(%eax),%eax
  80f58e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f591:	74 11                	je     80f5a4 <do_listen+0x75>
              /** @todo: should we drain the recvmbox here? */
              sys_mbox_free(msg->conn->recvmbox);
  80f593:	89 04 24             	mov    %eax,(%esp)
  80f596:	e8 bc e0 ff ff       	call   80d657 <sys_mbox_free>
              msg->conn->recvmbox = SYS_MBOX_NULL;
  80f59b:	8b 03                	mov    (%ebx),%eax
  80f59d:	c7 40 14 ff ff ff ff 	movl   $0xffffffff,0x14(%eax)
            }
            if (msg->conn->acceptmbox == SYS_MBOX_NULL) {
  80f5a4:	8b 3b                	mov    (%ebx),%edi
  80f5a6:	83 7f 18 ff          	cmpl   $0xffffffff,0x18(%edi)
  80f5aa:	75 1a                	jne    80f5c6 <do_listen+0x97>
              if ((msg->conn->acceptmbox = sys_mbox_new(DEFAULT_ACCEPTMBOX_SIZE)) == SYS_MBOX_NULL) {
  80f5ac:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80f5b3:	e8 57 e5 ff ff       	call   80db0f <sys_mbox_new>
  80f5b8:	89 47 18             	mov    %eax,0x18(%edi)
  80f5bb:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f5be:	75 06                	jne    80f5c6 <do_listen+0x97>
                msg->conn->err = ERR_MEM;
  80f5c0:	8b 03                	mov    (%ebx),%eax
  80f5c2:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
              }
            }
            if (msg->conn->err == ERR_OK) {
  80f5c6:	8b 03                	mov    (%ebx),%eax
  80f5c8:	80 78 0c 00          	cmpb   $0x0,0xc(%eax)
  80f5cc:	75 38                	jne    80f606 <do_listen+0xd7>
              msg->conn->state = NETCONN_LISTEN;
  80f5ce:	c7 40 04 02 00 00 00 	movl   $0x2,0x4(%eax)
              msg->conn->pcb.tcp = lpcb;
  80f5d5:	8b 03                	mov    (%ebx),%eax
  80f5d7:	89 70 08             	mov    %esi,0x8(%eax)
              tcp_arg(msg->conn->pcb.tcp, msg->conn);
  80f5da:	8b 03                	mov    (%ebx),%eax
  80f5dc:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f5e0:	8b 40 08             	mov    0x8(%eax),%eax
  80f5e3:	89 04 24             	mov    %eax,(%esp)
  80f5e6:	e8 db 92 ff ff       	call   8088c6 <tcp_arg>
              tcp_accept(msg->conn->pcb.tcp, accept_function);
  80f5eb:	c7 44 24 04 04 fc 80 	movl   $0x80fc04,0x4(%esp)
  80f5f2:	00 
  80f5f3:	8b 03                	mov    (%ebx),%eax
  80f5f5:	8b 40 08             	mov    0x8(%eax),%eax
  80f5f8:	89 04 24             	mov    %eax,(%esp)
  80f5fb:	e8 07 93 ff ff       	call   808907 <tcp_accept>
  80f600:	eb 04                	jmp    80f606 <do_listen+0xd7>
            }
          }
        } else {
          msg->conn->err = ERR_CONN;
  80f602:	c6 40 0c f8          	movb   $0xf8,0xc(%eax)
        }
      }
    }
  }
#endif /* LWIP_TCP */
  TCPIP_APIMSG_ACK(msg);
  80f606:	8b 03                	mov    (%ebx),%eax
  80f608:	8b 40 10             	mov    0x10(%eax),%eax
  80f60b:	89 04 24             	mov    %eax,(%esp)
  80f60e:	e8 14 e6 ff ff       	call   80dc27 <sys_sem_signal>
}
  80f613:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80f616:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80f619:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80f61c:	89 ec                	mov    %ebp,%esp
  80f61e:	5d                   	pop    %ebp
  80f61f:	c3                   	ret    

0080f620 <recv_tcp>:
 *
 * @see tcp.h (struct tcp_pcb.recv) for parameters and return value
 */
static err_t
recv_tcp(void *arg, struct tcp_pcb *pcb, struct pbuf *p, err_t err)
{
  80f620:	55                   	push   %ebp
  80f621:	89 e5                	mov    %esp,%ebp
  80f623:	83 ec 18             	sub    $0x18,%esp
  80f626:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f629:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f62c:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80f62f:	8b 45 0c             	mov    0xc(%ebp),%eax
  80f632:	8b 75 10             	mov    0x10(%ebp),%esi
  80f635:	0f b6 55 14          	movzbl 0x14(%ebp),%edx
  struct netconn *conn;
  u16_t len;

  LWIP_UNUSED_ARG(pcb);
  LWIP_ASSERT("recv_tcp must have a pcb argument", pcb != NULL);
  80f639:	85 c0                	test   %eax,%eax
  80f63b:	75 1c                	jne    80f659 <recv_tcp+0x39>
  80f63d:	c7 44 24 08 f0 4d 81 	movl   $0x814df0,0x8(%esp)
  80f644:	00 
  80f645:	c7 44 24 04 c1 00 00 	movl   $0xc1,0x4(%esp)
  80f64c:	00 
  80f64d:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f654:	e8 7b 13 ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("recv_tcp must have an argument", arg != NULL);
  80f659:	85 db                	test   %ebx,%ebx
  80f65b:	75 1c                	jne    80f679 <recv_tcp+0x59>
  80f65d:	c7 44 24 08 14 4e 81 	movl   $0x814e14,0x8(%esp)
  80f664:	00 
  80f665:	c7 44 24 04 c2 00 00 	movl   $0xc2,0x4(%esp)
  80f66c:	00 
  80f66d:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f674:	e8 5b 13 ff ff       	call   8009d4 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_tcp: recv for wrong pcb!", conn->pcb.tcp == pcb);
  80f679:	39 43 08             	cmp    %eax,0x8(%ebx)
  80f67c:	74 1c                	je     80f69a <recv_tcp+0x7a>
  80f67e:	c7 44 24 08 6b 4d 81 	movl   $0x814d6b,0x8(%esp)
  80f685:	00 
  80f686:	c7 44 24 04 c4 00 00 	movl   $0xc4,0x4(%esp)
  80f68d:	00 
  80f68e:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f695:	e8 3a 13 ff ff       	call   8009d4 <_panic>

  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80f69a:	85 db                	test   %ebx,%ebx
  80f69c:	74 4c                	je     80f6ea <recv_tcp+0xca>
  80f69e:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f6a2:	74 46                	je     80f6ea <recv_tcp+0xca>
    return ERR_VAL;
  }

  conn->err = err;
  80f6a4:	88 53 0c             	mov    %dl,0xc(%ebx)
  if (p != NULL) {
  80f6a7:	b8 00 00 00 00       	mov    $0x0,%eax
  80f6ac:	85 f6                	test   %esi,%esi
  80f6ae:	74 08                	je     80f6b8 <recv_tcp+0x98>
    len = p->tot_len;
  80f6b0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
    SYS_ARCH_INC(conn->recv_avail, len);
  80f6b4:	66 01 43 20          	add    %ax,0x20(%ebx)
  } else {
    len = 0;
  }
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, len);
  80f6b8:	8b 53 2c             	mov    0x2c(%ebx),%edx
  80f6bb:	85 d2                	test   %edx,%edx
  80f6bd:	74 14                	je     80f6d3 <recv_tcp+0xb3>
  80f6bf:	0f b7 c0             	movzwl %ax,%eax
  80f6c2:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f6c6:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f6cd:	00 
  80f6ce:	89 1c 24             	mov    %ebx,(%esp)
  80f6d1:	ff d2                	call   *%edx
  if (sys_mbox_trypost(conn->recvmbox, p) != ERR_OK) {
  80f6d3:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f6d7:	8b 43 14             	mov    0x14(%ebx),%eax
  80f6da:	89 04 24             	mov    %eax,(%esp)
  80f6dd:	e8 d6 e6 ff ff       	call   80ddb8 <sys_mbox_trypost>
  80f6e2:	3c 01                	cmp    $0x1,%al
  80f6e4:	19 c0                	sbb    %eax,%eax
  80f6e6:	f7 d0                	not    %eax
  80f6e8:	eb 05                	jmp    80f6ef <recv_tcp+0xcf>
  80f6ea:	b8 f7 ff ff ff       	mov    $0xfffffff7,%eax
    return ERR_MEM;
  }

  return ERR_OK;
}
  80f6ef:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f6f2:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f6f5:	89 ec                	mov    %ebp,%esp
  80f6f7:	5d                   	pop    %ebp
  80f6f8:	c3                   	ret    

0080f6f9 <do_disconnect>:
 *
 * @param msg the api_msg_msg pointing to the connection to disconnect
 */
void
do_disconnect(struct api_msg_msg *msg)
{
  80f6f9:	55                   	push   %ebp
  80f6fa:	89 e5                	mov    %esp,%ebp
  80f6fc:	53                   	push   %ebx
  80f6fd:	83 ec 14             	sub    $0x14,%esp
  80f700:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_UDP
  if (NETCONNTYPE_GROUP(msg->conn->type) == NETCONN_UDP) {
  80f703:	8b 03                	mov    (%ebx),%eax
  80f705:	8b 10                	mov    (%eax),%edx
  80f707:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f70d:	83 fa 20             	cmp    $0x20,%edx
  80f710:	75 0b                	jne    80f71d <do_disconnect+0x24>
    udp_disconnect(msg->conn->pcb.udp);
  80f712:	8b 40 08             	mov    0x8(%eax),%eax
  80f715:	89 04 24             	mov    %eax,(%esp)
  80f718:	e8 c3 c9 ff ff       	call   80c0e0 <udp_disconnect>
  }
#endif /* LWIP_UDP */
  TCPIP_APIMSG_ACK(msg);
  80f71d:	8b 03                	mov    (%ebx),%eax
  80f71f:	8b 40 10             	mov    0x10(%eax),%eax
  80f722:	89 04 24             	mov    %eax,(%esp)
  80f725:	e8 fd e4 ff ff       	call   80dc27 <sys_sem_signal>
}
  80f72a:	83 c4 14             	add    $0x14,%esp
  80f72d:	5b                   	pop    %ebx
  80f72e:	5d                   	pop    %ebp
  80f72f:	c3                   	ret    

0080f730 <do_connect>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to connect to
 */
void
do_connect(struct api_msg_msg *msg)
{
  80f730:	55                   	push   %ebp
  80f731:	89 e5                	mov    %esp,%ebp
  80f733:	56                   	push   %esi
  80f734:	53                   	push   %ebx
  80f735:	83 ec 10             	sub    $0x10,%esp
  80f738:	8b 75 08             	mov    0x8(%ebp),%esi
  if (msg->conn->pcb.tcp == NULL) {
  80f73b:	8b 1e                	mov    (%esi),%ebx
  80f73d:	8b 53 08             	mov    0x8(%ebx),%edx
  80f740:	85 d2                	test   %edx,%edx
  80f742:	75 10                	jne    80f754 <do_connect+0x24>
    sys_sem_signal(msg->conn->op_completed);
  80f744:	8b 43 10             	mov    0x10(%ebx),%eax
  80f747:	89 04 24             	mov    %eax,(%esp)
  80f74a:	e8 d8 e4 ff ff       	call   80dc27 <sys_sem_signal>
    return;
  80f74f:	e9 9d 00 00 00       	jmp    80f7f1 <do_connect+0xc1>
  }

  switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f754:	8b 03                	mov    (%ebx),%eax
  80f756:	25 f0 00 00 00       	and    $0xf0,%eax
  80f75b:	83 f8 20             	cmp    $0x20,%eax
  80f75e:	74 33                	je     80f793 <do_connect+0x63>
  80f760:	83 f8 40             	cmp    $0x40,%eax
  80f763:	74 0d                	je     80f772 <do_connect+0x42>
  80f765:	83 f8 10             	cmp    $0x10,%eax
  80f768:	0f 85 83 00 00 00    	jne    80f7f1 <do_connect+0xc1>
  80f76e:	66 90                	xchg   %ax,%ax
  80f770:	eb 4a                	jmp    80f7bc <do_connect+0x8c>
#if LWIP_RAW
  case NETCONN_RAW:
    msg->conn->err = raw_connect(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f772:	8b 46 04             	mov    0x4(%esi),%eax
  80f775:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f779:	89 14 24             	mov    %edx,(%esp)
  80f77c:	e8 9c 22 00 00       	call   811a1d <raw_connect>
  80f781:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f784:	8b 06                	mov    (%esi),%eax
  80f786:	8b 40 10             	mov    0x10(%eax),%eax
  80f789:	89 04 24             	mov    %eax,(%esp)
  80f78c:	e8 96 e4 ff ff       	call   80dc27 <sys_sem_signal>
    break;
  80f791:	eb 5e                	jmp    80f7f1 <do_connect+0xc1>
#endif /* LWIP_RAW */
#if LWIP_UDP
  case NETCONN_UDP:
    msg->conn->err = udp_connect(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f793:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f797:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f79b:	8b 46 04             	mov    0x4(%esi),%eax
  80f79e:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7a2:	89 14 24             	mov    %edx,(%esp)
  80f7a5:	e8 b4 ca ff ff       	call   80c25e <udp_connect>
  80f7aa:	88 43 0c             	mov    %al,0xc(%ebx)
    sys_sem_signal(msg->conn->op_completed);
  80f7ad:	8b 06                	mov    (%esi),%eax
  80f7af:	8b 40 10             	mov    0x10(%eax),%eax
  80f7b2:	89 04 24             	mov    %eax,(%esp)
  80f7b5:	e8 6d e4 ff ff       	call   80dc27 <sys_sem_signal>
    break;
  80f7ba:	eb 35                	jmp    80f7f1 <do_connect+0xc1>
#endif /* LWIP_UDP */
#if LWIP_TCP
  case NETCONN_TCP:
    msg->conn->state = NETCONN_CONNECT;
  80f7bc:	c7 43 04 03 00 00 00 	movl   $0x3,0x4(%ebx)
    setup_tcp(msg->conn);
  80f7c3:	8b 06                	mov    (%esi),%eax
  80f7c5:	e8 de f5 ff ff       	call   80eda8 <setup_tcp>
    msg->conn->err = tcp_connect(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port,
  80f7ca:	8b 1e                	mov    (%esi),%ebx
  80f7cc:	c7 44 24 0c 0c ee 80 	movl   $0x80ee0c,0xc(%esp)
  80f7d3:	00 
  80f7d4:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f7d8:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f7dc:	8b 46 04             	mov    0x4(%esi),%eax
  80f7df:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f7e3:	8b 43 08             	mov    0x8(%ebx),%eax
  80f7e6:	89 04 24             	mov    %eax,(%esp)
  80f7e9:	e8 15 97 ff ff       	call   808f03 <tcp_connect>
  80f7ee:	88 43 0c             	mov    %al,0xc(%ebx)
    break;
#endif /* LWIP_TCP */
  default:
    break;
  }
}
  80f7f1:	83 c4 10             	add    $0x10,%esp
  80f7f4:	5b                   	pop    %ebx
  80f7f5:	5e                   	pop    %esi
  80f7f6:	5d                   	pop    %ebp
  80f7f7:	c3                   	ret    

0080f7f8 <do_bind>:
 * @param msg the api_msg_msg pointing to the connection and containing
 *            the IP address and port to bind to
 */
void
do_bind(struct api_msg_msg *msg)
{
  80f7f8:	55                   	push   %ebp
  80f7f9:	89 e5                	mov    %esp,%ebp
  80f7fb:	83 ec 18             	sub    $0x18,%esp
  80f7fe:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80f801:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80f804:	8b 75 08             	mov    0x8(%ebp),%esi
  if (!ERR_IS_FATAL(msg->conn->err)) {
  80f807:	8b 1e                	mov    (%esi),%ebx
  80f809:	80 7b 0c fc          	cmpb   $0xfc,0xc(%ebx)
  80f80d:	7c 73                	jl     80f882 <do_bind+0x8a>
    if (msg->conn->pcb.tcp != NULL) {
  80f80f:	8b 53 08             	mov    0x8(%ebx),%edx
  80f812:	85 d2                	test   %edx,%edx
  80f814:	74 68                	je     80f87e <do_bind+0x86>
      switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f816:	8b 03                	mov    (%ebx),%eax
  80f818:	25 f0 00 00 00       	and    $0xf0,%eax
  80f81d:	83 f8 20             	cmp    $0x20,%eax
  80f820:	74 24                	je     80f846 <do_bind+0x4e>
  80f822:	83 f8 40             	cmp    $0x40,%eax
  80f825:	74 0b                	je     80f832 <do_bind+0x3a>
  80f827:	83 f8 10             	cmp    $0x10,%eax
  80f82a:	75 56                	jne    80f882 <do_bind+0x8a>
  80f82c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f830:	eb 30                	jmp    80f862 <do_bind+0x6a>
#if LWIP_RAW
      case NETCONN_RAW:
        msg->conn->err = raw_bind(msg->conn->pcb.raw, msg->msg.bc.ipaddr);
  80f832:	8b 46 04             	mov    0x4(%esi),%eax
  80f835:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f839:	89 14 24             	mov    %edx,(%esp)
  80f83c:	e8 bf 21 00 00       	call   811a00 <raw_bind>
  80f841:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f844:	eb 3c                	jmp    80f882 <do_bind+0x8a>
#endif /* LWIP_RAW */
#if LWIP_UDP
      case NETCONN_UDP:
        msg->conn->err = udp_bind(msg->conn->pcb.udp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f846:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f84a:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f84e:	8b 46 04             	mov    0x4(%esi),%eax
  80f851:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f855:	89 14 24             	mov    %edx,(%esp)
  80f858:	e8 3b c9 ff ff       	call   80c198 <udp_bind>
  80f85d:	88 43 0c             	mov    %al,0xc(%ebx)
        break;
  80f860:	eb 20                	jmp    80f882 <do_bind+0x8a>
#endif /* LWIP_UDP */
#if LWIP_TCP
      case NETCONN_TCP:
        msg->conn->err = tcp_bind(msg->conn->pcb.tcp, msg->msg.bc.ipaddr, msg->msg.bc.port);
  80f862:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80f866:	89 44 24 08          	mov    %eax,0x8(%esp)
  80f86a:	8b 46 04             	mov    0x4(%esi),%eax
  80f86d:	89 44 24 04          	mov    %eax,0x4(%esp)
  80f871:	89 14 24             	mov    %edx,(%esp)
  80f874:	e8 45 95 ff ff       	call   808dbe <tcp_bind>
  80f879:	88 43 0c             	mov    %al,0xc(%ebx)
  80f87c:	eb 04                	jmp    80f882 <do_bind+0x8a>
      default:
        break;
      }
    } else {
      /* msg->conn->pcb is NULL */
      msg->conn->err = ERR_VAL;
  80f87e:	c6 43 0c f7          	movb   $0xf7,0xc(%ebx)
    }
  }
  TCPIP_APIMSG_ACK(msg);
  80f882:	8b 06                	mov    (%esi),%eax
  80f884:	8b 40 10             	mov    0x10(%eax),%eax
  80f887:	89 04 24             	mov    %eax,(%esp)
  80f88a:	e8 98 e3 ff ff       	call   80dc27 <sys_sem_signal>
}
  80f88f:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80f892:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80f895:	89 ec                	mov    %ebp,%esp
  80f897:	5d                   	pop    %ebp
  80f898:	c3                   	ret    

0080f899 <do_delconn>:
 *
 * @param msg the api_msg_msg pointing to the connection
 */
void
do_delconn(struct api_msg_msg *msg)
{
  80f899:	55                   	push   %ebp
  80f89a:	89 e5                	mov    %esp,%ebp
  80f89c:	53                   	push   %ebx
  80f89d:	83 ec 14             	sub    $0x14,%esp
  80f8a0:	8b 5d 08             	mov    0x8(%ebp),%ebx
  if (msg->conn->pcb.tcp != NULL) {
  80f8a3:	8b 03                	mov    (%ebx),%eax
  80f8a5:	8b 48 08             	mov    0x8(%eax),%ecx
  80f8a8:	85 c9                	test   %ecx,%ecx
  80f8aa:	74 51                	je     80f8fd <do_delconn+0x64>
    switch (NETCONNTYPE_GROUP(msg->conn->type)) {
  80f8ac:	8b 10                	mov    (%eax),%edx
  80f8ae:	81 e2 f0 00 00 00    	and    $0xf0,%edx
  80f8b4:	83 fa 20             	cmp    $0x20,%edx
  80f8b7:	74 1e                	je     80f8d7 <do_delconn+0x3e>
  80f8b9:	83 fa 40             	cmp    $0x40,%edx
  80f8bc:	74 0c                	je     80f8ca <do_delconn+0x31>
  80f8be:	83 fa 10             	cmp    $0x10,%edx
  80f8c1:	75 3a                	jne    80f8fd <do_delconn+0x64>
  80f8c3:	90                   	nop
  80f8c4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f8c8:	eb 23                	jmp    80f8ed <do_delconn+0x54>
#if LWIP_RAW
    case NETCONN_RAW:
      raw_remove(msg->conn->pcb.raw);
  80f8ca:	89 0c 24             	mov    %ecx,(%esp)
  80f8cd:	8d 76 00             	lea    0x0(%esi),%esi
  80f8d0:	e8 d7 21 00 00       	call   811aac <raw_remove>
      break;
  80f8d5:	eb 26                	jmp    80f8fd <do_delconn+0x64>
#endif /* LWIP_RAW */
#if LWIP_UDP
    case NETCONN_UDP:
      msg->conn->pcb.udp->recv_arg = NULL;
  80f8d7:	c7 41 1c 00 00 00 00 	movl   $0x0,0x1c(%ecx)
      udp_remove(msg->conn->pcb.udp);
  80f8de:	8b 03                	mov    (%ebx),%eax
  80f8e0:	8b 40 08             	mov    0x8(%eax),%eax
  80f8e3:	89 04 24             	mov    %eax,(%esp)
  80f8e6:	e8 61 c8 ff ff       	call   80c14c <udp_remove>
      break;
  80f8eb:	eb 10                	jmp    80f8fd <do_delconn+0x64>
#endif /* LWIP_UDP */
#if LWIP_TCP
    case NETCONN_TCP:
      msg->conn->state = NETCONN_CLOSE;
  80f8ed:	c7 40 04 04 00 00 00 	movl   $0x4,0x4(%eax)
      do_close_internal(msg->conn);
  80f8f4:	8b 03                	mov    (%ebx),%eax
  80f8f6:	e8 58 f5 ff ff       	call   80ee53 <do_close_internal>
      /* API_EVENT is called inside do_close_internal, before releasing
         the application thread, so we can return at this point! */
      return;
  80f8fb:	eb 4e                	jmp    80f94b <do_delconn+0xb2>
  }
  /* tcp netconns don't come here! */

  /* Trigger select() in socket layer. This send should something else so the
     errorfd is set, not the read and write fd! */
  API_EVENT(msg->conn, NETCONN_EVT_RCVPLUS, 0);
  80f8fd:	8b 13                	mov    (%ebx),%edx
  80f8ff:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f902:	85 c0                	test   %eax,%eax
  80f904:	74 33                	je     80f939 <do_delconn+0xa0>
  80f906:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f90d:	00 
  80f90e:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80f915:	00 
  80f916:	89 14 24             	mov    %edx,(%esp)
  80f919:	ff d0                	call   *%eax
  API_EVENT(msg->conn, NETCONN_EVT_SENDPLUS, 0);
  80f91b:	8b 13                	mov    (%ebx),%edx
  80f91d:	8b 42 2c             	mov    0x2c(%edx),%eax
  80f920:	85 c0                	test   %eax,%eax
  80f922:	74 15                	je     80f939 <do_delconn+0xa0>
  80f924:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80f92b:	00 
  80f92c:	c7 44 24 04 02 00 00 	movl   $0x2,0x4(%esp)
  80f933:	00 
  80f934:	89 14 24             	mov    %edx,(%esp)
  80f937:	ff d0                	call   *%eax

  if (msg->conn->op_completed != SYS_SEM_NULL) {
  80f939:	8b 03                	mov    (%ebx),%eax
  80f93b:	8b 40 10             	mov    0x10(%eax),%eax
  80f93e:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f941:	74 08                	je     80f94b <do_delconn+0xb2>
    sys_sem_signal(msg->conn->op_completed);
  80f943:	89 04 24             	mov    %eax,(%esp)
  80f946:	e8 dc e2 ff ff       	call   80dc27 <sys_sem_signal>
  }
}
  80f94b:	83 c4 14             	add    $0x14,%esp
  80f94e:	5b                   	pop    %ebx
  80f94f:	5d                   	pop    %ebp
  80f950:	c3                   	ret    

0080f951 <netconn_free>:
 *
 * @param conn the netconn to free
 */
void
netconn_free(struct netconn *conn)
{
  80f951:	55                   	push   %ebp
  80f952:	89 e5                	mov    %esp,%ebp
  80f954:	56                   	push   %esi
  80f955:	53                   	push   %ebx
  80f956:	83 ec 20             	sub    $0x20,%esp
  80f959:	8b 5d 08             	mov    0x8(%ebp),%ebx
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);
  80f95c:	83 7b 08 00          	cmpl   $0x0,0x8(%ebx)
  80f960:	74 1c                	je     80f97e <netconn_free+0x2d>
  80f962:	c7 44 24 08 34 4e 81 	movl   $0x814e34,0x8(%esp)
  80f969:	00 
  80f96a:	c7 44 24 04 26 02 00 	movl   $0x226,0x4(%esp)
  80f971:	00 
  80f972:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80f979:	e8 56 10 ff ff       	call   8009d4 <_panic>

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f97e:	8d 75 f4             	lea    -0xc(%ebp),%esi
{
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
  80f981:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80f985:	75 27                	jne    80f9ae <netconn_free+0x5d>
  80f987:	eb 4b                	jmp    80f9d4 <netconn_free+0x83>
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
      if (conn->type == NETCONN_TCP) {
  80f989:	83 3b 10             	cmpl   $0x10,(%ebx)
  80f98c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80f990:	75 11                	jne    80f9a3 <netconn_free+0x52>
        if(mem != NULL) {
  80f992:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f995:	85 c0                	test   %eax,%eax
  80f997:	74 15                	je     80f9ae <netconn_free+0x5d>
          pbuf_free((struct pbuf *)mem);
  80f999:	89 04 24             	mov    %eax,(%esp)
  80f99c:	e8 b7 85 ff ff       	call   807f58 <pbuf_free>
  80f9a1:	eb 0b                	jmp    80f9ae <netconn_free+0x5d>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
  80f9a3:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f9a6:	89 04 24             	mov    %eax,(%esp)
  80f9a9:	e8 d0 5c ff ff       	call   80567e <netbuf_delete>
  void *mem;
  LWIP_ASSERT("PCB must be deallocated outside this function", conn->pcb.tcp == NULL);

  /* Drain the recvmbox. */
  if (conn->recvmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->recvmbox, &mem) != SYS_MBOX_EMPTY) {
  80f9ae:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f9b2:	8b 43 14             	mov    0x14(%ebx),%eax
  80f9b5:	89 04 24             	mov    %eax,(%esp)
  80f9b8:	e8 d9 e3 ff ff       	call   80dd96 <sys_arch_mbox_tryfetch>
  80f9bd:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f9c0:	75 c7                	jne    80f989 <netconn_free+0x38>
        }
      } else {
        netbuf_delete((struct netbuf *)mem);
      }
    }
    sys_mbox_free(conn->recvmbox);
  80f9c2:	8b 43 14             	mov    0x14(%ebx),%eax
  80f9c5:	89 04 24             	mov    %eax,(%esp)
  80f9c8:	e8 8a dc ff ff       	call   80d657 <sys_mbox_free>
    conn->recvmbox = SYS_MBOX_NULL;
  80f9cd:	c7 43 14 ff ff ff ff 	movl   $0xffffffff,0x14(%ebx)
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f9d4:	8d 75 f4             	lea    -0xc(%ebp),%esi
    sys_mbox_free(conn->recvmbox);
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
  80f9d7:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80f9db:	75 0d                	jne    80f9ea <netconn_free+0x99>
  80f9dd:	eb 31                	jmp    80fa10 <netconn_free+0xbf>
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
      netconn_delete((struct netconn *)mem);
  80f9df:	8b 45 f4             	mov    -0xc(%ebp),%eax
  80f9e2:	89 04 24             	mov    %eax,(%esp)
  80f9e5:	e8 b1 f1 ff ff       	call   80eb9b <netconn_delete>
    conn->recvmbox = SYS_MBOX_NULL;
  }

  /* Drain the acceptmbox. */
  if (conn->acceptmbox != SYS_MBOX_NULL) {
    while (sys_mbox_tryfetch(conn->acceptmbox, &mem) != SYS_MBOX_EMPTY) {
  80f9ea:	89 74 24 04          	mov    %esi,0x4(%esp)
  80f9ee:	8b 43 18             	mov    0x18(%ebx),%eax
  80f9f1:	89 04 24             	mov    %eax,(%esp)
  80f9f4:	e8 9d e3 ff ff       	call   80dd96 <sys_arch_mbox_tryfetch>
  80f9f9:	83 f8 ff             	cmp    $0xffffffff,%eax
  80f9fc:	75 e1                	jne    80f9df <netconn_free+0x8e>
      netconn_delete((struct netconn *)mem);
    }
    sys_mbox_free(conn->acceptmbox);
  80f9fe:	8b 43 18             	mov    0x18(%ebx),%eax
  80fa01:	89 04 24             	mov    %eax,(%esp)
  80fa04:	e8 4e dc ff ff       	call   80d657 <sys_mbox_free>
    conn->acceptmbox = SYS_MBOX_NULL;
  80fa09:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  }

  sys_sem_free(conn->op_completed);
  80fa10:	8b 43 10             	mov    0x10(%ebx),%eax
  80fa13:	89 04 24             	mov    %eax,(%esp)
  80fa16:	e8 c8 db ff ff       	call   80d5e3 <sys_sem_free>
  conn->op_completed = SYS_SEM_NULL;
  80fa1b:	c7 43 10 ff ff ff ff 	movl   $0xffffffff,0x10(%ebx)

  memp_free(MEMP_NETCONN, conn);
  80fa22:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fa26:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fa2d:	e8 8e 7d ff ff       	call   8077c0 <memp_free>
}
  80fa32:	83 c4 20             	add    $0x20,%esp
  80fa35:	5b                   	pop    %ebx
  80fa36:	5e                   	pop    %esi
  80fa37:	5d                   	pop    %ebp
  80fa38:	c3                   	ret    

0080fa39 <recv_udp>:
 * @see udp.h (struct udp_pcb.recv) for parameters
 */
static void
recv_udp(void *arg, struct udp_pcb *pcb, struct pbuf *p,
   struct ip_addr *addr, u16_t port)
{
  80fa39:	55                   	push   %ebp
  80fa3a:	89 e5                	mov    %esp,%ebp
  80fa3c:	83 ec 38             	sub    $0x38,%esp
  80fa3f:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fa42:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fa45:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fa48:	8b 5d 08             	mov    0x8(%ebp),%ebx
  80fa4b:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fa4e:	8b 7d 10             	mov    0x10(%ebp),%edi
  80fa51:	0f b7 55 18          	movzwl 0x18(%ebp),%edx
  80fa55:	66 89 55 e6          	mov    %dx,-0x1a(%ebp)
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(pcb); /* only used for asserts... */
  LWIP_ASSERT("recv_udp must have a pcb argument", pcb != NULL);
  80fa59:	85 c0                	test   %eax,%eax
  80fa5b:	75 1c                	jne    80fa79 <recv_udp+0x40>
  80fa5d:	c7 44 24 08 64 4e 81 	movl   $0x814e64,0x8(%esp)
  80fa64:	00 
  80fa65:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  80fa6c:	00 
  80fa6d:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80fa74:	e8 5b 0f ff ff       	call   8009d4 <_panic>
  LWIP_ASSERT("recv_udp must have an argument", arg != NULL);
  80fa79:	85 db                	test   %ebx,%ebx
  80fa7b:	75 1c                	jne    80fa99 <recv_udp+0x60>
  80fa7d:	c7 44 24 08 88 4e 81 	movl   $0x814e88,0x8(%esp)
  80fa84:	00 
  80fa85:	c7 44 24 04 8f 00 00 	movl   $0x8f,0x4(%esp)
  80fa8c:	00 
  80fa8d:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80fa94:	e8 3b 0f ff ff       	call   8009d4 <_panic>
  conn = arg;
  LWIP_ASSERT("recv_udp: recv for wrong pcb!", conn->pcb.udp == pcb);
  80fa99:	39 43 08             	cmp    %eax,0x8(%ebx)
  80fa9c:	74 1c                	je     80faba <recv_udp+0x81>
  80fa9e:	c7 44 24 08 89 4d 81 	movl   $0x814d89,0x8(%esp)
  80faa5:	00 
  80faa6:	c7 44 24 04 91 00 00 	movl   $0x91,0x4(%esp)
  80faad:	00 
  80faae:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80fab5:	e8 1a 0f ff ff       	call   8009d4 <_panic>
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL) ||
      ((recv_avail + (int)(p->tot_len)) > conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn == NULL) || (conn->recvmbox == SYS_MBOX_NULL)) {
  80faba:	85 db                	test   %ebx,%ebx
  80fabc:	74 06                	je     80fac4 <recv_udp+0x8b>
  80fabe:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80fac2:	75 0e                	jne    80fad2 <recv_udp+0x99>
#endif /* LWIP_SO_RCVBUF */
    pbuf_free(p);
  80fac4:	89 3c 24             	mov    %edi,(%esp)
  80fac7:	e8 8c 84 ff ff       	call   807f58 <pbuf_free>
    return;
  80facc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  80fad0:	eb 6e                	jmp    80fb40 <recv_udp+0x107>
  }

  buf = memp_malloc(MEMP_NETBUF);
  80fad2:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fad9:	e8 26 7d ff ff       	call   807804 <memp_malloc>
  80fade:	89 c6                	mov    %eax,%esi
  if (buf == NULL) {
  80fae0:	85 c0                	test   %eax,%eax
  80fae2:	75 0a                	jne    80faee <recv_udp+0xb5>
    pbuf_free(p);
  80fae4:	89 3c 24             	mov    %edi,(%esp)
  80fae7:	e8 6c 84 ff ff       	call   807f58 <pbuf_free>
    return;
  80faec:	eb 52                	jmp    80fb40 <recv_udp+0x107>
  } else {
    buf->p = p;
  80faee:	89 38                	mov    %edi,(%eax)
    buf->ptr = p;
  80faf0:	89 78 04             	mov    %edi,0x4(%eax)
    buf->addr = addr;
  80faf3:	8b 45 14             	mov    0x14(%ebp),%eax
  80faf6:	89 46 08             	mov    %eax,0x8(%esi)
    buf->port = port;
  80faf9:	0f b7 45 e6          	movzwl -0x1a(%ebp),%eax
  80fafd:	66 89 46 0c          	mov    %ax,0xc(%esi)
  }

  SYS_ARCH_INC(conn->recv_avail, p->tot_len);
  80fb01:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80fb05:	66 01 43 20          	add    %ax,0x20(%ebx)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, p->tot_len);
  80fb09:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fb0c:	85 c0                	test   %eax,%eax
  80fb0e:	74 15                	je     80fb25 <recv_udp+0xec>
  80fb10:	0f b7 57 08          	movzwl 0x8(%edi),%edx
  80fb14:	89 54 24 08          	mov    %edx,0x8(%esp)
  80fb18:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fb1f:	00 
  80fb20:	89 1c 24             	mov    %ebx,(%esp)
  80fb23:	ff d0                	call   *%eax
  if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80fb25:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fb29:	8b 43 14             	mov    0x14(%ebx),%eax
  80fb2c:	89 04 24             	mov    %eax,(%esp)
  80fb2f:	e8 84 e2 ff ff       	call   80ddb8 <sys_mbox_trypost>
  80fb34:	84 c0                	test   %al,%al
  80fb36:	74 08                	je     80fb40 <recv_udp+0x107>
    netbuf_delete(buf);
  80fb38:	89 34 24             	mov    %esi,(%esp)
  80fb3b:	e8 3e 5b ff ff       	call   80567e <netbuf_delete>
    return;
  }
}
  80fb40:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fb43:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fb46:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fb49:	89 ec                	mov    %ebp,%esp
  80fb4b:	5d                   	pop    %ebp
  80fb4c:	c3                   	ret    

0080fb4d <netconn_alloc>:
 * @return a newly allocated struct netconn or
 *         NULL on memory error
 */
struct netconn*
netconn_alloc(enum netconn_type t, netconn_callback callback)
{
  80fb4d:	55                   	push   %ebp
  80fb4e:	89 e5                	mov    %esp,%ebp
  80fb50:	53                   	push   %ebx
  80fb51:	83 ec 14             	sub    $0x14,%esp
  struct netconn *conn;
  int size;

  conn = memp_malloc(MEMP_NETCONN);
  80fb54:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fb5b:	e8 a4 7c ff ff       	call   807804 <memp_malloc>
  80fb60:	89 c3                	mov    %eax,%ebx
  if (conn == NULL) {
  80fb62:	85 c0                	test   %eax,%eax
  80fb64:	0f 84 92 00 00 00    	je     80fbfc <netconn_alloc+0xaf>
    return NULL;
  }

  conn->err = ERR_OK;
  80fb6a:	c6 40 0c 00          	movb   $0x0,0xc(%eax)
  conn->type = t;
  80fb6e:	8b 45 08             	mov    0x8(%ebp),%eax
  80fb71:	89 03                	mov    %eax,(%ebx)
  conn->pcb.tcp = NULL;
  80fb73:	c7 43 08 00 00 00 00 	movl   $0x0,0x8(%ebx)
    LWIP_ASSERT("netconn_alloc: undefined netconn_type", 0);
    break;
  }
#endif

  if ((conn->op_completed = sys_sem_new(0)) == SYS_SEM_NULL) {
  80fb7a:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fb81:	e8 ff de ff ff       	call   80da85 <sys_sem_new>
  80fb86:	89 43 10             	mov    %eax,0x10(%ebx)
  80fb89:	83 f8 ff             	cmp    $0xffffffff,%eax
  80fb8c:	75 17                	jne    80fba5 <netconn_alloc+0x58>
    memp_free(MEMP_NETCONN, conn);
  80fb8e:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fb92:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fb99:	e8 22 7c ff ff       	call   8077c0 <memp_free>
  80fb9e:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80fba3:	eb 57                	jmp    80fbfc <netconn_alloc+0xaf>
  }
  if ((conn->recvmbox = sys_mbox_new(size)) == SYS_MBOX_NULL) {
  80fba5:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  80fbac:	e8 5e df ff ff       	call   80db0f <sys_mbox_new>
  80fbb1:	89 43 14             	mov    %eax,0x14(%ebx)
  80fbb4:	83 f8 ff             	cmp    $0xffffffff,%eax
  80fbb7:	75 22                	jne    80fbdb <netconn_alloc+0x8e>
    sys_sem_free(conn->op_completed);
  80fbb9:	8b 43 10             	mov    0x10(%ebx),%eax
  80fbbc:	89 04 24             	mov    %eax,(%esp)
  80fbbf:	e8 1f da ff ff       	call   80d5e3 <sys_sem_free>
    memp_free(MEMP_NETCONN, conn);
  80fbc4:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  80fbc8:	c7 04 24 07 00 00 00 	movl   $0x7,(%esp)
  80fbcf:	e8 ec 7b ff ff       	call   8077c0 <memp_free>
  80fbd4:	bb 00 00 00 00       	mov    $0x0,%ebx
    return NULL;
  80fbd9:	eb 21                	jmp    80fbfc <netconn_alloc+0xaf>
  }

  conn->acceptmbox   = SYS_MBOX_NULL;
  80fbdb:	c7 43 18 ff ff ff ff 	movl   $0xffffffff,0x18(%ebx)
  conn->state        = NETCONN_NONE;
  80fbe2:	c7 43 04 00 00 00 00 	movl   $0x0,0x4(%ebx)
  /* initialize socket to -1 since 0 is a valid socket */
  conn->socket       = -1;
  80fbe9:	c7 43 1c ff ff ff ff 	movl   $0xffffffff,0x1c(%ebx)
  conn->callback     = callback;
  80fbf0:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fbf3:	89 43 2c             	mov    %eax,0x2c(%ebx)
  conn->recv_avail   = 0;
  80fbf6:	66 c7 43 20 00 00    	movw   $0x0,0x20(%ebx)
#endif /* LWIP_SO_RCVTIMEO */
#if LWIP_SO_RCVBUF
  conn->recv_bufsize = INT_MAX;
#endif /* LWIP_SO_RCVBUF */
  return conn;
}
  80fbfc:	89 d8                	mov    %ebx,%eax
  80fbfe:	83 c4 14             	add    $0x14,%esp
  80fc01:	5b                   	pop    %ebx
  80fc02:	5d                   	pop    %ebp
  80fc03:	c3                   	ret    

0080fc04 <accept_function>:
 *
 * @see tcp.h (struct tcp_pcb_listen.accept) for parameters and return value
 */
static err_t
accept_function(void *arg, struct tcp_pcb *newpcb, err_t err)
{
  80fc04:	55                   	push   %ebp
  80fc05:	89 e5                	mov    %esp,%ebp
  80fc07:	83 ec 28             	sub    $0x28,%esp
  80fc0a:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fc0d:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fc10:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fc13:	0f b6 7d 10          	movzbl 0x10(%ebp),%edi
#if API_MSG_DEBUG
#if TCP_DEBUG
  tcp_debug_print_state(newpcb->state);
#endif /* TCP_DEBUG */
#endif /* API_MSG_DEBUG */
  conn = (struct netconn *)arg;
  80fc17:	8b 5d 08             	mov    0x8(%ebp),%ebx

  LWIP_ERROR("accept_function: invalid conn->acceptmbox",
  80fc1a:	83 7b 18 ff          	cmpl   $0xffffffff,0x18(%ebx)
  80fc1e:	75 1c                	jne    80fc3c <accept_function+0x38>
  80fc20:	c7 44 24 08 a8 4e 81 	movl   $0x814ea8,0x8(%esp)
  80fc27:	00 
  80fc28:	c7 44 24 04 65 01 00 	movl   $0x165,0x4(%esp)
  80fc2f:	00 
  80fc30:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80fc37:	e8 98 0d ff ff       	call   8009d4 <_panic>
             conn->acceptmbox != SYS_MBOX_NULL, return ERR_VAL;);

  /* We have to set the callback here even though
   * the new socket is unknown. conn->socket is marked as -1. */
  newconn = netconn_alloc(conn->type, conn->callback);
  80fc3c:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fc3f:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fc43:	8b 03                	mov    (%ebx),%eax
  80fc45:	89 04 24             	mov    %eax,(%esp)
  80fc48:	e8 00 ff ff ff       	call   80fb4d <netconn_alloc>
  80fc4d:	89 c6                	mov    %eax,%esi
  if (newconn == NULL) {
  80fc4f:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
  80fc54:	85 f6                	test   %esi,%esi
  80fc56:	74 55                	je     80fcad <accept_function+0xa9>
    return ERR_MEM;
  }
  newconn->pcb.tcp = newpcb;
  80fc58:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fc5b:	89 46 08             	mov    %eax,0x8(%esi)
  setup_tcp(newconn);
  80fc5e:	89 f0                	mov    %esi,%eax
  80fc60:	e8 43 f1 ff ff       	call   80eda8 <setup_tcp>
  newconn->err = err;
  80fc65:	89 f8                	mov    %edi,%eax
  80fc67:	88 46 0c             	mov    %al,0xc(%esi)
  /* Register event with callback */
  API_EVENT(conn, NETCONN_EVT_RCVPLUS, 0);
  80fc6a:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fc6d:	85 c0                	test   %eax,%eax
  80fc6f:	74 15                	je     80fc86 <accept_function+0x82>
  80fc71:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fc78:	00 
  80fc79:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fc80:	00 
  80fc81:	89 1c 24             	mov    %ebx,(%esp)
  80fc84:	ff d0                	call   *%eax

  if (sys_mbox_trypost(conn->acceptmbox, newconn) != ERR_OK) {
  80fc86:	89 74 24 04          	mov    %esi,0x4(%esp)
  80fc8a:	8b 43 18             	mov    0x18(%ebx),%eax
  80fc8d:	89 04 24             	mov    %eax,(%esp)
  80fc90:	e8 23 e1 ff ff       	call   80ddb8 <sys_mbox_trypost>
  80fc95:	84 c0                	test   %al,%al
  80fc97:	74 14                	je     80fcad <accept_function+0xa9>
    /* When returning != ERR_OK, the connection is aborted in tcp_process(),
       so do nothing here! */
    newconn->pcb.tcp = NULL;
  80fc99:	c7 46 08 00 00 00 00 	movl   $0x0,0x8(%esi)
    netconn_free(newconn);
  80fca0:	89 34 24             	mov    %esi,(%esp)
  80fca3:	e8 a9 fc ff ff       	call   80f951 <netconn_free>
  80fca8:	b8 ff ff ff ff       	mov    $0xffffffff,%eax
    return ERR_MEM;
  }
  return ERR_OK;
}
  80fcad:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fcb0:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fcb3:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fcb6:	89 ec                	mov    %ebp,%esp
  80fcb8:	5d                   	pop    %ebp
  80fcb9:	c3                   	ret    

0080fcba <do_newconn>:
 *
 * @param msg the api_msg_msg describing the connection type
 */
void
do_newconn(struct api_msg_msg *msg)
{
  80fcba:	55                   	push   %ebp
  80fcbb:	89 e5                	mov    %esp,%ebp
  80fcbd:	83 ec 18             	sub    $0x18,%esp
  80fcc0:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  80fcc3:	89 75 fc             	mov    %esi,-0x4(%ebp)
  80fcc6:	8b 5d 08             	mov    0x8(%ebp),%ebx
   if(msg->conn->pcb.tcp == NULL) {
  80fcc9:	8b 03                	mov    (%ebx),%eax
  80fccb:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80fccf:	0f 85 d5 00 00 00    	jne    80fdaa <do_newconn+0xf0>
 * @return msg->conn->err, but the return value is currently ignored
 */
static err_t
pcb_new(struct api_msg_msg *msg)
{
   msg->conn->err = ERR_OK;
  80fcd5:	c6 40 0c 00          	movb   $0x0,0xc(%eax)

   LWIP_ASSERT("pcb_new: pcb already allocated", msg->conn->pcb.tcp == NULL);
  80fcd9:	8b 33                	mov    (%ebx),%esi
  80fcdb:	83 7e 08 00          	cmpl   $0x0,0x8(%esi)
  80fcdf:	74 1c                	je     80fcfd <do_newconn+0x43>
  80fce1:	c7 44 24 08 d4 4e 81 	movl   $0x814ed4,0x8(%esp)
  80fce8:	00 
  80fce9:	c7 44 24 04 8a 01 00 	movl   $0x18a,0x4(%esp)
  80fcf0:	00 
  80fcf1:	c7 04 24 c5 4c 81 00 	movl   $0x814cc5,(%esp)
  80fcf8:	e8 d7 0c ff ff       	call   8009d4 <_panic>

   /* Allocate a PCB for this connection */
   switch(NETCONNTYPE_GROUP(msg->conn->type)) {
  80fcfd:	8b 06                	mov    (%esi),%eax
  80fcff:	25 f0 00 00 00       	and    $0xf0,%eax
  80fd04:	83 f8 20             	cmp    $0x20,%eax
  80fd07:	74 45                	je     80fd4e <do_newconn+0x94>
  80fd09:	83 f8 40             	cmp    $0x40,%eax
  80fd0c:	74 0c                	je     80fd1a <do_newconn+0x60>
  80fd0e:	83 f8 10             	cmp    $0x10,%eax
  80fd11:	0f 85 8f 00 00 00    	jne    80fda6 <do_newconn+0xec>
  80fd17:	90                   	nop
  80fd18:	eb 6f                	jmp    80fd89 <do_newconn+0xcf>
#if LWIP_RAW
   case NETCONN_RAW:
     msg->conn->pcb.raw = raw_new(msg->msg.n.proto);
  80fd1a:	0f b6 43 04          	movzbl 0x4(%ebx),%eax
  80fd1e:	89 04 24             	mov    %eax,(%esp)
  80fd21:	e8 29 1d 00 00       	call   811a4f <raw_new>
  80fd26:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.raw == NULL) {
  80fd29:	8b 03                	mov    (%ebx),%eax
  80fd2b:	8b 50 08             	mov    0x8(%eax),%edx
  80fd2e:	85 d2                	test   %edx,%edx
  80fd30:	75 06                	jne    80fd38 <do_newconn+0x7e>
       msg->conn->err = ERR_MEM;
  80fd32:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fd36:	eb 72                	jmp    80fdaa <do_newconn+0xf0>
       break;
     }
     raw_recv(msg->conn->pcb.raw, recv_raw, msg->conn);
  80fd38:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fd3c:	c7 44 24 04 c1 fd 80 	movl   $0x80fdc1,0x4(%esp)
  80fd43:	00 
  80fd44:	89 14 24             	mov    %edx,(%esp)
  80fd47:	e8 ef 1c 00 00       	call   811a3b <raw_recv>
  80fd4c:	eb 5c                	jmp    80fdaa <do_newconn+0xf0>
     break;
#endif /* LWIP_RAW */
#if LWIP_UDP
   case NETCONN_UDP:
     msg->conn->pcb.udp = udp_new();
  80fd4e:	e8 bc c3 ff ff       	call   80c10f <udp_new>
  80fd53:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.udp == NULL) {
  80fd56:	8b 03                	mov    (%ebx),%eax
  80fd58:	8b 50 08             	mov    0x8(%eax),%edx
  80fd5b:	85 d2                	test   %edx,%edx
  80fd5d:	75 06                	jne    80fd65 <do_newconn+0xab>
       msg->conn->err = ERR_MEM;
  80fd5f:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fd63:	eb 45                	jmp    80fdaa <do_newconn+0xf0>
#if LWIP_UDPLITE
     if (msg->conn->type==NETCONN_UDPLITE) {
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_UDPLITE);
     }
#endif /* LWIP_UDPLITE */
     if (msg->conn->type==NETCONN_UDPNOCHKSUM) {
  80fd65:	83 38 22             	cmpl   $0x22,(%eax)
  80fd68:	75 04                	jne    80fd6e <do_newconn+0xb4>
       udp_setflags(msg->conn->pcb.udp, UDP_FLAGS_NOCHKSUM);
  80fd6a:	c6 42 10 01          	movb   $0x1,0x10(%edx)
     }
     udp_recv(msg->conn->pcb.udp, recv_udp, msg->conn);
  80fd6e:	8b 03                	mov    (%ebx),%eax
  80fd70:	89 44 24 08          	mov    %eax,0x8(%esp)
  80fd74:	c7 44 24 04 39 fa 80 	movl   $0x80fa39,0x4(%esp)
  80fd7b:	00 
  80fd7c:	8b 40 08             	mov    0x8(%eax),%eax
  80fd7f:	89 04 24             	mov    %eax,(%esp)
  80fd82:	e8 74 c3 ff ff       	call   80c0fb <udp_recv>
  80fd87:	eb 21                	jmp    80fdaa <do_newconn+0xf0>
     break;
#endif /* LWIP_UDP */
#if LWIP_TCP
   case NETCONN_TCP:
     msg->conn->pcb.tcp = tcp_new();
  80fd89:	e8 9c 95 ff ff       	call   80932a <tcp_new>
  80fd8e:	89 46 08             	mov    %eax,0x8(%esi)
     if(msg->conn->pcb.tcp == NULL) {
  80fd91:	8b 03                	mov    (%ebx),%eax
  80fd93:	83 78 08 00          	cmpl   $0x0,0x8(%eax)
  80fd97:	75 06                	jne    80fd9f <do_newconn+0xe5>
       msg->conn->err = ERR_MEM;
  80fd99:	c6 40 0c ff          	movb   $0xff,0xc(%eax)
  80fd9d:	eb 0b                	jmp    80fdaa <do_newconn+0xf0>
       break;
     }
     setup_tcp(msg->conn);
  80fd9f:	e8 04 f0 ff ff       	call   80eda8 <setup_tcp>
  80fda4:	eb 04                	jmp    80fdaa <do_newconn+0xf0>
     break;
#endif /* LWIP_TCP */
   default:
     /* Unsupported netconn type, e.g. protocol disabled */
     msg->conn->err = ERR_VAL;
  80fda6:	c6 46 0c f7          	movb   $0xf7,0xc(%esi)
   }
   /* Else? This "new" connection already has a PCB allocated. */
   /* Is this an error condition? Should it be deleted? */
   /* We currently just are happy and return. */

   TCPIP_APIMSG_ACK(msg);
  80fdaa:	8b 03                	mov    (%ebx),%eax
  80fdac:	8b 40 10             	mov    0x10(%eax),%eax
  80fdaf:	89 04 24             	mov    %eax,(%esp)
  80fdb2:	e8 70 de ff ff       	call   80dc27 <sys_sem_signal>
}
  80fdb7:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  80fdba:	8b 75 fc             	mov    -0x4(%ebp),%esi
  80fdbd:	89 ec                	mov    %ebp,%esp
  80fdbf:	5d                   	pop    %ebp
  80fdc0:	c3                   	ret    

0080fdc1 <recv_raw>:
 * @see raw.h (struct raw_pcb.recv) for parameters and return value
 */
static u8_t
recv_raw(void *arg, struct raw_pcb *pcb, struct pbuf *p,
    struct ip_addr *addr)
{
  80fdc1:	55                   	push   %ebp
  80fdc2:	89 e5                	mov    %esp,%ebp
  80fdc4:	83 ec 28             	sub    $0x28,%esp
  80fdc7:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  80fdca:	89 75 f8             	mov    %esi,-0x8(%ebp)
  80fdcd:	89 7d fc             	mov    %edi,-0x4(%ebp)
  80fdd0:	8b 7d 10             	mov    0x10(%ebp),%edi
#if LWIP_SO_RCVBUF
  int recv_avail;
#endif /* LWIP_SO_RCVBUF */

  LWIP_UNUSED_ARG(addr);
  conn = arg;
  80fdd3:	8b 5d 08             	mov    0x8(%ebp),%ebx
#if LWIP_SO_RCVBUF
  SYS_ARCH_GET(conn->recv_avail, recv_avail);
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL) &&
      ((recv_avail + (int)(p->tot_len)) <= conn->recv_bufsize)) {
#else  /* LWIP_SO_RCVBUF */
  if ((conn != NULL) && (conn->recvmbox != SYS_MBOX_NULL)) {
  80fdd6:	85 db                	test   %ebx,%ebx
  80fdd8:	0f 84 b0 00 00 00    	je     80fe8e <recv_raw+0xcd>
  80fdde:	83 7b 14 ff          	cmpl   $0xffffffff,0x14(%ebx)
  80fde2:	0f 84 a6 00 00 00    	je     80fe8e <recv_raw+0xcd>
#endif /* LWIP_SO_RCVBUF */
    /* copy the whole packet into new pbufs */
    q = pbuf_alloc(PBUF_RAW, p->tot_len, PBUF_RAM);
  80fde8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  80fdef:	00 
  80fdf0:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  80fdf4:	89 44 24 04          	mov    %eax,0x4(%esp)
  80fdf8:	c7 04 24 03 00 00 00 	movl   $0x3,(%esp)
  80fdff:	e8 0f 84 ff ff       	call   808213 <pbuf_alloc>
  80fe04:	89 c6                	mov    %eax,%esi
    if(q != NULL) {
  80fe06:	85 c0                	test   %eax,%eax
  80fe08:	0f 84 80 00 00 00    	je     80fe8e <recv_raw+0xcd>
      if (pbuf_copy(q, p) != ERR_OK) {
  80fe0e:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fe12:	89 04 24             	mov    %eax,(%esp)
  80fe15:	e8 8b 7f ff ff       	call   807da5 <pbuf_copy>
  80fe1a:	84 c0                	test   %al,%al
  80fe1c:	0f 84 7e 00 00 00    	je     80fea0 <recv_raw+0xdf>
        pbuf_free(q);
  80fe22:	89 34 24             	mov    %esi,(%esp)
  80fe25:	e8 2e 81 ff ff       	call   807f58 <pbuf_free>
  80fe2a:	eb 62                	jmp    80fe8e <recv_raw+0xcd>
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
      if (buf == NULL) {
        pbuf_free(q);
  80fe2c:	89 34 24             	mov    %esi,(%esp)
  80fe2f:	e8 24 81 ff ff       	call   807f58 <pbuf_free>
        return 0;
  80fe34:	eb 58                	jmp    80fe8e <recv_raw+0xcd>
      }

      buf->p = q;
  80fe36:	89 37                	mov    %esi,(%edi)
      buf->ptr = q;
  80fe38:	89 77 04             	mov    %esi,0x4(%edi)
      buf->addr = &(((struct ip_hdr*)(q->payload))->src);
  80fe3b:	8b 46 04             	mov    0x4(%esi),%eax
  80fe3e:	83 c0 0c             	add    $0xc,%eax
  80fe41:	89 47 08             	mov    %eax,0x8(%edi)
      buf->port = pcb->protocol;
  80fe44:	8b 45 0c             	mov    0xc(%ebp),%eax
  80fe47:	0f b6 40 10          	movzbl 0x10(%eax),%eax
  80fe4b:	66 89 47 0c          	mov    %ax,0xc(%edi)

      SYS_ARCH_INC(conn->recv_avail, q->tot_len);
  80fe4f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  80fe53:	66 01 43 20          	add    %ax,0x20(%ebx)
      /* Register event with callback */
      API_EVENT(conn, NETCONN_EVT_RCVPLUS, q->tot_len);
  80fe57:	8b 43 2c             	mov    0x2c(%ebx),%eax
  80fe5a:	85 c0                	test   %eax,%eax
  80fe5c:	74 15                	je     80fe73 <recv_raw+0xb2>
  80fe5e:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  80fe62:	89 54 24 08          	mov    %edx,0x8(%esp)
  80fe66:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  80fe6d:	00 
  80fe6e:	89 1c 24             	mov    %ebx,(%esp)
  80fe71:	ff d0                	call   *%eax
      if (sys_mbox_trypost(conn->recvmbox, buf) != ERR_OK) {
  80fe73:	89 7c 24 04          	mov    %edi,0x4(%esp)
  80fe77:	8b 43 14             	mov    0x14(%ebx),%eax
  80fe7a:	89 04 24             	mov    %eax,(%esp)
  80fe7d:	e8 36 df ff ff       	call   80ddb8 <sys_mbox_trypost>
  80fe82:	84 c0                	test   %al,%al
  80fe84:	74 08                	je     80fe8e <recv_raw+0xcd>
        netbuf_delete(buf);
  80fe86:	89 3c 24             	mov    %edi,(%esp)
  80fe89:	e8 f0 57 ff ff       	call   80567e <netbuf_delete>
      }
    }
  }

  return 0; /* do not eat the packet */
}
  80fe8e:	b8 00 00 00 00       	mov    $0x0,%eax
  80fe93:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  80fe96:	8b 75 f8             	mov    -0x8(%ebp),%esi
  80fe99:	8b 7d fc             	mov    -0x4(%ebp),%edi
  80fe9c:	89 ec                	mov    %ebp,%esp
  80fe9e:	5d                   	pop    %ebp
  80fe9f:	c3                   	ret    
        q = NULL;
      }
    }

    if(q != NULL) {
      buf = memp_malloc(MEMP_NETBUF);
  80fea0:	c7 04 24 06 00 00 00 	movl   $0x6,(%esp)
  80fea7:	e8 58 79 ff ff       	call   807804 <memp_malloc>
  80feac:	89 c7                	mov    %eax,%edi
      if (buf == NULL) {
  80feae:	85 c0                	test   %eax,%eax
  80feb0:	75 84                	jne    80fe36 <recv_raw+0x75>
  80feb2:	e9 75 ff ff ff       	jmp    80fe2c <recv_raw+0x6b>
	...

0080fec0 <tcp_parseopt>:
 *
 * @param pcb the tcp_pcb for which a segment arrived
 */
static void
tcp_parseopt(struct tcp_pcb *pcb)
{
  80fec0:	55                   	push   %ebp
  80fec1:	89 e5                	mov    %esp,%ebp
  80fec3:	57                   	push   %edi
  80fec4:	56                   	push   %esi
  80fec5:	53                   	push   %ebx
  80fec6:	83 ec 1c             	sub    $0x1c,%esp
  80fec9:	89 c7                	mov    %eax,%edi
  u8_t c;
  u8_t *opts, opt;
  u16_t mss;

  opts = (u8_t *)tcphdr + TCP_HLEN;
  80fecb:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  80fed0:	8d 70 14             	lea    0x14(%eax),%esi

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
  80fed3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80fed7:	89 04 24             	mov    %eax,(%esp)
  80feda:	e8 82 ae ff ff       	call   80ad61 <ntohs>
  80fedf:	66 c1 e8 0c          	shr    $0xc,%ax
  80fee3:	bb 00 00 00 00       	mov    $0x0,%ebx
  80fee8:	66 83 f8 05          	cmp    $0x5,%ax
  80feec:	77 53                	ja     80ff41 <tcp_parseopt+0x81>
  80feee:	eb 77                	jmp    80ff67 <tcp_parseopt+0xa7>
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
      opt = opts[c];
  80fef0:	0f b6 d3             	movzbl %bl,%edx
  80fef3:	0f b6 04 16          	movzbl (%esi,%edx,1),%eax
      if (opt == 0x00) {
  80fef7:	84 c0                	test   %al,%al
  80fef9:	74 6c                	je     80ff67 <tcp_parseopt+0xa7>
        /* End of options. */
        break;
      } else if (opt == 0x01) {
  80fefb:	3c 01                	cmp    $0x1,%al
  80fefd:	8d 76 00             	lea    0x0(%esi),%esi
  80ff00:	75 05                	jne    80ff07 <tcp_parseopt+0x47>
        ++c;
  80ff02:	83 c3 01             	add    $0x1,%ebx
  80ff05:	eb 3a                	jmp    80ff41 <tcp_parseopt+0x81>
        /* NOP option. */
      } else if (opt == 0x02 &&
  80ff07:	3c 02                	cmp    $0x2,%al
  80ff09:	75 2b                	jne    80ff36 <tcp_parseopt+0x76>
        opts[c + 1] == 0x04) {
  80ff0b:	80 7c 16 01 04       	cmpb   $0x4,0x1(%esi,%edx,1)
  80ff10:	75 24                	jne    80ff36 <tcp_parseopt+0x76>
        /* An MSS option with the right option length. */
        mss = (opts[c + 2] << 8) | opts[c + 3];
  80ff12:	0f b6 44 16 02       	movzbl 0x2(%esi,%edx,1),%eax
  80ff17:	c1 e0 08             	shl    $0x8,%eax
  80ff1a:	0f b6 54 16 03       	movzbl 0x3(%esi,%edx,1),%edx
  80ff1f:	09 d0                	or     %edx,%eax
        /* Limit the mss to the configured TCP_MSS and prevent division by zero */
        pcb->mss = ((mss > TCP_MSS) || (mss == 0)) ? TCP_MSS : mss;
  80ff21:	8d 50 ff             	lea    -0x1(%eax),%edx
  80ff24:	66 81 fa b3 05       	cmp    $0x5b3,%dx
  80ff29:	76 05                	jbe    80ff30 <tcp_parseopt+0x70>
  80ff2b:	b8 b4 05 00 00       	mov    $0x5b4,%eax
  80ff30:	66 89 47 34          	mov    %ax,0x34(%edi)

        /* And we are done processing options. */
        break;
  80ff34:	eb 31                	jmp    80ff67 <tcp_parseopt+0xa7>
      } else {
        if (opts[c + 1] == 0) {
  80ff36:	0f b6 44 16 01       	movzbl 0x1(%esi,%edx,1),%eax
  80ff3b:	84 c0                	test   %al,%al
  80ff3d:	74 28                	je     80ff67 <tcp_parseopt+0xa7>
             and we don't process them further. */
          break;
        }
        /* All other options have a length field, so that we easily
           can skip past them. */
        c += opts[c + 1];
  80ff3f:	01 c3                	add    %eax,%ebx

  opts = (u8_t *)tcphdr + TCP_HLEN;

  /* Parse the TCP MSS option, if present. */
  if(TCPH_HDRLEN(tcphdr) > 0x5) {
    for(c = 0; c < (TCPH_HDRLEN(tcphdr) - 5) << 2 ;) {
  80ff41:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  80ff46:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  80ff4a:	89 04 24             	mov    %eax,(%esp)
  80ff4d:	e8 0f ae ff ff       	call   80ad61 <ntohs>
  80ff52:	0f b6 d3             	movzbl %bl,%edx
  80ff55:	66 c1 e8 0c          	shr    $0xc,%ax
  80ff59:	0f b7 c0             	movzwl %ax,%eax
  80ff5c:	8d 04 85 ec ff ff ff 	lea    -0x14(,%eax,4),%eax
  80ff63:	39 c2                	cmp    %eax,%edx
  80ff65:	7c 89                	jl     80fef0 <tcp_parseopt+0x30>
           can skip past them. */
        c += opts[c + 1];
      }
    }
  }
}
  80ff67:	83 c4 1c             	add    $0x1c,%esp
  80ff6a:	5b                   	pop    %ebx
  80ff6b:	5e                   	pop    %esi
  80ff6c:	5f                   	pop    %edi
  80ff6d:	5d                   	pop    %ebp
  80ff6e:	c3                   	ret    

0080ff6f <tcp_receive>:
 *
 * @return 1 if the incoming segment is the next in sequence, 0 if not
 */
static u8_t
tcp_receive(struct tcp_pcb *pcb)
{
  80ff6f:	55                   	push   %ebp
  80ff70:	89 e5                	mov    %esp,%ebp
  80ff72:	57                   	push   %edi
  80ff73:	56                   	push   %esi
  80ff74:	53                   	push   %ebx
  80ff75:	83 ec 2c             	sub    $0x2c,%esp
  80ff78:	89 c3                	mov    %eax,%ebx
  s16_t m;
  u32_t right_wnd_edge;
  u16_t new_tot_len;
  u8_t accepted_inseq = 0;

  if (flags & TCP_ACK) {
  80ff7a:	f6 05 80 f5 b3 00 10 	testb  $0x10,0xb3f580
  80ff81:	0f 84 6d 04 00 00    	je     8103f4 <tcp_receive+0x485>
    right_wnd_edge = pcb->snd_wnd + pcb->snd_wl1;
  80ff87:	0f b7 70 5c          	movzwl 0x5c(%eax),%esi
  80ff8b:	8b 50 60             	mov    0x60(%eax),%edx

    /* Update window. */
    if (TCP_SEQ_LT(pcb->snd_wl1, seqno) ||
  80ff8e:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  80ff93:	39 c2                	cmp    %eax,%edx
  80ff95:	78 24                	js     80ffbb <tcp_receive+0x4c>
  80ff97:	39 c2                	cmp    %eax,%edx
  80ff99:	75 0a                	jne    80ffa5 <tcp_receive+0x36>
       (pcb->snd_wl1 == seqno && TCP_SEQ_LT(pcb->snd_wl2, ackno)) ||
  80ff9b:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  80ffa0:	39 43 64             	cmp    %eax,0x64(%ebx)
  80ffa3:	78 16                	js     80ffbb <tcp_receive+0x4c>
       (pcb->snd_wl2 == ackno && tcphdr->wnd > pcb->snd_wnd)) {
  80ffa5:	8b 43 64             	mov    0x64(%ebx),%eax
  80ffa8:	3b 05 7c f5 b3 00    	cmp    0xb3f57c,%eax
  80ffae:	75 3f                	jne    80ffef <tcp_receive+0x80>
  80ffb0:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  80ffb5:	66 3b 70 0e          	cmp    0xe(%eax),%si
  80ffb9:	73 34                	jae    80ffef <tcp_receive+0x80>
      pcb->snd_wnd = tcphdr->wnd;
  80ffbb:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  80ffc0:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  80ffc4:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno;
  80ffc8:	8b 0d 78 f5 b3 00    	mov    0xb3f578,%ecx
  80ffce:	89 4b 60             	mov    %ecx,0x60(%ebx)
      pcb->snd_wl2 = ackno;
  80ffd1:	8b 0d 7c f5 b3 00    	mov    0xb3f57c,%ecx
  80ffd7:	89 4b 64             	mov    %ecx,0x64(%ebx)
      if (pcb->snd_wnd > 0 && pcb->persist_backoff > 0) {
  80ffda:	66 85 c0             	test   %ax,%ax
  80ffdd:	74 10                	je     80ffef <tcp_receive+0x80>
  80ffdf:	80 bb a4 00 00 00 00 	cmpb   $0x0,0xa4(%ebx)
  80ffe6:	74 07                	je     80ffef <tcp_receive+0x80>
          pcb->persist_backoff = 0;
  80ffe8:	c6 83 a4 00 00 00 00 	movb   $0x0,0xa4(%ebx)
                               pcb->lastack, pcb->snd_max, ackno, pcb->snd_wl1, seqno, pcb->snd_wl2));
      }
#endif /* TCP_WND_DEBUG */
    }

    if (pcb->lastack == ackno) {
  80ffef:	8b 4b 48             	mov    0x48(%ebx),%ecx
  80fff2:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  80fff7:	39 c1                	cmp    %eax,%ecx
  80fff9:	0f 85 ac 00 00 00    	jne    8100ab <tcp_receive+0x13c>
      pcb->acked = 0;
  80ffff:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)

      if (pcb->snd_wl1 + pcb->snd_wnd == right_wnd_edge){
  810005:	0f b7 43 5c          	movzwl 0x5c(%ebx),%eax
  810009:	03 43 60             	add    0x60(%ebx),%eax
  81000c:	0f b7 f6             	movzwl %si,%esi
  81000f:	8d 14 16             	lea    (%esi,%edx,1),%edx
  810012:	39 d0                	cmp    %edx,%eax
  810014:	0f 85 ff 02 00 00    	jne    810319 <tcp_receive+0x3aa>
        ++pcb->dupacks;
  81001a:	0f b6 43 4c          	movzbl 0x4c(%ebx),%eax
  81001e:	83 c0 01             	add    $0x1,%eax
  810021:	88 43 4c             	mov    %al,0x4c(%ebx)
        if (pcb->dupacks >= 3 && pcb->unacked != NULL) {
  810024:	3c 02                	cmp    $0x2,%al
  810026:	0f 86 ed 02 00 00    	jbe    810319 <tcp_receive+0x3aa>
  81002c:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  810030:	0f 84 e3 02 00 00    	je     810319 <tcp_receive+0x3aa>
          if (!(pcb->flags & TF_INFR)) {
  810036:	f6 43 20 04          	testb  $0x4,0x20(%ebx)
  81003a:	75 53                	jne    81008f <tcp_receive+0x120>
            /* This is fast retransmit. Retransmit the first unacked segment. */
            LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupacks %"U16_F" (%"U32_F"), fast retransmit %"U32_F"\n",
                                       (u16_t)pcb->dupacks, pcb->lastack,
                                       ntohl(pcb->unacked->tcphdr->seqno)));
            tcp_rexmit(pcb);
  81003c:	89 1c 24             	mov    %ebx,(%esp)
  81003f:	90                   	nop
  810040:	e8 43 b8 ff ff       	call   80b888 <tcp_rexmit>
            /* Set ssthresh to max (FlightSize / 2, 2*SMSS) */
            /*pcb->ssthresh = LWIP_MAX((pcb->snd_max -
                                      pcb->lastack) / 2,
                                      2 * pcb->mss);*/
            /* Set ssthresh to half of the minimum of the current cwnd and the advertised window */
            if (pcb->cwnd > pcb->snd_wnd)
  810045:	0f b7 43 4e          	movzwl 0x4e(%ebx),%eax
  810049:	0f b7 53 5c          	movzwl 0x5c(%ebx),%edx
  81004d:	66 39 d0             	cmp    %dx,%ax
  810050:	76 09                	jbe    81005b <tcp_receive+0xec>
              pcb->ssthresh = pcb->snd_wnd / 2;
  810052:	66 d1 ea             	shr    %dx
  810055:	66 89 53 50          	mov    %dx,0x50(%ebx)
  810059:	eb 07                	jmp    810062 <tcp_receive+0xf3>
            else
              pcb->ssthresh = pcb->cwnd / 2;
  81005b:	66 d1 e8             	shr    %ax
  81005e:	66 89 43 50          	mov    %ax,0x50(%ebx)

            /* The minimum value for ssthresh should be 2 MSS */
            if (pcb->ssthresh < 2*pcb->mss) {
  810062:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  810066:	0f b7 4b 50          	movzwl 0x50(%ebx),%ecx
  81006a:	0f b7 d0             	movzwl %ax,%edx
  81006d:	01 d2                	add    %edx,%edx
  81006f:	39 d1                	cmp    %edx,%ecx
  810071:	7d 06                	jge    810079 <tcp_receive+0x10a>
              LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: The minimum value for ssthresh %"U16_F" should be min 2 mss %"U16_F"...\n", pcb->ssthresh, 2*pcb->mss));
              pcb->ssthresh = 2*pcb->mss;
  810073:	01 c0                	add    %eax,%eax
  810075:	66 89 43 50          	mov    %ax,0x50(%ebx)
            }

            pcb->cwnd = pcb->ssthresh + 3 * pcb->mss;
  810079:	66 6b 43 34 03       	imul   $0x3,0x34(%ebx),%ax
  81007e:	66 03 43 50          	add    0x50(%ebx),%ax
  810082:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
            pcb->flags |= TF_INFR;
  810086:	80 4b 20 04          	orb    $0x4,0x20(%ebx)
  81008a:	e9 8a 02 00 00       	jmp    810319 <tcp_receive+0x3aa>
          } else {
            /* Inflate the congestion window, but not if it means that
               the value overflows. */
            if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81008f:	0f b7 53 4e          	movzwl 0x4e(%ebx),%edx
  810093:	89 d0                	mov    %edx,%eax
  810095:	66 03 43 34          	add    0x34(%ebx),%ax
  810099:	66 39 c2             	cmp    %ax,%dx
  81009c:	0f 83 77 02 00 00    	jae    810319 <tcp_receive+0x3aa>
              pcb->cwnd += pcb->mss;
  8100a2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  8100a6:	e9 6e 02 00 00       	jmp    810319 <tcp_receive+0x3aa>
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  8100ab:	f7 d1                	not    %ecx
  8100ad:	01 c1                	add    %eax,%ecx
  8100af:	0f 88 b2 01 00 00    	js     810267 <tcp_receive+0x2f8>
  8100b5:	2b 43 58             	sub    0x58(%ebx),%eax
  8100b8:	85 c0                	test   %eax,%eax
  8100ba:	0f 8f a7 01 00 00    	jg     810267 <tcp_receive+0x2f8>
      /* We come here when the ACK acknowledges new data. */
      
      /* Reset the "IN Fast Retransmit" flag, since we are no longer
         in fast retransmit. Also reset the congestion window to the
         slow start threshold. */
      if (pcb->flags & TF_INFR) {
  8100c0:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8100c4:	a8 04                	test   $0x4,%al
  8100c6:	74 0e                	je     8100d6 <tcp_receive+0x167>
        pcb->flags &= ~TF_INFR;
  8100c8:	83 e0 fb             	and    $0xfffffffb,%eax
  8100cb:	88 43 20             	mov    %al,0x20(%ebx)
        pcb->cwnd = pcb->ssthresh;
  8100ce:	0f b7 43 50          	movzwl 0x50(%ebx),%eax
  8100d2:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      }

      /* Reset the number of retransmissions. */
      pcb->nrtx = 0;
  8100d6:	c6 43 46 00          	movb   $0x0,0x46(%ebx)

      /* Reset the retransmission time-out. */
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  8100da:	0f b7 43 40          	movzwl 0x40(%ebx),%eax
  8100de:	66 c1 f8 03          	sar    $0x3,%ax
  8100e2:	66 03 43 42          	add    0x42(%ebx),%ax
  8100e6:	66 89 43 44          	mov    %ax,0x44(%ebx)

      /* Update the send buffer space. Diff between the two can never exceed 64K? */
      pcb->acked = (u16_t)(ackno - pcb->lastack);
  8100ea:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  8100ef:	66 2b 43 48          	sub    0x48(%ebx),%ax
  8100f3:	66 89 43 6c          	mov    %ax,0x6c(%ebx)

      pcb->snd_buf += pcb->acked;
  8100f7:	66 01 43 6e          	add    %ax,0x6e(%ebx)

      /* Reset the fast retransmit variables. */
      pcb->dupacks = 0;
  8100fb:	c6 43 4c 00          	movb   $0x0,0x4c(%ebx)
      pcb->lastack = ackno;
  8100ff:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  810104:	89 43 48             	mov    %eax,0x48(%ebx)

      /* Update the congestion control variables (cwnd and
         ssthresh). */
      if (pcb->state >= ESTABLISHED) {
  810107:	83 7b 10 03          	cmpl   $0x3,0x10(%ebx)
  81010b:	0f 86 d3 00 00 00    	jbe    8101e4 <tcp_receive+0x275>
        if (pcb->cwnd < pcb->ssthresh) {
  810111:	0f b7 4b 4e          	movzwl 0x4e(%ebx),%ecx
  810115:	66 3b 4b 50          	cmp    0x50(%ebx),%cx
  810119:	73 18                	jae    810133 <tcp_receive+0x1c4>
          if ((u16_t)(pcb->cwnd + pcb->mss) > pcb->cwnd) {
  81011b:	89 c8                	mov    %ecx,%eax
  81011d:	66 03 43 34          	add    0x34(%ebx),%ax
  810121:	66 39 c1             	cmp    %ax,%cx
  810124:	0f 83 ba 00 00 00    	jae    8101e4 <tcp_receive+0x275>
            pcb->cwnd += pcb->mss;
  81012a:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  81012e:	e9 b1 00 00 00       	jmp    8101e4 <tcp_receive+0x275>
          }
          LWIP_DEBUGF(TCP_CWND_DEBUG, ("tcp_receive: slow start cwnd %"U16_F"\n", pcb->cwnd));
        } else {
          u16_t new_cwnd = (pcb->cwnd + pcb->mss * pcb->mss / pcb->cwnd);
  810133:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  810137:	0f af d2             	imul   %edx,%edx
  81013a:	0f b7 f1             	movzwl %cx,%esi
  81013d:	89 d0                	mov    %edx,%eax
  81013f:	c1 fa 1f             	sar    $0x1f,%edx
  810142:	f7 fe                	idiv   %esi
  810144:	8d 04 01             	lea    (%ecx,%eax,1),%eax
          if (new_cwnd > pcb->cwnd) {
  810147:	66 39 c1             	cmp    %ax,%cx
  81014a:	0f 83 94 00 00 00    	jae    8101e4 <tcp_receive+0x275>
            pcb->cwnd = new_cwnd;
  810150:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
  810154:	e9 8b 00 00 00       	jmp    8101e4 <tcp_receive+0x275>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unacked\n",
                                      ntohl(pcb->unacked->tcphdr->seqno),
                                      ntohl(pcb->unacked->tcphdr->seqno) +
                                      TCP_TCPLEN(pcb->unacked)));

        next = pcb->unacked;
  810159:	8b 73 78             	mov    0x78(%ebx),%esi
        pcb->unacked = pcb->unacked->next;
  81015c:	8b 06                	mov    (%esi),%eax
  81015e:	89 43 78             	mov    %eax,0x78(%ebx)

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
        LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  810161:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810165:	8b 46 04             	mov    0x4(%esi),%eax
  810168:	89 04 24             	mov    %eax,(%esp)
  81016b:	e8 80 79 ff ff       	call   807af0 <pbuf_clen>
  810170:	0f b6 c0             	movzbl %al,%eax
  810173:	66 39 c7             	cmp    %ax,%di
  810176:	73 1c                	jae    810194 <tcp_receive+0x225>
  810178:	c7 44 24 08 f4 4e 81 	movl   $0x814ef4,0x8(%esp)
  81017f:	00 
  810180:	c7 44 24 04 55 03 00 	movl   $0x355,0x4(%esp)
  810187:	00 
  810188:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  81018f:	e8 40 08 ff ff       	call   8009d4 <_panic>
        pcb->snd_queuelen -= pbuf_clen(next->p);
  810194:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810198:	8b 46 04             	mov    0x4(%esi),%eax
  81019b:	89 04 24             	mov    %eax,(%esp)
  81019e:	e8 4d 79 ff ff       	call   807af0 <pbuf_clen>
  8101a3:	0f b6 c0             	movzbl %al,%eax
  8101a6:	66 29 c7             	sub    %ax,%di
  8101a9:	66 89 7b 70          	mov    %di,0x70(%ebx)
        tcp_seg_free(next);
  8101ad:	89 34 24             	mov    %esi,(%esp)
  8101b0:	e8 1c 89 ff ff       	call   808ad1 <tcp_seg_free>

        LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unacked)\n", (u16_t)pcb->snd_queuelen));
        if (pcb->snd_queuelen != 0) {
  8101b5:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  8101ba:	74 28                	je     8101e4 <tcp_receive+0x275>
          LWIP_ASSERT("tcp_receive: valid queue length", pcb->unacked != NULL ||
  8101bc:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8101c0:	75 22                	jne    8101e4 <tcp_receive+0x275>
  8101c2:	83 7b 74 00          	cmpl   $0x0,0x74(%ebx)
  8101c6:	75 1c                	jne    8101e4 <tcp_receive+0x275>
  8101c8:	c7 44 24 08 1c 4f 81 	movl   $0x814f1c,0x8(%esp)
  8101cf:	00 
  8101d0:	c7 44 24 04 5c 03 00 	movl   $0x35c,0x4(%esp)
  8101d7:	00 
  8101d8:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8101df:	e8 f0 07 ff ff       	call   8009d4 <_panic>
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  8101e4:	8b 43 78             	mov    0x78(%ebx),%eax
  8101e7:	85 c0                	test   %eax,%eax
  8101e9:	74 65                	je     810250 <tcp_receive+0x2e1>
             TCP_SEQ_LEQ(ntohl(pcb->unacked->tcphdr->seqno) +
  8101eb:	8b 40 10             	mov    0x10(%eax),%eax
  8101ee:	8b 40 04             	mov    0x4(%eax),%eax
  8101f1:	89 04 24             	mov    %eax,(%esp)
  8101f4:	e8 a1 ad ff ff       	call   80af9a <ntohl>
  8101f9:	89 c6                	mov    %eax,%esi
  8101fb:	8b 43 78             	mov    0x78(%ebx),%eax
  8101fe:	0f b7 78 0c          	movzwl 0xc(%eax),%edi
  810202:	8b 40 10             	mov    0x10(%eax),%eax
  810205:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810209:	89 04 24             	mov    %eax,(%esp)
  81020c:	e8 50 ab ff ff       	call   80ad61 <ntohs>
  810211:	a8 01                	test   $0x1,%al
  810213:	75 1b                	jne    810230 <tcp_receive+0x2c1>
  810215:	8b 43 78             	mov    0x78(%ebx),%eax
  810218:	8b 40 10             	mov    0x10(%eax),%eax
  81021b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81021f:	89 04 24             	mov    %eax,(%esp)
  810222:	e8 3a ab ff ff       	call   80ad61 <ntohs>
  810227:	ba 00 00 00 00       	mov    $0x0,%edx
  81022c:	a8 02                	test   $0x2,%al
  81022e:	74 05                	je     810235 <tcp_receive+0x2c6>
  810230:	ba 01 00 00 00       	mov    $0x1,%edx
                                    pcb->unacked != NULL?
                                    ntohl(pcb->unacked->tcphdr->seqno) + TCP_TCPLEN(pcb->unacked): 0));

      /* Remove segment from the unacknowledged list if the incoming
         ACK acknowlegdes them. */
      while (pcb->unacked != NULL &&
  810235:	2b 35 7c f5 b3 00    	sub    0xb3f57c,%esi
  81023b:	0f b7 ff             	movzwl %di,%edi
  81023e:	01 fa                	add    %edi,%edx
  810240:	01 d6                	add    %edx,%esi
  810242:	85 f6                	test   %esi,%esi
  810244:	0f 8e 0f ff ff ff    	jle    810159 <tcp_receive+0x1ea>
        }
      }

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  81024a:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  81024e:	75 08                	jne    810258 <tcp_receive+0x2e9>
        pcb->rtime = -1;
  810250:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  810256:	eb 06                	jmp    81025e <tcp_receive+0x2ef>
      else
        pcb->rtime = 0;
  810258:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)

      pcb->polltmr = 0;
  81025e:	c6 43 30 00          	movb   $0x0,0x30(%ebx)
        }
      } else {
        LWIP_DEBUGF(TCP_FR_DEBUG, ("tcp_receive: dupack averted %"U32_F" %"U32_F"\n",
                                   pcb->snd_wl1 + pcb->snd_wnd, right_wnd_edge));
      }
    } else if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_max)){
  810262:	e9 b2 00 00 00       	jmp    810319 <tcp_receive+0x3aa>
        pcb->rtime = 0;

      pcb->polltmr = 0;
    } else {
      /* Fix bug bug #21582: out of sequence ACK, didn't really ack anything */
      pcb->acked = 0;
  810267:	66 c7 43 6c 00 00    	movw   $0x0,0x6c(%ebx)
  81026d:	8d 76 00             	lea    0x0(%esi),%esi
  810270:	e9 a4 00 00 00       	jmp    810319 <tcp_receive+0x3aa>
           ) {
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: removing %"U32_F":%"U32_F" from pcb->unsent\n",
                                    ntohl(pcb->unsent->tcphdr->seqno), ntohl(pcb->unsent->tcphdr->seqno) +
                                    TCP_TCPLEN(pcb->unsent)));

      next = pcb->unsent;
  810275:	8b 73 74             	mov    0x74(%ebx),%esi
      pcb->unsent = pcb->unsent->next;
  810278:	8b 06                	mov    (%esi),%eax
  81027a:	89 43 74             	mov    %eax,0x74(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_receive: queuelen %"U16_F" ... ", (u16_t)pcb->snd_queuelen));
      LWIP_ASSERT("pcb->snd_queuelen >= pbuf_clen(next->p)", (pcb->snd_queuelen >= pbuf_clen(next->p)));
  81027d:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  810281:	8b 46 04             	mov    0x4(%esi),%eax
  810284:	89 04 24             	mov    %eax,(%esp)
  810287:	e8 64 78 ff ff       	call   807af0 <pbuf_clen>
  81028c:	0f b6 c0             	movzbl %al,%eax
  81028f:	66 39 c7             	cmp    %ax,%di
  810292:	73 1c                	jae    8102b0 <tcp_receive+0x341>
  810294:	c7 44 24 08 f4 4e 81 	movl   $0x814ef4,0x8(%esp)
  81029b:	00 
  81029c:	c7 44 24 04 7f 03 00 	movl   $0x37f,0x4(%esp)
  8102a3:	00 
  8102a4:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8102ab:	e8 24 07 ff ff       	call   8009d4 <_panic>
      pcb->snd_queuelen -= pbuf_clen(next->p);
  8102b0:	0f b7 7b 70          	movzwl 0x70(%ebx),%edi
  8102b4:	8b 46 04             	mov    0x4(%esi),%eax
  8102b7:	89 04 24             	mov    %eax,(%esp)
  8102ba:	e8 31 78 ff ff       	call   807af0 <pbuf_clen>
  8102bf:	0f b6 c0             	movzbl %al,%eax
  8102c2:	66 29 c7             	sub    %ax,%di
  8102c5:	66 89 7b 70          	mov    %di,0x70(%ebx)
      tcp_seg_free(next);
  8102c9:	89 34 24             	mov    %esi,(%esp)
  8102cc:	e8 00 88 ff ff       	call   808ad1 <tcp_seg_free>
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("%"U16_F" (after freeing unsent)\n", (u16_t)pcb->snd_queuelen));
      if (pcb->snd_queuelen != 0) {
  8102d1:	66 83 7b 70 00       	cmpw   $0x0,0x70(%ebx)
  8102d6:	74 29                	je     810301 <tcp_receive+0x392>
        LWIP_ASSERT("tcp_receive: valid queue length",
  8102d8:	83 7b 78 00          	cmpl   $0x0,0x78(%ebx)
  8102dc:	75 23                	jne    810301 <tcp_receive+0x392>
  8102de:	8b 43 74             	mov    0x74(%ebx),%eax
  8102e1:	85 c0                	test   %eax,%eax
  8102e3:	75 23                	jne    810308 <tcp_receive+0x399>
  8102e5:	c7 44 24 08 1c 4f 81 	movl   $0x814f1c,0x8(%esp)
  8102ec:	00 
  8102ed:	c7 44 24 04 85 03 00 	movl   $0x385,0x4(%esp)
  8102f4:	00 
  8102f5:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8102fc:	e8 d3 06 ff ff       	call   8009d4 <_panic>
          pcb->unacked != NULL || pcb->unsent != NULL);
      }

      if (pcb->unsent != NULL) {
  810301:	8b 43 74             	mov    0x74(%ebx),%eax
  810304:	85 c0                	test   %eax,%eax
  810306:	74 11                	je     810319 <tcp_receive+0x3aa>
        pcb->snd_nxt = htonl(pcb->unsent->tcphdr->seqno);
  810308:	8b 40 10             	mov    0x10(%eax),%eax
  81030b:	8b 40 04             	mov    0x4(%eax),%eax
  81030e:	89 04 24             	mov    %eax,(%esp)
  810311:	e8 5f aa ff ff       	call   80ad75 <htonl>
  810316:	89 43 54             	mov    %eax,0x54(%ebx)
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  810319:	8b 43 74             	mov    0x74(%ebx),%eax
  81031c:	85 c0                	test   %eax,%eax
  81031e:	74 70                	je     810390 <tcp_receive+0x421>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  810320:	8b 35 7c f5 b3 00    	mov    0xb3f57c,%esi
  810326:	8b 40 10             	mov    0x10(%eax),%eax
  810329:	8b 40 04             	mov    0x4(%eax),%eax
  81032c:	89 04 24             	mov    %eax,(%esp)
  81032f:	e8 66 ac ff ff       	call   80af9a <ntohl>
  810334:	89 c7                	mov    %eax,%edi
  810336:	8b 43 74             	mov    0x74(%ebx),%eax
  810339:	0f b7 50 0c          	movzwl 0xc(%eax),%edx
  81033d:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  810341:	8b 40 10             	mov    0x10(%eax),%eax
  810344:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810348:	89 04 24             	mov    %eax,(%esp)
  81034b:	e8 11 aa ff ff       	call   80ad61 <ntohs>
  810350:	a8 01                	test   $0x1,%al
  810352:	75 1b                	jne    81036f <tcp_receive+0x400>
  810354:	8b 43 74             	mov    0x74(%ebx),%eax
  810357:	8b 40 10             	mov    0x10(%eax),%eax
  81035a:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81035e:	89 04 24             	mov    %eax,(%esp)
  810361:	e8 fb a9 ff ff       	call   80ad61 <ntohs>
  810366:	ba 00 00 00 00       	mov    $0x0,%edx
  81036b:	a8 02                	test   $0x2,%al
  81036d:	74 05                	je     810374 <tcp_receive+0x405>
  81036f:	ba 01 00 00 00       	mov    $0x1,%edx
       on the list are acknowledged by the ACK. This may seem
       strange since an "unsent" segment shouldn't be acked. The
       rationale is that lwIP puts all outstanding segments on the
       ->unsent list after a retransmission, so these segments may
       in fact have been sent once. */
    while (pcb->unsent != NULL &&
  810374:	29 fe                	sub    %edi,%esi
  810376:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  81037a:	01 c2                	add    %eax,%edx
  81037c:	39 d6                	cmp    %edx,%esi
  81037e:	78 10                	js     810390 <tcp_receive+0x421>
           /*TCP_SEQ_LEQ(ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), ackno) &&
             TCP_SEQ_LEQ(ackno, pcb->snd_max)*/
           TCP_SEQ_BETWEEN(ackno, ntohl(pcb->unsent->tcphdr->seqno) + TCP_TCPLEN(pcb->unsent), pcb->snd_max)
  810380:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  810385:	2b 43 58             	sub    0x58(%ebx),%eax
  810388:	85 c0                	test   %eax,%eax
  81038a:	0f 8e e5 fe ff ff    	jle    810275 <tcp_receive+0x306>
                                pcb->rttest, pcb->rtseq, ackno));

    /* RTT estimation calculations. This is done by checking if the
       incoming segment acknowledges the segment we use to take a
       round-trip time measurement. */
    if (pcb->rttest && TCP_SEQ_LT(pcb->rtseq, ackno)) {
  810390:	8b 43 38             	mov    0x38(%ebx),%eax
  810393:	85 c0                	test   %eax,%eax
  810395:	74 5d                	je     8103f4 <tcp_receive+0x485>
  810397:	8b 35 7c f5 b3 00    	mov    0xb3f57c,%esi
  81039d:	39 73 3c             	cmp    %esi,0x3c(%ebx)
  8103a0:	79 52                	jns    8103f4 <tcp_receive+0x485>

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: experienced rtt %"U16_F" ticks (%"U16_F" msec).\n",
                                  m, m * TCP_SLOW_INTERVAL));

      /* This is taken directly from VJs original code in his paper */
      m = m - (pcb->sa >> 3);
  8103a2:	0f b7 53 40          	movzwl 0x40(%ebx),%edx
  8103a6:	8b 0d 0c f6 b3 00    	mov    0xb3f60c,%ecx
  8103ac:	66 29 c1             	sub    %ax,%cx
  8103af:	89 c8                	mov    %ecx,%eax
  8103b1:	89 d1                	mov    %edx,%ecx
  8103b3:	66 c1 f9 03          	sar    $0x3,%cx
  8103b7:	66 29 c8             	sub    %cx,%ax
      pcb->sa += m;
  8103ba:	8d 14 10             	lea    (%eax,%edx,1),%edx
  8103bd:	66 89 53 40          	mov    %dx,0x40(%ebx)
      if (m < 0) {
        m = -m;
      }
      m = m - (pcb->sv >> 2);
  8103c1:	0f b7 4b 42          	movzwl 0x42(%ebx),%ecx
      pcb->sv += m;
  8103c5:	89 ce                	mov    %ecx,%esi
  8103c7:	66 c1 fe 02          	sar    $0x2,%si
  8103cb:	66 29 f1             	sub    %si,%cx
  8103ce:	89 ce                	mov    %ecx,%esi
  8103d0:	89 c1                	mov    %eax,%ecx
  8103d2:	66 c1 f9 0f          	sar    $0xf,%cx
  8103d6:	31 c8                	xor    %ecx,%eax
  8103d8:	66 29 c8             	sub    %cx,%ax
  8103db:	8d 04 06             	lea    (%esi,%eax,1),%eax
  8103de:	66 89 43 42          	mov    %ax,0x42(%ebx)
      pcb->rto = (pcb->sa >> 3) + pcb->sv;
  8103e2:	66 c1 fa 03          	sar    $0x3,%dx
  8103e6:	8d 04 02             	lea    (%edx,%eax,1),%eax
  8103e9:	66 89 43 44          	mov    %ax,0x44(%ebx)

      LWIP_DEBUGF(TCP_RTO_DEBUG, ("tcp_receive: RTO %"U16_F" (%"U16_F" milliseconds)\n",
                                  pcb->rto, pcb->rto * TCP_SLOW_INTERVAL));

      pcb->rttest = 0;
  8103ed:	c7 43 38 00 00 00 00 	movl   $0x0,0x38(%ebx)
    }
  }

  /* If the incoming segment contains data, we must process it
     further. */
  if (tcplen > 0) {
  8103f4:	0f b7 0d 82 f5 b3 00 	movzwl 0xb3f582,%ecx
  8103fb:	66 85 c9             	test   %cx,%cx
  8103fe:	0f 84 a5 07 00 00    	je     810ba9 <tcp_receive+0xc3a>
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  810404:	8b 53 24             	mov    0x24(%ebx),%edx
  810407:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  81040c:	89 c6                	mov    %eax,%esi
  81040e:	f7 d6                	not    %esi
  810410:	01 d6                	add    %edx,%esi
  810412:	0f 88 3a 01 00 00    	js     810552 <tcp_receive+0x5e3>
  810418:	8d 7a 01             	lea    0x1(%edx),%edi
  81041b:	29 c7                	sub    %eax,%edi
  81041d:	0f b7 f1             	movzwl %cx,%esi
  810420:	89 f9                	mov    %edi,%ecx
  810422:	29 f1                	sub    %esi,%ecx
  810424:	85 c9                	test   %ecx,%ecx
  810426:	0f 8f 26 01 00 00    	jg     810552 <tcp_receive+0x5e3>
         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
      p = inseg.p;
  81042c:	8b 35 60 f5 b3 00    	mov    0xb3f560,%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
  810432:	85 f6                	test   %esi,%esi
  810434:	75 1c                	jne    810452 <tcp_receive+0x4e3>
  810436:	c7 44 24 08 77 50 81 	movl   $0x815077,0x8(%esp)
  81043d:	00 
  81043e:	c7 44 24 04 e5 03 00 	movl   $0x3e5,0x4(%esp)
  810445:	00 
  810446:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  81044d:	e8 82 05 ff ff       	call   8009d4 <_panic>

         After we are done with adjusting the pbuf pointers we must
         adjust the ->data pointer in the seg and the segment
         length.*/

      off = pcb->rcv_nxt - seqno;
  810452:	29 c2                	sub    %eax,%edx
      p = inseg.p;
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
  810454:	81 fa fe 7f 00 00    	cmp    $0x7ffe,%edx
  81045a:	7e 1c                	jle    810478 <tcp_receive+0x509>
  81045c:	c7 44 24 08 87 50 81 	movl   $0x815087,0x8(%esp)
  810463:	00 
  810464:	c7 44 24 04 e6 03 00 	movl   $0x3e6,0x4(%esp)
  81046b:	00 
  81046c:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810473:	e8 5c 05 ff ff       	call   8009d4 <_panic>
      if (inseg.p->len < off) {
  810478:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  81047c:	39 c2                	cmp    %eax,%edx
  81047e:	7e 71                	jle    8104f1 <tcp_receive+0x582>
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
  810480:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  810484:	0f b7 f9             	movzwl %cx,%edi
  810487:	39 fa                	cmp    %edi,%edx
  810489:	7e 1c                	jle    8104a7 <tcp_receive+0x538>
  81048b:	c7 44 24 08 96 50 81 	movl   $0x815096,0x8(%esp)
  810492:	00 
  810493:	c7 44 24 04 e8 03 00 	movl   $0x3e8,0x4(%esp)
  81049a:	00 
  81049b:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8104a2:	e8 2d 05 ff ff       	call   8009d4 <_panic>
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
  8104a7:	66 29 d1             	sub    %dx,%cx
        while (p->len < off) {
          off -= p->len;
  8104aa:	29 c2                	sub    %eax,%edx
          /* KJM following line changed (with addition of new_tot_len var)
             to fix bug #9076
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
  8104ac:	66 89 4e 08          	mov    %cx,0x8(%esi)
          p->len = 0;
  8104b0:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
          p = p->next;
  8104b6:	8b 36                	mov    (%esi),%esi
      LWIP_ASSERT("inseg.p != NULL", inseg.p);
      LWIP_ASSERT("insane offset!", (off < 0x7fff));
      if (inseg.p->len < off) {
        LWIP_ASSERT("pbuf too short!", (((s32_t)inseg.p->tot_len) >= off));
        new_tot_len = (u16_t)(inseg.p->tot_len - off);
        while (p->len < off) {
  8104b8:	0f b7 46 0a          	movzwl 0xa(%esi),%eax
  8104bc:	39 d0                	cmp    %edx,%eax
  8104be:	7c ea                	jl     8104aa <tcp_receive+0x53b>
             inseg.p->tot_len -= p->len; */
          p->tot_len = new_tot_len;
          p->len = 0;
          p = p->next;
        }
        if(pbuf_header(p, (s16_t)-off)) {
  8104c0:	f7 da                	neg    %edx
  8104c2:	0f bf c2             	movswl %dx,%eax
  8104c5:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104c9:	89 34 24             	mov    %esi,(%esp)
  8104cc:	e8 12 77 ff ff       	call   807be3 <pbuf_header>
  8104d1:	84 c0                	test   %al,%al
  8104d3:	74 4d                	je     810522 <tcp_receive+0x5b3>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  8104d5:	c7 44 24 08 a6 50 81 	movl   $0x8150a6,0x8(%esp)
  8104dc:	00 
  8104dd:	c7 44 24 04 f5 03 00 	movl   $0x3f5,0x4(%esp)
  8104e4:	00 
  8104e5:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8104ec:	e8 e3 04 ff ff       	call   8009d4 <_panic>
        }
      } else {
        if(pbuf_header(inseg.p, (s16_t)-off)) {
  8104f1:	f7 da                	neg    %edx
  8104f3:	0f bf c2             	movswl %dx,%eax
  8104f6:	89 44 24 04          	mov    %eax,0x4(%esp)
  8104fa:	89 34 24             	mov    %esi,(%esp)
  8104fd:	e8 e1 76 ff ff       	call   807be3 <pbuf_header>
  810502:	84 c0                	test   %al,%al
  810504:	74 1c                	je     810522 <tcp_receive+0x5b3>
          /* Do we need to cope with this failing?  Assert for now */
          LWIP_ASSERT("pbuf_header failed", 0);
  810506:	c7 44 24 08 a6 50 81 	movl   $0x8150a6,0x8(%esp)
  81050d:	00 
  81050e:	c7 44 24 04 fa 03 00 	movl   $0x3fa,0x4(%esp)
  810515:	00 
  810516:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  81051d:	e8 b2 04 ff ff       	call   8009d4 <_panic>
        }
      }
      /* KJM following line changed to use p->payload rather than inseg->p->payload
         to fix bug #9076 */
      inseg.dataptr = p->payload;
  810522:	8b 46 04             	mov    0x4(%esi),%eax
  810525:	a3 64 f5 b3 00       	mov    %eax,0xb3f564
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
  81052a:	b8 68 f5 b3 00       	mov    $0xb3f568,%eax
  81052f:	8b 15 78 f5 b3 00    	mov    0xb3f578,%edx
  810535:	66 03 10             	add    (%eax),%dx
  810538:	66 2b 53 24          	sub    0x24(%ebx),%dx
  81053c:	66 89 10             	mov    %dx,(%eax)
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
  81053f:	8b 43 24             	mov    0x24(%ebx),%eax
  810542:	a3 78 f5 b3 00       	mov    %eax,0xb3f578
  810547:	8b 15 6c f5 b3 00    	mov    0xb3f56c,%edx
  81054d:	89 42 04             	mov    %eax,0x4(%edx)
       this if the sequence number of the incoming segment is less
       than rcv_nxt, and the sequence number plus the length of the
       segment is larger than rcv_nxt. */
    /*    if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
          if (TCP_SEQ_LT(pcb->rcv_nxt, seqno + tcplen)) {*/
    if (TCP_SEQ_BETWEEN(pcb->rcv_nxt, seqno + 1, seqno + tcplen - 1)){
  810550:	eb 10                	jmp    810562 <tcp_receive+0x5f3>
      inseg.dataptr = p->payload;
      inseg.len -= (u16_t)(pcb->rcv_nxt - seqno);
      inseg.tcphdr->seqno = seqno = pcb->rcv_nxt;
    }
    else {
      if (TCP_SEQ_LT(seqno, pcb->rcv_nxt)){
  810552:	39 d0                	cmp    %edx,%eax
  810554:	79 1c                	jns    810572 <tcp_receive+0x603>
        /* the whole segment is < rcv_nxt */
        /* must be a duplicate of a packet that has already been correctly handled */

        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: duplicate seqno %"U32_F"\n", seqno));
        tcp_ack_now(pcb);
  810556:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81055a:	89 1c 24             	mov    %ebx,(%esp)
  81055d:	e8 79 ae ff ff       	call   80b3db <tcp_output>
    }

    /* The sequence number must be within the window (above rcv_nxt
       and below rcv_nxt + rcv_wnd) in order to be further
       processed. */
    if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  810562:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  810567:	8b 53 24             	mov    0x24(%ebx),%edx
  81056a:	39 d0                	cmp    %edx,%eax
  81056c:	0f 88 24 06 00 00    	js     810b96 <tcp_receive+0xc27>
  810572:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810576:	89 c7                	mov    %eax,%edi
  810578:	29 cf                	sub    %ecx,%edi
  81057a:	8d 4f 01             	lea    0x1(%edi),%ecx
  81057d:	29 d1                	sub    %edx,%ecx
  81057f:	85 c9                	test   %ecx,%ecx
  810581:	0f 8f 0f 06 00 00    	jg     810b96 <tcp_receive+0xc27>
                        pcb->rcv_nxt + pcb->rcv_wnd - 1)){
      if (pcb->rcv_nxt == seqno) {
  810587:	39 d0                	cmp    %edx,%eax
  810589:	0f 85 95 03 00 00    	jne    810924 <tcp_receive+0x9b5>
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  81058f:	8b 53 7c             	mov    0x7c(%ebx),%edx
  810592:	85 d2                	test   %edx,%edx
  810594:	0f 84 86 00 00 00    	je     810620 <tcp_receive+0x6b1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
  81059a:	8b 4a 10             	mov    0x10(%edx),%ecx
  81059d:	8b 49 04             	mov    0x4(%ecx),%ecx
        accepted_inseq = 1; 
        /* The incoming segment is the next in sequence. We check if
           we have to trim the end of the segment and update rcv_nxt
           and pass the data to the application. */
#if TCP_QUEUE_OOSEQ
        if (pcb->ooseq != NULL &&
  8105a0:	0f b7 35 68 f5 b3 00 	movzwl 0xb3f568,%esi
  8105a7:	89 cf                	mov    %ecx,%edi
  8105a9:	29 f7                	sub    %esi,%edi
  8105ab:	89 fe                	mov    %edi,%esi
  8105ad:	29 c6                	sub    %eax,%esi
  8105af:	85 f6                	test   %esi,%esi
  8105b1:	7f 6d                	jg     810620 <tcp_receive+0x6b1>
                TCP_SEQ_LEQ(pcb->ooseq->tcphdr->seqno, seqno + inseg.len)) {
          if (pcb->ooseq->len > 0) {
  8105b3:	66 83 7a 0c 00       	cmpw   $0x0,0xc(%edx)
  8105b8:	74 20                	je     8105da <tcp_receive+0x66b>
            /* We have to trim the second edge of the incoming
               segment. */
            inseg.len = (u16_t)(pcb->ooseq->tcphdr->seqno - seqno);
  8105ba:	66 29 c1             	sub    %ax,%cx
  8105bd:	66 89 0d 68 f5 b3 00 	mov    %cx,0xb3f568
            pbuf_realloc(inseg.p, inseg.len);
  8105c4:	0f b7 c1             	movzwl %cx,%eax
  8105c7:	89 44 24 04          	mov    %eax,0x4(%esp)
  8105cb:	a1 60 f5 b3 00       	mov    0xb3f560,%eax
  8105d0:	89 04 24             	mov    %eax,(%esp)
  8105d3:	e8 08 7b ff ff       	call   8080e0 <pbuf_realloc>
  8105d8:	eb 46                	jmp    810620 <tcp_receive+0x6b1>
          } else {
            /* does the ooseq segment contain only flags that are in inseg also? */
            if ((TCPH_FLAGS(inseg.tcphdr) & (TCP_FIN|TCP_SYN)) ==
  8105da:	a1 6c f5 b3 00       	mov    0xb3f56c,%eax
  8105df:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8105e3:	89 04 24             	mov    %eax,(%esp)
  8105e6:	e8 76 a7 ff ff       	call   80ad61 <ntohs>
  8105eb:	89 c6                	mov    %eax,%esi
  8105ed:	8b 43 7c             	mov    0x7c(%ebx),%eax
  8105f0:	8b 40 10             	mov    0x10(%eax),%eax
  8105f3:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8105f7:	89 04 24             	mov    %eax,(%esp)
  8105fa:	e8 62 a7 ff ff       	call   80ad61 <ntohs>
  8105ff:	31 c6                	xor    %eax,%esi
  810601:	66 f7 c6 03 00       	test   $0x3,%si
  810606:	75 18                	jne    810620 <tcp_receive+0x6b1>
                (TCPH_FLAGS(pcb->ooseq->tcphdr) & (TCP_FIN|TCP_SYN))) {
              struct tcp_seg *old_ooseq = pcb->ooseq;
  810608:	8b 43 7c             	mov    0x7c(%ebx),%eax
              pcb->ooseq = pcb->ooseq->next;
  81060b:	8b 10                	mov    (%eax),%edx
  81060d:	89 53 7c             	mov    %edx,0x7c(%ebx)
              memp_free(MEMP_TCP_SEG, old_ooseq);
  810610:	89 44 24 04          	mov    %eax,0x4(%esp)
  810614:	c7 04 24 04 00 00 00 	movl   $0x4,(%esp)
  81061b:	e8 a0 71 ff ff       	call   8077c0 <memp_free>
            }
          }
        }
#endif /* TCP_QUEUE_OOSEQ */

        tcplen = TCP_TCPLEN(&inseg);
  810620:	0f b7 35 68 f5 b3 00 	movzwl 0xb3f568,%esi
  810627:	a1 6c f5 b3 00       	mov    0xb3f56c,%eax
  81062c:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810630:	89 04 24             	mov    %eax,(%esp)
  810633:	e8 29 a7 ff ff       	call   80ad61 <ntohs>
  810638:	a8 01                	test   $0x1,%al
  81063a:	75 1a                	jne    810656 <tcp_receive+0x6e7>
  81063c:	a1 6c f5 b3 00       	mov    0xb3f56c,%eax
  810641:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810645:	89 04 24             	mov    %eax,(%esp)
  810648:	e8 14 a7 ff ff       	call   80ad61 <ntohs>
  81064d:	ba 00 00 00 00       	mov    $0x0,%edx
  810652:	a8 02                	test   $0x2,%al
  810654:	74 05                	je     81065b <tcp_receive+0x6ec>
  810656:	ba 01 00 00 00       	mov    $0x1,%edx
  81065b:	01 d6                	add    %edx,%esi
  81065d:	66 89 35 82 f5 b3 00 	mov    %si,0xb3f582

        /* First received FIN will be ACKed +1, on any successive (duplicate)
         * FINs we are already in CLOSE_WAIT and have already done +1.
         */
        if (pcb->state != CLOSE_WAIT) {
  810664:	83 7b 10 07          	cmpl   $0x7,0x10(%ebx)
  810668:	74 06                	je     810670 <tcp_receive+0x701>
          pcb->rcv_nxt += tcplen;
  81066a:	0f b7 f6             	movzwl %si,%esi
  81066d:	01 73 24             	add    %esi,0x24(%ebx)
        }

        /* Update the receiver's (our) window. */
        if (pcb->rcv_wnd < tcplen) {
  810670:	0f b7 53 28          	movzwl 0x28(%ebx),%edx
  810674:	0f b7 05 82 f5 b3 00 	movzwl 0xb3f582,%eax
  81067b:	66 39 c2             	cmp    %ax,%dx
  81067e:	73 08                	jae    810688 <tcp_receive+0x719>
          pcb->rcv_wnd = 0;
  810680:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  810686:	eb 07                	jmp    81068f <tcp_receive+0x720>
        } else {
          pcb->rcv_wnd -= tcplen;
  810688:	66 29 c2             	sub    %ax,%dx
  81068b:	66 89 53 28          	mov    %dx,0x28(%ebx)
        }

        if (pcb->rcv_ann_wnd < tcplen) {
  81068f:	0f b7 53 2a          	movzwl 0x2a(%ebx),%edx
  810693:	0f b7 05 82 f5 b3 00 	movzwl 0xb3f582,%eax
  81069a:	66 39 c2             	cmp    %ax,%dx
  81069d:	73 08                	jae    8106a7 <tcp_receive+0x738>
          pcb->rcv_ann_wnd = 0;
  81069f:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  8106a5:	eb 07                	jmp    8106ae <tcp_receive+0x73f>
        } else {
          pcb->rcv_ann_wnd -= tcplen;
  8106a7:	66 29 c2             	sub    %ax,%dx
  8106aa:	66 89 53 2a          	mov    %dx,0x2a(%ebx)
           chains its data on this pbuf as well.

           If the segment was a FIN, we set the TF_GOT_FIN flag that will
           be used to indicate to the application that the remote side has
           closed its end of the connection. */
        if (inseg.p->tot_len > 0) {
  8106ae:	a1 60 f5 b3 00       	mov    0xb3f560,%eax
  8106b3:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  8106b8:	74 0f                	je     8106c9 <tcp_receive+0x75a>
          recv_data = inseg.p;
  8106ba:	a3 88 f5 b3 00       	mov    %eax,0xb3f588
          /* Since this pbuf now is the responsibility of the
             application, we delete our reference to it so that we won't
             (mistakingly) deallocate it. */
          inseg.p = NULL;
  8106bf:	c7 05 60 f5 b3 00 00 	movl   $0x0,0xb3f560
  8106c6:	00 00 00 
        }
        if (TCPH_FLAGS(inseg.tcphdr) & TCP_FIN) {
  8106c9:	a1 6c f5 b3 00       	mov    0xb3f56c,%eax
  8106ce:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8106d2:	89 04 24             	mov    %eax,(%esp)
  8106d5:	e8 87 a6 ff ff       	call   80ad61 <ntohs>
  8106da:	a8 01                	test   $0x1,%al
  8106dc:	74 07                	je     8106e5 <tcp_receive+0x776>
          LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: received FIN.\n"));
          recv_flags = TF_GOT_FIN;
  8106de:	c6 05 84 f5 b3 00 20 	movb   $0x20,0xb3f584
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  8106e5:	8b 73 7c             	mov    0x7c(%ebx),%esi
  8106e8:	85 f6                	test   %esi,%esi
  8106ea:	0f 84 01 02 00 00    	je     8108f1 <tcp_receive+0x982>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  8106f0:	8b 46 10             	mov    0x10(%esi),%eax
  8106f3:	8b 40 04             	mov    0x4(%eax),%eax
  8106f6:	3b 43 24             	cmp    0x24(%ebx),%eax
  8106f9:	0f 85 f2 01 00 00    	jne    8108f1 <tcp_receive+0x982>

          cseg = pcb->ooseq;
          seqno = pcb->ooseq->tcphdr->seqno;
  8106ff:	a3 78 f5 b3 00       	mov    %eax,0xb3f578

          pcb->rcv_nxt += TCP_TCPLEN(cseg);
  810704:	8b 43 24             	mov    0x24(%ebx),%eax
  810707:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  81070a:	0f b7 7e 0c          	movzwl 0xc(%esi),%edi
  81070e:	8b 46 10             	mov    0x10(%esi),%eax
  810711:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810715:	89 04 24             	mov    %eax,(%esp)
  810718:	e8 44 a6 ff ff       	call   80ad61 <ntohs>
  81071d:	a8 01                	test   $0x1,%al
  81071f:	75 18                	jne    810739 <tcp_receive+0x7ca>
  810721:	8b 46 10             	mov    0x10(%esi),%eax
  810724:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810728:	89 04 24             	mov    %eax,(%esp)
  81072b:	e8 31 a6 ff ff       	call   80ad61 <ntohs>
  810730:	ba 00 00 00 00       	mov    $0x0,%edx
  810735:	a8 02                	test   $0x2,%al
  810737:	74 05                	je     81073e <tcp_receive+0x7cf>
  810739:	ba 01 00 00 00       	mov    $0x1,%edx
  81073e:	0f b7 ff             	movzwl %di,%edi
  810741:	01 fa                	add    %edi,%edx
  810743:	03 55 e4             	add    -0x1c(%ebp),%edx
  810746:	89 53 24             	mov    %edx,0x24(%ebx)
          if (pcb->rcv_wnd < TCP_TCPLEN(cseg)) {
  810749:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  81074d:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  810751:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  810755:	8b 46 10             	mov    0x10(%esi),%eax
  810758:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81075c:	89 04 24             	mov    %eax,(%esp)
  81075f:	e8 fd a5 ff ff       	call   80ad61 <ntohs>
  810764:	a8 01                	test   $0x1,%al
  810766:	75 18                	jne    810780 <tcp_receive+0x811>
  810768:	8b 46 10             	mov    0x10(%esi),%eax
  81076b:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81076f:	89 04 24             	mov    %eax,(%esp)
  810772:	e8 ea a5 ff ff       	call   80ad61 <ntohs>
  810777:	ba 00 00 00 00       	mov    $0x0,%edx
  81077c:	a8 02                	test   $0x2,%al
  81077e:	74 05                	je     810785 <tcp_receive+0x816>
  810780:	ba 01 00 00 00       	mov    $0x1,%edx
  810785:	0f b7 ff             	movzwl %di,%edi
  810788:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  81078c:	01 c2                	add    %eax,%edx
  81078e:	39 d7                	cmp    %edx,%edi
  810790:	7d 08                	jge    81079a <tcp_receive+0x82b>
            pcb->rcv_wnd = 0;
  810792:	66 c7 43 28 00 00    	movw   $0x0,0x28(%ebx)
  810798:	eb 47                	jmp    8107e1 <tcp_receive+0x872>
          } else {
            pcb->rcv_wnd -= TCP_TCPLEN(cseg);
  81079a:	0f b7 7b 28          	movzwl 0x28(%ebx),%edi
  81079e:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  8107a2:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  8107a6:	8b 46 10             	mov    0x10(%esi),%eax
  8107a9:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107ad:	89 04 24             	mov    %eax,(%esp)
  8107b0:	e8 ac a5 ff ff       	call   80ad61 <ntohs>
  8107b5:	a8 01                	test   $0x1,%al
  8107b7:	75 18                	jne    8107d1 <tcp_receive+0x862>
  8107b9:	8b 46 10             	mov    0x10(%esi),%eax
  8107bc:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107c0:	89 04 24             	mov    %eax,(%esp)
  8107c3:	e8 99 a5 ff ff       	call   80ad61 <ntohs>
  8107c8:	ba 00 00 00 00       	mov    $0x0,%edx
  8107cd:	a8 02                	test   $0x2,%al
  8107cf:	74 05                	je     8107d6 <tcp_receive+0x867>
  8107d1:	ba 01 00 00 00       	mov    $0x1,%edx
  8107d6:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  8107da:	66 29 d7             	sub    %dx,%di
  8107dd:	66 89 7b 28          	mov    %di,0x28(%ebx)
          }
          if (pcb->rcv_ann_wnd < TCP_TCPLEN(cseg)) {
  8107e1:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  8107e5:	0f b7 56 0c          	movzwl 0xc(%esi),%edx
  8107e9:	66 89 55 e4          	mov    %dx,-0x1c(%ebp)
  8107ed:	8b 46 10             	mov    0x10(%esi),%eax
  8107f0:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8107f4:	89 04 24             	mov    %eax,(%esp)
  8107f7:	e8 65 a5 ff ff       	call   80ad61 <ntohs>
  8107fc:	a8 01                	test   $0x1,%al
  8107fe:	75 18                	jne    810818 <tcp_receive+0x8a9>
  810800:	8b 46 10             	mov    0x10(%esi),%eax
  810803:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810807:	89 04 24             	mov    %eax,(%esp)
  81080a:	e8 52 a5 ff ff       	call   80ad61 <ntohs>
  81080f:	ba 00 00 00 00       	mov    $0x0,%edx
  810814:	a8 02                	test   $0x2,%al
  810816:	74 05                	je     81081d <tcp_receive+0x8ae>
  810818:	ba 01 00 00 00       	mov    $0x1,%edx
  81081d:	0f b7 ff             	movzwl %di,%edi
  810820:	0f b7 45 e4          	movzwl -0x1c(%ebp),%eax
  810824:	01 c2                	add    %eax,%edx
  810826:	39 d7                	cmp    %edx,%edi
  810828:	7d 08                	jge    810832 <tcp_receive+0x8c3>
            pcb->rcv_ann_wnd = 0;
  81082a:	66 c7 43 2a 00 00    	movw   $0x0,0x2a(%ebx)
  810830:	eb 47                	jmp    810879 <tcp_receive+0x90a>
          } else {
            pcb->rcv_ann_wnd -= TCP_TCPLEN(cseg);
  810832:	0f b7 7b 2a          	movzwl 0x2a(%ebx),%edi
  810836:	0f b7 46 0c          	movzwl 0xc(%esi),%eax
  81083a:	66 89 45 e4          	mov    %ax,-0x1c(%ebp)
  81083e:	8b 46 10             	mov    0x10(%esi),%eax
  810841:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810845:	89 04 24             	mov    %eax,(%esp)
  810848:	e8 14 a5 ff ff       	call   80ad61 <ntohs>
  81084d:	a8 01                	test   $0x1,%al
  81084f:	75 18                	jne    810869 <tcp_receive+0x8fa>
  810851:	8b 46 10             	mov    0x10(%esi),%eax
  810854:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810858:	89 04 24             	mov    %eax,(%esp)
  81085b:	e8 01 a5 ff ff       	call   80ad61 <ntohs>
  810860:	ba 00 00 00 00       	mov    $0x0,%edx
  810865:	a8 02                	test   $0x2,%al
  810867:	74 05                	je     81086e <tcp_receive+0x8ff>
  810869:	ba 01 00 00 00       	mov    $0x1,%edx
  81086e:	66 2b 7d e4          	sub    -0x1c(%ebp),%di
  810872:	66 29 d7             	sub    %dx,%di
  810875:	66 89 7b 2a          	mov    %di,0x2a(%ebx)
          }

          if (cseg->p->tot_len > 0) {
  810879:	8b 46 04             	mov    0x4(%esi),%eax
  81087c:	66 83 78 08 00       	cmpw   $0x0,0x8(%eax)
  810881:	74 24                	je     8108a7 <tcp_receive+0x938>
            /* Chain this pbuf onto the pbuf that we will pass to
               the application. */
            if (recv_data) {
  810883:	8b 15 88 f5 b3 00    	mov    0xb3f588,%edx
  810889:	85 d2                	test   %edx,%edx
  81088b:	74 0e                	je     81089b <tcp_receive+0x92c>
              pbuf_cat(recv_data, cseg->p);
  81088d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810891:	89 14 24             	mov    %edx,(%esp)
  810894:	e8 82 72 ff ff       	call   807b1b <pbuf_cat>
  810899:	eb 05                	jmp    8108a0 <tcp_receive+0x931>
            } else {
              recv_data = cseg->p;
  81089b:	a3 88 f5 b3 00       	mov    %eax,0xb3f588
            }
            cseg->p = NULL;
  8108a0:	c7 46 04 00 00 00 00 	movl   $0x0,0x4(%esi)
          }
          if (TCPH_FLAGS(cseg->tcphdr) & TCP_FIN) {
  8108a7:	8b 46 10             	mov    0x10(%esi),%eax
  8108aa:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  8108ae:	89 04 24             	mov    %eax,(%esp)
  8108b1:	e8 ab a4 ff ff       	call   80ad61 <ntohs>
  8108b6:	a8 01                	test   $0x1,%al
  8108b8:	74 14                	je     8108ce <tcp_receive+0x95f>
            LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_receive: dequeued FIN.\n"));
            recv_flags = TF_GOT_FIN;
  8108ba:	c6 05 84 f5 b3 00 20 	movb   $0x20,0xb3f584
            if (pcb->state == ESTABLISHED) { /* force passive close or we can move to active close */
  8108c1:	83 7b 10 04          	cmpl   $0x4,0x10(%ebx)
  8108c5:	75 07                	jne    8108ce <tcp_receive+0x95f>
              pcb->state = CLOSE_WAIT;
  8108c7:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
            } 
          }


          pcb->ooseq = cseg->next;
  8108ce:	8b 06                	mov    (%esi),%eax
  8108d0:	89 43 7c             	mov    %eax,0x7c(%ebx)
          tcp_seg_free(cseg);
  8108d3:	89 34 24             	mov    %esi,(%esp)
  8108d6:	e8 f6 81 ff ff       	call   808ad1 <tcp_seg_free>
        }

#if TCP_QUEUE_OOSEQ
        /* We now check if we have segments on the ->ooseq queue that
           is now in sequence. */
        while (pcb->ooseq != NULL &&
  8108db:	8b 73 7c             	mov    0x7c(%ebx),%esi
  8108de:	85 f6                	test   %esi,%esi
  8108e0:	74 0f                	je     8108f1 <tcp_receive+0x982>
               pcb->ooseq->tcphdr->seqno == pcb->rcv_nxt) {
  8108e2:	8b 46 10             	mov    0x10(%esi),%eax
  8108e5:	8b 40 04             	mov    0x4(%eax),%eax
  8108e8:	3b 43 24             	cmp    0x24(%ebx),%eax
  8108eb:	0f 84 0e fe ff ff    	je     8106ff <tcp_receive+0x790>
        }
#endif /* TCP_QUEUE_OOSEQ */


        /* Acknowledge the segment(s). */
        tcp_ack(pcb);
  8108f1:	0f b6 43 20          	movzbl 0x20(%ebx),%eax
  8108f5:	a8 01                	test   $0x1,%al
  8108f7:	74 1b                	je     810914 <tcp_receive+0x9a5>
  8108f9:	83 e0 fe             	and    $0xfffffffe,%eax
  8108fc:	83 c8 02             	or     $0x2,%eax
  8108ff:	88 43 20             	mov    %al,0x20(%ebx)
  810902:	89 1c 24             	mov    %ebx,(%esp)
  810905:	e8 d1 aa ff ff       	call   80b3db <tcp_output>
  81090a:	b8 01 00 00 00       	mov    $0x1,%eax
  81090f:	e9 cb 02 00 00       	jmp    810bdf <tcp_receive+0xc70>
  810914:	83 c8 01             	or     $0x1,%eax
  810917:	88 43 20             	mov    %al,0x20(%ebx)
  81091a:	b8 01 00 00 00       	mov    $0x1,%eax
  81091f:	e9 bb 02 00 00       	jmp    810bdf <tcp_receive+0xc70>

      } else {
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
  810924:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810928:	89 1c 24             	mov    %ebx,(%esp)
  81092b:	e8 ab aa ff ff       	call   80b3db <tcp_output>
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
  810930:	8b 73 7c             	mov    0x7c(%ebx),%esi
  810933:	85 f6                	test   %esi,%esi
  810935:	74 31                	je     810968 <tcp_receive+0x9f9>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810937:	8b 46 10             	mov    0x10(%esi),%eax
  81093a:	8b 40 04             	mov    0x4(%eax),%eax
  81093d:	8b 15 78 f5 b3 00    	mov    0xb3f578,%edx
  810943:	39 d0                	cmp    %edx,%eax
  810945:	74 18                	je     81095f <tcp_receive+0x9f0>
  810947:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  81094a:	bf 00 00 00 00       	mov    $0x0,%edi
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  81094f:	8d 72 01             	lea    0x1(%edx),%esi
  810952:	8b 4d e4             	mov    -0x1c(%ebp),%ecx
  810955:	89 5d e0             	mov    %ebx,-0x20(%ebp)
  810958:	89 f3                	mov    %esi,%ebx
  81095a:	e9 b7 00 00 00       	jmp    810a16 <tcp_receive+0xaa7>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  81095f:	c7 45 e4 00 00 00 00 	movl   $0x0,-0x1c(%ebp)
  810966:	eb 1f                	jmp    810987 <tcp_receive+0xa18>
        /* We get here if the incoming segment is out-of-sequence. */
        tcp_ack_now(pcb);
#if TCP_QUEUE_OOSEQ
        /* We queue the segment on the ->ooseq queue. */
        if (pcb->ooseq == NULL) {
          pcb->ooseq = tcp_seg_copy(&inseg);
  810968:	c7 04 24 5c f5 b3 00 	movl   $0xb3f55c,(%esp)
  81096f:	e8 1a 81 ff ff       	call   808a8e <tcp_seg_copy>
  810974:	89 43 7c             	mov    %eax,0x7c(%ebx)
  810977:	b8 00 00 00 00       	mov    $0x0,%eax
  81097c:	e9 5e 02 00 00       	jmp    810bdf <tcp_receive+0xc70>
  810981:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810984:	8b 5d e0             	mov    -0x20(%ebp),%ebx
            if (seqno == next->tcphdr->seqno) {
              /* The sequence number of the incoming segment is the
                 same as the sequence number of the segment on
                 ->ooseq. We check the lengths to see which one to
                 discard. */
              if (inseg.len > next->len) {
  810987:	0f b7 05 68 f5 b3 00 	movzwl 0xb3f568,%eax
  81098e:	66 3b 46 0c          	cmp    0xc(%esi),%ax
  810992:	0f 86 42 02 00 00    	jbe    810bda <tcp_receive+0xc6b>
                /* The incoming segment is larger than the old
                   segment. We replace the old segment with the new
                   one. */
                cseg = tcp_seg_copy(&inseg);
  810998:	c7 04 24 5c f5 b3 00 	movl   $0xb3f55c,(%esp)
  81099f:	e8 ea 80 ff ff       	call   808a8e <tcp_seg_copy>
  8109a4:	89 c7                	mov    %eax,%edi
                if (cseg != NULL) {
  8109a6:	85 c0                	test   %eax,%eax
  8109a8:	0f 84 2c 02 00 00    	je     810bda <tcp_receive+0xc6b>
                  cseg->next = next->next;
  8109ae:	8b 06                	mov    (%esi),%eax
  8109b0:	89 07                	mov    %eax,(%edi)
                  if (prev != NULL) {
  8109b2:	83 7d e4 00          	cmpl   $0x0,-0x1c(%ebp)
  8109b6:	74 07                	je     8109bf <tcp_receive+0xa50>
                    prev->next = cseg;
  8109b8:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  8109bb:	89 3b                	mov    %edi,(%ebx)
  8109bd:	eb 03                	jmp    8109c2 <tcp_receive+0xa53>
                  } else {
                    pcb->ooseq = cseg;
  8109bf:	89 7b 7c             	mov    %edi,0x7c(%ebx)
                  }
                  tcp_seg_free(next);
  8109c2:	89 34 24             	mov    %esi,(%esp)
  8109c5:	e8 07 81 ff ff       	call   808ad1 <tcp_seg_free>
                  if (cseg->next != NULL) {
  8109ca:	8b 17                	mov    (%edi),%edx
  8109cc:	85 d2                	test   %edx,%edx
  8109ce:	0f 84 06 02 00 00    	je     810bda <tcp_receive+0xc6b>
                    next = cseg->next;
                    if (TCP_SEQ_GT(seqno + cseg->len, next->tcphdr->seqno)) {
  8109d4:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  8109d9:	8b 52 10             	mov    0x10(%edx),%edx
  8109dc:	8b 52 04             	mov    0x4(%edx),%edx
  8109df:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  8109e3:	29 d1                	sub    %edx,%ecx
  8109e5:	01 c1                	add    %eax,%ecx
  8109e7:	85 c9                	test   %ecx,%ecx
  8109e9:	0f 8e eb 01 00 00    	jle    810bda <tcp_receive+0xc6b>
                      /* We need to trim the incoming segment. */
                      cseg->len = (u16_t)(next->tcphdr->seqno - seqno);
  8109ef:	66 29 c2             	sub    %ax,%dx
  8109f2:	66 89 57 0c          	mov    %dx,0xc(%edi)
                      pbuf_realloc(cseg->p, cseg->len);
  8109f6:	0f b7 c2             	movzwl %dx,%eax
  8109f9:	89 44 24 04          	mov    %eax,0x4(%esp)
  8109fd:	8b 47 04             	mov    0x4(%edi),%eax
  810a00:	89 04 24             	mov    %eax,(%esp)
  810a03:	e8 d8 76 ff ff       	call   8080e0 <pbuf_realloc>
  810a08:	b8 00 00 00 00       	mov    $0x0,%eax
  810a0d:	e9 cd 01 00 00       	jmp    810bdf <tcp_receive+0xc70>
  810a12:	89 cf                	mov    %ecx,%edi
  810a14:	89 f1                	mov    %esi,%ecx
                   segment was smaller than the old one; in either
                   case, we ditch the incoming segment. */
                break;
              }
            } else {
              if (prev == NULL) {
  810a16:	85 ff                	test   %edi,%edi
  810a18:	75 60                	jne    810a7a <tcp_receive+0xb0b>
                if (TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {
  810a1a:	39 c2                	cmp    %eax,%edx
  810a1c:	0f 89 fd 00 00 00    	jns    810b1f <tcp_receive+0xbb0>
  810a22:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810a25:	8b 5d e0             	mov    -0x20(%ebp),%ebx
                  /* The sequence number of the incoming segment is lower
                     than the sequence number of the first segment on the
                     queue. We put the incoming segment first on the
                     queue. */

                  if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810a28:	0f b7 0d 68 f5 b3 00 	movzwl 0xb3f568,%ecx
  810a2f:	01 d1                	add    %edx,%ecx
  810a31:	29 c1                	sub    %eax,%ecx
  810a33:	85 c9                	test   %ecx,%ecx
  810a35:	7e 1d                	jle    810a54 <tcp_receive+0xae5>
                    /* We need to trim the incoming segment. */
                    inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810a37:	66 29 d0             	sub    %dx,%ax
  810a3a:	66 a3 68 f5 b3 00    	mov    %ax,0xb3f568
                    pbuf_realloc(inseg.p, inseg.len);
  810a40:	0f b7 c0             	movzwl %ax,%eax
  810a43:	89 44 24 04          	mov    %eax,0x4(%esp)
  810a47:	a1 60 f5 b3 00       	mov    0xb3f560,%eax
  810a4c:	89 04 24             	mov    %eax,(%esp)
  810a4f:	e8 8c 76 ff ff       	call   8080e0 <pbuf_realloc>
                  }
                  cseg = tcp_seg_copy(&inseg);
  810a54:	c7 04 24 5c f5 b3 00 	movl   $0xb3f55c,(%esp)
  810a5b:	e8 2e 80 ff ff       	call   808a8e <tcp_seg_copy>
                  if (cseg != NULL) {
  810a60:	85 c0                	test   %eax,%eax
  810a62:	0f 84 72 01 00 00    	je     810bda <tcp_receive+0xc6b>
                    cseg->next = next;
  810a68:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  810a6b:	89 30                	mov    %esi,(%eax)
                    pcb->ooseq = cseg;
  810a6d:	89 43 7c             	mov    %eax,0x7c(%ebx)
  810a70:	b8 00 00 00 00       	mov    $0x0,%eax
  810a75:	e9 65 01 00 00       	jmp    810bdf <tcp_receive+0xc70>
                  break;
                }
              } else 
                /*if (TCP_SEQ_LT(prev->tcphdr->seqno, seqno) &&
                  TCP_SEQ_LT(seqno, next->tcphdr->seqno)) {*/
                if(TCP_SEQ_BETWEEN(seqno, prev->tcphdr->seqno+1, next->tcphdr->seqno-1)){
  810a7a:	8b 77 10             	mov    0x10(%edi),%esi
  810a7d:	8b 76 04             	mov    0x4(%esi),%esi
  810a80:	f7 d6                	not    %esi
  810a82:	01 d6                	add    %edx,%esi
  810a84:	0f 88 95 00 00 00    	js     810b1f <tcp_receive+0xbb0>
  810a8a:	89 de                	mov    %ebx,%esi
  810a8c:	29 c6                	sub    %eax,%esi
  810a8e:	85 f6                	test   %esi,%esi
  810a90:	0f 8f 89 00 00 00    	jg     810b1f <tcp_receive+0xbb0>
  810a96:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
                /* The sequence number of the incoming segment is in
                   between the sequence numbers of the previous and
                   the next segment on ->ooseq. We trim and insert the
                   incoming segment and trim the previous segment, if
                   needed. */
                if (TCP_SEQ_GT(seqno + inseg.len, next->tcphdr->seqno)) {
  810a99:	0f b7 0d 68 f5 b3 00 	movzwl 0xb3f568,%ecx
  810aa0:	01 d1                	add    %edx,%ecx
  810aa2:	29 c1                	sub    %eax,%ecx
  810aa4:	85 c9                	test   %ecx,%ecx
  810aa6:	7e 1d                	jle    810ac5 <tcp_receive+0xb56>
                  /* We need to trim the incoming segment. */
                  inseg.len = (u16_t)(next->tcphdr->seqno - seqno);
  810aa8:	66 29 d0             	sub    %dx,%ax
  810aab:	66 a3 68 f5 b3 00    	mov    %ax,0xb3f568
                  pbuf_realloc(inseg.p, inseg.len);
  810ab1:	0f b7 c0             	movzwl %ax,%eax
  810ab4:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ab8:	a1 60 f5 b3 00       	mov    0xb3f560,%eax
  810abd:	89 04 24             	mov    %eax,(%esp)
  810ac0:	e8 1b 76 ff ff       	call   8080e0 <pbuf_realloc>
                }

                cseg = tcp_seg_copy(&inseg);
  810ac5:	c7 04 24 5c f5 b3 00 	movl   $0xb3f55c,(%esp)
  810acc:	e8 bd 7f ff ff       	call   808a8e <tcp_seg_copy>
                if (cseg != NULL) {
  810ad1:	85 c0                	test   %eax,%eax
  810ad3:	0f 84 01 01 00 00    	je     810bda <tcp_receive+0xc6b>
                  cseg->next = next;
  810ad9:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  810adc:	89 10                	mov    %edx,(%eax)
                  prev->next = cseg;
  810ade:	89 07                	mov    %eax,(%edi)
                  if (TCP_SEQ_GT(prev->tcphdr->seqno + prev->len, seqno)) {
  810ae0:	8b 47 10             	mov    0x10(%edi),%eax
  810ae3:	8b 40 04             	mov    0x4(%eax),%eax
  810ae6:	8b 15 78 f5 b3 00    	mov    0xb3f578,%edx
  810aec:	0f b7 4f 0c          	movzwl 0xc(%edi),%ecx
  810af0:	29 d1                	sub    %edx,%ecx
  810af2:	01 c1                	add    %eax,%ecx
  810af4:	85 c9                	test   %ecx,%ecx
  810af6:	0f 8e de 00 00 00    	jle    810bda <tcp_receive+0xc6b>
                    /* We need to trim the prev segment. */
                    prev->len = (u16_t)(seqno - prev->tcphdr->seqno);
  810afc:	66 29 c2             	sub    %ax,%dx
  810aff:	66 89 57 0c          	mov    %dx,0xc(%edi)
                    pbuf_realloc(prev->p, prev->len);
  810b03:	0f b7 c2             	movzwl %dx,%eax
  810b06:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b0a:	8b 47 04             	mov    0x4(%edi),%eax
  810b0d:	89 04 24             	mov    %eax,(%esp)
  810b10:	e8 cb 75 ff ff       	call   8080e0 <pbuf_realloc>
  810b15:	b8 00 00 00 00       	mov    $0x0,%eax
  810b1a:	e9 c0 00 00 00       	jmp    810bdf <tcp_receive+0xc70>
                break;
              }
              /* If the "next" segment is the last segment on the
                 ooseq queue, we add the incoming segment to the end
                 of the list. */
              if (next->next == NULL &&
  810b1f:	8b 31                	mov    (%ecx),%esi
  810b21:	85 f6                	test   %esi,%esi
  810b23:	75 5e                	jne    810b83 <tcp_receive+0xc14>
  810b25:	89 4d e4             	mov    %ecx,-0x1c(%ebp)
  810b28:	29 c2                	sub    %eax,%edx
  810b2a:	85 d2                	test   %edx,%edx
  810b2c:	0f 8e a8 00 00 00    	jle    810bda <tcp_receive+0xc6b>
                  TCP_SEQ_GT(seqno, next->tcphdr->seqno)) {
                next->next = tcp_seg_copy(&inseg);
  810b32:	c7 04 24 5c f5 b3 00 	movl   $0xb3f55c,(%esp)
  810b39:	e8 50 7f ff ff       	call   808a8e <tcp_seg_copy>
  810b3e:	8b 5d e4             	mov    -0x1c(%ebp),%ebx
  810b41:	89 03                	mov    %eax,(%ebx)
                if (next->next != NULL) {
  810b43:	85 c0                	test   %eax,%eax
  810b45:	0f 84 8f 00 00 00    	je     810bda <tcp_receive+0xc6b>
                  if (TCP_SEQ_GT(next->tcphdr->seqno + next->len, seqno)) {
  810b4b:	8b 43 10             	mov    0x10(%ebx),%eax
  810b4e:	8b 40 04             	mov    0x4(%eax),%eax
  810b51:	8b 15 78 f5 b3 00    	mov    0xb3f578,%edx
  810b57:	0f b7 4b 0c          	movzwl 0xc(%ebx),%ecx
  810b5b:	29 d1                	sub    %edx,%ecx
  810b5d:	01 c1                	add    %eax,%ecx
  810b5f:	85 c9                	test   %ecx,%ecx
  810b61:	7e 77                	jle    810bda <tcp_receive+0xc6b>
                    /* We need to trim the last segment. */
                    next->len = (u16_t)(seqno - next->tcphdr->seqno);
  810b63:	66 29 c2             	sub    %ax,%dx
  810b66:	66 89 53 0c          	mov    %dx,0xc(%ebx)
                    pbuf_realloc(next->p, next->len);
  810b6a:	0f b7 c2             	movzwl %dx,%eax
  810b6d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810b71:	8b 43 04             	mov    0x4(%ebx),%eax
  810b74:	89 04 24             	mov    %eax,(%esp)
  810b77:	e8 64 75 ff ff       	call   8080e0 <pbuf_realloc>
  810b7c:	b8 00 00 00 00       	mov    $0x0,%eax
  810b81:	eb 5c                	jmp    810bdf <tcp_receive+0xc70>
             segment on the ->ooseq queue, we discard the segment that
             contains less data. */

          prev = NULL;
          for(next = pcb->ooseq; next != NULL; next = next->next) {
            if (seqno == next->tcphdr->seqno) {
  810b83:	8b 46 10             	mov    0x10(%esi),%eax
  810b86:	8b 40 04             	mov    0x4(%eax),%eax
  810b89:	39 d0                	cmp    %edx,%eax
  810b8b:	0f 85 81 fe ff ff    	jne    810a12 <tcp_receive+0xaa3>
  810b91:	e9 eb fd ff ff       	jmp    810981 <tcp_receive+0xa12>
        }
#endif /* TCP_QUEUE_OOSEQ */

      }
    } else {
      tcp_ack_now(pcb);
  810b96:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810b9a:	89 1c 24             	mov    %ebx,(%esp)
  810b9d:	e8 39 a8 ff ff       	call   80b3db <tcp_output>
  810ba2:	b8 00 00 00 00       	mov    $0x0,%eax
  810ba7:	eb 36                	jmp    810bdf <tcp_receive+0xc70>
  } else {
    /* Segments with length 0 is taken care of here. Segments that
       fall out of the window are ACKed. */
    /*if (TCP_SEQ_GT(pcb->rcv_nxt, seqno) ||
      TCP_SEQ_GEQ(seqno, pcb->rcv_nxt + pcb->rcv_wnd)) {*/
    if(!TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, pcb->rcv_nxt + pcb->rcv_wnd-1)){
  810ba9:	8b 15 78 f5 b3 00    	mov    0xb3f578,%edx
  810baf:	8b 43 24             	mov    0x24(%ebx),%eax
  810bb2:	39 c2                	cmp    %eax,%edx
  810bb4:	78 11                	js     810bc7 <tcp_receive+0xc58>
  810bb6:	83 c2 01             	add    $0x1,%edx
  810bb9:	29 c2                	sub    %eax,%edx
  810bbb:	89 d0                	mov    %edx,%eax
  810bbd:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  810bc1:	29 c8                	sub    %ecx,%eax
  810bc3:	85 c0                	test   %eax,%eax
  810bc5:	7e 13                	jle    810bda <tcp_receive+0xc6b>
      tcp_ack_now(pcb);
  810bc7:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810bcb:	89 1c 24             	mov    %ebx,(%esp)
  810bce:	e8 08 a8 ff ff       	call   80b3db <tcp_output>
  810bd3:	b8 00 00 00 00       	mov    $0x0,%eax
  810bd8:	eb 05                	jmp    810bdf <tcp_receive+0xc70>
  810bda:	b8 00 00 00 00       	mov    $0x0,%eax
    }
  }
  return accepted_inseq;
}
  810bdf:	83 c4 2c             	add    $0x2c,%esp
  810be2:	5b                   	pop    %ebx
  810be3:	5e                   	pop    %esi
  810be4:	5f                   	pop    %edi
  810be5:	5d                   	pop    %ebp
  810be6:	c3                   	ret    

00810be7 <tcp_input>:
 * @param p received TCP segment to process (p->payload pointing to the IP header)
 * @param inp network interface on which this segment was received
 */
void
tcp_input(struct pbuf *p, struct netif *inp)
{
  810be7:	55                   	push   %ebp
  810be8:	89 e5                	mov    %esp,%ebp
  810bea:	57                   	push   %edi
  810beb:	56                   	push   %esi
  810bec:	53                   	push   %ebx
  810bed:	83 ec 5c             	sub    $0x5c,%esp
  810bf0:	8b 75 08             	mov    0x8(%ebp),%esi
  PERF_START;

  TCP_STATS_INC(tcp.recv);
  snmp_inc_tcpinsegs();

  iphdr = p->payload;
  810bf3:	8b 46 04             	mov    0x4(%esi),%eax
  810bf6:	a3 74 f5 b3 00       	mov    %eax,0xb3f574
  tcphdr = (struct tcp_hdr *)((u8_t *)p->payload + IPH_HL(iphdr) * 4);
  810bfb:	8b 5e 04             	mov    0x4(%esi),%ebx
  810bfe:	0f b7 00             	movzwl (%eax),%eax
  810c01:	89 04 24             	mov    %eax,(%esp)
  810c04:	e8 58 a1 ff ff       	call   80ad61 <ntohs>
  810c09:	c1 e8 06             	shr    $0x6,%eax
  810c0c:	83 e0 3c             	and    $0x3c,%eax
  810c0f:	01 c3                	add    %eax,%ebx
  810c11:	89 1d 70 f5 b3 00    	mov    %ebx,0xb3f570
#if TCP_INPUT_DEBUG
  tcp_debug_print(tcphdr);
#endif

  /* remove header from payload */
  if (pbuf_header(p, -((s16_t)(IPH_HL(iphdr) * 4))) || (p->tot_len < sizeof(struct tcp_hdr))) {
  810c17:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
  810c1c:	0f b7 00             	movzwl (%eax),%eax
  810c1f:	89 04 24             	mov    %eax,(%esp)
  810c22:	e8 3a a1 ff ff       	call   80ad61 <ntohs>
  810c27:	66 c1 e8 06          	shr    $0x6,%ax
  810c2b:	83 e0 3c             	and    $0x3c,%eax
  810c2e:	f7 d8                	neg    %eax
  810c30:	98                   	cwtl   
  810c31:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c35:	89 34 24             	mov    %esi,(%esp)
  810c38:	e8 a6 6f ff ff       	call   807be3 <pbuf_header>
  810c3d:	84 c0                	test   %al,%al
  810c3f:	75 07                	jne    810c48 <tcp_input+0x61>
  810c41:	66 83 7e 08 13       	cmpw   $0x13,0x8(%esi)
  810c46:	77 12                	ja     810c5a <tcp_input+0x73>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet (%"U16_F" bytes) discarded\n", p->tot_len));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c48:	89 34 24             	mov    %esi,(%esp)
  810c4b:	90                   	nop
  810c4c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  810c50:	e8 03 73 ff ff       	call   807f58 <pbuf_free>
    return;
  810c55:	e9 9a 0d 00 00       	jmp    8119f4 <tcp_input+0xe0d>
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  810c5a:	8b 45 0c             	mov    0xc(%ebp),%eax
  810c5d:	89 44 24 04          	mov    %eax,0x4(%esp)
  810c61:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
  810c66:	83 c0 10             	add    $0x10,%eax
  810c69:	89 04 24             	mov    %eax,(%esp)
  810c6c:	e8 d7 8c ff ff       	call   809948 <ip_addr_isbroadcast>
  810c71:	84 c0                	test   %al,%al
  810c73:	75 28                	jne    810c9d <tcp_input+0xb6>
      ip_addr_ismulticast(&(iphdr->dest))) {
  810c75:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
  810c7a:	8b 78 10             	mov    0x10(%eax),%edi
  810c7d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  810c84:	e8 11 a3 ff ff       	call   80af9a <ntohl>
  810c89:	89 c3                	mov    %eax,%ebx
  810c8b:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  810c92:	e8 03 a3 ff ff       	call   80af9a <ntohl>
    pbuf_free(p);
    return;
  }

  /* Don't even process incoming broadcasts/multicasts. */
  if (ip_addr_isbroadcast(&(iphdr->dest), inp) ||
  810c97:	21 fb                	and    %edi,%ebx
  810c99:	39 c3                	cmp    %eax,%ebx
  810c9b:	75 0d                	jne    810caa <tcp_input+0xc3>
      ip_addr_ismulticast(&(iphdr->dest))) {
    TCP_STATS_INC(tcp.proterr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810c9d:	89 34 24             	mov    %esi,(%esp)
  810ca0:	e8 b3 72 ff ff       	call   807f58 <pbuf_free>
    return;
  810ca5:	e9 4a 0d 00 00       	jmp    8119f4 <tcp_input+0xe0d>
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
      (struct ip_addr *)&(iphdr->dest),
  810caa:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
    return;
  }

#if CHECKSUM_CHECK_TCP
  /* Verify TCP checksum. */
  if (inet_chksum_pseudo(p, (struct ip_addr *)&(iphdr->src),
  810caf:	0f b7 56 08          	movzwl 0x8(%esi),%edx
  810cb3:	89 54 24 10          	mov    %edx,0x10(%esp)
  810cb7:	c7 44 24 0c 06 00 00 	movl   $0x6,0xc(%esp)
  810cbe:	00 
  810cbf:	8d 50 10             	lea    0x10(%eax),%edx
  810cc2:	89 54 24 08          	mov    %edx,0x8(%esp)
  810cc6:	83 c0 0c             	add    $0xc,%eax
  810cc9:	89 44 24 04          	mov    %eax,0x4(%esp)
  810ccd:	89 34 24             	mov    %esi,(%esp)
  810cd0:	e8 7b 9d ff ff       	call   80aa50 <inet_chksum_pseudo>
  810cd5:	66 85 c0             	test   %ax,%ax
  810cd8:	74 0d                	je     810ce7 <tcp_input+0x100>
    tcp_debug_print(tcphdr);
#endif /* TCP_DEBUG */
    TCP_STATS_INC(tcp.chkerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810cda:	89 34 24             	mov    %esi,(%esp)
  810cdd:	e8 76 72 ff ff       	call   807f58 <pbuf_free>
    return;
  810ce2:	e9 0d 0d 00 00       	jmp    8119f4 <tcp_input+0xe0d>
  }
#endif

  /* Move the payload pointer in the pbuf so that it points to the
     TCP data instead of the TCP header. */
  hdrlen = TCPH_HDRLEN(tcphdr);
  810ce7:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  810cec:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810cf0:	89 04 24             	mov    %eax,(%esp)
  810cf3:	e8 69 a0 ff ff       	call   80ad61 <ntohs>
  if(pbuf_header(p, -(hdrlen * 4))){
  810cf8:	66 c1 e8 0c          	shr    $0xc,%ax
  810cfc:	c1 e0 02             	shl    $0x2,%eax
  810cff:	f7 d8                	neg    %eax
  810d01:	98                   	cwtl   
  810d02:	89 44 24 04          	mov    %eax,0x4(%esp)
  810d06:	89 34 24             	mov    %esi,(%esp)
  810d09:	e8 d5 6e ff ff       	call   807be3 <pbuf_header>
  810d0e:	84 c0                	test   %al,%al
  810d10:	74 0d                	je     810d1f <tcp_input+0x138>
    /* drop short packets */
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: short packet\n"));
    TCP_STATS_INC(tcp.lenerr);
    TCP_STATS_INC(tcp.drop);
    snmp_inc_tcpinerrs();
    pbuf_free(p);
  810d12:	89 34 24             	mov    %esi,(%esp)
  810d15:	e8 3e 72 ff ff       	call   807f58 <pbuf_free>
    return;
  810d1a:	e9 d5 0c 00 00       	jmp    8119f4 <tcp_input+0xe0d>
  }

  /* Convert fields in TCP header to host byte order. */
  tcphdr->src = ntohs(tcphdr->src);
  810d1f:	8b 1d 70 f5 b3 00    	mov    0xb3f570,%ebx
  810d25:	0f b7 03             	movzwl (%ebx),%eax
  810d28:	89 04 24             	mov    %eax,(%esp)
  810d2b:	e8 31 a0 ff ff       	call   80ad61 <ntohs>
  810d30:	66 89 03             	mov    %ax,(%ebx)
  tcphdr->dest = ntohs(tcphdr->dest);
  810d33:	8b 1d 70 f5 b3 00    	mov    0xb3f570,%ebx
  810d39:	0f b7 43 02          	movzwl 0x2(%ebx),%eax
  810d3d:	89 04 24             	mov    %eax,(%esp)
  810d40:	e8 1c a0 ff ff       	call   80ad61 <ntohs>
  810d45:	66 89 43 02          	mov    %ax,0x2(%ebx)
  seqno = tcphdr->seqno = ntohl(tcphdr->seqno);
  810d49:	8b 1d 70 f5 b3 00    	mov    0xb3f570,%ebx
  810d4f:	8b 43 04             	mov    0x4(%ebx),%eax
  810d52:	89 04 24             	mov    %eax,(%esp)
  810d55:	e8 40 a2 ff ff       	call   80af9a <ntohl>
  810d5a:	89 43 04             	mov    %eax,0x4(%ebx)
  810d5d:	a3 78 f5 b3 00       	mov    %eax,0xb3f578
  ackno = tcphdr->ackno = ntohl(tcphdr->ackno);
  810d62:	8b 1d 70 f5 b3 00    	mov    0xb3f570,%ebx
  810d68:	8b 43 08             	mov    0x8(%ebx),%eax
  810d6b:	89 04 24             	mov    %eax,(%esp)
  810d6e:	e8 27 a2 ff ff       	call   80af9a <ntohl>
  810d73:	89 43 08             	mov    %eax,0x8(%ebx)
  810d76:	a3 7c f5 b3 00       	mov    %eax,0xb3f57c
  tcphdr->wnd = ntohs(tcphdr->wnd);
  810d7b:	8b 1d 70 f5 b3 00    	mov    0xb3f570,%ebx
  810d81:	0f b7 43 0e          	movzwl 0xe(%ebx),%eax
  810d85:	89 04 24             	mov    %eax,(%esp)
  810d88:	e8 d4 9f ff ff       	call   80ad61 <ntohs>
  810d8d:	66 89 43 0e          	mov    %ax,0xe(%ebx)

  flags = TCPH_FLAGS(tcphdr) & TCP_FLAGS;
  810d91:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  810d96:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  810d9a:	89 04 24             	mov    %eax,(%esp)
  810d9d:	e8 bf 9f ff ff       	call   80ad61 <ntohs>
  810da2:	83 e0 3f             	and    $0x3f,%eax
  810da5:	a2 80 f5 b3 00       	mov    %al,0xb3f580
  tcplen = p->tot_len + ((flags & TCP_FIN || flags & TCP_SYN)? 1: 0);
  810daa:	0f b7 4e 08          	movzwl 0x8(%esi),%ecx
  810dae:	ba 01 00 00 00       	mov    $0x1,%edx
  810db3:	a8 01                	test   $0x1,%al
  810db5:	75 07                	jne    810dbe <tcp_input+0x1d7>
  810db7:	d1 e8                	shr    %eax
  810db9:	89 c2                	mov    %eax,%edx
  810dbb:	83 e2 01             	and    $0x1,%edx
  810dbe:	8d 14 11             	lea    (%ecx,%edx,1),%edx
  810dc1:	66 89 15 82 f5 b3 00 	mov    %dx,0xb3f582
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810dc8:	8b 1d 08 f6 b3 00    	mov    0xb3f608,%ebx
  810dce:	85 db                	test   %ebx,%ebx
  810dd0:	0f 84 32 01 00 00    	je     810f08 <tcp_input+0x321>
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810dd6:	8b 43 10             	mov    0x10(%ebx),%eax
  810dd9:	85 c0                	test   %eax,%eax
  810ddb:	74 15                	je     810df2 <tcp_input+0x20b>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  810ddd:	83 f8 0a             	cmp    $0xa,%eax
  810de0:	74 31                	je     810e13 <tcp_input+0x22c>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810de2:	83 f8 01             	cmp    $0x1,%eax
  810de5:	75 6f                	jne    810e56 <tcp_input+0x26f>
  810de7:	90                   	nop
  810de8:	eb 50                	jmp    810e3a <tcp_input+0x253>
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
  810dea:	8b 50 10             	mov    0x10(%eax),%edx
  810ded:	85 d2                	test   %edx,%edx
  810def:	90                   	nop
  810df0:	75 1c                	jne    810e0e <tcp_input+0x227>
  810df2:	c7 44 24 08 3c 4f 81 	movl   $0x814f3c,0x8(%esp)
  810df9:	00 
  810dfa:	c7 44 24 04 b5 00 00 	movl   $0xb5,0x4(%esp)
  810e01:	00 
  810e02:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810e09:	e8 c6 fb fe ff       	call   8009d4 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
  810e0e:	83 fa 0a             	cmp    $0xa,%edx
  810e11:	75 1c                	jne    810e2f <tcp_input+0x248>
  810e13:	c7 44 24 08 64 4f 81 	movl   $0x814f64,0x8(%esp)
  810e1a:	00 
  810e1b:	c7 44 24 04 b6 00 00 	movl   $0xb6,0x4(%esp)
  810e22:	00 
  810e23:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810e2a:	e8 a5 fb fe ff       	call   8009d4 <_panic>
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
  810e2f:	83 fa 01             	cmp    $0x1,%edx
  810e32:	74 06                	je     810e3a <tcp_input+0x253>
  810e34:	89 da                	mov    %ebx,%edx
  810e36:	89 c3                	mov    %eax,%ebx
  810e38:	eb 35                	jmp    810e6f <tcp_input+0x288>
  810e3a:	c7 44 24 08 90 4f 81 	movl   $0x814f90,0x8(%esp)
  810e41:	00 
  810e42:	c7 44 24 04 b7 00 00 	movl   $0xb7,0x4(%esp)
  810e49:	00 
  810e4a:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810e51:	e8 7e fb fe ff       	call   8009d4 <_panic>
    if (pcb->remote_port == tcphdr->src &&
  810e56:	8b 3d 70 f5 b3 00    	mov    0xb3f570,%edi
  810e5c:	0f b7 0f             	movzwl (%edi),%ecx
       pcb->local_port == tcphdr->dest &&
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810e5f:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
  810e64:	89 45 d4             	mov    %eax,-0x2c(%ebp)
  810e67:	ba 00 00 00 00       	mov    $0x0,%edx
  810e6c:	89 75 c4             	mov    %esi,-0x3c(%ebp)
  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
    LWIP_ASSERT("tcp_input: active pcb->state != CLOSED", pcb->state != CLOSED);
    LWIP_ASSERT("tcp_input: active pcb->state != TIME-WAIT", pcb->state != TIME_WAIT);
    LWIP_ASSERT("tcp_input: active pcb->state != LISTEN", pcb->state != LISTEN);
    if (pcb->remote_port == tcphdr->src &&
  810e6f:	66 39 4b 1e          	cmp    %cx,0x1e(%ebx)
  810e73:	75 7b                	jne    810ef0 <tcp_input+0x309>
       pcb->local_port == tcphdr->dest &&
  810e75:	0f b7 43 1c          	movzwl 0x1c(%ebx),%eax
  810e79:	66 3b 47 02          	cmp    0x2(%edi),%ax
  810e7d:	75 71                	jne    810ef0 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810e7f:	8b 43 04             	mov    0x4(%ebx),%eax
  810e82:	8b 75 d4             	mov    -0x2c(%ebp),%esi
  810e85:	3b 46 0c             	cmp    0xc(%esi),%eax
  810e88:	75 66                	jne    810ef0 <tcp_input+0x309>
       ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  810e8a:	8b 03                	mov    (%ebx),%eax
  810e8c:	3b 46 10             	cmp    0x10(%esi),%eax
  810e8f:	75 5f                	jne    810ef0 <tcp_input+0x309>
  810e91:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  810e94:	89 d8                	mov    %ebx,%eax

      /* Move this PCB to the front of the list so that subsequent
         lookups will be faster (we exploit locality in TCP segment
         arrivals). */
      LWIP_ASSERT("tcp_input: pcb->next != pcb (before cache)", pcb->next != pcb);
  810e96:	8b 4b 0c             	mov    0xc(%ebx),%ecx
  810e99:	39 d9                	cmp    %ebx,%ecx
  810e9b:	75 1c                	jne    810eb9 <tcp_input+0x2d2>
  810e9d:	c7 44 24 08 b8 4f 81 	movl   $0x814fb8,0x8(%esp)
  810ea4:	00 
  810ea5:	c7 44 24 04 c0 00 00 	movl   $0xc0,0x4(%esp)
  810eac:	00 
  810ead:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810eb4:	e8 1b fb fe ff       	call   8009d4 <_panic>
      if (prev != NULL) {
  810eb9:	85 d2                	test   %edx,%edx
  810ebb:	74 43                	je     810f00 <tcp_input+0x319>
        prev->next = pcb->next;
  810ebd:	89 4a 0c             	mov    %ecx,0xc(%edx)
        pcb->next = tcp_active_pcbs;
  810ec0:	8b 15 08 f6 b3 00    	mov    0xb3f608,%edx
  810ec6:	89 53 0c             	mov    %edx,0xc(%ebx)
        tcp_active_pcbs = pcb;
  810ec9:	89 1d 08 f6 b3 00    	mov    %ebx,0xb3f608
      }
      LWIP_ASSERT("tcp_input: pcb->next != pcb (after cache)", pcb->next != pcb);
  810ecf:	39 5b 0c             	cmp    %ebx,0xc(%ebx)
  810ed2:	75 2c                	jne    810f00 <tcp_input+0x319>
  810ed4:	c7 44 24 08 e4 4f 81 	movl   $0x814fe4,0x8(%esp)
  810edb:	00 
  810edc:	c7 44 24 04 c6 00 00 	movl   $0xc6,0x4(%esp)
  810ee3:	00 
  810ee4:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810eeb:	e8 e4 fa fe ff       	call   8009d4 <_panic>
  /* Demultiplex an incoming segment. First, we check if it is destined
     for an active connection. */
  prev = NULL;

  
  for(pcb = tcp_active_pcbs; pcb != NULL; pcb = pcb->next) {
  810ef0:	8b 43 0c             	mov    0xc(%ebx),%eax
  810ef3:	85 c0                	test   %eax,%eax
  810ef5:	0f 85 ef fe ff ff    	jne    810dea <tcp_input+0x203>
  810efb:	8b 75 c4             	mov    -0x3c(%ebp),%esi
  810efe:	eb 08                	jmp    810f08 <tcp_input+0x321>
      break;
    }
    prev = pcb;
  }

  if (pcb == NULL) {
  810f00:	85 c0                	test   %eax,%eax
  810f02:	0f 85 be 02 00 00    	jne    8111c6 <tcp_input+0x5df>
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810f08:	8b 1d 1c f6 b3 00    	mov    0xb3f61c,%ebx
  810f0e:	85 db                	test   %ebx,%ebx
  810f10:	0f 84 ad 00 00 00    	je     810fc3 <tcp_input+0x3dc>
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
  810f16:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810f1a:	74 2a                	je     810f46 <tcp_input+0x35f>
  810f1c:	eb 0c                	jmp    810f2a <tcp_input+0x343>
  810f1e:	83 7b 10 0a          	cmpl   $0xa,0x10(%ebx)
  810f22:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  810f28:	74 2b                	je     810f55 <tcp_input+0x36e>
  810f2a:	c7 44 24 08 10 50 81 	movl   $0x815010,0x8(%esp)
  810f31:	00 
  810f32:	c7 44 24 04 d0 00 00 	movl   $0xd0,0x4(%esp)
  810f39:	00 
  810f3a:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  810f41:	e8 8e fa fe ff       	call   8009d4 <_panic>
      if (pcb->remote_port == tcphdr->src &&
  810f46:	8b 0d 70 f5 b3 00    	mov    0xb3f570,%ecx
  810f4c:	0f b7 01             	movzwl (%ecx),%eax
         pcb->local_port == tcphdr->dest &&
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810f4f:	8b 3d 74 f5 b3 00    	mov    0xb3f574,%edi
  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
      LWIP_ASSERT("tcp_input: TIME-WAIT pcb->state == TIME-WAIT", pcb->state == TIME_WAIT);
      if (pcb->remote_port == tcphdr->src &&
  810f55:	66 39 43 1e          	cmp    %ax,0x1e(%ebx)
  810f59:	75 5d                	jne    810fb8 <tcp_input+0x3d1>
         pcb->local_port == tcphdr->dest &&
  810f5b:	0f b7 53 1c          	movzwl 0x1c(%ebx),%edx
  810f5f:	66 3b 51 02          	cmp    0x2(%ecx),%dx
  810f63:	75 53                	jne    810fb8 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->remote_ip), &(iphdr->src)) &&
  810f65:	8b 53 04             	mov    0x4(%ebx),%edx
  810f68:	3b 57 0c             	cmp    0xc(%edi),%edx
  810f6b:	75 4b                	jne    810fb8 <tcp_input+0x3d1>
         ip_addr_cmp(&(pcb->local_ip), &(iphdr->dest))) {
  810f6d:	8b 13                	mov    (%ebx),%edx
  810f6f:	3b 57 10             	cmp    0x10(%edi),%edx
  810f72:	75 44                	jne    810fb8 <tcp_input+0x3d1>
 *       involved is passed as a parameter to this function
 */
static err_t
tcp_timewait_input(struct tcp_pcb *pcb)
{
  if (TCP_SEQ_GT(seqno + tcplen, pcb->rcv_nxt)) {
  810f74:	0f b7 05 82 f5 b3 00 	movzwl 0xb3f582,%eax
  810f7b:	03 05 78 f5 b3 00    	add    0xb3f578,%eax
  810f81:	89 c2                	mov    %eax,%edx
  810f83:	2b 53 24             	sub    0x24(%ebx),%edx
  810f86:	85 d2                	test   %edx,%edx
  810f88:	7e 03                	jle    810f8d <tcp_input+0x3a6>
    pcb->rcv_nxt = seqno + tcplen;
  810f8a:	89 43 24             	mov    %eax,0x24(%ebx)
  }
  if (tcplen > 0) {
  810f8d:	66 83 3d 82 f5 b3 00 	cmpw   $0x0,0xb3f582
  810f94:	00 
  810f95:	74 0c                	je     810fa3 <tcp_input+0x3bc>
    tcp_ack_now(pcb);
  810f97:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  810f9b:	89 1c 24             	mov    %ebx,(%esp)
  810f9e:	e8 38 a4 ff ff       	call   80b3db <tcp_output>
  }
  return tcp_output(pcb);
  810fa3:	89 1c 24             	mov    %ebx,(%esp)
  810fa6:	e8 30 a4 ff ff       	call   80b3db <tcp_output>
        /* We don't really care enough to move this PCB to the front
           of the list since we are not very likely to receive that
           many segments for connections in TIME-WAIT. */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for TIME_WAITing connection.\n"));
        tcp_timewait_input(pcb);
        pbuf_free(p);
  810fab:	89 34 24             	mov    %esi,(%esp)
  810fae:	e8 a5 6f ff ff       	call   807f58 <pbuf_free>
        return;
  810fb3:	e9 3c 0a 00 00       	jmp    8119f4 <tcp_input+0xe0d>
  }

  if (pcb == NULL) {
    /* If it did not go to an active connection, we check the connections
       in the TIME-WAIT state. */
    for(pcb = tcp_tw_pcbs; pcb != NULL; pcb = pcb->next) {
  810fb8:	8b 5b 0c             	mov    0xc(%ebx),%ebx
  810fbb:	85 db                	test   %ebx,%ebx
  810fbd:	0f 85 5b ff ff ff    	jne    810f1e <tcp_input+0x337>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  810fc3:	8b 3d 10 f6 b3 00    	mov    0xb3f610,%edi
  810fc9:	85 ff                	test   %edi,%edi
  810fcb:	0f 84 ed 01 00 00    	je     8111be <tcp_input+0x5d7>
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810fd1:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
        lpcb->local_port == tcphdr->dest) {
  810fd6:	8b 0d 70 f5 b3 00    	mov    0xb3f570,%ecx
  810fdc:	ba 00 00 00 00       	mov    $0x0,%edx
  810fe1:	89 5d d4             	mov    %ebx,-0x2c(%ebp)
  810fe4:	89 c3                	mov    %eax,%ebx

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
      if ((ip_addr_isany(&(lpcb->local_ip)) ||
  810fe6:	85 ff                	test   %edi,%edi
  810fe8:	74 0f                	je     810ff9 <tcp_input+0x412>
  810fea:	8b 07                	mov    (%edi),%eax
  810fec:	85 c0                	test   %eax,%eax
  810fee:	74 09                	je     810ff9 <tcp_input+0x412>
        ip_addr_cmp(&(lpcb->local_ip), &(iphdr->dest))) &&
  810ff0:	3b 43 10             	cmp    0x10(%ebx),%eax
  810ff3:	0f 85 b1 01 00 00    	jne    8111aa <tcp_input+0x5c3>
        lpcb->local_port == tcphdr->dest) {
  810ff9:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  810ffd:	66 3b 41 02          	cmp    0x2(%ecx),%ax
  811001:	0f 85 a3 01 00 00    	jne    8111aa <tcp_input+0x5c3>
        /* Move this PCB to the front of the list so that subsequent
           lookups will be faster (we exploit locality in TCP segment
           arrivals). */
        if (prev != NULL) {
  811007:	85 d2                	test   %edx,%edx
  811009:	74 14                	je     81101f <tcp_input+0x438>
          ((struct tcp_pcb_listen *)prev)->next = lpcb->next;
  81100b:	8b 47 0c             	mov    0xc(%edi),%eax
  81100e:	89 42 0c             	mov    %eax,0xc(%edx)
                /* our successor is the remainder of the listening list */
          lpcb->next = tcp_listen_pcbs.listen_pcbs;
  811011:	a1 10 f6 b3 00       	mov    0xb3f610,%eax
  811016:	89 47 0c             	mov    %eax,0xc(%edi)
                /* put this listening pcb at the head of the listening list */
          tcp_listen_pcbs.listen_pcbs = lpcb;
  811019:	89 3d 10 f6 b3 00    	mov    %edi,0xb3f610
  struct tcp_pcb *npcb;
  u32_t optdata;

  /* In the LISTEN state, we check for incoming SYN segments,
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
  81101f:	0f b6 05 80 f5 b3 00 	movzbl 0xb3f580,%eax
  811026:	a8 10                	test   $0x10,%al
  811028:	74 4e                	je     811078 <tcp_input+0x491>
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  81102a:	8b 15 70 f5 b3 00    	mov    0xb3f570,%edx
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
      &(iphdr->dest), &(iphdr->src),
  811030:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
     creates a new PCB, and responds with a SYN|ACK. */
  if (flags & TCP_ACK) {
    /* For incoming segments with the ACK flag set, respond with a
       RST. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_listen_input: ACK in LISTEN, sending reset\n"));
    tcp_rst(ackno + 1, seqno + tcplen,
  811035:	0f b7 0a             	movzwl (%edx),%ecx
  811038:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  81103c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  811040:	89 54 24 10          	mov    %edx,0x10(%esp)
  811044:	8d 50 0c             	lea    0xc(%eax),%edx
  811047:	89 54 24 0c          	mov    %edx,0xc(%esp)
  81104b:	83 c0 10             	add    $0x10,%eax
  81104e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811052:	0f b7 05 82 f5 b3 00 	movzwl 0xb3f582,%eax
  811059:	03 05 78 f5 b3 00    	add    0xb3f578,%eax
  81105f:	89 44 24 04          	mov    %eax,0x4(%esp)
  811063:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  811068:	83 c0 01             	add    $0x1,%eax
  81106b:	89 04 24             	mov    %eax,(%esp)
  81106e:	e8 09 a2 ff ff       	call   80b27c <tcp_rst>
  811073:	e9 25 01 00 00       	jmp    81119d <tcp_input+0x5b6>
      &(iphdr->dest), &(iphdr->src),
      tcphdr->dest, tcphdr->src);
  } else if (flags & TCP_SYN) {
  811078:	a8 02                	test   $0x2,%al
  81107a:	0f 84 1d 01 00 00    	je     81119d <tcp_input+0x5b6>
#if TCP_LISTEN_BACKLOG
    if (pcb->accepts_pending >= pcb->backlog) {
      return ERR_ABRT;
    }
#endif /* TCP_LISTEN_BACKLOG */
    npcb = tcp_alloc(pcb->prio);
  811080:	0f b6 47 14          	movzbl 0x14(%edi),%eax
  811084:	89 04 24             	mov    %eax,(%esp)
  811087:	e8 02 81 ff ff       	call   80918e <tcp_alloc>
  81108c:	89 c3                	mov    %eax,%ebx
    /* If a new PCB could not be created (probably due to lack of memory),
       we don't do anything, but rely on the sender will retransmit the
       SYN at a time when we have more memory available. */
    if (npcb == NULL) {
  81108e:	85 c0                	test   %eax,%eax
  811090:	0f 84 07 01 00 00    	je     81119d <tcp_input+0x5b6>
    }
#if TCP_LISTEN_BACKLOG
    pcb->accepts_pending++;
#endif /* TCP_LISTEN_BACKLOG */
    /* Set up the new PCB. */
    ip_addr_set(&(npcb->local_ip), &(iphdr->dest));
  811096:	8b 15 74 f5 b3 00    	mov    0xb3f574,%edx
  81109c:	b8 00 00 00 00       	mov    $0x0,%eax
  8110a1:	83 fa f0             	cmp    $0xfffffff0,%edx
  8110a4:	74 03                	je     8110a9 <tcp_input+0x4c2>
  8110a6:	8b 42 10             	mov    0x10(%edx),%eax
  8110a9:	89 03                	mov    %eax,(%ebx)
    npcb->local_port = pcb->local_port;
  8110ab:	0f b7 47 1c          	movzwl 0x1c(%edi),%eax
  8110af:	66 89 43 1c          	mov    %ax,0x1c(%ebx)
    ip_addr_set(&(npcb->remote_ip), &(iphdr->src));
  8110b3:	8b 15 74 f5 b3 00    	mov    0xb3f574,%edx
  8110b9:	b8 00 00 00 00       	mov    $0x0,%eax
  8110be:	83 fa f4             	cmp    $0xfffffff4,%edx
  8110c1:	74 03                	je     8110c6 <tcp_input+0x4df>
  8110c3:	8b 42 0c             	mov    0xc(%edx),%eax
  8110c6:	89 43 04             	mov    %eax,0x4(%ebx)
    npcb->remote_port = tcphdr->src;
  8110c9:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  8110ce:	0f b7 00             	movzwl (%eax),%eax
  8110d1:	66 89 43 1e          	mov    %ax,0x1e(%ebx)
    npcb->state = SYN_RCVD;
  8110d5:	c7 43 10 03 00 00 00 	movl   $0x3,0x10(%ebx)
    npcb->rcv_nxt = seqno + 1;
  8110dc:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  8110e1:	83 c0 01             	add    $0x1,%eax
  8110e4:	89 43 24             	mov    %eax,0x24(%ebx)
    npcb->snd_wnd = tcphdr->wnd;
  8110e7:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  8110ec:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  8110f0:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
    npcb->ssthresh = npcb->snd_wnd;
  8110f4:	66 89 43 50          	mov    %ax,0x50(%ebx)
    npcb->snd_wl1 = seqno - 1;/* initialise to seqno-1 to force window update */
  8110f8:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  8110fd:	83 e8 01             	sub    $0x1,%eax
  811100:	89 43 60             	mov    %eax,0x60(%ebx)
    npcb->callback_arg = pcb->callback_arg;
  811103:	8b 47 18             	mov    0x18(%edi),%eax
  811106:	89 43 18             	mov    %eax,0x18(%ebx)
#if LWIP_CALLBACK_API
    npcb->accept = pcb->accept;
  811109:	8b 47 20             	mov    0x20(%edi),%eax
  81110c:	89 83 90 00 00 00    	mov    %eax,0x90(%ebx)
#endif /* LWIP_CALLBACK_API */
    /* inherit socket options */
    npcb->so_options = pcb->so_options & (SOF_DEBUG|SOF_DONTROUTE|SOF_KEEPALIVE|SOF_OOBINLINE|SOF_LINGER);
  811112:	0f b7 47 08          	movzwl 0x8(%edi),%eax
  811116:	66 25 99 01          	and    $0x199,%ax
  81111a:	66 89 43 08          	mov    %ax,0x8(%ebx)
    /* Register the new PCB so that we can begin receiving segments
       for it. */
    TCP_REG(&tcp_active_pcbs, npcb);
  81111e:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
  811123:	89 43 0c             	mov    %eax,0xc(%ebx)
  811126:	89 1d 08 f6 b3 00    	mov    %ebx,0xb3f608
  81112c:	e8 cc 3e ff ff       	call   804ffd <tcp_timer_needed>

    /* Parse any options in the SYN. */
    tcp_parseopt(npcb);
  811131:	89 d8                	mov    %ebx,%eax
  811133:	e8 88 ed ff ff       	call   80fec0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
    npcb->mss = tcp_eff_send_mss(npcb->mss, &(npcb->remote_ip));
  811138:	8d 43 04             	lea    0x4(%ebx),%eax
  81113b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81113f:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  811143:	89 04 24             	mov    %eax,(%esp)
  811146:	e8 f6 77 ff ff       	call   808941 <tcp_eff_send_mss>
  81114b:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

    snmp_inc_tcppassiveopens();

    /* Build an MSS option. */
    optdata = TCP_BUILD_MSS_OPTION();
  81114f:	c7 04 24 b4 05 04 02 	movl   $0x20405b4,(%esp)
  811156:	e8 1a 9c ff ff       	call   80ad75 <htonl>
  81115b:	89 45 e4             	mov    %eax,-0x1c(%ebp)
    /* Send a SYN|ACK together with the MSS option. */
    tcp_enqueue(npcb, NULL, 0, TCP_SYN | TCP_ACK, 0, (u8_t *)&optdata, 4);
  81115e:	c7 44 24 18 04 00 00 	movl   $0x4,0x18(%esp)
  811165:	00 
  811166:	8d 45 e4             	lea    -0x1c(%ebp),%eax
  811169:	89 44 24 14          	mov    %eax,0x14(%esp)
  81116d:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811174:	00 
  811175:	c7 44 24 0c 12 00 00 	movl   $0x12,0xc(%esp)
  81117c:	00 
  81117d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811184:	00 
  811185:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  81118c:	00 
  81118d:	89 1c 24             	mov    %ebx,(%esp)
  811190:	e8 93 a7 ff ff       	call   80b928 <tcp_enqueue>
    return tcp_output(npcb);
  811195:	89 1c 24             	mov    %ebx,(%esp)
  811198:	e8 3e a2 ff ff       	call   80b3db <tcp_output>
          tcp_listen_pcbs.listen_pcbs = lpcb;
        }
      
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
  81119d:	89 34 24             	mov    %esi,(%esp)
  8111a0:	e8 b3 6d ff ff       	call   807f58 <pbuf_free>
        return;
  8111a5:	e9 4a 08 00 00       	jmp    8119f4 <tcp_input+0xe0d>
    }

  /* Finally, if we still did not get a match, we check all PCBs that
     are LISTENing for incoming connections. */
    prev = NULL;
    for(lpcb = tcp_listen_pcbs.listen_pcbs; lpcb != NULL; lpcb = lpcb->next) {
  8111aa:	8b 47 0c             	mov    0xc(%edi),%eax
  8111ad:	85 c0                	test   %eax,%eax
  8111af:	90                   	nop
  8111b0:	74 09                	je     8111bb <tcp_input+0x5d4>
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: packed for LISTENing connection.\n"));
        tcp_listen_input(lpcb);
        pbuf_free(p);
        return;
      }
      prev = (struct tcp_pcb *)lpcb;
  8111b2:	89 fa                	mov    %edi,%edx
  8111b4:	89 c7                	mov    %eax,%edi
  8111b6:	e9 2b fe ff ff       	jmp    810fe6 <tcp_input+0x3ff>
  8111bb:	8b 5d d4             	mov    -0x2c(%ebp),%ebx
  tcp_debug_print_flags(TCPH_FLAGS(tcphdr));
  LWIP_DEBUGF(TCP_INPUT_DEBUG, ("-+-+-+-+-+-+-+-+-+-+-+-+-+-+\n"));
#endif /* TCP_INPUT_DEBUG */


  if (pcb != NULL) {
  8111be:	85 db                	test   %ebx,%ebx
  8111c0:	0f 84 9b 07 00 00    	je     811961 <tcp_input+0xd7a>
    tcp_debug_print_state(pcb->state);
#endif /* TCP_DEBUG */
#endif /* TCP_INPUT_DEBUG */

    /* Set up a tcp_seg structure. */
    inseg.next = NULL;
  8111c6:	c7 05 5c f5 b3 00 00 	movl   $0x0,0xb3f55c
  8111cd:	00 00 00 
    inseg.len = p->tot_len;
  8111d0:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  8111d4:	66 a3 68 f5 b3 00    	mov    %ax,0xb3f568
    inseg.dataptr = p->payload;
  8111da:	8b 46 04             	mov    0x4(%esi),%eax
  8111dd:	a3 64 f5 b3 00       	mov    %eax,0xb3f564
    inseg.p = p;
  8111e2:	89 35 60 f5 b3 00    	mov    %esi,0xb3f560
    inseg.tcphdr = tcphdr;
  8111e8:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  8111ed:	a3 6c f5 b3 00       	mov    %eax,0xb3f56c

    recv_data = NULL;
  8111f2:	c7 05 88 f5 b3 00 00 	movl   $0x0,0xb3f588
  8111f9:	00 00 00 
    recv_flags = 0;
  8111fc:	c6 05 84 f5 b3 00 00 	movb   $0x0,0xb3f584

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
  811203:	8b 83 80 00 00 00    	mov    0x80(%ebx),%eax
  811209:	85 c0                	test   %eax,%eax
  81120b:	74 49                	je     811256 <tcp_input+0x66f>
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  81120d:	8b 93 88 00 00 00    	mov    0x88(%ebx),%edx
  811213:	85 d2                	test   %edx,%edx
  811215:	74 1e                	je     811235 <tcp_input+0x64e>
  811217:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81121e:	00 
  81121f:	89 44 24 08          	mov    %eax,0x8(%esp)
  811223:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811227:	8b 43 18             	mov    0x18(%ebx),%eax
  81122a:	89 04 24             	mov    %eax,(%esp)
  81122d:	ff d2                	call   *%edx
      if (err == ERR_OK) {
  81122f:	84 c0                	test   %al,%al
  811231:	74 0a                	je     81123d <tcp_input+0x656>
  811233:	eb 14                	jmp    811249 <tcp_input+0x662>

    /* If there is data which was previously "refused" by upper layer */
    if (pcb->refused_data != NULL) {
      /* Notify again application with data previously received. */
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: notify kept packet\n"));
      TCP_EVENT_RECV(pcb, pcb->refused_data, ERR_OK, err);
  811235:	89 04 24             	mov    %eax,(%esp)
  811238:	e8 1b 6d ff ff       	call   807f58 <pbuf_free>
      if (err == ERR_OK) {
        pcb->refused_data = NULL;
  81123d:	c7 83 80 00 00 00 00 	movl   $0x0,0x80(%ebx)
  811244:	00 00 00 
  811247:	eb 0d                	jmp    811256 <tcp_input+0x66f>
      } else {
        /* drop incoming packets, because pcb is "full" */
        LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_input: drop incoming packets, because pcb is \"full\"\n"));
        TCP_STATS_INC(tcp.drop);
        snmp_inc_tcpinerrs();
        pbuf_free(p);
  811249:	89 34 24             	mov    %esi,(%esp)
  81124c:	e8 07 6d ff ff       	call   807f58 <pbuf_free>
        return;
  811251:	e9 9e 07 00 00       	jmp    8119f4 <tcp_input+0xe0d>
      }
    }

    tcp_input_pcb = pcb;
  811256:	89 1d 24 f6 b3 00    	mov    %ebx,0xb3f624
  u8_t accepted_inseq;

  err = ERR_OK;

  /* Process incoming RST segments. */
  if (flags & TCP_RST) {
  81125c:	f6 05 80 f5 b3 00 04 	testb  $0x4,0xb3f580
  811263:	74 68                	je     8112cd <tcp_input+0x6e6>
    /* First, determine if the reset is acceptable. */
    if (pcb->state == SYN_SENT) {
  811265:	8b 43 10             	mov    0x10(%ebx),%eax
  811268:	83 f8 02             	cmp    $0x2,%eax
  81126b:	75 0e                	jne    81127b <tcp_input+0x694>
  81126d:	8b 53 54             	mov    0x54(%ebx),%edx
  811270:	3b 15 7c f5 b3 00    	cmp    0xb3f57c,%edx
  811276:	0f 94 c2             	sete   %dl
  811279:	eb 1a                	jmp    811295 <tcp_input+0x6ae>
      if (ackno == pcb->snd_nxt) {
        acceptable = 1;
      }
    } else {
      if (TCP_SEQ_BETWEEN(seqno, pcb->rcv_nxt, 
  81127b:	8b 15 78 f5 b3 00    	mov    0xb3f578,%edx
  811281:	2b 53 24             	sub    0x24(%ebx),%edx
  811284:	0f 88 51 07 00 00    	js     8119db <tcp_input+0xdf4>
  81128a:	0f b7 4b 28          	movzwl 0x28(%ebx),%ecx
  81128e:	29 ca                	sub    %ecx,%edx
  811290:	85 d2                	test   %edx,%edx
  811292:	0f 9e c2             	setle  %dl
                          pcb->rcv_nxt+pcb->rcv_wnd)) {
        acceptable = 1;
      }
    }

    if (acceptable) {
  811295:	84 d2                	test   %dl,%dl
  811297:	0f 84 3e 07 00 00    	je     8119db <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_INPUT_DEBUG, ("tcp_process: Connection RESET\n"));
      LWIP_ASSERT("tcp_input: pcb->state != CLOSED", pcb->state != CLOSED);
  81129d:	85 c0                	test   %eax,%eax
  81129f:	75 1c                	jne    8112bd <tcp_input+0x6d6>
  8112a1:	c7 44 24 08 40 50 81 	movl   $0x815040,0x8(%esp)
  8112a8:	00 
  8112a9:	c7 44 24 04 09 02 00 	movl   $0x209,0x4(%esp)
  8112b0:	00 
  8112b1:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8112b8:	e8 17 f7 fe ff       	call   8009d4 <_panic>
      recv_flags = TF_RESET;
  8112bd:	c6 05 84 f5 b3 00 08 	movb   $0x8,0xb3f584
      pcb->flags &= ~TF_ACK_DELAY;
  8112c4:	80 63 20 fe          	andb   $0xfe,0x20(%ebx)
  8112c8:	e9 0e 07 00 00       	jmp    8119db <tcp_input+0xdf4>
      return ERR_OK;
    }
  }

  /* Update the PCB (in)activity timer. */
  pcb->tmr = tcp_ticks;
  8112cd:	a1 0c f6 b3 00       	mov    0xb3f60c,%eax
  8112d2:	89 43 2c             	mov    %eax,0x2c(%ebx)
  pcb->keep_cnt_sent = 0;
  8112d5:	c6 83 a5 00 00 00 00 	movb   $0x0,0xa5(%ebx)

  /* Do different things depending on the TCP state. */
  switch (pcb->state) {
  8112dc:	83 7b 10 09          	cmpl   $0x9,0x10(%ebx)
  8112e0:	0f 87 07 05 00 00    	ja     8117ed <tcp_input+0xc06>
  8112e6:	8b 43 10             	mov    0x10(%ebx),%eax
  8112e9:	ff 24 85 e4 50 81 00 	jmp    *0x8150e4(,%eax,4)
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  8112f0:	0f b6 05 80 f5 b3 00 	movzbl 0xb3f580,%eax
  8112f7:	83 e0 12             	and    $0x12,%eax
  8112fa:	83 f8 12             	cmp    $0x12,%eax
  8112fd:	0f 85 0a 01 00 00    	jne    81140d <tcp_input+0x826>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
  811303:	8b 43 78             	mov    0x78(%ebx),%eax
  811306:	8b 40 10             	mov    0x10(%eax),%eax
  811309:	8b 40 04             	mov    0x4(%eax),%eax
  81130c:	89 04 24             	mov    %eax,(%esp)
  81130f:	e8 86 9c ff ff       	call   80af9a <ntohl>
  switch (pcb->state) {
  case SYN_SENT:
    LWIP_DEBUGF(TCP_INPUT_DEBUG, ("SYN-SENT: ackno %"U32_F" pcb->snd_nxt %"U32_F" unacked %"U32_F"\n", ackno,
     pcb->snd_nxt, ntohl(pcb->unacked->tcphdr->seqno)));
    /* received SYN ACK with expected sequence number? */
    if ((flags & TCP_ACK) && (flags & TCP_SYN)
  811314:	83 c0 01             	add    $0x1,%eax
  811317:	3b 05 7c f5 b3 00    	cmp    0xb3f57c,%eax
  81131d:	0f 85 ea 00 00 00    	jne    81140d <tcp_input+0x826>
        && ackno == ntohl(pcb->unacked->tcphdr->seqno) + 1) {
      pcb->snd_buf++;
  811323:	66 83 43 6e 01       	addw   $0x1,0x6e(%ebx)
      pcb->rcv_nxt = seqno + 1;
  811328:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  81132d:	83 c0 01             	add    $0x1,%eax
  811330:	89 43 24             	mov    %eax,0x24(%ebx)
      pcb->lastack = ackno;
  811333:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  811338:	89 43 48             	mov    %eax,0x48(%ebx)
      pcb->snd_wnd = tcphdr->wnd;
  81133b:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  811340:	0f b7 40 0e          	movzwl 0xe(%eax),%eax
  811344:	66 89 43 5c          	mov    %ax,0x5c(%ebx)
      pcb->snd_wl1 = seqno - 1; /* initialise to seqno - 1 to force window update */
  811348:	a1 78 f5 b3 00       	mov    0xb3f578,%eax
  81134d:	83 e8 01             	sub    $0x1,%eax
  811350:	89 43 60             	mov    %eax,0x60(%ebx)
      pcb->state = ESTABLISHED;
  811353:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)

      /* Parse any options in the SYNACK before using pcb->mss since that
       * can be changed by the received options! */
      tcp_parseopt(pcb);
  81135a:	89 d8                	mov    %ebx,%eax
  81135c:	e8 5f eb ff ff       	call   80fec0 <tcp_parseopt>
#if TCP_CALCULATE_EFF_SEND_MSS
      pcb->mss = tcp_eff_send_mss(pcb->mss, &(pcb->remote_ip));
  811361:	8d 43 04             	lea    0x4(%ebx),%eax
  811364:	89 44 24 04          	mov    %eax,0x4(%esp)
  811368:	0f b7 43 34          	movzwl 0x34(%ebx),%eax
  81136c:	89 04 24             	mov    %eax,(%esp)
  81136f:	e8 cd 75 ff ff       	call   808941 <tcp_eff_send_mss>
  811374:	66 89 43 34          	mov    %ax,0x34(%ebx)
#endif /* TCP_CALCULATE_EFF_SEND_MSS */

      /* Set ssthresh again after changing pcb->mss (already set in tcp_connect
       * but for the default value of pcb->mss) */
      pcb->ssthresh = pcb->mss * 10;
  811378:	6b d0 0a             	imul   $0xa,%eax,%edx
  81137b:	66 89 53 50          	mov    %dx,0x50(%ebx)

      pcb->cwnd = ((pcb->cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  81137f:	66 83 7b 4e 01       	cmpw   $0x1,0x4e(%ebx)
  811384:	75 02                	jne    811388 <tcp_input+0x7a1>
  811386:	01 c0                	add    %eax,%eax
  811388:	66 89 43 4e          	mov    %ax,0x4e(%ebx)
      LWIP_ASSERT("pcb->snd_queuelen > 0", (pcb->snd_queuelen > 0));
  81138c:	0f b7 43 70          	movzwl 0x70(%ebx),%eax
  811390:	66 85 c0             	test   %ax,%ax
  811393:	75 1c                	jne    8113b1 <tcp_input+0x7ca>
  811395:	c7 44 24 08 b9 50 81 	movl   $0x8150b9,0x8(%esp)
  81139c:	00 
  81139d:	c7 44 24 04 35 02 00 	movl   $0x235,0x4(%esp)
  8113a4:	00 
  8113a5:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8113ac:	e8 23 f6 fe ff       	call   8009d4 <_panic>
      --pcb->snd_queuelen;
  8113b1:	83 e8 01             	sub    $0x1,%eax
  8113b4:	66 89 43 70          	mov    %ax,0x70(%ebx)
      LWIP_DEBUGF(TCP_QLEN_DEBUG, ("tcp_process: SYN-SENT --queuelen %"U16_F"\n", (u16_t)pcb->snd_queuelen));
      rseg = pcb->unacked;
  8113b8:	8b 43 78             	mov    0x78(%ebx),%eax
      pcb->unacked = rseg->next;
  8113bb:	8b 10                	mov    (%eax),%edx
  8113bd:	89 53 78             	mov    %edx,0x78(%ebx)

      /* If there's nothing left to acknowledge, stop the retransmit
         timer, otherwise reset it to start again */
      if(pcb->unacked == NULL)
  8113c0:	85 d2                	test   %edx,%edx
  8113c2:	75 08                	jne    8113cc <tcp_input+0x7e5>
        pcb->rtime = -1;
  8113c4:	66 c7 43 32 ff ff    	movw   $0xffff,0x32(%ebx)
  8113ca:	eb 0a                	jmp    8113d6 <tcp_input+0x7ef>
      else {
        pcb->rtime = 0;
  8113cc:	66 c7 43 32 00 00    	movw   $0x0,0x32(%ebx)
        pcb->nrtx = 0;
  8113d2:	c6 43 46 00          	movb   $0x0,0x46(%ebx)
      }

      tcp_seg_free(rseg);
  8113d6:	89 04 24             	mov    %eax,(%esp)
  8113d9:	e8 f3 76 ff ff       	call   808ad1 <tcp_seg_free>

      /* Call the user specified function to call when sucessfully
       * connected. */
      TCP_EVENT_CONNECTED(pcb, ERR_OK, err);
  8113de:	8b 83 8c 00 00 00    	mov    0x8c(%ebx),%eax
  8113e4:	85 c0                	test   %eax,%eax
  8113e6:	74 14                	je     8113fc <tcp_input+0x815>
  8113e8:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8113ef:	00 
  8113f0:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8113f4:	8b 53 18             	mov    0x18(%ebx),%edx
  8113f7:	89 14 24             	mov    %edx,(%esp)
  8113fa:	ff d0                	call   *%eax
      tcp_ack_now(pcb);
  8113fc:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  811400:	89 1c 24             	mov    %ebx,(%esp)
  811403:	e8 d3 9f ff ff       	call   80b3db <tcp_output>
  811408:	e9 ce 05 00 00       	jmp    8119db <tcp_input+0xdf4>
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
  81140d:	f6 05 80 f5 b3 00 10 	testb  $0x10,0xb3f580
  811414:	0f 84 c1 05 00 00    	je     8119db <tcp_input+0xdf4>
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  81141a:	8b 15 70 f5 b3 00    	mov    0xb3f570,%edx
      tcp_ack_now(pcb);
    }
    /* received ACK? possibly a half-open connection */
    else if (flags & TCP_ACK) {
      /* send a RST to bring the other side in a non-synchronized state. */
      tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  811420:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
  811425:	0f b7 0a             	movzwl (%edx),%ecx
  811428:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  81142c:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  811430:	89 54 24 10          	mov    %edx,0x10(%esp)
  811434:	8d 50 0c             	lea    0xc(%eax),%edx
  811437:	89 54 24 0c          	mov    %edx,0xc(%esp)
  81143b:	83 c0 10             	add    $0x10,%eax
  81143e:	89 44 24 08          	mov    %eax,0x8(%esp)
  811442:	0f b7 05 82 f5 b3 00 	movzwl 0xb3f582,%eax
  811449:	03 05 78 f5 b3 00    	add    0xb3f578,%eax
  81144f:	89 44 24 04          	mov    %eax,0x4(%esp)
  811453:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  811458:	89 04 24             	mov    %eax,(%esp)
  81145b:	e8 1c 9e ff ff       	call   80b27c <tcp_rst>
  811460:	e9 76 05 00 00       	jmp    8119db <tcp_input+0xdf4>
        tcphdr->dest, tcphdr->src);
    }
    break;
  case SYN_RCVD:
    if (flags & TCP_ACK &&
  811465:	0f b6 05 80 f5 b3 00 	movzbl 0xb3f580,%eax
  81146c:	83 e0 14             	and    $0x14,%eax
  81146f:	83 f8 10             	cmp    $0x10,%eax
  811472:	0f 85 63 05 00 00    	jne    8119db <tcp_input+0xdf4>
       !(flags & TCP_RST)) {
      /* expected ACK number? */
      if (TCP_SEQ_BETWEEN(ackno, pcb->lastack+1, pcb->snd_nxt)) {
  811478:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  81147d:	8b 53 48             	mov    0x48(%ebx),%edx
  811480:	f7 d2                	not    %edx
  811482:	01 c2                	add    %eax,%edx
  811484:	0f 88 b7 00 00 00    	js     811541 <tcp_input+0x95a>
  81148a:	89 c2                	mov    %eax,%edx
  81148c:	2b 53 54             	sub    0x54(%ebx),%edx
  81148f:	85 d2                	test   %edx,%edx
  811491:	0f 8f aa 00 00 00    	jg     811541 <tcp_input+0x95a>
        u16_t old_cwnd;
        pcb->state = ESTABLISHED;
  811497:	c7 43 10 04 00 00 00 	movl   $0x4,0x10(%ebx)
        LWIP_DEBUGF(TCP_DEBUG, ("TCP connection established %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
#if LWIP_CALLBACK_API
        LWIP_ASSERT("pcb->accept != NULL", pcb->accept != NULL);
  81149e:	8b 83 90 00 00 00    	mov    0x90(%ebx),%eax
  8114a4:	85 c0                	test   %eax,%eax
  8114a6:	75 1c                	jne    8114c4 <tcp_input+0x8dd>
  8114a8:	c7 44 24 08 cf 50 81 	movl   $0x8150cf,0x8(%esp)
  8114af:	00 
  8114b0:	c7 44 24 04 5b 02 00 	movl   $0x25b,0x4(%esp)
  8114b7:	00 
  8114b8:	c7 04 24 60 50 81 00 	movl   $0x815060,(%esp)
  8114bf:	e8 10 f5 fe ff       	call   8009d4 <_panic>
#endif
        /* Call the accept function. */
        TCP_EVENT_ACCEPT(pcb, ERR_OK, err);
  8114c4:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  8114cb:	00 
  8114cc:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8114d0:	8b 53 18             	mov    0x18(%ebx),%edx
  8114d3:	89 14 24             	mov    %edx,(%esp)
  8114d6:	ff d0                	call   *%eax
        if (err != ERR_OK) {
  8114d8:	84 c0                	test   %al,%al
  8114da:	74 17                	je     8114f3 <tcp_input+0x90c>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
  8114dc:	89 1c 24             	mov    %ebx,(%esp)
  8114df:	e8 9a 7b ff ff       	call   80907e <tcp_abort>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  8114e4:	c7 05 24 f6 b3 00 00 	movl   $0x0,0xb3f624
  8114eb:	00 00 00 
  8114ee:	e9 4a 04 00 00       	jmp    81193d <tcp_input+0xd56>
          /* If the accept function returns with an error, we abort
           * the connection. */
          tcp_abort(pcb);
          return ERR_ABRT;
        }
        old_cwnd = pcb->cwnd;
  8114f3:	0f b7 73 4e          	movzwl 0x4e(%ebx),%esi
        /* If there was any data contained within this ACK,
         * we'd better pass it on to the application as well. */
        accepted_inseq = tcp_receive(pcb);
  8114f7:	89 d8                	mov    %ebx,%eax
  8114f9:	e8 71 ea ff ff       	call   80ff6f <tcp_receive>

        pcb->cwnd = ((old_cwnd == 1) ? (pcb->mss * 2) : pcb->mss);
  8114fe:	66 83 fe 01          	cmp    $0x1,%si
  811502:	75 08                	jne    81150c <tcp_input+0x925>
  811504:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  811508:	01 d2                	add    %edx,%edx
  81150a:	eb 04                	jmp    811510 <tcp_input+0x929>
  81150c:	0f b7 53 34          	movzwl 0x34(%ebx),%edx
  811510:	66 89 53 4e          	mov    %dx,0x4e(%ebx)

        if ((flags & TCP_FIN) && accepted_inseq) {
  811514:	f6 05 80 f5 b3 00 01 	testb  $0x1,0xb3f580
  81151b:	0f 84 ba 04 00 00    	je     8119db <tcp_input+0xdf4>
  811521:	84 c0                	test   %al,%al
  811523:	0f 84 b2 04 00 00    	je     8119db <tcp_input+0xdf4>
          tcp_ack_now(pcb);
  811529:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81152d:	89 1c 24             	mov    %ebx,(%esp)
  811530:	e8 a6 9e ff ff       	call   80b3db <tcp_output>
          pcb->state = CLOSE_WAIT;
  811535:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  81153c:	e9 9a 04 00 00       	jmp    8119db <tcp_input+0xdf4>
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
                tcphdr->dest, tcphdr->src);
  811541:	8b 0d 70 f5 b3 00    	mov    0xb3f570,%ecx
        }
      }
      /* incorrect ACK number */
      else {
        /* send RST */
        tcp_rst(ackno, seqno + tcplen, &(iphdr->dest), &(iphdr->src),
  811547:	8b 15 74 f5 b3 00    	mov    0xb3f574,%edx
  81154d:	0f b7 31             	movzwl (%ecx),%esi
  811550:	89 74 24 14          	mov    %esi,0x14(%esp)
  811554:	0f b7 49 02          	movzwl 0x2(%ecx),%ecx
  811558:	89 4c 24 10          	mov    %ecx,0x10(%esp)
  81155c:	8d 4a 0c             	lea    0xc(%edx),%ecx
  81155f:	89 4c 24 0c          	mov    %ecx,0xc(%esp)
  811563:	83 c2 10             	add    $0x10,%edx
  811566:	89 54 24 08          	mov    %edx,0x8(%esp)
  81156a:	0f b7 15 82 f5 b3 00 	movzwl 0xb3f582,%edx
  811571:	03 15 78 f5 b3 00    	add    0xb3f578,%edx
  811577:	89 54 24 04          	mov    %edx,0x4(%esp)
  81157b:	89 04 24             	mov    %eax,(%esp)
  81157e:	e8 f9 9c ff ff       	call   80b27c <tcp_rst>
  811583:	e9 53 04 00 00       	jmp    8119db <tcp_input+0xdf4>
    }
    break;
  case CLOSE_WAIT:
    /* FALLTHROUGH */
  case ESTABLISHED:
    accepted_inseq = tcp_receive(pcb);
  811588:	89 d8                	mov    %ebx,%eax
  81158a:	e8 e0 e9 ff ff       	call   80ff6f <tcp_receive>
    if ((flags & TCP_FIN) && accepted_inseq) { /* passive close */
  81158f:	f6 05 80 f5 b3 00 01 	testb  $0x1,0xb3f580
  811596:	0f 84 3f 04 00 00    	je     8119db <tcp_input+0xdf4>
  81159c:	84 c0                	test   %al,%al
  81159e:	0f 84 37 04 00 00    	je     8119db <tcp_input+0xdf4>
      tcp_ack_now(pcb);
  8115a4:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8115a8:	89 1c 24             	mov    %ebx,(%esp)
  8115ab:	e8 2b 9e ff ff       	call   80b3db <tcp_output>
      pcb->state = CLOSE_WAIT;
  8115b0:	c7 43 10 07 00 00 00 	movl   $0x7,0x10(%ebx)
  8115b7:	e9 1f 04 00 00       	jmp    8119db <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_1:
    tcp_receive(pcb);
  8115bc:	89 d8                	mov    %ebx,%eax
  8115be:	e8 ac e9 ff ff       	call   80ff6f <tcp_receive>
    if (flags & TCP_FIN) {
  8115c3:	0f b6 05 80 f5 b3 00 	movzbl 0xb3f580,%eax
  8115ca:	a8 01                	test   $0x1,%al
  8115cc:	0f 84 a3 00 00 00    	je     811675 <tcp_input+0xa8e>
      if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8115d2:	a8 10                	test   $0x10,%al
  8115d4:	0f 84 81 00 00 00    	je     81165b <tcp_input+0xa74>
  8115da:	8b 43 54             	mov    0x54(%ebx),%eax
  8115dd:	3b 05 7c f5 b3 00    	cmp    0xb3f57c,%eax
  8115e3:	75 76                	jne    81165b <tcp_input+0xa74>
        LWIP_DEBUGF(TCP_DEBUG,
          ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
        tcp_ack_now(pcb);
  8115e5:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8115e9:	89 1c 24             	mov    %ebx,(%esp)
  8115ec:	e8 ea 9d ff ff       	call   80b3db <tcp_output>
        tcp_pcb_purge(pcb);
  8115f1:	89 1c 24             	mov    %ebx,(%esp)
  8115f4:	e8 4e 75 ff ff       	call   808b47 <tcp_pcb_purge>
        TCP_RMV(&tcp_active_pcbs, pcb);
  8115f9:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
  8115fe:	39 c3                	cmp    %eax,%ebx
  811600:	75 0a                	jne    81160c <tcp_input+0xa25>
  811602:	8b 43 0c             	mov    0xc(%ebx),%eax
  811605:	a3 08 f6 b3 00       	mov    %eax,0xb3f608
  81160a:	eb 29                	jmp    811635 <tcp_input+0xa4e>
  81160c:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  811611:	eb 19                	jmp    81162c <tcp_input+0xa45>
  811613:	8b 50 0c             	mov    0xc(%eax),%edx
  811616:	85 d2                	test   %edx,%edx
  811618:	74 0c                	je     811626 <tcp_input+0xa3f>
  81161a:	39 d3                	cmp    %edx,%ebx
  81161c:	75 08                	jne    811626 <tcp_input+0xa3f>
  81161e:	8b 53 0c             	mov    0xc(%ebx),%edx
  811621:	89 50 0c             	mov    %edx,0xc(%eax)
  811624:	eb 0f                	jmp    811635 <tcp_input+0xa4e>
  811626:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  81162c:	a1 14 f6 b3 00       	mov    0xb3f614,%eax
  811631:	85 c0                	test   %eax,%eax
  811633:	75 de                	jne    811613 <tcp_input+0xa2c>
  811635:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
        pcb->state = TIME_WAIT;
  81163c:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
        TCP_REG(&tcp_tw_pcbs, pcb);
  811643:	a1 1c f6 b3 00       	mov    0xb3f61c,%eax
  811648:	89 43 0c             	mov    %eax,0xc(%ebx)
  81164b:	89 1d 1c f6 b3 00    	mov    %ebx,0xb3f61c
  811651:	e8 a7 39 ff ff       	call   804ffd <tcp_timer_needed>
  811656:	e9 80 03 00 00       	jmp    8119db <tcp_input+0xdf4>
      } else {
        tcp_ack_now(pcb);
  81165b:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81165f:	89 1c 24             	mov    %ebx,(%esp)
  811662:	e8 74 9d ff ff       	call   80b3db <tcp_output>
        pcb->state = CLOSING;
  811667:	c7 43 10 08 00 00 00 	movl   $0x8,0x10(%ebx)
  81166e:	66 90                	xchg   %ax,%ax
  811670:	e9 66 03 00 00       	jmp    8119db <tcp_input+0xdf4>
      }
    } else if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  811675:	a8 10                	test   $0x10,%al
  811677:	0f 84 5e 03 00 00    	je     8119db <tcp_input+0xdf4>
  81167d:	8b 43 54             	mov    0x54(%ebx),%eax
  811680:	3b 05 7c f5 b3 00    	cmp    0xb3f57c,%eax
  811686:	0f 85 4f 03 00 00    	jne    8119db <tcp_input+0xdf4>
      pcb->state = FIN_WAIT_2;
  81168c:	c7 43 10 06 00 00 00 	movl   $0x6,0x10(%ebx)
  811693:	e9 43 03 00 00       	jmp    8119db <tcp_input+0xdf4>
    }
    break;
  case FIN_WAIT_2:
    tcp_receive(pcb);
  811698:	89 d8                	mov    %ebx,%eax
  81169a:	e8 d0 e8 ff ff       	call   80ff6f <tcp_receive>
    if (flags & TCP_FIN) {
  81169f:	f6 05 80 f5 b3 00 01 	testb  $0x1,0xb3f580
  8116a6:	0f 84 2f 03 00 00    	je     8119db <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  8116ac:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  8116b0:	89 1c 24             	mov    %ebx,(%esp)
  8116b3:	e8 23 9d ff ff       	call   80b3db <tcp_output>
      tcp_pcb_purge(pcb);
  8116b8:	89 1c 24             	mov    %ebx,(%esp)
  8116bb:	e8 87 74 ff ff       	call   808b47 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  8116c0:	8b 15 08 f6 b3 00    	mov    0xb3f608,%edx
  8116c6:	39 d3                	cmp    %edx,%ebx
  8116c8:	75 0a                	jne    8116d4 <tcp_input+0xaed>
  8116ca:	8b 43 0c             	mov    0xc(%ebx),%eax
  8116cd:	a3 08 f6 b3 00       	mov    %eax,0xb3f608
  8116d2:	eb 2a                	jmp    8116fe <tcp_input+0xb17>
  8116d4:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  8116da:	85 d2                	test   %edx,%edx
  8116dc:	74 20                	je     8116fe <tcp_input+0xb17>
  8116de:	8b 42 0c             	mov    0xc(%edx),%eax
  8116e1:	85 c0                	test   %eax,%eax
  8116e3:	0f 84 dd 02 00 00    	je     8119c6 <tcp_input+0xddf>
  8116e9:	39 c3                	cmp    %eax,%ebx
  8116eb:	75 08                	jne    8116f5 <tcp_input+0xb0e>
  8116ed:	8b 43 0c             	mov    0xc(%ebx),%eax
  8116f0:	89 42 0c             	mov    %eax,0xc(%edx)
  8116f3:	eb 09                	jmp    8116fe <tcp_input+0xb17>
  8116f5:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  8116fa:	89 c2                	mov    %eax,%edx
  8116fc:	eb e0                	jmp    8116de <tcp_input+0xaf7>
  8116fe:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  811705:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  81170c:	a1 1c f6 b3 00       	mov    0xb3f61c,%eax
  811711:	89 43 0c             	mov    %eax,0xc(%ebx)
  811714:	89 1d 1c f6 b3 00    	mov    %ebx,0xb3f61c
  81171a:	e8 de 38 ff ff       	call   804ffd <tcp_timer_needed>
  81171f:	e9 b7 02 00 00       	jmp    8119db <tcp_input+0xdf4>
    }
    break;
  case CLOSING:
    tcp_receive(pcb);
  811724:	89 d8                	mov    %ebx,%eax
  811726:	e8 44 e8 ff ff       	call   80ff6f <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  81172b:	f6 05 80 f5 b3 00 10 	testb  $0x10,0xb3f580
  811732:	0f 84 a3 02 00 00    	je     8119db <tcp_input+0xdf4>
  811738:	8b 43 54             	mov    0x54(%ebx),%eax
  81173b:	3b 05 7c f5 b3 00    	cmp    0xb3f57c,%eax
  811741:	0f 85 94 02 00 00    	jne    8119db <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
  811747:	80 4b 20 02          	orb    $0x2,0x20(%ebx)
  81174b:	89 1c 24             	mov    %ebx,(%esp)
  81174e:	e8 88 9c ff ff       	call   80b3db <tcp_output>
      tcp_pcb_purge(pcb);
  811753:	89 1c 24             	mov    %ebx,(%esp)
  811756:	e8 ec 73 ff ff       	call   808b47 <tcp_pcb_purge>
      TCP_RMV(&tcp_active_pcbs, pcb);
  81175b:	a1 08 f6 b3 00       	mov    0xb3f608,%eax
  811760:	39 c3                	cmp    %eax,%ebx
  811762:	75 0a                	jne    81176e <tcp_input+0xb87>
  811764:	8b 43 0c             	mov    0xc(%ebx),%eax
  811767:	a3 08 f6 b3 00       	mov    %eax,0xb3f608
  81176c:	eb 2a                	jmp    811798 <tcp_input+0xbb1>
  81176e:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  811773:	85 c0                	test   %eax,%eax
  811775:	74 21                	je     811798 <tcp_input+0xbb1>
  811777:	8b 50 0c             	mov    0xc(%eax),%edx
  81177a:	85 d2                	test   %edx,%edx
  81177c:	0f 84 4e 02 00 00    	je     8119d0 <tcp_input+0xde9>
  811782:	39 d3                	cmp    %edx,%ebx
  811784:	75 08                	jne    81178e <tcp_input+0xba7>
  811786:	8b 53 0c             	mov    0xc(%ebx),%edx
  811789:	89 50 0c             	mov    %edx,0xc(%eax)
  81178c:	eb 0a                	jmp    811798 <tcp_input+0xbb1>
  81178e:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  811794:	89 d0                	mov    %edx,%eax
  811796:	eb df                	jmp    811777 <tcp_input+0xb90>
  811798:	c7 43 0c 00 00 00 00 	movl   $0x0,0xc(%ebx)
      pcb->state = TIME_WAIT;
  81179f:	c7 43 10 0a 00 00 00 	movl   $0xa,0x10(%ebx)
      TCP_REG(&tcp_tw_pcbs, pcb);
  8117a6:	a1 1c f6 b3 00       	mov    0xb3f61c,%eax
  8117ab:	89 43 0c             	mov    %eax,0xc(%ebx)
  8117ae:	89 1d 1c f6 b3 00    	mov    %ebx,0xb3f61c
  8117b4:	e8 44 38 ff ff       	call   804ffd <tcp_timer_needed>
  8117b9:	e9 1d 02 00 00       	jmp    8119db <tcp_input+0xdf4>
    }
    break;
  case LAST_ACK:
    tcp_receive(pcb);
  8117be:	89 d8                	mov    %ebx,%eax
  8117c0:	e8 aa e7 ff ff       	call   80ff6f <tcp_receive>
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
  8117c5:	f6 05 80 f5 b3 00 10 	testb  $0x10,0xb3f580
  8117cc:	0f 84 09 02 00 00    	je     8119db <tcp_input+0xdf4>
  8117d2:	8b 43 54             	mov    0x54(%ebx),%eax
  8117d5:	3b 05 7c f5 b3 00    	cmp    0xb3f57c,%eax
  8117db:	0f 85 fa 01 00 00    	jne    8119db <tcp_input+0xdf4>
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      /* bugfix #21699: don't set pcb->state to CLOSED here or we risk leaking segments */
      recv_flags = TF_CLOSED;
  8117e1:	c6 05 84 f5 b3 00 10 	movb   $0x10,0xb3f584
  8117e8:	e9 ee 01 00 00       	jmp    8119db <tcp_input+0xdf4>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  8117ed:	c7 05 24 f6 b3 00 00 	movl   $0x0,0xb3f624
  8117f4:	00 00 00 
    /* A return value of ERR_ABRT means that tcp_abort() was called
       and that the pcb has been freed. If so, we don't do anything. */
    if (err != ERR_ABRT) {
      if (recv_flags & TF_RESET) {
  8117f7:	0f b6 05 84 f5 b3 00 	movzbl 0xb3f584,%eax
  8117fe:	a8 08                	test   $0x8,%al
  811800:	74 3f                	je     811841 <tcp_input+0xc5a>
        /* TF_RESET means that the connection was reset by the other
           end. We then call the error callback to inform the
           application that the connection is dead before we
           deallocate the PCB. */
        TCP_EVENT_ERR(pcb->errf, pcb->callback_arg, ERR_RST);
  811802:	8b 83 98 00 00 00    	mov    0x98(%ebx),%eax
  811808:	85 c0                	test   %eax,%eax
  81180a:	74 10                	je     81181c <tcp_input+0xc35>
  81180c:	c7 44 24 04 fa ff ff 	movl   $0xfffffffa,0x4(%esp)
  811813:	ff 
  811814:	8b 53 18             	mov    0x18(%ebx),%edx
  811817:	89 14 24             	mov    %edx,(%esp)
  81181a:	ff d0                	call   *%eax
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  81181c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811820:	c7 04 24 08 f6 b3 00 	movl   $0xb3f608,(%esp)
  811827:	e8 94 73 ff ff       	call   808bc0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  81182c:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811830:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811837:	e8 84 5f ff ff       	call   8077c0 <memp_free>
  81183c:	e9 fc 00 00 00       	jmp    81193d <tcp_input+0xd56>
      } else if (recv_flags & TF_CLOSED) {
  811841:	a8 10                	test   $0x10,%al
  811843:	74 25                	je     81186a <tcp_input+0xc83>
        /* The connection has been closed and we will deallocate the
           PCB. */
        tcp_pcb_remove(&tcp_active_pcbs, pcb);
  811845:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811849:	c7 04 24 08 f6 b3 00 	movl   $0xb3f608,(%esp)
  811850:	e8 6b 73 ff ff       	call   808bc0 <tcp_pcb_remove>
        memp_free(MEMP_TCP_PCB, pcb);
  811855:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811859:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  811860:	e8 5b 5f ff ff       	call   8077c0 <memp_free>
  811865:	e9 d3 00 00 00       	jmp    81193d <tcp_input+0xd56>
      } else {
        err = ERR_OK;
        /* If the application has registered a "sent" function to be
           called when new send buffer space is available, we call it
           now. */
        if (pcb->acked > 0) {
  81186a:	0f b7 43 6c          	movzwl 0x6c(%ebx),%eax
  81186e:	66 85 c0             	test   %ax,%ax
  811871:	74 1f                	je     811892 <tcp_input+0xcab>
          TCP_EVENT_SENT(pcb, pcb->acked, err);
  811873:	8b 93 84 00 00 00    	mov    0x84(%ebx),%edx
  811879:	85 d2                	test   %edx,%edx
  81187b:	74 15                	je     811892 <tcp_input+0xcab>
  81187d:	0f b7 c0             	movzwl %ax,%eax
  811880:	89 44 24 08          	mov    %eax,0x8(%esp)
  811884:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811888:	8b 43 18             	mov    0x18(%ebx),%eax
  81188b:	89 04 24             	mov    %eax,(%esp)
  81188e:	ff d2                	call   *%edx
  811890:	eb 05                	jmp    811897 <tcp_input+0xcb0>
  811892:	b8 00 00 00 00       	mov    $0x0,%eax
        }
      
        if (recv_data != NULL) {
  811897:	8b 15 88 f5 b3 00    	mov    0xb3f588,%edx
  81189d:	85 d2                	test   %edx,%edx
  81189f:	74 61                	je     811902 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
  8118a1:	f6 05 80 f5 b3 00 08 	testb  $0x8,0xb3f580
  8118a8:	74 04                	je     8118ae <tcp_input+0xcc7>
            recv_data->flags |= PBUF_FLAG_PUSH;
  8118aa:	80 4a 0d 01          	orb    $0x1,0xd(%edx)
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  8118ae:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  8118b4:	85 c0                	test   %eax,%eax
  8118b6:	74 24                	je     8118dc <tcp_input+0xcf5>
  8118b8:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  8118bf:	00 
  8118c0:	8b 15 88 f5 b3 00    	mov    0xb3f588,%edx
  8118c6:	89 54 24 08          	mov    %edx,0x8(%esp)
  8118ca:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  8118ce:	8b 53 18             	mov    0x18(%ebx),%edx
  8118d1:	89 14 24             	mov    %edx,(%esp)
  8118d4:	ff d0                	call   *%eax

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
  8118d6:	84 c0                	test   %al,%al
  8118d8:	75 1c                	jne    8118f6 <tcp_input+0xd0f>
  8118da:	eb 26                	jmp    811902 <tcp_input+0xd1b>
          if(flags & TCP_PSH) {
            recv_data->flags |= PBUF_FLAG_PUSH;
          }

          /* Notify application that data has been received. */
          TCP_EVENT_RECV(pcb, recv_data, ERR_OK, err);
  8118dc:	a1 88 f5 b3 00       	mov    0xb3f588,%eax
  8118e1:	85 c0                	test   %eax,%eax
  8118e3:	0f 84 01 01 00 00    	je     8119ea <tcp_input+0xe03>
  8118e9:	89 04 24             	mov    %eax,(%esp)
  8118ec:	e8 67 66 ff ff       	call   807f58 <pbuf_free>
  8118f1:	e9 f4 00 00 00       	jmp    8119ea <tcp_input+0xe03>

          /* If the upper layer can't receive this data, store it */
          if (err != ERR_OK) {
            pcb->refused_data = recv_data;
  8118f6:	8b 15 88 f5 b3 00    	mov    0xb3f588,%edx
  8118fc:	89 93 80 00 00 00    	mov    %edx,0x80(%ebx)
          }
        }

        /* If a FIN segment was received, we call the callback
           function with a NULL buffer to indicate EOF. */
        if (recv_flags & TF_GOT_FIN) {
  811902:	f6 05 84 f5 b3 00 20 	testb  $0x20,0xb3f584
  811909:	74 26                	je     811931 <tcp_input+0xd4a>
          TCP_EVENT_RECV(pcb, NULL, ERR_OK, err);
  81190b:	8b 83 88 00 00 00    	mov    0x88(%ebx),%eax
  811911:	85 c0                	test   %eax,%eax
  811913:	74 20                	je     811935 <tcp_input+0xd4e>
  811915:	c7 44 24 0c 00 00 00 	movl   $0x0,0xc(%esp)
  81191c:	00 
  81191d:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811924:	00 
  811925:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811929:	8b 53 18             	mov    0x18(%ebx),%edx
  81192c:	89 14 24             	mov    %edx,(%esp)
  81192f:	ff d0                	call   *%eax
        }

        /* If there were no errors, we try to send something out. */
        if (err == ERR_OK) {
  811931:	84 c0                	test   %al,%al
  811933:	75 08                	jne    81193d <tcp_input+0xd56>
          tcp_output(pcb);
  811935:	89 1c 24             	mov    %ebx,(%esp)
  811938:	e8 9e 9a ff ff       	call   80b3db <tcp_output>
      }
    }


    /* give up our reference to inseg.p */
    if (inseg.p != NULL)
  81193d:	a1 60 f5 b3 00       	mov    0xb3f560,%eax
  811942:	85 c0                	test   %eax,%eax
  811944:	0f 84 aa 00 00 00    	je     8119f4 <tcp_input+0xe0d>
    {
      pbuf_free(inseg.p);
  81194a:	89 04 24             	mov    %eax,(%esp)
  81194d:	e8 06 66 ff ff       	call   807f58 <pbuf_free>
      inseg.p = NULL;
  811952:	c7 05 60 f5 b3 00 00 	movl   $0x0,0xb3f560
  811959:	00 00 00 
  81195c:	e9 93 00 00 00       	jmp    8119f4 <tcp_input+0xe0d>
  } else {

    /* If no matching PCB was found, send a TCP RST (reset) to the
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
  811961:	a1 70 f5 b3 00       	mov    0xb3f570,%eax
  811966:	0f b7 40 0c          	movzwl 0xc(%eax),%eax
  81196a:	89 04 24             	mov    %eax,(%esp)
  81196d:	e8 ef 93 ff ff       	call   80ad61 <ntohs>
  811972:	a8 04                	test   $0x4,%al
  811974:	75 46                	jne    8119bc <tcp_input+0xdd5>
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
  811976:	8b 15 70 f5 b3 00    	mov    0xb3f570,%edx
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
        &(iphdr->dest), &(iphdr->src),
  81197c:	a1 74 f5 b3 00       	mov    0xb3f574,%eax
       sender. */
    LWIP_DEBUGF(TCP_RST_DEBUG, ("tcp_input: no PCB match found, resetting.\n"));
    if (!(TCPH_FLAGS(tcphdr) & TCP_RST)) {
      TCP_STATS_INC(tcp.proterr);
      TCP_STATS_INC(tcp.drop);
      tcp_rst(ackno, seqno + tcplen,
  811981:	0f b7 0a             	movzwl (%edx),%ecx
  811984:	89 4c 24 14          	mov    %ecx,0x14(%esp)
  811988:	0f b7 52 02          	movzwl 0x2(%edx),%edx
  81198c:	89 54 24 10          	mov    %edx,0x10(%esp)
  811990:	8d 50 0c             	lea    0xc(%eax),%edx
  811993:	89 54 24 0c          	mov    %edx,0xc(%esp)
  811997:	83 c0 10             	add    $0x10,%eax
  81199a:	89 44 24 08          	mov    %eax,0x8(%esp)
  81199e:	0f b7 05 82 f5 b3 00 	movzwl 0xb3f582,%eax
  8119a5:	03 05 78 f5 b3 00    	add    0xb3f578,%eax
  8119ab:	89 44 24 04          	mov    %eax,0x4(%esp)
  8119af:	a1 7c f5 b3 00       	mov    0xb3f57c,%eax
  8119b4:	89 04 24             	mov    %eax,(%esp)
  8119b7:	e8 c0 98 ff ff       	call   80b27c <tcp_rst>
        &(iphdr->dest), &(iphdr->src),
        tcphdr->dest, tcphdr->src);
    }
    pbuf_free(p);
  8119bc:	89 34 24             	mov    %esi,(%esp)
  8119bf:	e8 94 65 ff ff       	call   807f58 <pbuf_free>
  8119c4:	eb 2e                	jmp    8119f4 <tcp_input+0xe0d>
    tcp_receive(pcb);
    if (flags & TCP_FIN) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  8119c6:	a3 14 f6 b3 00       	mov    %eax,0xb3f614
  8119cb:	e9 2e fd ff ff       	jmp    8116fe <tcp_input+0xb17>
    tcp_receive(pcb);
    if (flags & TCP_ACK && ackno == pcb->snd_nxt) {
      LWIP_DEBUGF(TCP_DEBUG, ("TCP connection closed %"U16_F" -> %"U16_F".\n", inseg.tcphdr->src, inseg.tcphdr->dest));
      tcp_ack_now(pcb);
      tcp_pcb_purge(pcb);
      TCP_RMV(&tcp_active_pcbs, pcb);
  8119d0:	89 15 14 f6 b3 00    	mov    %edx,0xb3f614
  8119d6:	e9 bd fd ff ff       	jmp    811798 <tcp_input+0xbb1>
      }
    }

    tcp_input_pcb = pcb;
    err = tcp_process(pcb);
    tcp_input_pcb = NULL;
  8119db:	c7 05 24 f6 b3 00 00 	movl   $0x0,0xb3f624
  8119e2:	00 00 00 
  8119e5:	e9 0d fe ff ff       	jmp    8117f7 <tcp_input+0xc10>
  8119ea:	b8 00 00 00 00       	mov    $0x0,%eax
  8119ef:	e9 0e ff ff ff       	jmp    811902 <tcp_input+0xd1b>
    pbuf_free(p);
  }

  LWIP_ASSERT("tcp_input: tcp_pcbs_sane()", tcp_pcbs_sane());
  PERF_STOP("tcp_input");
}
  8119f4:	83 c4 5c             	add    $0x5c,%esp
  8119f7:	5b                   	pop    %ebx
  8119f8:	5e                   	pop    %esi
  8119f9:	5f                   	pop    %edi
  8119fa:	5d                   	pop    %ebp
  8119fb:	c3                   	ret    
  8119fc:	00 00                	add    %al,(%eax)
	...

00811a00 <raw_bind>:
 *
 * @see raw_disconnect()
 */
err_t
raw_bind(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811a00:	55                   	push   %ebp
  811a01:	89 e5                	mov    %esp,%ebp
  811a03:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->local_ip, ipaddr);
  811a06:	b8 00 00 00 00       	mov    $0x0,%eax
  811a0b:	85 d2                	test   %edx,%edx
  811a0d:	74 02                	je     811a11 <raw_bind+0x11>
  811a0f:	8b 02                	mov    (%edx),%eax
  811a11:	8b 55 08             	mov    0x8(%ebp),%edx
  811a14:	89 02                	mov    %eax,(%edx)
  return ERR_OK;
}
  811a16:	b8 00 00 00 00       	mov    $0x0,%eax
  811a1b:	5d                   	pop    %ebp
  811a1c:	c3                   	ret    

00811a1d <raw_connect>:
 *
 * @see raw_disconnect() and raw_sendto()
 */
err_t
raw_connect(struct raw_pcb *pcb, struct ip_addr *ipaddr)
{
  811a1d:	55                   	push   %ebp
  811a1e:	89 e5                	mov    %esp,%ebp
  811a20:	8b 55 0c             	mov    0xc(%ebp),%edx
  ip_addr_set(&pcb->remote_ip, ipaddr);
  811a23:	b8 00 00 00 00       	mov    $0x0,%eax
  811a28:	85 d2                	test   %edx,%edx
  811a2a:	74 02                	je     811a2e <raw_connect+0x11>
  811a2c:	8b 02                	mov    (%edx),%eax
  811a2e:	8b 55 08             	mov    0x8(%ebp),%edx
  811a31:	89 42 04             	mov    %eax,0x4(%edx)
  return ERR_OK;
}
  811a34:	b8 00 00 00 00       	mov    $0x0,%eax
  811a39:	5d                   	pop    %ebp
  811a3a:	c3                   	ret    

00811a3b <raw_recv>:
void
raw_recv(struct raw_pcb *pcb,
         u8_t (* recv)(void *arg, struct raw_pcb *upcb, struct pbuf *p,
                      struct ip_addr *addr),
         void *recv_arg)
{
  811a3b:	55                   	push   %ebp
  811a3c:	89 e5                	mov    %esp,%ebp
  811a3e:	8b 45 08             	mov    0x8(%ebp),%eax
  /* remember recv() callback and user data */
  pcb->recv = recv;
  811a41:	8b 55 0c             	mov    0xc(%ebp),%edx
  811a44:	89 50 14             	mov    %edx,0x14(%eax)
  pcb->recv_arg = recv_arg;
  811a47:	8b 55 10             	mov    0x10(%ebp),%edx
  811a4a:	89 50 18             	mov    %edx,0x18(%eax)
}
  811a4d:	5d                   	pop    %ebp
  811a4e:	c3                   	ret    

00811a4f <raw_new>:
 * @param proto the protocol number of the IPs payload (e.g. IP_PROTO_ICMP)
 *
 * @see raw_remove()
 */
struct raw_pcb *
raw_new(u8_t proto) {
  811a4f:	55                   	push   %ebp
  811a50:	89 e5                	mov    %esp,%ebp
  811a52:	83 ec 18             	sub    $0x18,%esp
  811a55:	89 5d f8             	mov    %ebx,-0x8(%ebp)
  811a58:	89 75 fc             	mov    %esi,-0x4(%ebp)
  811a5b:	0f b6 75 08          	movzbl 0x8(%ebp),%esi
  struct raw_pcb *pcb;

  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_new\n"));

  pcb = memp_malloc(MEMP_RAW_PCB);
  811a5f:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811a66:	e8 99 5d ff ff       	call   807804 <memp_malloc>
  811a6b:	89 c3                	mov    %eax,%ebx
  /* could allocate RAW PCB? */
  if (pcb != NULL) {
  811a6d:	85 c0                	test   %eax,%eax
  811a6f:	74 2f                	je     811aa0 <raw_new+0x51>
    /* initialize PCB to all zeroes */
    memset(pcb, 0, sizeof(struct raw_pcb));
  811a71:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811a78:	00 
  811a79:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811a80:	00 
  811a81:	89 04 24             	mov    %eax,(%esp)
  811a84:	e8 2d f8 fe ff       	call   8012b6 <memset>
    pcb->protocol = proto;
  811a89:	89 f0                	mov    %esi,%eax
  811a8b:	88 43 10             	mov    %al,0x10(%ebx)
    pcb->ttl = RAW_TTL;
  811a8e:	c6 43 0b ff          	movb   $0xff,0xb(%ebx)
    pcb->next = raw_pcbs;
  811a92:	a1 8c f5 b3 00       	mov    0xb3f58c,%eax
  811a97:	89 43 0c             	mov    %eax,0xc(%ebx)
    raw_pcbs = pcb;
  811a9a:	89 1d 8c f5 b3 00    	mov    %ebx,0xb3f58c
  }
  return pcb;
}
  811aa0:	89 d8                	mov    %ebx,%eax
  811aa2:	8b 5d f8             	mov    -0x8(%ebp),%ebx
  811aa5:	8b 75 fc             	mov    -0x4(%ebp),%esi
  811aa8:	89 ec                	mov    %ebp,%esp
  811aaa:	5d                   	pop    %ebp
  811aab:	c3                   	ret    

00811aac <raw_remove>:
 *
 * @see raw_new()
 */
void
raw_remove(struct raw_pcb *pcb)
{
  811aac:	55                   	push   %ebp
  811aad:	89 e5                	mov    %esp,%ebp
  811aaf:	83 ec 18             	sub    $0x18,%esp
  811ab2:	8b 4d 08             	mov    0x8(%ebp),%ecx
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
  811ab5:	8b 15 8c f5 b3 00    	mov    0xb3f58c,%edx
  811abb:	39 ca                	cmp    %ecx,%edx
  811abd:	74 06                	je     811ac5 <raw_remove+0x19>
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811abf:	85 d2                	test   %edx,%edx
  811ac1:	75 0e                	jne    811ad1 <raw_remove+0x25>
  811ac3:	eb 21                	jmp    811ae6 <raw_remove+0x3a>
{
  struct raw_pcb *pcb2;
  /* pcb to be removed is first in list? */
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
  811ac5:	8b 42 0c             	mov    0xc(%edx),%eax
  811ac8:	a3 8c f5 b3 00       	mov    %eax,0xb3f58c
  811acd:	eb 17                	jmp    811ae6 <raw_remove+0x3a>
  811acf:	89 c2                	mov    %eax,%edx
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
      /* find pcb in raw_pcbs list */
      if (pcb2->next != NULL && pcb2->next == pcb) {
  811ad1:	8b 42 0c             	mov    0xc(%edx),%eax
  811ad4:	85 c0                	test   %eax,%eax
  811ad6:	74 0e                	je     811ae6 <raw_remove+0x3a>
  811ad8:	39 c1                	cmp    %eax,%ecx
  811ada:	75 f3                	jne    811acf <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
  811adc:	8b 41 0c             	mov    0xc(%ecx),%eax
  811adf:	89 42 0c             	mov    %eax,0xc(%edx)
  if (raw_pcbs == pcb) {
    /* make list start at 2nd pcb */
    raw_pcbs = raw_pcbs->next;
    /* pcb not 1st in list */
  } else {
    for(pcb2 = raw_pcbs; pcb2 != NULL; pcb2 = pcb2->next) {
  811ae2:	85 c0                	test   %eax,%eax
  811ae4:	75 e9                	jne    811acf <raw_remove+0x23>
        /* remove pcb from list */
        pcb2->next = pcb->next;
      }
    }
  }
  memp_free(MEMP_RAW_PCB, pcb);
  811ae6:	89 4c 24 04          	mov    %ecx,0x4(%esp)
  811aea:	c7 04 24 00 00 00 00 	movl   $0x0,(%esp)
  811af1:	e8 ca 5c ff ff       	call   8077c0 <memp_free>
}
  811af6:	c9                   	leave  
  811af7:	c3                   	ret    

00811af8 <raw_sendto>:
 * @param ipaddr the destination address of the IP packet
 *
 */
err_t
raw_sendto(struct raw_pcb *pcb, struct pbuf *p, struct ip_addr *ipaddr)
{
  811af8:	55                   	push   %ebp
  811af9:	89 e5                	mov    %esp,%ebp
  811afb:	57                   	push   %edi
  811afc:	56                   	push   %esi
  811afd:	53                   	push   %ebx
  811afe:	83 ec 3c             	sub    $0x3c,%esp
  811b01:	8b 5d 08             	mov    0x8(%ebp),%ebx
  811b04:	8b 7d 0c             	mov    0xc(%ebp),%edi
  struct pbuf *q; /* q will be sent down the stack */
  
  LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 3, ("raw_sendto\n"));
  
  /* not enough space to add an IP header to first pbuf in given p chain? */
  if (pbuf_header(p, IP_HLEN)) {
  811b07:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  811b0e:	00 
  811b0f:	89 3c 24             	mov    %edi,(%esp)
  811b12:	e8 cc 60 ff ff       	call   807be3 <pbuf_header>
  811b17:	84 c0                	test   %al,%al
  811b19:	74 38                	je     811b53 <raw_sendto+0x5b>
    /* allocate header in new pbuf */
    q = pbuf_alloc(PBUF_IP, 0, PBUF_RAM);
  811b1b:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811b22:	00 
  811b23:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811b2a:	00 
  811b2b:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811b32:	e8 dc 66 ff ff       	call   808213 <pbuf_alloc>
  811b37:	89 c6                	mov    %eax,%esi
    /* new header pbuf could not be allocated? */
    if (q == NULL) {
  811b39:	c6 45 e7 ff          	movb   $0xff,-0x19(%ebp)
  811b3d:	85 c0                	test   %eax,%eax
  811b3f:	0f 84 b1 00 00 00    	je     811bf6 <raw_sendto+0xfe>
      LWIP_DEBUGF(RAW_DEBUG | LWIP_DBG_TRACE | 2, ("raw_sendto: could not allocate header\n"));
      return ERR_MEM;
    }
    /* chain header q in front of given pbuf p */
    pbuf_chain(q, p);
  811b45:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811b49:	89 04 24             	mov    %eax,(%esp)
  811b4c:	e8 6b 60 ff ff       	call   807bbc <pbuf_chain>
  811b51:	eb 32                	jmp    811b85 <raw_sendto+0x8d>
    /* { first pbuf q points to header pbuf } */
    LWIP_DEBUGF(RAW_DEBUG, ("raw_sendto: added header pbuf %p before given pbuf %p\n", (void *)q, (void *)p));
  }  else {
    /* first pbuf q equals given pbuf */
    q = p;
    if(pbuf_header(q, -IP_HLEN)) {
  811b53:	c7 44 24 04 ec ff ff 	movl   $0xffffffec,0x4(%esp)
  811b5a:	ff 
  811b5b:	89 3c 24             	mov    %edi,(%esp)
  811b5e:	e8 80 60 ff ff       	call   807be3 <pbuf_header>
  811b63:	84 c0                	test   %al,%al
  811b65:	74 1c                	je     811b83 <raw_sendto+0x8b>
      LWIP_ASSERT("Can't restore header we just removed!", 0);
  811b67:	c7 44 24 08 0c 51 81 	movl   $0x81510c,0x8(%esp)
  811b6e:	00 
  811b6f:	c7 44 24 04 e3 00 00 	movl   $0xe3,0x4(%esp)
  811b76:	00 
  811b77:	c7 04 24 32 51 81 00 	movl   $0x815132,(%esp)
  811b7e:	e8 51 ee fe ff       	call   8009d4 <_panic>
  811b83:	89 fe                	mov    %edi,%esi
      return ERR_MEM;
    }
  }
  
  if ((netif = ip_route(ipaddr)) == NULL) {
  811b85:	8b 45 10             	mov    0x10(%ebp),%eax
  811b88:	89 04 24             	mov    %eax,(%esp)
  811b8b:	e8 b1 7f ff ff       	call   809b41 <ip_route>
  811b90:	85 c0                	test   %eax,%eax
  811b92:	75 16                	jne    811baa <raw_sendto+0xb2>
    LWIP_DEBUGF(RAW_DEBUG | 1, ("raw_sendto: No route to 0x%"X32_F"\n", ipaddr->addr));
    /* free any temporary header pbuf allocated by pbuf_header() */
    if (q != p) {
  811b94:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811b98:	39 fe                	cmp    %edi,%esi
  811b9a:	74 5a                	je     811bf6 <raw_sendto+0xfe>
      pbuf_free(q);
  811b9c:	89 34 24             	mov    %esi,(%esp)
  811b9f:	e8 b4 63 ff ff       	call   807f58 <pbuf_free>
  811ba4:	c6 45 e7 fc          	movb   $0xfc,-0x19(%ebp)
  811ba8:	eb 4c                	jmp    811bf6 <raw_sendto+0xfe>
    }
    return ERR_RTE;
  }

  if (ip_addr_isany(&pcb->local_ip)) {
  811baa:	89 da                	mov    %ebx,%edx
  811bac:	85 db                	test   %ebx,%ebx
  811bae:	74 05                	je     811bb5 <raw_sendto+0xbd>
  811bb0:	83 3b 00             	cmpl   $0x0,(%ebx)
  811bb3:	75 03                	jne    811bb8 <raw_sendto+0xc0>
    /* use outgoing network interface IP address as source address */
    src_ip = &(netif->ip_addr);
  811bb5:	8d 50 04             	lea    0x4(%eax),%edx
  }

#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = &(pcb->addr_hint);
#endif /* LWIP_NETIF_HWADDRHINT*/
  err = ip_output_if (q, src_ip, ipaddr, pcb->ttl, pcb->tos, pcb->protocol, netif);
  811bb8:	89 44 24 18          	mov    %eax,0x18(%esp)
  811bbc:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811bc0:	89 44 24 14          	mov    %eax,0x14(%esp)
  811bc4:	0f b6 43 0a          	movzbl 0xa(%ebx),%eax
  811bc8:	89 44 24 10          	mov    %eax,0x10(%esp)
  811bcc:	0f b6 43 0b          	movzbl 0xb(%ebx),%eax
  811bd0:	89 44 24 0c          	mov    %eax,0xc(%esp)
  811bd4:	8b 45 10             	mov    0x10(%ebp),%eax
  811bd7:	89 44 24 08          	mov    %eax,0x8(%esp)
  811bdb:	89 54 24 04          	mov    %edx,0x4(%esp)
  811bdf:	89 34 24             	mov    %esi,(%esp)
  811be2:	e8 a9 7d ff ff       	call   809990 <ip_output_if>
  811be7:	88 45 e7             	mov    %al,-0x19(%ebp)
#if LWIP_NETIF_HWADDRHINT
  netif->addr_hint = NULL;
#endif /* LWIP_NETIF_HWADDRHINT*/

  /* did we chain a header earlier? */
  if (q != p) {
  811bea:	39 fe                	cmp    %edi,%esi
  811bec:	74 08                	je     811bf6 <raw_sendto+0xfe>
    /* free the header */
    pbuf_free(q);
  811bee:	89 34 24             	mov    %esi,(%esp)
  811bf1:	e8 62 63 ff ff       	call   807f58 <pbuf_free>
  }
  return err;
}
  811bf6:	0f b6 45 e7          	movzbl -0x19(%ebp),%eax
  811bfa:	83 c4 3c             	add    $0x3c,%esp
  811bfd:	5b                   	pop    %ebx
  811bfe:	5e                   	pop    %esi
  811bff:	5f                   	pop    %edi
  811c00:	5d                   	pop    %ebp
  811c01:	c3                   	ret    

00811c02 <raw_send>:
 * @param p the IP payload to send
 *
 */
err_t
raw_send(struct raw_pcb *pcb, struct pbuf *p)
{
  811c02:	55                   	push   %ebp
  811c03:	89 e5                	mov    %esp,%ebp
  811c05:	83 ec 18             	sub    $0x18,%esp
  811c08:	8b 45 08             	mov    0x8(%ebp),%eax
  return raw_sendto(pcb, p, &pcb->remote_ip);
  811c0b:	8d 50 04             	lea    0x4(%eax),%edx
  811c0e:	89 54 24 08          	mov    %edx,0x8(%esp)
  811c12:	8b 55 0c             	mov    0xc(%ebp),%edx
  811c15:	89 54 24 04          	mov    %edx,0x4(%esp)
  811c19:	89 04 24             	mov    %eax,(%esp)
  811c1c:	e8 d7 fe ff ff       	call   811af8 <raw_sendto>
}
  811c21:	c9                   	leave  
  811c22:	c3                   	ret    

00811c23 <raw_input>:
 *           caller).
 *
 */
u8_t
raw_input(struct pbuf *p, struct netif *inp)
{
  811c23:	55                   	push   %ebp
  811c24:	89 e5                	mov    %esp,%ebp
  811c26:	57                   	push   %edi
  811c27:	56                   	push   %esi
  811c28:	53                   	push   %ebx
  811c29:	83 ec 2c             	sub    $0x2c,%esp
  s16_t proto;
  u8_t eaten = 0;

  LWIP_UNUSED_ARG(inp);

  iphdr = p->payload;
  811c2c:	8b 45 08             	mov    0x8(%ebp),%eax
  811c2f:	8b 70 04             	mov    0x4(%eax),%esi
  proto = IPH_PROTO(iphdr);
  811c32:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  811c36:	89 04 24             	mov    %eax,(%esp)
  811c39:	e8 23 91 ff ff       	call   80ad61 <ntohs>
  811c3e:	66 25 ff 00          	and    $0xff,%ax

  prev = NULL;
  pcb = raw_pcbs;
  811c42:	8b 1d 8c f5 b3 00    	mov    0xb3f58c,%ebx
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811c48:	85 db                	test   %ebx,%ebx
  811c4a:	74 6c                	je     811cb8 <raw_input+0x95>
    if (pcb->protocol == proto) {
      /* receive callback function available? */
      if (pcb->recv != NULL) {
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  811c4c:	83 c6 0c             	add    $0xc,%esi
  811c4f:	89 75 e4             	mov    %esi,-0x1c(%ebp)
  811c52:	be 00 00 00 00       	mov    $0x0,%esi
  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
    if (pcb->protocol == proto) {
  811c57:	0f bf f8             	movswl %ax,%edi
  811c5a:	0f b6 43 10          	movzbl 0x10(%ebx),%eax
  811c5e:	39 f8                	cmp    %edi,%eax
  811c60:	75 49                	jne    811cab <raw_input+0x88>
      /* receive callback function available? */
      if (pcb->recv != NULL) {
  811c62:	8b 43 14             	mov    0x14(%ebx),%eax
  811c65:	85 c0                	test   %eax,%eax
  811c67:	74 42                	je     811cab <raw_input+0x88>
        /* the receive callback function did not eat the packet? */
        if (pcb->recv(pcb->recv_arg, pcb, p, &(iphdr->src)) != 0)
  811c69:	8b 55 e4             	mov    -0x1c(%ebp),%edx
  811c6c:	89 54 24 0c          	mov    %edx,0xc(%esp)
  811c70:	8b 55 08             	mov    0x8(%ebp),%edx
  811c73:	89 54 24 08          	mov    %edx,0x8(%esp)
  811c77:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  811c7b:	8b 53 18             	mov    0x18(%ebx),%edx
  811c7e:	89 14 24             	mov    %edx,(%esp)
  811c81:	ff d0                	call   *%eax
  811c83:	84 c0                	test   %al,%al
  811c85:	74 24                	je     811cab <raw_input+0x88>
        {
          /* receive function ate the packet */
          p = NULL;
          eaten = 1;
          if (prev != NULL) {
  811c87:	b8 01 00 00 00       	mov    $0x1,%eax
  811c8c:	85 f6                	test   %esi,%esi
  811c8e:	74 2d                	je     811cbd <raw_input+0x9a>
          /* move the pcb to the front of raw_pcbs so that is
             found faster next time */
            prev->next = pcb->next;
  811c90:	8b 43 0c             	mov    0xc(%ebx),%eax
  811c93:	89 46 0c             	mov    %eax,0xc(%esi)
            pcb->next = raw_pcbs;
  811c96:	a1 8c f5 b3 00       	mov    0xb3f58c,%eax
  811c9b:	89 43 0c             	mov    %eax,0xc(%ebx)
            raw_pcbs = pcb;
  811c9e:	89 1d 8c f5 b3 00    	mov    %ebx,0xb3f58c
  811ca4:	b8 01 00 00 00       	mov    $0x1,%eax
  811ca9:	eb 12                	jmp    811cbd <raw_input+0x9a>
      }
      /* no receive callback function was set for this raw PCB */
      /* drop the packet */
    }
    prev = pcb;
    pcb = pcb->next;
  811cab:	8b 43 0c             	mov    0xc(%ebx),%eax

  prev = NULL;
  pcb = raw_pcbs;
  /* loop through all raw pcbs until the packet is eaten by one */
  /* this allows multiple pcbs to match against the packet by design */
  while ((eaten == 0) && (pcb != NULL)) {
  811cae:	85 c0                	test   %eax,%eax
  811cb0:	74 06                	je     811cb8 <raw_input+0x95>
  811cb2:	89 de                	mov    %ebx,%esi
  811cb4:	89 c3                	mov    %eax,%ebx
  811cb6:	eb a2                	jmp    811c5a <raw_input+0x37>
  811cb8:	b8 00 00 00 00       	mov    $0x0,%eax
    }
    prev = pcb;
    pcb = pcb->next;
  }
  return eaten;
}
  811cbd:	83 c4 2c             	add    $0x2c,%esp
  811cc0:	5b                   	pop    %ebx
  811cc1:	5e                   	pop    %esi
  811cc2:	5f                   	pop    %edi
  811cc3:	5d                   	pop    %ebp
  811cc4:	c3                   	ret    
	...

00811cd0 <icmp_time_exceeded>:
 *          p->payload pointing to the IP header
 * @param t type of the 'time exceeded' packet
 */
void
icmp_time_exceeded(struct pbuf *p, enum icmp_te_type t)
{
  811cd0:	55                   	push   %ebp
  811cd1:	89 e5                	mov    %esp,%ebp
  811cd3:	57                   	push   %edi
  811cd4:	56                   	push   %esi
  811cd5:	53                   	push   %ebx
  811cd6:	83 ec 3c             	sub    $0x3c,%esp
  811cd9:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_te_hdr *tehdr;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811cdc:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811ce3:	00 
  811ce4:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811ceb:	00 
  811cec:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811cf3:	e8 1b 65 ff ff       	call   808213 <pbuf_alloc>
  811cf8:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  811cfa:	85 c0                	test   %eax,%eax
  811cfc:	0f 84 d8 00 00 00    	je     811dda <icmp_time_exceeded+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_time_exceeded: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811d02:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811d07:	77 1c                	ja     811d25 <icmp_time_exceeded+0x55>
  811d09:	c7 44 24 08 48 51 81 	movl   $0x815148,0x8(%esp)
  811d10:	00 
  811d11:	c7 44 24 04 1e 01 00 	movl   $0x11e,0x4(%esp)
  811d18:	00 
  811d19:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  811d20:	e8 af ec fe ff       	call   8009d4 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811d25:	8b 47 04             	mov    0x4(%edi),%eax
  811d28:	89 45 e4             	mov    %eax,-0x1c(%ebp)
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->src));
  LWIP_DEBUGF(ICMP_DEBUG, (" to "));
  ip_addr_debug_print(ICMP_DEBUG, &(iphdr->dest));
  LWIP_DEBUGF(ICMP_DEBUG, ("\n"));

  tehdr = q->payload;
  811d2b:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(tehdr, ICMP_TE);
  811d2e:	0f b7 06             	movzwl (%esi),%eax
  811d31:	89 04 24             	mov    %eax,(%esp)
  811d34:	e8 28 90 ff ff       	call   80ad61 <ntohs>
  811d39:	0f b6 c0             	movzbl %al,%eax
  811d3c:	80 cc 0b             	or     $0xb,%ah
  811d3f:	89 04 24             	mov    %eax,(%esp)
  811d42:	e8 0d 90 ff ff       	call   80ad54 <htons>
  811d47:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(tehdr, t);
  811d4a:	0f b7 c0             	movzwl %ax,%eax
  811d4d:	89 04 24             	mov    %eax,(%esp)
  811d50:	e8 0c 90 ff ff       	call   80ad61 <ntohs>
  811d55:	b0 00                	mov    $0x0,%al
  811d57:	66 0b 45 0c          	or     0xc(%ebp),%ax
  811d5b:	0f b7 c0             	movzwl %ax,%eax
  811d5e:	89 04 24             	mov    %eax,(%esp)
  811d61:	e8 ee 8f ff ff       	call   80ad54 <htons>
  811d66:	66 89 06             	mov    %ax,(%esi)

  /* copy fields from original packet */
  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), (u8_t *)p->payload,
  811d69:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811d70:	00 
  811d71:	8b 47 04             	mov    0x4(%edi),%eax
  811d74:	89 44 24 04          	mov    %eax,0x4(%esp)
  811d78:	8b 43 04             	mov    0x4(%ebx),%eax
  811d7b:	83 c0 08             	add    $0x8,%eax
  811d7e:	89 04 24             	mov    %eax,(%esp)
  811d81:	e8 0b f6 fe ff       	call   801391 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  tehdr->chksum = 0;
  811d86:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  tehdr->chksum = inet_chksum(tehdr, q->len);
  811d8c:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811d90:	89 44 24 04          	mov    %eax,0x4(%esp)
  811d94:	89 34 24             	mov    %esi,(%esp)
  811d97:	e8 9e 8c ff ff       	call   80aa3a <inet_chksum>
  811d9c:	66 89 46 02          	mov    %ax,0x2(%esi)
  ICMP_STATS_INC(icmp.xmit);
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpouttimeexcds();
  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811da0:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811da7:	00 
  811da8:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811daf:	00 
  811db0:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811db7:	00 
  811db8:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811dbb:	83 c0 0c             	add    $0xc,%eax
  811dbe:	89 44 24 08          	mov    %eax,0x8(%esp)
  811dc2:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811dc9:	00 
  811dca:	89 1c 24             	mov    %ebx,(%esp)
  811dcd:	e8 cb 7d ff ff       	call   809b9d <ip_output>
  pbuf_free(q);
  811dd2:	89 1c 24             	mov    %ebx,(%esp)
  811dd5:	e8 7e 61 ff ff       	call   807f58 <pbuf_free>
}
  811dda:	83 c4 3c             	add    $0x3c,%esp
  811ddd:	5b                   	pop    %ebx
  811dde:	5e                   	pop    %esi
  811ddf:	5f                   	pop    %edi
  811de0:	5d                   	pop    %ebp
  811de1:	c3                   	ret    

00811de2 <icmp_dest_unreach>:
 *          p->payload pointing to the IP header
 * @param t type of the 'unreachable' packet
 */
void
icmp_dest_unreach(struct pbuf *p, enum icmp_dur_type t)
{
  811de2:	55                   	push   %ebp
  811de3:	89 e5                	mov    %esp,%ebp
  811de5:	57                   	push   %edi
  811de6:	56                   	push   %esi
  811de7:	53                   	push   %ebx
  811de8:	83 ec 3c             	sub    $0x3c,%esp
  811deb:	8b 7d 08             	mov    0x8(%ebp),%edi
  struct pbuf *q;
  struct ip_hdr *iphdr;
  struct icmp_dur_hdr *idur;

  /* ICMP header + IP header + 8 bytes of data */
  q = pbuf_alloc(PBUF_IP, sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE,
  811dee:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  811df5:	00 
  811df6:	c7 44 24 04 24 00 00 	movl   $0x24,0x4(%esp)
  811dfd:	00 
  811dfe:	c7 04 24 01 00 00 00 	movl   $0x1,(%esp)
  811e05:	e8 09 64 ff ff       	call   808213 <pbuf_alloc>
  811e0a:	89 c3                	mov    %eax,%ebx
                 PBUF_RAM);
  if (q == NULL) {
  811e0c:	85 c0                	test   %eax,%eax
  811e0e:	0f 84 d8 00 00 00    	je     811eec <icmp_dest_unreach+0x10a>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_dest_unreach: failed to allocate pbuf for ICMP packet.\n"));
    return;
  }
  LWIP_ASSERT("check that first pbuf can hold icmp message",
  811e14:	66 83 78 0a 23       	cmpw   $0x23,0xa(%eax)
  811e19:	77 1c                	ja     811e37 <icmp_dest_unreach+0x55>
  811e1b:	c7 44 24 08 48 51 81 	movl   $0x815148,0x8(%esp)
  811e22:	00 
  811e23:	c7 44 24 04 ef 00 00 	movl   $0xef,0x4(%esp)
  811e2a:	00 
  811e2b:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  811e32:	e8 9d eb fe ff       	call   8009d4 <_panic>
             (q->len >= (sizeof(struct icmp_dur_hdr) + IP_HLEN + ICMP_DEST_UNREACH_DATASIZE)));

  iphdr = p->payload;
  811e37:	8b 47 04             	mov    0x4(%edi),%eax
  811e3a:	89 45 e4             	mov    %eax,-0x1c(%ebp)

  idur = q->payload;
  811e3d:	8b 73 04             	mov    0x4(%ebx),%esi
  ICMPH_TYPE_SET(idur, ICMP_DUR);
  811e40:	0f b7 06             	movzwl (%esi),%eax
  811e43:	89 04 24             	mov    %eax,(%esp)
  811e46:	e8 16 8f ff ff       	call   80ad61 <ntohs>
  811e4b:	0f b6 c0             	movzbl %al,%eax
  811e4e:	80 cc 03             	or     $0x3,%ah
  811e51:	89 04 24             	mov    %eax,(%esp)
  811e54:	e8 fb 8e ff ff       	call   80ad54 <htons>
  811e59:	66 89 06             	mov    %ax,(%esi)
  ICMPH_CODE_SET(idur, t);
  811e5c:	0f b7 c0             	movzwl %ax,%eax
  811e5f:	89 04 24             	mov    %eax,(%esp)
  811e62:	e8 fa 8e ff ff       	call   80ad61 <ntohs>
  811e67:	b0 00                	mov    $0x0,%al
  811e69:	66 0b 45 0c          	or     0xc(%ebp),%ax
  811e6d:	0f b7 c0             	movzwl %ax,%eax
  811e70:	89 04 24             	mov    %eax,(%esp)
  811e73:	e8 dc 8e ff ff       	call   80ad54 <htons>
  811e78:	66 89 06             	mov    %ax,(%esi)

  SMEMCPY((u8_t *)q->payload + sizeof(struct icmp_dur_hdr), p->payload,
  811e7b:	c7 44 24 08 1c 00 00 	movl   $0x1c,0x8(%esp)
  811e82:	00 
  811e83:	8b 47 04             	mov    0x4(%edi),%eax
  811e86:	89 44 24 04          	mov    %eax,0x4(%esp)
  811e8a:	8b 43 04             	mov    0x4(%ebx),%eax
  811e8d:	83 c0 08             	add    $0x8,%eax
  811e90:	89 04 24             	mov    %eax,(%esp)
  811e93:	e8 f9 f4 fe ff       	call   801391 <memcpy>
          IP_HLEN + ICMP_DEST_UNREACH_DATASIZE);

  /* calculate checksum */
  idur->chksum = 0;
  811e98:	66 c7 46 02 00 00    	movw   $0x0,0x2(%esi)
  idur->chksum = inet_chksum(idur, q->len);
  811e9e:	0f b7 43 0a          	movzwl 0xa(%ebx),%eax
  811ea2:	89 44 24 04          	mov    %eax,0x4(%esp)
  811ea6:	89 34 24             	mov    %esi,(%esp)
  811ea9:	e8 8c 8b ff ff       	call   80aa3a <inet_chksum>
  811eae:	66 89 46 02          	mov    %ax,0x2(%esi)
  /* increase number of messages attempted to send */
  snmp_inc_icmpoutmsgs();
  /* increase number of destination unreachable messages attempted to send */
  snmp_inc_icmpoutdestunreachs();

  ip_output(q, NULL, &(iphdr->src), ICMP_TTL, 0, IP_PROTO_ICMP);
  811eb2:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  811eb9:	00 
  811eba:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  811ec1:	00 
  811ec2:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  811ec9:	00 
  811eca:	8b 45 e4             	mov    -0x1c(%ebp),%eax
  811ecd:	83 c0 0c             	add    $0xc,%eax
  811ed0:	89 44 24 08          	mov    %eax,0x8(%esp)
  811ed4:	c7 44 24 04 00 00 00 	movl   $0x0,0x4(%esp)
  811edb:	00 
  811edc:	89 1c 24             	mov    %ebx,(%esp)
  811edf:	e8 b9 7c ff ff       	call   809b9d <ip_output>
  pbuf_free(q);
  811ee4:	89 1c 24             	mov    %ebx,(%esp)
  811ee7:	e8 6c 60 ff ff       	call   807f58 <pbuf_free>
}
  811eec:	83 c4 3c             	add    $0x3c,%esp
  811eef:	5b                   	pop    %ebx
  811ef0:	5e                   	pop    %esi
  811ef1:	5f                   	pop    %edi
  811ef2:	5d                   	pop    %ebp
  811ef3:	c3                   	ret    

00811ef4 <icmp_input>:
 * @param p the icmp echo request packet, p->payload pointing to the ip header
 * @param inp the netif on which this packet was received
 */
void
icmp_input(struct pbuf *p, struct netif *inp)
{
  811ef4:	55                   	push   %ebp
  811ef5:	89 e5                	mov    %esp,%ebp
  811ef7:	83 ec 48             	sub    $0x48,%esp
  811efa:	89 5d f4             	mov    %ebx,-0xc(%ebp)
  811efd:	89 75 f8             	mov    %esi,-0x8(%ebp)
  811f00:	89 7d fc             	mov    %edi,-0x4(%ebp)
  811f03:	8b 5d 08             	mov    0x8(%ebp),%ebx

  ICMP_STATS_INC(icmp.recv);
  snmp_inc_icmpinmsgs();


  iphdr = p->payload;
  811f06:	8b 73 04             	mov    0x4(%ebx),%esi
  hlen = IPH_HL(iphdr) * 4;
  811f09:	0f b7 06             	movzwl (%esi),%eax
  811f0c:	89 04 24             	mov    %eax,(%esp)
  811f0f:	e8 4d 8e ff ff       	call   80ad61 <ntohs>
  811f14:	66 c1 e8 06          	shr    $0x6,%ax
  811f18:	83 e0 3c             	and    $0x3c,%eax
  811f1b:	66 89 45 e6          	mov    %ax,-0x1a(%ebp)
  if (pbuf_header(p, -hlen) || (p->tot_len < sizeof(u16_t)*2)) {
  811f1f:	89 c7                	mov    %eax,%edi
  811f21:	f7 df                	neg    %edi
  811f23:	0f bf ff             	movswl %di,%edi
  811f26:	89 7c 24 04          	mov    %edi,0x4(%esp)
  811f2a:	89 1c 24             	mov    %ebx,(%esp)
  811f2d:	e8 b1 5c ff ff       	call   807be3 <pbuf_header>
  811f32:	84 c0                	test   %al,%al
  811f34:	0f 85 ee 02 00 00    	jne    812228 <icmp_input+0x334>
  811f3a:	66 83 7b 08 03       	cmpw   $0x3,0x8(%ebx)
  811f3f:	0f 86 e3 02 00 00    	jbe    812228 <icmp_input+0x334>

  type = *((u8_t *)p->payload);
#ifdef LWIP_DEBUG
  code = *(((u8_t *)p->payload)+1);
#endif /* LWIP_DEBUG */
  switch (type) {
  811f45:	8b 43 04             	mov    0x4(%ebx),%eax
  811f48:	80 38 08             	cmpb   $0x8,(%eax)
  811f4b:	0f 85 cd 02 00 00    	jne    81221e <icmp_input+0x32a>
  case ICMP_ECHO:
    /* broadcast or multicast destination address? */
    if (ip_addr_isbroadcast(&iphdr->dest, inp) || ip_addr_ismulticast(&iphdr->dest)) {
  811f51:	8b 45 0c             	mov    0xc(%ebp),%eax
  811f54:	89 44 24 04          	mov    %eax,0x4(%esp)
  811f58:	8d 46 10             	lea    0x10(%esi),%eax
  811f5b:	89 04 24             	mov    %eax,(%esp)
  811f5e:	e8 e5 79 ff ff       	call   809948 <ip_addr_isbroadcast>
  811f63:	84 c0                	test   %al,%al
  811f65:	75 2b                	jne    811f92 <icmp_input+0x9e>
  811f67:	8b 56 10             	mov    0x10(%esi),%edx
  811f6a:	89 55 dc             	mov    %edx,-0x24(%ebp)
  811f6d:	c7 04 24 00 00 00 f0 	movl   $0xf0000000,(%esp)
  811f74:	e8 21 90 ff ff       	call   80af9a <ntohl>
  811f79:	89 45 e0             	mov    %eax,-0x20(%ebp)
  811f7c:	c7 04 24 00 00 00 e0 	movl   $0xe0000000,(%esp)
  811f83:	e8 12 90 ff ff       	call   80af9a <ntohl>
  811f88:	8b 55 e0             	mov    -0x20(%ebp),%edx
  811f8b:	23 55 dc             	and    -0x24(%ebp),%edx
  811f8e:	39 c2                	cmp    %eax,%edx
  811f90:	75 0d                	jne    811f9f <icmp_input+0xab>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: Not echoing to multicast or broadcast pings\n"));
      ICMP_STATS_INC(icmp.err);
      pbuf_free(p);
  811f92:	89 1c 24             	mov    %ebx,(%esp)
  811f95:	e8 be 5f ff ff       	call   807f58 <pbuf_free>
      return;
  811f9a:	e9 9b 02 00 00       	jmp    81223a <icmp_input+0x346>
    }
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ping\n"));
    if (p->tot_len < sizeof(struct icmp_echo_hdr)) {
  811f9f:	66 83 7b 08 07       	cmpw   $0x7,0x8(%ebx)
  811fa4:	0f 86 7e 02 00 00    	jbe    812228 <icmp_input+0x334>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: bad ICMP echo received\n"));
      goto lenerr;
    }
    if (inet_chksum_pbuf(p) != 0) {
  811faa:	89 1c 24             	mov    %ebx,(%esp)
  811fad:	8d 76 00             	lea    0x0(%esi),%esi
  811fb0:	e8 00 8a ff ff       	call   80a9b5 <inet_chksum_pbuf>
  811fb5:	66 85 c0             	test   %ax,%ax
  811fb8:	74 0d                	je     811fc7 <icmp_input+0xd3>
      LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: checksum failed for received ICMP echo\n"));
      pbuf_free(p);
  811fba:	89 1c 24             	mov    %ebx,(%esp)
  811fbd:	e8 96 5f ff ff       	call   807f58 <pbuf_free>
      ICMP_STATS_INC(icmp.chkerr);
      snmp_inc_icmpinerrors();
      return;
  811fc2:	e9 73 02 00 00       	jmp    81223a <icmp_input+0x346>
    }
    if (pbuf_header(p, (PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  811fc7:	c7 44 24 04 22 00 00 	movl   $0x22,0x4(%esp)
  811fce:	00 
  811fcf:	89 1c 24             	mov    %ebx,(%esp)
  811fd2:	e8 0c 5c ff ff       	call   807be3 <pbuf_header>
  811fd7:	84 c0                	test   %al,%al
  811fd9:	0f 84 f0 00 00 00    	je     8120cf <icmp_input+0x1db>
      /* p is not big enough to contain link headers
       * allocate a new one and copy p into it
       */
      struct pbuf *r;
      /* switch p->payload to ip header */
      if (pbuf_header(p, hlen)) {
  811fdf:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  811fe3:	89 44 24 04          	mov    %eax,0x4(%esp)
  811fe7:	89 1c 24             	mov    %ebx,(%esp)
  811fea:	e8 f4 5b ff ff       	call   807be3 <pbuf_header>
  811fef:	84 c0                	test   %al,%al
  811ff1:	74 1c                	je     81200f <icmp_input+0x11b>
        LWIP_ASSERT("icmp_input: moving p->payload to ip header failed\n", 0);
  811ff3:	c7 44 24 08 74 51 81 	movl   $0x815174,0x8(%esp)
  811ffa:	00 
  811ffb:	c7 44 24 04 7b 00 00 	movl   $0x7b,0x4(%esp)
  812002:	00 
  812003:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  81200a:	e8 c5 e9 fe ff       	call   8009d4 <_panic>
        goto memerr;
      }
      /* allocate new packet buffer with space for link headers */
      r = pbuf_alloc(PBUF_LINK, p->tot_len, PBUF_RAM);
  81200f:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  812016:	00 
  812017:	0f b7 43 08          	movzwl 0x8(%ebx),%eax
  81201b:	89 44 24 04          	mov    %eax,0x4(%esp)
  81201f:	c7 04 24 02 00 00 00 	movl   $0x2,(%esp)
  812026:	e8 e8 61 ff ff       	call   808213 <pbuf_alloc>
  81202b:	89 45 e0             	mov    %eax,-0x20(%ebp)
      if (r == NULL) {
  81202e:	85 c0                	test   %eax,%eax
  812030:	0f 84 fc 01 00 00    	je     812232 <icmp_input+0x33e>
        LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: allocating new pbuf failed\n"));
        goto memerr;
      }
      LWIP_ASSERT("check that first pbuf can hold struct the ICMP header",
  812036:	0f b7 50 0a          	movzwl 0xa(%eax),%edx
  81203a:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  81203e:	83 c0 08             	add    $0x8,%eax
  812041:	39 c2                	cmp    %eax,%edx
  812043:	73 1c                	jae    812061 <icmp_input+0x16d>
  812045:	c7 44 24 08 a8 51 81 	movl   $0x8151a8,0x8(%esp)
  81204c:	00 
  81204d:	c7 44 24 04 85 00 00 	movl   $0x85,0x4(%esp)
  812054:	00 
  812055:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  81205c:	e8 73 e9 fe ff       	call   8009d4 <_panic>
                  (r->len >= hlen + sizeof(struct icmp_echo_hdr)));
      /* copy the whole packet including ip header */
      if (pbuf_copy(r, p) != ERR_OK) {
  812061:	89 5c 24 04          	mov    %ebx,0x4(%esp)
  812065:	8b 45 e0             	mov    -0x20(%ebp),%eax
  812068:	89 04 24             	mov    %eax,(%esp)
  81206b:	e8 35 5d ff ff       	call   807da5 <pbuf_copy>
  812070:	84 c0                	test   %al,%al
  812072:	74 1c                	je     812090 <icmp_input+0x19c>
        LWIP_ASSERT("icmp_input: copying to new pbuf failed\n", 0);
  812074:	c7 44 24 08 e0 51 81 	movl   $0x8151e0,0x8(%esp)
  81207b:	00 
  81207c:	c7 44 24 04 88 00 00 	movl   $0x88,0x4(%esp)
  812083:	00 
  812084:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  81208b:	e8 44 e9 fe ff       	call   8009d4 <_panic>
        goto memerr;
      }
      iphdr = r->payload;
  812090:	8b 55 e0             	mov    -0x20(%ebp),%edx
  812093:	8b 72 04             	mov    0x4(%edx),%esi
      /* switch r->payload back to icmp header */
      if (pbuf_header(r, -hlen)) {
  812096:	89 7c 24 04          	mov    %edi,0x4(%esp)
  81209a:	89 14 24             	mov    %edx,(%esp)
  81209d:	e8 41 5b ff ff       	call   807be3 <pbuf_header>
  8120a2:	84 c0                	test   %al,%al
  8120a4:	74 1c                	je     8120c2 <icmp_input+0x1ce>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8120a6:	c7 44 24 08 08 52 81 	movl   $0x815208,0x8(%esp)
  8120ad:	00 
  8120ae:	c7 44 24 04 8e 00 00 	movl   $0x8e,0x4(%esp)
  8120b5:	00 
  8120b6:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  8120bd:	e8 12 e9 fe ff       	call   8009d4 <_panic>
        goto memerr;
      }
      /* free the original p */
      pbuf_free(p);
  8120c2:	89 1c 24             	mov    %ebx,(%esp)
  8120c5:	e8 8e 5e ff ff       	call   807f58 <pbuf_free>
  8120ca:	8b 5d e0             	mov    -0x20(%ebp),%ebx
  8120cd:	eb 30                	jmp    8120ff <icmp_input+0x20b>
      /* we now have an identical copy of p that has room for link headers */
      p = r;
    } else {
      /* restore p->payload to point to icmp header */
      if (pbuf_header(p, -(s16_t)(PBUF_IP_HLEN + PBUF_LINK_HLEN))) {
  8120cf:	c7 44 24 04 de ff ff 	movl   $0xffffffde,0x4(%esp)
  8120d6:	ff 
  8120d7:	89 1c 24             	mov    %ebx,(%esp)
  8120da:	e8 04 5b ff ff       	call   807be3 <pbuf_header>
  8120df:	84 c0                	test   %al,%al
  8120e1:	74 1c                	je     8120ff <icmp_input+0x20b>
        LWIP_ASSERT("icmp_input: restoring original p->payload failed\n", 0);
  8120e3:	c7 44 24 08 08 52 81 	movl   $0x815208,0x8(%esp)
  8120ea:	00 
  8120eb:	c7 44 24 04 98 00 00 	movl   $0x98,0x4(%esp)
  8120f2:	00 
  8120f3:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  8120fa:	e8 d5 e8 fe ff       	call   8009d4 <_panic>
      }
    }
    /* At this point, all checks are OK. */
    /* We generate an answer by switching the dest and src ip addresses,
     * setting the icmp type to ECHO_RESPONSE and updating the checksum. */
    iecho = p->payload;
  8120ff:	8b 7b 04             	mov    0x4(%ebx),%edi
    tmpaddr.addr = iphdr->src.addr;
  812102:	8b 46 0c             	mov    0xc(%esi),%eax
    iphdr->src.addr = iphdr->dest.addr;
  812105:	8b 56 10             	mov    0x10(%esi),%edx
  812108:	89 56 0c             	mov    %edx,0xc(%esi)
    iphdr->dest.addr = tmpaddr.addr;
  81210b:	89 46 10             	mov    %eax,0x10(%esi)
    ICMPH_TYPE_SET(iecho, ICMP_ER);
  81210e:	0f b7 07             	movzwl (%edi),%eax
  812111:	89 04 24             	mov    %eax,(%esp)
  812114:	e8 48 8c ff ff       	call   80ad61 <ntohs>
  812119:	0f b6 c0             	movzbl %al,%eax
  81211c:	89 04 24             	mov    %eax,(%esp)
  81211f:	e8 30 8c ff ff       	call   80ad54 <htons>
  812124:	66 89 07             	mov    %ax,(%edi)
    /* adjust the checksum */
    if (iecho->chksum >= htons(0xffff - (ICMP_ECHO << 8))) {
  812127:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  81212b:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  81212f:	c7 04 24 ff f7 00 00 	movl   $0xf7ff,(%esp)
  812136:	e8 19 8c ff ff       	call   80ad54 <htons>
  81213b:	66 39 45 e0          	cmp    %ax,-0x20(%ebp)
  81213f:	72 22                	jb     812163 <icmp_input+0x26f>
      iecho->chksum += htons(ICMP_ECHO << 8) + 1;
  812141:	0f b7 57 02          	movzwl 0x2(%edi),%edx
  812145:	66 89 55 e0          	mov    %dx,-0x20(%ebp)
  812149:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  812150:	e8 ff 8b ff ff       	call   80ad54 <htons>
  812155:	0f b7 55 e0          	movzwl -0x20(%ebp),%edx
  812159:	8d 44 02 01          	lea    0x1(%edx,%eax,1),%eax
  81215d:	66 89 47 02          	mov    %ax,0x2(%edi)
  812161:	eb 1c                	jmp    81217f <icmp_input+0x28b>
    } else {
      iecho->chksum += htons(ICMP_ECHO << 8);
  812163:	0f b7 47 02          	movzwl 0x2(%edi),%eax
  812167:	66 89 45 e0          	mov    %ax,-0x20(%ebp)
  81216b:	c7 04 24 00 08 00 00 	movl   $0x800,(%esp)
  812172:	e8 dd 8b ff ff       	call   80ad54 <htons>
  812177:	66 03 45 e0          	add    -0x20(%ebp),%ax
  81217b:	66 89 47 02          	mov    %ax,0x2(%edi)
    }

    /* Set the correct TTL and recalculate the header checksum. */
    IPH_TTL_SET(iphdr, ICMP_TTL);
  81217f:	0f b7 46 08          	movzwl 0x8(%esi),%eax
  812183:	89 04 24             	mov    %eax,(%esp)
  812186:	e8 d6 8b ff ff       	call   80ad61 <ntohs>
  81218b:	66 0d 00 ff          	or     $0xff00,%ax
  81218f:	0f b7 c0             	movzwl %ax,%eax
  812192:	89 04 24             	mov    %eax,(%esp)
  812195:	e8 ba 8b ff ff       	call   80ad54 <htons>
  81219a:	66 89 46 08          	mov    %ax,0x8(%esi)
    IPH_CHKSUM_SET(iphdr, 0);
  81219e:	66 c7 46 0a 00 00    	movw   $0x0,0xa(%esi)
#if CHECKSUM_GEN_IP
    IPH_CHKSUM_SET(iphdr, inet_chksum(iphdr, IP_HLEN));
  8121a4:	c7 44 24 04 14 00 00 	movl   $0x14,0x4(%esp)
  8121ab:	00 
  8121ac:	89 34 24             	mov    %esi,(%esp)
  8121af:	e8 86 88 ff ff       	call   80aa3a <inet_chksum>
  8121b4:	66 89 46 0a          	mov    %ax,0xa(%esi)
    /* increase number of messages attempted to send */
    snmp_inc_icmpoutmsgs();
    /* increase number of echo replies attempted to send */
    snmp_inc_icmpoutechoreps();

    if(pbuf_header(p, hlen)) {
  8121b8:	0f bf 45 e6          	movswl -0x1a(%ebp),%eax
  8121bc:	89 44 24 04          	mov    %eax,0x4(%esp)
  8121c0:	89 1c 24             	mov    %ebx,(%esp)
  8121c3:	e8 1b 5a ff ff       	call   807be3 <pbuf_header>
  8121c8:	84 c0                	test   %al,%al
  8121ca:	74 1c                	je     8121e8 <icmp_input+0x2f4>
      LWIP_ASSERT("Can't move over header in packet", 0);
  8121cc:	c7 44 24 08 4c 42 81 	movl   $0x81424c,0x8(%esp)
  8121d3:	00 
  8121d4:	c7 44 24 04 b9 00 00 	movl   $0xb9,0x4(%esp)
  8121db:	00 
  8121dc:	c7 04 24 3c 52 81 00 	movl   $0x81523c,(%esp)
  8121e3:	e8 ec e7 fe ff       	call   8009d4 <_panic>
    } else {
      err_t ret;
      ret = ip_output_if(p, &(iphdr->src), IP_HDRINCL,
  8121e8:	8b 55 0c             	mov    0xc(%ebp),%edx
  8121eb:	89 54 24 18          	mov    %edx,0x18(%esp)
  8121ef:	c7 44 24 14 01 00 00 	movl   $0x1,0x14(%esp)
  8121f6:	00 
  8121f7:	c7 44 24 10 00 00 00 	movl   $0x0,0x10(%esp)
  8121fe:	00 
  8121ff:	c7 44 24 0c ff 00 00 	movl   $0xff,0xc(%esp)
  812206:	00 
  812207:	c7 44 24 08 00 00 00 	movl   $0x0,0x8(%esp)
  81220e:	00 
  81220f:	83 c6 0c             	add    $0xc,%esi
  812212:	89 74 24 04          	mov    %esi,0x4(%esp)
  812216:	89 1c 24             	mov    %ebx,(%esp)
  812219:	e8 72 77 ff ff       	call   809990 <ip_output_if>
    LWIP_DEBUGF(ICMP_DEBUG, ("icmp_input: ICMP type %"S16_F" code %"S16_F" not supported.\n", 
                (s16_t)type, (s16_t)code));
    ICMP_STATS_INC(icmp.proterr);
    ICMP_STATS_INC(icmp.drop);
  }
  pbuf_free(p);
  81221e:	89 1c 24             	mov    %ebx,(%esp)
  812221:	e8 32 5d ff ff       	call   807f58 <pbuf_free>
  return;
  812226:	eb 12                	jmp    81223a <icmp_input+0x346>
lenerr:
  pbuf_free(p);
  812228:	89 1c 24             	mov    %ebx,(%esp)
  81222b:	e8 28 5d ff ff       	call   807f58 <pbuf_free>
  ICMP_STATS_INC(icmp.lenerr);
  snmp_inc_icmpinerrors();
  return;
  812230:	eb 08                	jmp    81223a <icmp_input+0x346>
memerr:
  pbuf_free(p);
  812232:	89 1c 24             	mov    %ebx,(%esp)
  812235:	e8 1e 5d ff ff       	call   807f58 <pbuf_free>
  ICMP_STATS_INC(icmp.err);
  snmp_inc_icmpinerrors();
  return;
}
  81223a:	8b 5d f4             	mov    -0xc(%ebp),%ebx
  81223d:	8b 75 f8             	mov    -0x8(%ebp),%esi
  812240:	8b 7d fc             	mov    -0x4(%ebp),%edi
  812243:	89 ec                	mov    %ebp,%esp
  812245:	5d                   	pop    %ebp
  812246:	c3                   	ret    
	...

00812250 <__udivdi3>:
  812250:	55                   	push   %ebp
  812251:	89 e5                	mov    %esp,%ebp
  812253:	57                   	push   %edi
  812254:	56                   	push   %esi
  812255:	83 ec 10             	sub    $0x10,%esp
  812258:	8b 45 14             	mov    0x14(%ebp),%eax
  81225b:	8b 55 08             	mov    0x8(%ebp),%edx
  81225e:	8b 75 10             	mov    0x10(%ebp),%esi
  812261:	8b 7d 0c             	mov    0xc(%ebp),%edi
  812264:	85 c0                	test   %eax,%eax
  812266:	89 55 f0             	mov    %edx,-0x10(%ebp)
  812269:	75 35                	jne    8122a0 <__udivdi3+0x50>
  81226b:	39 fe                	cmp    %edi,%esi
  81226d:	77 61                	ja     8122d0 <__udivdi3+0x80>
  81226f:	85 f6                	test   %esi,%esi
  812271:	75 0b                	jne    81227e <__udivdi3+0x2e>
  812273:	b8 01 00 00 00       	mov    $0x1,%eax
  812278:	31 d2                	xor    %edx,%edx
  81227a:	f7 f6                	div    %esi
  81227c:	89 c6                	mov    %eax,%esi
  81227e:	8b 4d f0             	mov    -0x10(%ebp),%ecx
  812281:	31 d2                	xor    %edx,%edx
  812283:	89 f8                	mov    %edi,%eax
  812285:	f7 f6                	div    %esi
  812287:	89 c7                	mov    %eax,%edi
  812289:	89 c8                	mov    %ecx,%eax
  81228b:	f7 f6                	div    %esi
  81228d:	89 c1                	mov    %eax,%ecx
  81228f:	89 fa                	mov    %edi,%edx
  812291:	89 c8                	mov    %ecx,%eax
  812293:	83 c4 10             	add    $0x10,%esp
  812296:	5e                   	pop    %esi
  812297:	5f                   	pop    %edi
  812298:	5d                   	pop    %ebp
  812299:	c3                   	ret    
  81229a:	8d b6 00 00 00 00    	lea    0x0(%esi),%esi
  8122a0:	39 f8                	cmp    %edi,%eax
  8122a2:	77 1c                	ja     8122c0 <__udivdi3+0x70>
  8122a4:	0f bd d0             	bsr    %eax,%edx
  8122a7:	83 f2 1f             	xor    $0x1f,%edx
  8122aa:	89 55 f4             	mov    %edx,-0xc(%ebp)
  8122ad:	75 39                	jne    8122e8 <__udivdi3+0x98>
  8122af:	3b 75 f0             	cmp    -0x10(%ebp),%esi
  8122b2:	0f 86 a0 00 00 00    	jbe    812358 <__udivdi3+0x108>
  8122b8:	39 f8                	cmp    %edi,%eax
  8122ba:	0f 82 98 00 00 00    	jb     812358 <__udivdi3+0x108>
  8122c0:	31 ff                	xor    %edi,%edi
  8122c2:	31 c9                	xor    %ecx,%ecx
  8122c4:	89 c8                	mov    %ecx,%eax
  8122c6:	89 fa                	mov    %edi,%edx
  8122c8:	83 c4 10             	add    $0x10,%esp
  8122cb:	5e                   	pop    %esi
  8122cc:	5f                   	pop    %edi
  8122cd:	5d                   	pop    %ebp
  8122ce:	c3                   	ret    
  8122cf:	90                   	nop
  8122d0:	89 d1                	mov    %edx,%ecx
  8122d2:	89 fa                	mov    %edi,%edx
  8122d4:	89 c8                	mov    %ecx,%eax
  8122d6:	31 ff                	xor    %edi,%edi
  8122d8:	f7 f6                	div    %esi
  8122da:	89 c1                	mov    %eax,%ecx
  8122dc:	89 fa                	mov    %edi,%edx
  8122de:	89 c8                	mov    %ecx,%eax
  8122e0:	83 c4 10             	add    $0x10,%esp
  8122e3:	5e                   	pop    %esi
  8122e4:	5f                   	pop    %edi
  8122e5:	5d                   	pop    %ebp
  8122e6:	c3                   	ret    
  8122e7:	90                   	nop
  8122e8:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  8122ec:	89 f2                	mov    %esi,%edx
  8122ee:	d3 e0                	shl    %cl,%eax
  8122f0:	89 45 ec             	mov    %eax,-0x14(%ebp)
  8122f3:	b8 20 00 00 00       	mov    $0x20,%eax
  8122f8:	2b 45 f4             	sub    -0xc(%ebp),%eax
  8122fb:	89 c1                	mov    %eax,%ecx
  8122fd:	d3 ea                	shr    %cl,%edx
  8122ff:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  812303:	0b 55 ec             	or     -0x14(%ebp),%edx
  812306:	d3 e6                	shl    %cl,%esi
  812308:	89 c1                	mov    %eax,%ecx
  81230a:	89 75 e8             	mov    %esi,-0x18(%ebp)
  81230d:	89 fe                	mov    %edi,%esi
  81230f:	d3 ee                	shr    %cl,%esi
  812311:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  812315:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812318:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81231b:	d3 e7                	shl    %cl,%edi
  81231d:	89 c1                	mov    %eax,%ecx
  81231f:	d3 ea                	shr    %cl,%edx
  812321:	09 d7                	or     %edx,%edi
  812323:	89 f2                	mov    %esi,%edx
  812325:	89 f8                	mov    %edi,%eax
  812327:	f7 75 ec             	divl   -0x14(%ebp)
  81232a:	89 d6                	mov    %edx,%esi
  81232c:	89 c7                	mov    %eax,%edi
  81232e:	f7 65 e8             	mull   -0x18(%ebp)
  812331:	39 d6                	cmp    %edx,%esi
  812333:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812336:	72 30                	jb     812368 <__udivdi3+0x118>
  812338:	8b 55 f0             	mov    -0x10(%ebp),%edx
  81233b:	0f b6 4d f4          	movzbl -0xc(%ebp),%ecx
  81233f:	d3 e2                	shl    %cl,%edx
  812341:	39 c2                	cmp    %eax,%edx
  812343:	73 05                	jae    81234a <__udivdi3+0xfa>
  812345:	3b 75 ec             	cmp    -0x14(%ebp),%esi
  812348:	74 1e                	je     812368 <__udivdi3+0x118>
  81234a:	89 f9                	mov    %edi,%ecx
  81234c:	31 ff                	xor    %edi,%edi
  81234e:	e9 71 ff ff ff       	jmp    8122c4 <__udivdi3+0x74>
  812353:	90                   	nop
  812354:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812358:	31 ff                	xor    %edi,%edi
  81235a:	b9 01 00 00 00       	mov    $0x1,%ecx
  81235f:	e9 60 ff ff ff       	jmp    8122c4 <__udivdi3+0x74>
  812364:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812368:	8d 4f ff             	lea    -0x1(%edi),%ecx
  81236b:	31 ff                	xor    %edi,%edi
  81236d:	89 c8                	mov    %ecx,%eax
  81236f:	89 fa                	mov    %edi,%edx
  812371:	83 c4 10             	add    $0x10,%esp
  812374:	5e                   	pop    %esi
  812375:	5f                   	pop    %edi
  812376:	5d                   	pop    %ebp
  812377:	c3                   	ret    
	...

00812380 <__umoddi3>:
  812380:	55                   	push   %ebp
  812381:	89 e5                	mov    %esp,%ebp
  812383:	57                   	push   %edi
  812384:	56                   	push   %esi
  812385:	83 ec 20             	sub    $0x20,%esp
  812388:	8b 55 14             	mov    0x14(%ebp),%edx
  81238b:	8b 4d 08             	mov    0x8(%ebp),%ecx
  81238e:	8b 7d 10             	mov    0x10(%ebp),%edi
  812391:	8b 75 0c             	mov    0xc(%ebp),%esi
  812394:	85 d2                	test   %edx,%edx
  812396:	89 c8                	mov    %ecx,%eax
  812398:	89 4d f4             	mov    %ecx,-0xc(%ebp)
  81239b:	75 13                	jne    8123b0 <__umoddi3+0x30>
  81239d:	39 f7                	cmp    %esi,%edi
  81239f:	76 3f                	jbe    8123e0 <__umoddi3+0x60>
  8123a1:	89 f2                	mov    %esi,%edx
  8123a3:	f7 f7                	div    %edi
  8123a5:	89 d0                	mov    %edx,%eax
  8123a7:	31 d2                	xor    %edx,%edx
  8123a9:	83 c4 20             	add    $0x20,%esp
  8123ac:	5e                   	pop    %esi
  8123ad:	5f                   	pop    %edi
  8123ae:	5d                   	pop    %ebp
  8123af:	c3                   	ret    
  8123b0:	39 f2                	cmp    %esi,%edx
  8123b2:	77 4c                	ja     812400 <__umoddi3+0x80>
  8123b4:	0f bd ca             	bsr    %edx,%ecx
  8123b7:	83 f1 1f             	xor    $0x1f,%ecx
  8123ba:	89 4d f0             	mov    %ecx,-0x10(%ebp)
  8123bd:	75 51                	jne    812410 <__umoddi3+0x90>
  8123bf:	3b 7d f4             	cmp    -0xc(%ebp),%edi
  8123c2:	0f 87 e0 00 00 00    	ja     8124a8 <__umoddi3+0x128>
  8123c8:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8123cb:	29 f8                	sub    %edi,%eax
  8123cd:	19 d6                	sbb    %edx,%esi
  8123cf:	89 45 f4             	mov    %eax,-0xc(%ebp)
  8123d2:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8123d5:	89 f2                	mov    %esi,%edx
  8123d7:	83 c4 20             	add    $0x20,%esp
  8123da:	5e                   	pop    %esi
  8123db:	5f                   	pop    %edi
  8123dc:	5d                   	pop    %ebp
  8123dd:	c3                   	ret    
  8123de:	66 90                	xchg   %ax,%ax
  8123e0:	85 ff                	test   %edi,%edi
  8123e2:	75 0b                	jne    8123ef <__umoddi3+0x6f>
  8123e4:	b8 01 00 00 00       	mov    $0x1,%eax
  8123e9:	31 d2                	xor    %edx,%edx
  8123eb:	f7 f7                	div    %edi
  8123ed:	89 c7                	mov    %eax,%edi
  8123ef:	89 f0                	mov    %esi,%eax
  8123f1:	31 d2                	xor    %edx,%edx
  8123f3:	f7 f7                	div    %edi
  8123f5:	8b 45 f4             	mov    -0xc(%ebp),%eax
  8123f8:	f7 f7                	div    %edi
  8123fa:	eb a9                	jmp    8123a5 <__umoddi3+0x25>
  8123fc:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812400:	89 c8                	mov    %ecx,%eax
  812402:	89 f2                	mov    %esi,%edx
  812404:	83 c4 20             	add    $0x20,%esp
  812407:	5e                   	pop    %esi
  812408:	5f                   	pop    %edi
  812409:	5d                   	pop    %ebp
  81240a:	c3                   	ret    
  81240b:	90                   	nop
  81240c:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  812410:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812414:	d3 e2                	shl    %cl,%edx
  812416:	89 55 f4             	mov    %edx,-0xc(%ebp)
  812419:	ba 20 00 00 00       	mov    $0x20,%edx
  81241e:	2b 55 f0             	sub    -0x10(%ebp),%edx
  812421:	89 55 ec             	mov    %edx,-0x14(%ebp)
  812424:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812428:	89 fa                	mov    %edi,%edx
  81242a:	d3 ea                	shr    %cl,%edx
  81242c:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812430:	0b 55 f4             	or     -0xc(%ebp),%edx
  812433:	d3 e7                	shl    %cl,%edi
  812435:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812439:	89 55 f4             	mov    %edx,-0xc(%ebp)
  81243c:	89 f2                	mov    %esi,%edx
  81243e:	89 7d e8             	mov    %edi,-0x18(%ebp)
  812441:	89 c7                	mov    %eax,%edi
  812443:	d3 ea                	shr    %cl,%edx
  812445:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812449:	89 55 e4             	mov    %edx,-0x1c(%ebp)
  81244c:	89 c2                	mov    %eax,%edx
  81244e:	d3 e6                	shl    %cl,%esi
  812450:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812454:	d3 ea                	shr    %cl,%edx
  812456:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  81245a:	09 d6                	or     %edx,%esi
  81245c:	89 f0                	mov    %esi,%eax
  81245e:	8b 75 e4             	mov    -0x1c(%ebp),%esi
  812461:	d3 e7                	shl    %cl,%edi
  812463:	89 f2                	mov    %esi,%edx
  812465:	f7 75 f4             	divl   -0xc(%ebp)
  812468:	89 d6                	mov    %edx,%esi
  81246a:	f7 65 e8             	mull   -0x18(%ebp)
  81246d:	39 d6                	cmp    %edx,%esi
  81246f:	72 2b                	jb     81249c <__umoddi3+0x11c>
  812471:	39 c7                	cmp    %eax,%edi
  812473:	72 23                	jb     812498 <__umoddi3+0x118>
  812475:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  812479:	29 c7                	sub    %eax,%edi
  81247b:	19 d6                	sbb    %edx,%esi
  81247d:	89 f0                	mov    %esi,%eax
  81247f:	89 f2                	mov    %esi,%edx
  812481:	d3 ef                	shr    %cl,%edi
  812483:	0f b6 4d ec          	movzbl -0x14(%ebp),%ecx
  812487:	d3 e0                	shl    %cl,%eax
  812489:	0f b6 4d f0          	movzbl -0x10(%ebp),%ecx
  81248d:	09 f8                	or     %edi,%eax
  81248f:	d3 ea                	shr    %cl,%edx
  812491:	83 c4 20             	add    $0x20,%esp
  812494:	5e                   	pop    %esi
  812495:	5f                   	pop    %edi
  812496:	5d                   	pop    %ebp
  812497:	c3                   	ret    
  812498:	39 d6                	cmp    %edx,%esi
  81249a:	75 d9                	jne    812475 <__umoddi3+0xf5>
  81249c:	2b 45 e8             	sub    -0x18(%ebp),%eax
  81249f:	1b 55 f4             	sbb    -0xc(%ebp),%edx
  8124a2:	eb d1                	jmp    812475 <__umoddi3+0xf5>
  8124a4:	8d 74 26 00          	lea    0x0(%esi,%eiz,1),%esi
  8124a8:	39 f2                	cmp    %esi,%edx
  8124aa:	0f 82 18 ff ff ff    	jb     8123c8 <__umoddi3+0x48>
  8124b0:	e9 1d ff ff ff       	jmp    8123d2 <__umoddi3+0x52>
